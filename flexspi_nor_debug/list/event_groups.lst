###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:18
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\amazon-freertos\freertos\event_groups.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWD877.tmp
#        (C:\Development\smart_washing_machine_3080\amazon-freertos\freertos\event_groups.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\event_groups.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\event_groups.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\amazon-freertos\freertos\event_groups.c
      1          /*
      2           * FreeRTOS Kernel V10.2.0
      3           * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * http://www.FreeRTOS.org
     23           * http://aws.amazon.com/freertos
     24           *
     25           * 1 tab == 4 spaces!
     26           */
     27          
     28          /* Standard includes. */
     29          #include <stdlib.h>
     30          
     31          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     32          all the API functions to use the MPU wrappers.  That should only be done when
     33          task.h is included from an application file. */
     34          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     35          
     36          /* FreeRTOS includes. */
     37          #include "FreeRTOS.h"
     38          #include "task.h"
     39          #include "timers.h"
     40          #include "event_groups.h"
     41          
     42          /* Lint e961, e750 and e9021 are suppressed as a MISRA exception justified
     43          because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     44          for the header files above, but not in this file, in order to generate the
     45          correct privileged Vs unprivileged linkage and placement. */
     46          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021 See comment above. */
     47          
     48          /* The following bit fields convey control information in a task's event list
     49          item value.  It is important they don't clash with the
     50          taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
     51          #if configUSE_16_BIT_TICKS == 1
     52          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
     53          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
     54          	#define eventWAIT_FOR_ALL_BITS			0x0400U
     55          	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
     56          #else
     57          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
     58          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
     59          	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
     60          	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
     61          #endif
     62          
     63          typedef struct EventGroupDef_t
     64          {
     65          	EventBits_t uxEventBits;
     66          	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
     67          
     68          	#if( configUSE_TRACE_FACILITY == 1 )
     69          		UBaseType_t uxEventGroupNumber;
     70          	#endif
     71          
     72          	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
     73          		uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */
     74          	#endif
     75          } EventGroup_t;
     76          
     77          /*-----------------------------------------------------------*/
     78          
     79          /*
     80           * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
     81           * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
     82           * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
     83           * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
     84           * wait condition is met if any of the bits set in uxBitsToWait for are also set
     85           * in uxCurrentEventBits.
     86           */
     87          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION;
     88          
     89          /*-----------------------------------------------------------*/
     90          
     91          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
     92          
     93          	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )
     94          	{
     95          	EventGroup_t *pxEventBits;
     96          
     97          		/* A StaticEventGroup_t object must be provided. */
     98          		configASSERT( pxEventGroupBuffer );
     99          
    100          		#if( configASSERT_DEFINED == 1 )
    101          		{
    102          			/* Sanity check that the size of the structure used to declare a
    103          			variable of type StaticEventGroup_t equals the size of the real
    104          			event group structure. */
    105          			volatile size_t xSize = sizeof( StaticEventGroup_t );
    106          			configASSERT( xSize == sizeof( EventGroup_t ) );
    107          		} /*lint !e529 xSize is referenced if configASSERT() is defined. */
    108          		#endif /* configASSERT_DEFINED */
    109          
    110          		/* The user has provided a statically allocated event group - use it. */
    111          		pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 !e9087 EventGroup_t and StaticEventGroup_t are deliberately aliased for data hiding purposes and guaranteed to have the same size and alignment requirement - checked by configASSERT(). */
    112          
    113          		if( pxEventBits != NULL )
    114          		{
    115          			pxEventBits->uxEventBits = 0;
    116          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    117          
    118          			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    119          			{
    120          				/* Both static and dynamic allocation can be used, so note that
    121          				this event group was created statically in case the event group
    122          				is later deleted. */
    123          				pxEventBits->ucStaticallyAllocated = pdTRUE;
    124          			}
    125          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    126          
    127          			traceEVENT_GROUP_CREATE( pxEventBits );
    128          		}
    129          		else
    130          		{
    131          			/* xEventGroupCreateStatic should only ever be called with
    132          			pxEventGroupBuffer pointing to a pre-allocated (compile time
    133          			allocated) StaticEventGroup_t variable. */
    134          			traceEVENT_GROUP_CREATE_FAILED();
    135          		}
    136          
    137          		return pxEventBits;
    138          	}
    139          
    140          #endif /* configSUPPORT_STATIC_ALLOCATION */
    141          /*-----------------------------------------------------------*/
    142          
    143          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    144          

   \                                 In section .text, align 2, keep-with-next
    145          	EventGroupHandle_t xEventGroupCreate( void )
    146          	{
   \                     xEventGroupCreate: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    147          	EventGroup_t *pxEventBits;
    148          
    149          		/* Allocate the event group.  Justification for MISRA deviation as
    150          		follows:  pvPortMalloc() always ensures returned memory blocks are
    151          		aligned per the requirements of the MCU stack.  In this case
    152          		pvPortMalloc() must return a pointer that is guaranteed to meet the
    153          		alignment requirements of the EventGroup_t structure - which (if you
    154          		follow it through) is the alignment requirements of the TickType_t type
    155          		(EventBits_t being of TickType_t itself).  Therefore, whenever the
    156          		stack alignment requirements are greater than or equal to the
    157          		TickType_t alignment requirements the cast is safe.  In other cases,
    158          		where the natural word size of the architecture is less than
    159          		sizeof( TickType_t ), the TickType_t variables will be accessed in two
    160          		or more reads operations, and the alignment requirements is only that
    161          		of each individual read. */
    162          		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
   \        0x2   0x201C             MOVS     R0,#+28
   \        0x4   0x....'....        BL       pvPortMalloc
   \        0x8   0x0004             MOVS     R4,R0
    163          
    164          		if( pxEventBits != NULL )
   \        0xA   0xD004             BEQ.N    ??xEventGroupCreate_0
    165          		{
    166          			pxEventBits->uxEventBits = 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6020             STR      R0,[R4, #+0]
    167          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
   \       0x10   0x1D20             ADDS     R0,R4,#+4
   \       0x12   0x....'....        BL       vListInitialise
    168          
    169          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    170          			{
    171          				/* Both static and dynamic allocation can be used, so note this
    172          				event group was allocated statically in case the event group is
    173          				later deleted. */
    174          				pxEventBits->ucStaticallyAllocated = pdFALSE;
    175          			}
    176          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    177          
    178          			traceEVENT_GROUP_CREATE( pxEventBits );
    179          		}
    180          		else
    181          		{
    182          			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
    183          		}
    184          
    185          		return pxEventBits;
   \                     ??xEventGroupCreate_0: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    186          	}
    187          
    188          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    189          /*-----------------------------------------------------------*/
    190          

   \                                 In section .text, align 2, keep-with-next
    191          EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
    192          {
   \                     xEventGroupSync: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461C             MOV      R4,R3
    193          EventBits_t uxOriginalBitValue, uxReturn;
    194          EventGroup_t *pxEventBits = xEventGroup;
    195          BaseType_t xAlreadyYielded;
    196          BaseType_t xTimeoutOccurred = pdFALSE;
    197          
    198          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \        0xC   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x10   0xD007             BEQ.N    ??xEventGroupSync_0
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_1: (+1)
   \       0x20   0xE7FE             B.N      ??xEventGroupSync_1
    199          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupSync_0: (+1)
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD107             BNE.N    ??xEventGroupSync_2
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_3: (+1)
   \       0x34   0xE7FE             B.N      ??xEventGroupSync_3
    200          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    201          	{
    202          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xEventGroupSync_2: (+1)
   \       0x36   0x....'....        BL       xTaskGetSchedulerState
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD104             BNE.N    ??xEventGroupSync_4
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0x1E40             SUBS     R0,R0,#+1
   \       0x42   0x4180             SBCS     R0,R0,R0
   \       0x44   0x0FC0             LSRS     R0,R0,#+31
   \       0x46   0xE000             B.N      ??xEventGroupSync_5
   \                     ??xEventGroupSync_4: (+1)
   \       0x48   0x2001             MOVS     R0,#+1
   \                     ??xEventGroupSync_5: (+1)
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD107             BNE.N    ??xEventGroupSync_6
   \       0x4E   0x2020             MOVS     R0,#+32
   \       0x50   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x54   0xF3BF 0x8F4F      DSB      SY
   \       0x58   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_7: (+1)
   \       0x5C   0xE7FE             B.N      ??xEventGroupSync_7
    203          	}
    204          	#endif
    205          
    206          	vTaskSuspendAll();
   \                     ??xEventGroupSync_6: (+1)
   \       0x5E   0x....'....        BL       vTaskSuspendAll
    207          	{
    208          		uxOriginalBitValue = pxEventBits->uxEventBits;
   \       0x62   0xF8D6 0x8000      LDR      R8,[R6, #+0]
    209          
    210          		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
   \       0x66   0x4639             MOV      R1,R7
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0x....'....        BL       xEventGroupSetBits
    211          
    212          		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0x6E   0xEA47 0x0008      ORR      R0,R7,R8
   \       0x72   0x4028             ANDS     R0,R5,R0
   \       0x74   0x42A8             CMP      R0,R5
   \       0x76   0xD106             BNE.N    ??xEventGroupSync_8
    213          		{
    214          			/* All the rendezvous bits are now set - no need to block. */
    215          			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
   \       0x78   0xEA47 0x0708      ORR      R7,R7,R8
    216          
    217          			/* Rendezvous always clear the bits.  They will have been cleared
    218          			already unless this is the only task in the rendezvous. */
    219          			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0x7C   0x6830             LDR      R0,[R6, #+0]
   \       0x7E   0x43A8             BICS     R0,R0,R5
   \       0x80   0x6030             STR      R0,[R6, #+0]
    220          
    221          			xTicksToWait = 0;
   \       0x82   0x2400             MOVS     R4,#+0
   \       0x84   0xE00A             B.N      ??xEventGroupSync_9
    222          		}
    223          		else
    224          		{
    225          			if( xTicksToWait != ( TickType_t ) 0 )
   \                     ??xEventGroupSync_8: (+1)
   \       0x86   0x2C00             CMP      R4,#+0
   \       0x88   0xD007             BEQ.N    ??xEventGroupSync_10
    226          			{
    227          				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
    228          
    229          				/* Store the bits that the calling task is waiting for in the
    230          				task's event list item so the kernel knows when a match is
    231          				found.  Then enter the blocked state. */
    232          				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
   \       0x8A   0x4622             MOV      R2,R4
   \       0x8C   0xF045 0x61A0      ORR      R1,R5,#0x5000000
   \       0x90   0x1D30             ADDS     R0,R6,#+4
   \       0x92   0x....'....        BL       vTaskPlaceOnUnorderedEventList
    233          
    234          				/* This assignment is obsolete as uxReturn will get set after
    235          				the task unblocks, but some compilers mistakenly generate a
    236          				warning about uxReturn being returned without being set if the
    237          				assignment is omitted. */
    238          				uxReturn = 0;
   \       0x96   0x2700             MOVS     R7,#+0
   \       0x98   0xE000             B.N      ??xEventGroupSync_9
    239          			}
    240          			else
    241          			{
    242          				/* The rendezvous bits were not set, but no block time was
    243          				specified - just return the current event bit value. */
    244          				uxReturn = pxEventBits->uxEventBits;
   \                     ??xEventGroupSync_10: (+1)
   \       0x9A   0x6837             LDR      R7,[R6, #+0]
    245          				xTimeoutOccurred = pdTRUE;
    246          			}
    247          		}
    248          	}
    249          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupSync_9: (+1)
   \       0x9C   0x....'....        BL       xTaskResumeAll
    250          
    251          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0xA0   0x2C00             CMP      R4,#+0
   \       0xA2   0xD01D             BEQ.N    ??xEventGroupSync_11
    252          	{
    253          		if( xAlreadyYielded == pdFALSE )
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD107             BNE.N    ??xEventGroupSync_12
    254          		{
    255          			portYIELD_WITHIN_API();
   \       0xA8   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xAC   0x....             LDR.N    R1,??DataTable3  ;; 0xe000ed04
   \       0xAE   0x6008             STR      R0,[R1, #+0]
   \       0xB0   0xF3BF 0x8F4F      DSB      SY
   \       0xB4   0xF3BF 0x8F6F      ISB      SY
    256          		}
    257          		else
    258          		{
    259          			mtCOVERAGE_TEST_MARKER();
    260          		}
    261          
    262          		/* The task blocked to wait for its required bits to be set - at this
    263          		point either the required bits were set or the block time expired.  If
    264          		the required bits were set they will have been stored in the task's
    265          		event list item, and they should now be retrieved then cleared. */
    266          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupSync_12: (+1)
   \       0xB8   0x....'....        BL       uxTaskResetEventItemValue
   \       0xBC   0x4607             MOV      R7,R0
    267          
    268          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0xBE   0x01B8             LSLS     R0,R7,#+6
   \       0xC0   0xD40C             BMI.N    ??xEventGroupSync_13
    269          		{
    270          			/* The task timed out, just return the current event bit value. */
    271          			taskENTER_CRITICAL();
   \       0xC2   0x....'....        BL       vPortEnterCritical
    272          			{
    273          				uxReturn = pxEventBits->uxEventBits;
   \       0xC6   0x6837             LDR      R7,[R6, #+0]
    274          
    275          				/* Although the task got here because it timed out before the
    276          				bits it was waiting for were set, it is possible that since it
    277          				unblocked another task has set the bits.  If this is the case
    278          				then it needs to clear the bits before exiting. */
    279          				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0xC8   0xEA05 0x0007      AND      R0,R5,R7
   \       0xCC   0x42A8             CMP      R0,R5
   \       0xCE   0xD103             BNE.N    ??xEventGroupSync_14
    280          				{
    281          					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0xD0   0x4638             MOV      R0,R7
   \       0xD2   0xEA20 0x0505      BIC      R5,R0,R5
   \       0xD6   0x6035             STR      R5,[R6, #+0]
    282          				}
    283          				else
    284          				{
    285          					mtCOVERAGE_TEST_MARKER();
    286          				}
    287          			}
    288          			taskEXIT_CRITICAL();
   \                     ??xEventGroupSync_14: (+1)
   \       0xD8   0x....'....        BL       vPortExitCritical
    289          
    290          			xTimeoutOccurred = pdTRUE;
    291          		}
    292          		else
    293          		{
    294          			/* The task unblocked because the bits were set. */
    295          		}
    296          
    297          		/* Control bits might be set as the task had blocked should not be
    298          		returned. */
    299          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupSync_13: (+1)
   \       0xDC   0xF027 0x477F      BIC      R7,R7,#0xFF000000
    300          	}
    301          
    302          	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
    303          
    304          	/* Prevent compiler warnings when trace macros are not used. */
    305          	( void ) xTimeoutOccurred;
    306          
    307          	return uxReturn;
   \                     ??xEventGroupSync_11: (+1)
   \       0xE0   0x4638             MOV      R0,R7
   \       0xE2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    308          }
    309          /*-----------------------------------------------------------*/
    310          

   \                                 In section .text, align 2, keep-with-next
    311          EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
    312          {
   \                     xEventGroupWaitBits: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x4698             MOV      R8,R3
    313          EventGroup_t *pxEventBits = xEventGroup;
    314          EventBits_t uxReturn, uxControlBits = 0;
   \        0xA   0xF04F 0x0900      MOV      R9,#+0
    315          BaseType_t xWaitConditionMet, xAlreadyYielded;
    316          BaseType_t xTimeoutOccurred = pdFALSE;
    317          
    318          	/* Check the user is not attempting to wait on the bits used by the kernel
    319          	itself, and that at least one bit is being requested. */
    320          	configASSERT( xEventGroup );
   \        0xE   0x2F00             CMP      R7,#+0
   \       0x10   0xD107             BNE.N    ??xEventGroupWaitBits_0
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_1: (+1)
   \       0x20   0xE7FE             B.N      ??xEventGroupWaitBits_1
   \                     ??xEventGroupWaitBits_0: (+1)
   \       0x22   0x460E             MOV      R6,R1
    321          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \       0x24   0xF016 0x4F7F      TST      R6,#0xFF000000
   \       0x28   0xD007             BEQ.N    ??xEventGroupWaitBits_2
   \       0x2A   0x2020             MOVS     R0,#+32
   \       0x2C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x30   0xF3BF 0x8F4F      DSB      SY
   \       0x34   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_3: (+1)
   \       0x38   0xE7FE             B.N      ??xEventGroupWaitBits_3
    322          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupWaitBits_2: (+1)
   \       0x3A   0x2E00             CMP      R6,#+0
   \       0x3C   0xD107             BNE.N    ??xEventGroupWaitBits_4
   \       0x3E   0x2020             MOVS     R0,#+32
   \       0x40   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x44   0xF3BF 0x8F4F      DSB      SY
   \       0x48   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_5: (+1)
   \       0x4C   0xE7FE             B.N      ??xEventGroupWaitBits_5
   \                     ??xEventGroupWaitBits_4: (+1)
   \       0x4E   0x9D08             LDR      R5,[SP, #+32]
    323          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    324          	{
    325          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \       0x50   0x....'....        BL       xTaskGetSchedulerState
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD104             BNE.N    ??xEventGroupWaitBits_6
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x1E40             SUBS     R0,R0,#+1
   \       0x5C   0x4180             SBCS     R0,R0,R0
   \       0x5E   0x0FC0             LSRS     R0,R0,#+31
   \       0x60   0xE000             B.N      ??xEventGroupWaitBits_7
   \                     ??xEventGroupWaitBits_6: (+1)
   \       0x62   0x2001             MOVS     R0,#+1
   \                     ??xEventGroupWaitBits_7: (+1)
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD107             BNE.N    ??xEventGroupWaitBits_8
   \       0x68   0x2020             MOVS     R0,#+32
   \       0x6A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x6E   0xF3BF 0x8F4F      DSB      SY
   \       0x72   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_9: (+1)
   \       0x76   0xE7FE             B.N      ??xEventGroupWaitBits_9
    326          	}
    327          	#endif
    328          
    329          	vTaskSuspendAll();
   \                     ??xEventGroupWaitBits_8: (+1)
   \       0x78   0x....'....        BL       vTaskSuspendAll
    330          	{
    331          		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
   \       0x7C   0xF8D7 0xA000      LDR      R10,[R7, #+0]
    332          
    333          		/* Check to see if the wait condition is already met or not. */
    334          		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    335          
    336          		if( xWaitConditionMet != pdFALSE )
   \       0x80   0x4642             MOV      R2,R8
   \       0x82   0x4631             MOV      R1,R6
   \       0x84   0x4650             MOV      R0,R10
   \       0x86   0x....'....        BL       prvTestWaitCondition
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD006             BEQ.N    ??xEventGroupWaitBits_10
    337          		{
    338          			/* The wait condition has already been met so there is no need to
    339          			block. */
    340          			uxReturn = uxCurrentEventBits;
    341          			xTicksToWait = ( TickType_t ) 0;
   \       0x8E   0x464D             MOV      R5,R9
    342          
    343          			/* Clear the wait bits if requested to do so. */
    344          			if( xClearOnExit != pdFALSE )
   \       0x90   0x2C00             CMP      R4,#+0
   \       0x92   0xD017             BEQ.N    ??xEventGroupWaitBits_11
    345          			{
    346          				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0x94   0x6838             LDR      R0,[R7, #+0]
   \       0x96   0x43B0             BICS     R0,R0,R6
   \       0x98   0x6038             STR      R0,[R7, #+0]
   \       0x9A   0xE013             B.N      ??xEventGroupWaitBits_11
    347          			}
    348          			else
    349          			{
    350          				mtCOVERAGE_TEST_MARKER();
    351          			}
    352          		}
    353          		else if( xTicksToWait == ( TickType_t ) 0 )
   \                     ??xEventGroupWaitBits_10: (+1)
   \       0x9C   0x2D00             CMP      R5,#+0
   \       0x9E   0xD011             BEQ.N    ??xEventGroupWaitBits_11
    354          		{
    355          			/* The wait condition has not been met, but no block time was
    356          			specified, so just return the current value. */
    357          			uxReturn = uxCurrentEventBits;
    358          			xTimeoutOccurred = pdTRUE;
    359          		}
    360          		else
    361          		{
    362          			/* The task is going to block to wait for its required bits to be
    363          			set.  uxControlBits are used to remember the specified behaviour of
    364          			this call to xEventGroupWaitBits() - for use when the event bits
    365          			unblock the task. */
    366          			if( xClearOnExit != pdFALSE )
   \       0xA0   0x2C00             CMP      R4,#+0
   \       0xA2   0xD001             BEQ.N    ??xEventGroupWaitBits_12
    367          			{
    368          				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
   \       0xA4   0xF04F 0x7980      MOV      R9,#+16777216
    369          			}
    370          			else
    371          			{
    372          				mtCOVERAGE_TEST_MARKER();
    373          			}
    374          
    375          			if( xWaitForAllBits != pdFALSE )
   \                     ??xEventGroupWaitBits_12: (+1)
   \       0xA8   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xAC   0xD001             BEQ.N    ??xEventGroupWaitBits_13
    376          			{
    377          				uxControlBits |= eventWAIT_FOR_ALL_BITS;
   \       0xAE   0xF049 0x6980      ORR      R9,R9,#0x4000000
    378          			}
    379          			else
    380          			{
    381          				mtCOVERAGE_TEST_MARKER();
    382          			}
    383          
    384          			/* Store the bits that the calling task is waiting for in the
    385          			task's event list item so the kernel knows when a match is
    386          			found.  Then enter the blocked state. */
    387          			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
   \                     ??xEventGroupWaitBits_13: (+1)
   \       0xB2   0x462A             MOV      R2,R5
   \       0xB4   0xEA49 0x0906      ORR      R9,R9,R6
   \       0xB8   0x4649             MOV      R1,R9
   \       0xBA   0x1D38             ADDS     R0,R7,#+4
   \       0xBC   0x....'....        BL       vTaskPlaceOnUnorderedEventList
    388          
    389          			/* This is obsolete as it will get set after the task unblocks, but
    390          			some compilers mistakenly generate a warning about the variable
    391          			being returned without being set if it is not done. */
    392          			uxReturn = 0;
   \       0xC0   0xF04F 0x0A00      MOV      R10,#+0
    393          
    394          			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
    395          		}
    396          	}
    397          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupWaitBits_11: (+1)
   \       0xC4   0x....'....        BL       xTaskResumeAll
    398          
    399          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0xC8   0x2D00             CMP      R5,#+0
   \       0xCA   0xD024             BEQ.N    ??xEventGroupWaitBits_14
    400          	{
    401          		if( xAlreadyYielded == pdFALSE )
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD107             BNE.N    ??xEventGroupWaitBits_15
    402          		{
    403          			portYIELD_WITHIN_API();
   \       0xD0   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xD4   0x....             LDR.N    R1,??DataTable3  ;; 0xe000ed04
   \       0xD6   0x6008             STR      R0,[R1, #+0]
   \       0xD8   0xF3BF 0x8F4F      DSB      SY
   \       0xDC   0xF3BF 0x8F6F      ISB      SY
    404          		}
    405          		else
    406          		{
    407          			mtCOVERAGE_TEST_MARKER();
    408          		}
    409          
    410          		/* The task blocked to wait for its required bits to be set - at this
    411          		point either the required bits were set or the block time expired.  If
    412          		the required bits were set they will have been stored in the task's
    413          		event list item, and they should now be retrieved then cleared. */
    414          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupWaitBits_15: (+1)
   \       0xE0   0x....'....        BL       uxTaskResetEventItemValue
   \       0xE4   0x4682             MOV      R10,R0
    415          
    416          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0xE6   0xEA5F 0x108A      LSLS     R0,R10,#+6
   \       0xEA   0xD412             BMI.N    ??xEventGroupWaitBits_16
    417          		{
    418          			taskENTER_CRITICAL();
   \       0xEC   0x....'....        BL       vPortEnterCritical
    419          			{
    420          				/* The task timed out, just return the current event bit value. */
    421          				uxReturn = pxEventBits->uxEventBits;
   \       0xF0   0xF8D7 0xA000      LDR      R10,[R7, #+0]
    422          
    423          				/* It is possible that the event bits were updated between this
    424          				task leaving the Blocked state and running again. */
    425          				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
   \       0xF4   0x4642             MOV      R2,R8
   \       0xF6   0x4631             MOV      R1,R6
   \       0xF8   0x4650             MOV      R0,R10
   \       0xFA   0x....'....        BL       prvTestWaitCondition
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD005             BEQ.N    ??xEventGroupWaitBits_17
    426          				{
    427          					if( xClearOnExit != pdFALSE )
   \      0x102   0x2C00             CMP      R4,#+0
   \      0x104   0xD003             BEQ.N    ??xEventGroupWaitBits_17
    428          					{
    429          						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \      0x106   0x6838             LDR      R0,[R7, #+0]
   \      0x108   0xEA20 0x0606      BIC      R6,R0,R6
   \      0x10C   0x603E             STR      R6,[R7, #+0]
    430          					}
    431          					else
    432          					{
    433          						mtCOVERAGE_TEST_MARKER();
    434          					}
    435          				}
    436          				else
    437          				{
    438          					mtCOVERAGE_TEST_MARKER();
    439          				}
    440          				xTimeoutOccurred = pdTRUE;
    441          			}
    442          			taskEXIT_CRITICAL();
   \                     ??xEventGroupWaitBits_17: (+1)
   \      0x10E   0x....'....        BL       vPortExitCritical
    443          		}
    444          		else
    445          		{
    446          			/* The task unblocked because the bits were set. */
    447          		}
    448          
    449          		/* The task blocked so control bits may have been set. */
    450          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupWaitBits_16: (+1)
   \      0x112   0xF02A 0x4A7F      BIC      R10,R10,#0xFF000000
    451          	}
    452          	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
    453          
    454          	/* Prevent compiler warnings when trace macros are not used. */
    455          	( void ) xTimeoutOccurred;
    456          
    457          	return uxReturn;
   \                     ??xEventGroupWaitBits_14: (+1)
   \      0x116   0x4650             MOV      R0,R10
   \      0x118   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    458          }
    459          /*-----------------------------------------------------------*/
    460          

   \                                 In section .text, align 2, keep-with-next
    461          EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    462          {
   \                     xEventGroupClearBits: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    463          EventGroup_t *pxEventBits = xEventGroup;
    464          EventBits_t uxReturn;
    465          
    466          	/* Check the user is not attempting to clear the bits used by the kernel
    467          	itself. */
    468          	configASSERT( xEventGroup );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xEventGroupClearBits_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupClearBits_1: (+1)
   \       0x18   0xE7FE             B.N      ??xEventGroupClearBits_1
    469          	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupClearBits_0: (+1)
   \       0x1A   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x1E   0xD007             BEQ.N    ??xEventGroupClearBits_2
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x26   0xF3BF 0x8F4F      DSB      SY
   \       0x2A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupClearBits_3: (+1)
   \       0x2E   0xE7FE             B.N      ??xEventGroupClearBits_3
    470          
    471          	taskENTER_CRITICAL();
   \                     ??xEventGroupClearBits_2: (+1)
   \       0x30   0x....'....        BL       vPortEnterCritical
    472          	{
    473          		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
    474          
    475          		/* The value returned is the event group value prior to the bits being
    476          		cleared. */
    477          		uxReturn = pxEventBits->uxEventBits;
   \       0x34   0x6826             LDR      R6,[R4, #+0]
    478          
    479          		/* Clear the bits. */
    480          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0xEA20 0x0505      BIC      R5,R0,R5
   \       0x3C   0x6025             STR      R5,[R4, #+0]
    481          	}
    482          	taskEXIT_CRITICAL();
   \       0x3E   0x....'....        BL       vPortExitCritical
    483          
    484          	return uxReturn;
   \       0x42   0x4630             MOV      R0,R6
   \       0x44   0xBD70             POP      {R4-R6,PC}       ;; return
    485          }
    486          /*-----------------------------------------------------------*/
    487          
    488          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    489          

   \                                 In section .text, align 2, keep-with-next
    490          	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    491          	{
   \                     xEventGroupClearBitsFromISR: (+1)
   \        0x0   0x460A             MOV      R2,R1
    492          		BaseType_t xReturn;
    493          
    494          		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
    495          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
    496          
    497          		return xReturn;
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x....'....        ADR.W    R0,vEventGroupClearBitsCallback
   \        0xA   0x....'....        B.W      xTimerPendFunctionCallFromISR
    498          	}
    499          
    500          #endif
    501          /*-----------------------------------------------------------*/
    502          

   \                                 In section .text, align 2, keep-with-next
    503          EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
    504          {
    505          UBaseType_t uxSavedInterruptStatus;
    506          EventGroup_t const * const pxEventBits = xEventGroup;
    507          EventBits_t uxReturn;
    508          
    509          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     xEventGroupGetBitsFromISR: (+1)
   \        0x0   0xF3EF 0x8111      MRS      R1,BASEPRI
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0xF382 0x8811      MSR      BASEPRI,R2
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
    510          	{
    511          		uxReturn = pxEventBits->uxEventBits;
   \       0x12   0x6800             LDR      R0,[R0, #+0]
    512          	}
    513          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \       0x14   0xF381 0x8811      MSR      BASEPRI,R1
    514          
    515          	return uxReturn;
   \       0x18   0x4770             BX       LR               ;; return
    516          } /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    517          /*-----------------------------------------------------------*/
    518          

   \                                 In section .text, align 2, keep-with-next
    519          EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
    520          {
   \                     xEventGroupSetBits: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
    521          ListItem_t *pxListItem, *pxNext;
    522          ListItem_t const *pxListEnd;
    523          List_t const * pxList;
    524          EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
   \        0x8   0x2600             MOVS     R6,#+0
    525          EventGroup_t *pxEventBits = xEventGroup;
    526          BaseType_t xMatchFound = pdFALSE;
    527          
    528          	/* Check the user is not attempting to set the bits used by the kernel
    529          	itself. */
    530          	configASSERT( xEventGroup );
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD107             BNE.N    ??xEventGroupSetBits_0
   \        0xE   0x2020             MOVS     R0,#+32
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSetBits_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xEventGroupSetBits_1
    531          	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupSetBits_0: (+1)
   \       0x1E   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x22   0xD007             BEQ.N    ??xEventGroupSetBits_2
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSetBits_3: (+1)
   \       0x32   0xE7FE             B.N      ??xEventGroupSetBits_3
    532          
    533          	pxList = &( pxEventBits->xTasksWaitingForBits );
   \                     ??xEventGroupSetBits_2: (+1)
   \       0x34   0xF104 0x0804      ADD      R8,R4,#+4
    534          	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \       0x38   0xF108 0x0708      ADD      R7,R8,#+8
    535          	vTaskSuspendAll();
   \       0x3C   0x....'....        BL       vTaskSuspendAll
    536          	{
    537          		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
    538          
    539          		pxListItem = listGET_HEAD_ENTRY( pxList );
   \       0x40   0xF8D8 0x200C      LDR      R2,[R8, #+12]
    540          
    541          		/* Set the bits. */
    542          		pxEventBits->uxEventBits |= uxBitsToSet;
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x4305             ORRS     R5,R5,R0
   \       0x48   0x6025             STR      R5,[R4, #+0]
    543          
    544          		/* See if the new bit value should unblock any tasks. */
    545          		while( pxListItem != pxListEnd )
   \                     ??xEventGroupSetBits_4: (+1)
   \       0x4A   0x42BA             CMP      R2,R7
   \       0x4C   0xD022             BEQ.N    ??xEventGroupSetBits_5
    546          		{
    547          			pxNext = listGET_NEXT( pxListItem );
   \       0x4E   0x6855             LDR      R5,[R2, #+4]
    548          			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
   \       0x50   0x6811             LDR      R1,[R2, #+0]
    549          			xMatchFound = pdFALSE;
   \       0x52   0x2000             MOVS     R0,#+0
    550          
    551          			/* Split the bits waited for from the control bits. */
    552          			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
   \       0x54   0xF001 0x437F      AND      R3,R1,#0xFF000000
    553          			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
   \       0x58   0xF021 0x417F      BIC      R1,R1,#0xFF000000
    554          
    555          			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
   \       0x5C   0xEA5F 0x1C43      LSLS     R12,R3,#+5
   \       0x60   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \       0x64   0xD505             BPL.N    ??xEventGroupSetBits_6
    556          			{
    557          				/* Just looking for single bit being set. */
    558          				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    559          				{
    560          					xMatchFound = pdTRUE;
    561          				}
    562          				else
    563          				{
    564          					mtCOVERAGE_TEST_MARKER();
    565          				}
    566          			}
    567          			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
   \       0x66   0xEA0C 0x0C01      AND      R12,R12,R1
   \       0x6A   0x458C             CMP      R12,R1
   \       0x6C   0xD105             BNE.N    ??xEventGroupSetBits_7
    568          			{
    569          				/* All bits are set. */
    570          				xMatchFound = pdTRUE;
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0xE003             B.N      ??xEventGroupSetBits_7
    571          			}
   \                     ??xEventGroupSetBits_6: (+1)
   \       0x72   0xEA11 0x0F0C      TST      R1,R12
   \       0x76   0xD000             BEQ.N    ??xEventGroupSetBits_7
   \       0x78   0x2001             MOVS     R0,#+1
    572          			else
    573          			{
    574          				/* Need all bits to be set, but not all the bits were set. */
    575          			}
    576          
    577          			if( xMatchFound != pdFALSE )
   \                     ??xEventGroupSetBits_7: (+1)
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD008             BEQ.N    ??xEventGroupSetBits_8
    578          			{
    579          				/* The bits match.  Should the bits be cleared on exit? */
    580          				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
   \       0x7E   0x01D8             LSLS     R0,R3,#+7
   \       0x80   0xD500             BPL.N    ??xEventGroupSetBits_9
    581          				{
    582          					uxBitsToClear |= uxBitsWaitedFor;
   \       0x82   0x430E             ORRS     R6,R1,R6
    583          				}
    584          				else
    585          				{
    586          					mtCOVERAGE_TEST_MARKER();
    587          				}
    588          
    589          				/* Store the actual event flag value in the task's event list
    590          				item before removing the task from the event list.  The
    591          				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
    592          				that is was unblocked due to its required bits matching, rather
    593          				than because it timed out. */
    594          				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??xEventGroupSetBits_9: (+1)
   \       0x84   0x6821             LDR      R1,[R4, #+0]
   \       0x86   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \       0x8A   0x4610             MOV      R0,R2
   \       0x8C   0x....'....        BL       vTaskRemoveFromUnorderedEventList
    595          			}
    596          
    597          			/* Move onto the next list item.  Note pxListItem->pxNext is not
    598          			used here as the list item may have been removed from the event list
    599          			and inserted into the ready/pending reading list. */
    600          			pxListItem = pxNext;
   \                     ??xEventGroupSetBits_8: (+1)
   \       0x90   0x462A             MOV      R2,R5
   \       0x92   0xE7DA             B.N      ??xEventGroupSetBits_4
    601          		}
    602          
    603          		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
    604          		bit was set in the control word. */
    605          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \                     ??xEventGroupSetBits_5: (+1)
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0xEA20 0x0606      BIC      R6,R0,R6
   \       0x9A   0x6026             STR      R6,[R4, #+0]
    606          	}
    607          	( void ) xTaskResumeAll();
   \       0x9C   0x....'....        BL       xTaskResumeAll
    608          
    609          	return pxEventBits->uxEventBits;
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    610          }
    611          /*-----------------------------------------------------------*/
    612          

   \                                 In section .text, align 2, keep-with-next
    613          void vEventGroupDelete( EventGroupHandle_t xEventGroup )
    614          {
   \                     vEventGroupDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    615          EventGroup_t *pxEventBits = xEventGroup;
    616          const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
   \        0x4   0x1D25             ADDS     R5,R4,#+4
    617          
    618          	vTaskSuspendAll();
   \        0x6   0x....'....        BL       vTaskSuspendAll
   \        0xA   0xE003             B.N      ??vEventGroupDelete_0
    619          	{
    620          		traceEVENT_GROUP_DELETE( xEventGroup );
    621          
    622          		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    623          		{
    624          			/* Unblock the task, returning 0 as the event list is being deleted
    625          			and cannot therefore have any bits set. */
    626          			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
    627          			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??vEventGroupDelete_1: (+1)
   \        0xC   0xF04F 0x7100      MOV      R1,#+33554432
   \       0x10   0x....'....        BL       vTaskRemoveFromUnorderedEventList
   \                     ??vEventGroupDelete_0: (+1)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD00C             BEQ.N    ??vEventGroupDelete_2
   \       0x1A   0x68E8             LDR      R0,[R5, #+12]
   \       0x1C   0xF105 0x0108      ADD      R1,R5,#+8
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD1F3             BNE.N    ??vEventGroupDelete_1
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??vEventGroupDelete_3: (+1)
   \       0x32   0xE7FE             B.N      ??vEventGroupDelete_3
    628          		}
    629          
    630          		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    631          		{
    632          			/* The event group can only have been allocated dynamically - free
    633          			it again. */
    634          			vPortFree( pxEventBits );
   \                     ??vEventGroupDelete_2: (+1)
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       vPortFree
    635          		}
    636          		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    637          		{
    638          			/* The event group could have been allocated statically or
    639          			dynamically, so check before attempting to free the memory. */
    640          			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
    641          			{
    642          				vPortFree( pxEventBits );
    643          			}
    644          			else
    645          			{
    646          				mtCOVERAGE_TEST_MARKER();
    647          			}
    648          		}
    649          		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    650          	}
    651          	( void ) xTaskResumeAll();
   \       0x3A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x3E   0x....'....        B.W      xTaskResumeAll
    652          }
    653          /*-----------------------------------------------------------*/
    654          
    655          /* For internal use only - execute a 'set bits' command that was pended from
    656          an interrupt. */

   \                                 In section .text, align 2, keep-with-next
    657          void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
    658          {
    659          	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
   \                     vEventGroupSetBitsCallback: (+1)
   \        0x0   0x....             B.N      xEventGroupSetBits
    660          }
    661          /*-----------------------------------------------------------*/
    662          
    663          /* For internal use only - execute a 'clear bits' command that was pended from
    664          an interrupt. */

   \                                 In section .text, align 4, keep-with-next
    665          void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
    666          {
    667          	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
   \                     vEventGroupClearBitsCallback: (+1)
   \        0x0   0x....             B.N      xEventGroupClearBits
    668          }
    669          /*-----------------------------------------------------------*/
    670          

   \                                 In section .text, align 2, keep-with-next
    671          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
    672          {
   \                     prvTestWaitCondition: (+1)
   \        0x0   0x4603             MOV      R3,R0
    673          BaseType_t xWaitConditionMet = pdFALSE;
   \        0x2   0x2000             MOVS     R0,#+0
    674          
    675          	if( xWaitForAllBits == pdFALSE )
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD103             BNE.N    ??prvTestWaitCondition_0
    676          	{
    677          		/* Task only has to wait for one bit within uxBitsToWaitFor to be
    678          		set.  Is one already set? */
    679          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
   \        0x8   0x420B             TST      R3,R1
   \        0xA   0xD005             BEQ.N    ??prvTestWaitCondition_1
    680          		{
    681          			xWaitConditionMet = pdTRUE;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x4770             BX       LR
    682          		}
    683          		else
    684          		{
    685          			mtCOVERAGE_TEST_MARKER();
    686          		}
    687          	}
    688          	else
    689          	{
    690          		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
    691          		Are they set already? */
    692          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \                     ??prvTestWaitCondition_0: (+1)
   \       0x10   0x400B             ANDS     R3,R1,R3
   \       0x12   0x428B             CMP      R3,R1
   \       0x14   0xD100             BNE.N    ??prvTestWaitCondition_1
    693          		{
    694          			xWaitConditionMet = pdTRUE;
   \       0x16   0x2001             MOVS     R0,#+1
    695          		}
    696          		else
    697          		{
    698          			mtCOVERAGE_TEST_MARKER();
    699          		}
    700          	}
    701          
    702          	return xWaitConditionMet;
   \                     ??prvTestWaitCondition_1: (+1)
   \       0x18   0x4770             BX       LR               ;; return
    703          }
    704          /*-----------------------------------------------------------*/
    705          
    706          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    707          

   \                                 In section .text, align 2, keep-with-next
    708          	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
    709          	{
   \                     xEventGroupSetBitsFromISR: (+1)
   \        0x0   0x4613             MOV      R3,R2
    710          	BaseType_t xReturn;
    711          
    712          		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
    713          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
    714          
    715          		return xReturn;
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x....             LDR.N    R0,??DataTable3_1
   \        0x8   0x....'....        B.W      xTimerPendFunctionCallFromISR
    716          	}
    717          
    718          #endif
    719          /*-----------------------------------------------------------*/
    720          
    721          #if (configUSE_TRACE_FACILITY == 1)
    722          

   \                                 In section .text, align 2, keep-with-next
    723          	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
    724          	{
    725          	UBaseType_t xReturn;
    726          	EventGroup_t const *pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
    727          
    728          		if( xEventGroup == NULL )
   \                     uxEventGroupGetNumber: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??uxEventGroupGetNumber_0
    729          		{
    730          			xReturn = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
    731          		}
    732          		else
    733          		{
    734          			xReturn = pxEventBits->uxEventGroupNumber;
   \                     ??uxEventGroupGetNumber_0: (+1)
   \        0x8   0x6980             LDR      R0,[R0, #+24]
    735          		}
    736          
    737          		return xReturn;
   \        0xA   0x4770             BX       LR               ;; return
    738          	}
    739          
    740          #endif /* configUSE_TRACE_FACILITY */
    741          /*-----------------------------------------------------------*/
    742          
    743          #if ( configUSE_TRACE_FACILITY == 1 )
    744          

   \                                 In section .text, align 2, keep-with-next
    745          	void vEventGroupSetNumber( void * xEventGroup, UBaseType_t uxEventGroupNumber )
    746          	{
    747          		( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
   \                     vEventGroupSetNumber: (+1)
   \        0x0   0x6181             STR      R1,[R0, #+24]
    748          	}
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     vEventGroupSetBitsCallback
    749          
    750          #endif /* configUSE_TRACE_FACILITY */
    751          /*-----------------------------------------------------------*/
    752          
    753          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   prvTestWaitCondition
       0   uxEventGroupGetNumber
       0   vEventGroupClearBitsCallback
         0   -> xEventGroupClearBits
      16   vEventGroupDelete
        16   -> vPortFree
        16   -> vTaskRemoveFromUnorderedEventList
        16   -> vTaskSuspendAll
         0   -> xTaskResumeAll
       0   vEventGroupSetBitsCallback
         0   -> xEventGroupSetBits
       0   vEventGroupSetNumber
      16   xEventGroupClearBits
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   xEventGroupClearBitsFromISR
         0   -> xTimerPendFunctionCallFromISR
       8   xEventGroupCreate
         8   -> pvPortMalloc
         8   -> vListInitialise
       0   xEventGroupGetBitsFromISR
      24   xEventGroupSetBits
        24   -> vTaskRemoveFromUnorderedEventList
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
       0   xEventGroupSetBitsFromISR
         0   -> xTimerPendFunctionCallFromISR
      24   xEventGroupSync
        24   -> uxTaskResetEventItemValue
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vTaskPlaceOnUnorderedEventList
        24   -> vTaskSuspendAll
        24   -> xEventGroupSetBits
        24   -> xTaskGetSchedulerState
        24   -> xTaskResumeAll
      32   xEventGroupWaitBits
        32   -> prvTestWaitCondition
        32   -> uxTaskResetEventItemValue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskPlaceOnUnorderedEventList
        32   -> vTaskSuspendAll
        32   -> xTaskGetSchedulerState
        32   -> xTaskResumeAll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
      26  prvTestWaitCondition
      12  uxEventGroupGetNumber
       2  vEventGroupClearBitsCallback
      66  vEventGroupDelete
       2  vEventGroupSetBitsCallback
       4  vEventGroupSetNumber
      70  xEventGroupClearBits
      14  xEventGroupClearBitsFromISR
      26  xEventGroupCreate
      26  xEventGroupGetBitsFromISR
     166  xEventGroupSetBits
      12  xEventGroupSetBitsFromISR
     230  xEventGroupSync
     284  xEventGroupWaitBits

 
 948 bytes in section .text
 
 948 bytes of CODE memory

Errors: none
Warnings: none
