###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:41
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\mbedtls\library\pk_wrap.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW2DFC.tmp
#        (C:\Development\smart_washing_machine_3080\mbedtls\library\pk_wrap.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\pk_wrap.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\pk_wrap.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\mbedtls\library\pk_wrap.c
      1          /*
      2           *  Public Key abstraction layer: wrapper functions
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_PK_C)
     29          #include "mbedtls/pk_internal.h"
     30          
     31          /* Even if RSA not activated, for the sake of RSA-alt */
     32          #include "mbedtls/rsa.h"
     33          
     34          #include <string.h>
     35          
     36          #if defined(MBEDTLS_ECP_C)
     37          #include "mbedtls/ecp.h"
     38          #endif
     39          
     40          #if defined(MBEDTLS_ECDSA_C)
     41          #include "mbedtls/ecdsa.h"
     42          #endif
     43          
     44          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
     45          #include "mbedtls/platform_util.h"
     46          #endif
     47          
     48          #if defined(MBEDTLS_PLATFORM_C)
     49          #include "mbedtls/platform.h"
     50          #else
     51          #include <stdlib.h>
     52          #define mbedtls_calloc    calloc
     53          #define mbedtls_free       free
     54          #endif
     55          
     56          #include <limits.h>
     57          #include <stdint.h>
     58          
     59          #if defined(MBEDTLS_RSA_C)

   \                                 In section .text, align 2, keep-with-next
     60          static int rsa_can_do( mbedtls_pk_type_t type )
     61          {
     62              return( type == MBEDTLS_PK_RSA ||
     63                      type == MBEDTLS_PK_RSASSA_PSS );
   \                     rsa_can_do: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x2901             CMP      R1,#+1
   \        0x4   0xD001             BEQ.N    ??rsa_can_do_0
   \        0x6   0x2806             CMP      R0,#+6
   \        0x8   0xD101             BNE.N    ??rsa_can_do_1
   \                     ??rsa_can_do_0: (+1)
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x4770             BX       LR
   \                     ??rsa_can_do_1: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR               ;; return
     64          }
     65          

   \                                 In section .text, align 2, keep-with-next
     66          static size_t rsa_get_bitlen( const void *ctx )
     67          {
   \                     rsa_get_bitlen: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     68              const mbedtls_rsa_context * rsa = (const mbedtls_rsa_context *) ctx;
     69              return( 8 * mbedtls_rsa_get_len( rsa ) );
   \        0x2   0x....'....        BL       mbedtls_rsa_get_len
   \        0x6   0x00C0             LSLS     R0,R0,#+3
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
     70          }
     71          

   \                                 In section .text, align 2, keep-with-next
     72          static int rsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
     73                             const unsigned char *hash, size_t hash_len,
     74                             const unsigned char *sig, size_t sig_len )
     75          {
   \                     rsa_verify_wrap: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x461F             MOV      R7,R3
   \        0xE   0xF8DD 0x8034      LDR      R8,[SP, #+52]
     76              int ret;
     77              mbedtls_rsa_context * rsa = (mbedtls_rsa_context *) ctx;
     78              size_t rsa_len = mbedtls_rsa_get_len( rsa );
   \       0x12   0x....'....        BL       mbedtls_rsa_get_len
   \       0x16   0x4681             MOV      R9,R0
     79          
     80          #if SIZE_MAX > UINT_MAX
     81              if( md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len )
     82                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
     83          #endif /* SIZE_MAX > UINT_MAX */
     84          
     85              if( sig_len < rsa_len )
   \       0x18   0x45C8             CMP      R8,R9
   \       0x1A   0xD202             BCS.N    ??rsa_verify_wrap_0
     86                  return( MBEDTLS_ERR_RSA_VERIFY_FAILED );
   \       0x1C   0x....'....        LDR.W    R0,??DataTable8  ;; 0xffffbc80
   \       0x20   0xE011             B.N      ??rsa_verify_wrap_1
   \                     ??rsa_verify_wrap_0: (+1)
   \       0x22   0x980C             LDR      R0,[SP, #+48]
     87          
     88              if( ( ret = mbedtls_rsa_pkcs1_verify( rsa, NULL, NULL,
     89                                            MBEDTLS_RSA_PUBLIC, md_alg,
     90                                            (unsigned int) hash_len, hash, sig ) ) != 0 )
   \       0x24   0x9003             STR      R0,[SP, #+12]
   \       0x26   0x9602             STR      R6,[SP, #+8]
   \       0x28   0x9701             STR      R7,[SP, #+4]
   \       0x2A   0x9500             STR      R5,[SP, #+0]
   \       0x2C   0x2300             MOVS     R3,#+0
   \       0x2E   0x461A             MOV      R2,R3
   \       0x30   0x4611             MOV      R1,R2
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x....'....        BL       mbedtls_rsa_pkcs1_verify
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD104             BNE.N    ??rsa_verify_wrap_1
     91                  return( ret );
     92          
     93              /* The buffer contains a valid signature followed by extra data.
     94               * We have a special error code for that so that so that callers can
     95               * use mbedtls_pk_verify() to check "Does the buffer start with a
     96               * valid signature?" and not just "Does the buffer contain a valid
     97               * signature?". */
     98              if( sig_len > rsa_len )
   \       0x3C   0x45C1             CMP      R9,R8
   \       0x3E   0xD201             BCS.N    ??rsa_verify_wrap_2
     99                  return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
   \       0x40   0x....             LDR.N    R0,??DataTable8_1  ;; 0xffffc700
   \       0x42   0xE000             B.N      ??rsa_verify_wrap_1
    100          
    101              return( 0 );
   \                     ??rsa_verify_wrap_2: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??rsa_verify_wrap_1: (+1)
   \       0x46   0xB005             ADD      SP,SP,#+20
   \       0x48   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    102          }
    103          

   \                                 In section .text, align 2, keep-with-next
    104          static int rsa_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    105                             const unsigned char *hash, size_t hash_len,
    106                             unsigned char *sig, size_t *sig_len,
    107                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    108          {
   \                     rsa_sign_wrap: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x461F             MOV      R7,R3
   \        0xE   0xF8DD 0x8038      LDR      R8,[SP, #+56]
   \       0x12   0xF8DD 0x903C      LDR      R9,[SP, #+60]
   \       0x16   0xF8DD 0xA040      LDR      R10,[SP, #+64]
   \       0x1A   0xF8DD 0xB044      LDR      R11,[SP, #+68]
    109              mbedtls_rsa_context * rsa = (mbedtls_rsa_context *) ctx;
    110          
    111          #if SIZE_MAX > UINT_MAX
    112              if( md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len )
    113                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    114          #endif /* SIZE_MAX > UINT_MAX */
    115          
    116              *sig_len = mbedtls_rsa_get_len( rsa );
   \       0x1E   0x....'....        BL       mbedtls_rsa_get_len
   \       0x22   0xF8C9 0x0000      STR      R0,[R9, #+0]
    117          
    118              return( mbedtls_rsa_pkcs1_sign( rsa, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
    119                          md_alg, (unsigned int) hash_len, hash, sig ) );
   \       0x26   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x2A   0x9602             STR      R6,[SP, #+8]
   \       0x2C   0x9701             STR      R7,[SP, #+4]
   \       0x2E   0x9500             STR      R5,[SP, #+0]
   \       0x30   0x2301             MOVS     R3,#+1
   \       0x32   0x465A             MOV      R2,R11
   \       0x34   0x4651             MOV      R1,R10
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x....'....        BL       mbedtls_rsa_pkcs1_sign
   \       0x3C   0xB005             ADD      SP,SP,#+20
   \       0x3E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    120          }
    121          

   \                                 In section .text, align 2, keep-with-next
    122          static int rsa_decrypt_wrap( void *ctx,
    123                              const unsigned char *input, size_t ilen,
    124                              unsigned char *output, size_t *olen, size_t osize,
    125                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    126          {
   \                     rsa_decrypt_wrap: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    127              mbedtls_rsa_context * rsa = (mbedtls_rsa_context *) ctx;
    128          
    129              if( ilen != mbedtls_rsa_get_len( rsa ) )
   \        0xC   0x....'....        BL       mbedtls_rsa_get_len
   \       0x10   0x4286             CMP      R6,R0
   \       0x12   0xD001             BEQ.N    ??rsa_decrypt_wrap_0
    130                  return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
   \       0x14   0x....             LDR.N    R0,??DataTable8_2  ;; 0xffffbf80
   \       0x16   0xE00B             B.N      ??rsa_decrypt_wrap_1
   \                     ??rsa_decrypt_wrap_0: (+1)
   \       0x18   0x9A0D             LDR      R2,[SP, #+52]
   \       0x1A   0x990C             LDR      R1,[SP, #+48]
   \       0x1C   0x9B0B             LDR      R3,[SP, #+44]
   \       0x1E   0x980A             LDR      R0,[SP, #+40]
    131          
    132              return( mbedtls_rsa_pkcs1_decrypt( rsa, f_rng, p_rng,
    133                          MBEDTLS_RSA_PRIVATE, olen, input, output, osize ) );
   \       0x20   0x9303             STR      R3,[SP, #+12]
   \       0x22   0x9702             STR      R7,[SP, #+8]
   \       0x24   0x9501             STR      R5,[SP, #+4]
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0x2301             MOVS     R3,#+1
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       mbedtls_rsa_pkcs1_decrypt
   \                     ??rsa_decrypt_wrap_1: (+1)
   \       0x30   0xB005             ADD      SP,SP,#+20
   \       0x32   0xBDF0             POP      {R4-R7,PC}       ;; return
    134          }
    135          

   \                                 In section .text, align 2, keep-with-next
    136          static int rsa_encrypt_wrap( void *ctx,
    137                              const unsigned char *input, size_t ilen,
    138                              unsigned char *output, size_t *olen, size_t osize,
    139                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    140          {
   \                     rsa_encrypt_wrap: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \       0x10   0xF8DD 0x902C      LDR      R9,[SP, #+44]
    141              mbedtls_rsa_context * rsa = (mbedtls_rsa_context *) ctx;
    142              *olen = mbedtls_rsa_get_len( rsa );
   \       0x14   0x....'....        BL       mbedtls_rsa_get_len
   \       0x18   0xF8C8 0x0000      STR      R0,[R8, #+0]
    143          
    144              if( *olen > osize )
   \       0x1C   0x4581             CMP      R9,R0
   \       0x1E   0xD201             BCS.N    ??rsa_encrypt_wrap_0
    145                  return( MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE );
   \       0x20   0x....             LDR.N    R0,??DataTable8_3  ;; 0xffffbc00
   \       0x22   0xE008             B.N      ??rsa_encrypt_wrap_1
   \                     ??rsa_encrypt_wrap_0: (+1)
   \       0x24   0x9A0D             LDR      R2,[SP, #+52]
   \       0x26   0x990C             LDR      R1,[SP, #+48]
    146          
    147              return( mbedtls_rsa_pkcs1_encrypt( rsa, f_rng, p_rng, MBEDTLS_RSA_PUBLIC,
    148                                                 ilen, input, output ) );
   \       0x28   0x9702             STR      R7,[SP, #+8]
   \       0x2A   0x9501             STR      R5,[SP, #+4]
   \       0x2C   0x9600             STR      R6,[SP, #+0]
   \       0x2E   0x2300             MOVS     R3,#+0
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       mbedtls_rsa_pkcs1_encrypt
   \                     ??rsa_encrypt_wrap_1: (+1)
   \       0x36   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    149          }
    150          

   \                                 In section .text, align 2, keep-with-next
    151          static int rsa_check_pair_wrap( const void *pub, const void *prv )
    152          {
    153              return( mbedtls_rsa_check_pub_priv( (const mbedtls_rsa_context *) pub,
    154                                          (const mbedtls_rsa_context *) prv ) );
   \                     rsa_check_pair_wrap: (+1)
   \        0x0   0x....'....        B.W      mbedtls_rsa_check_pub_priv
    155          }
    156          

   \                                 In section .text, align 2, keep-with-next
    157          static void *rsa_alloc_wrap( void )
    158          {
   \                     rsa_alloc_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    159              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_rsa_context ) );
   \        0x2   0x21AC             MOVS     R1,#+172
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x....'....        BL       mbedtls_calloc
   \        0xA   0x0004             MOVS     R4,R0
    160          
    161              if( ctx != NULL )
   \        0xC   0xD003             BEQ.N    ??rsa_alloc_wrap_0
    162                  mbedtls_rsa_init( (mbedtls_rsa_context *) ctx, 0, 0 );
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x4611             MOV      R1,R2
   \       0x12   0x....'....        BL       mbedtls_rsa_init
    163          
    164              return( ctx );
   \                     ??rsa_alloc_wrap_0: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    165          }
    166          

   \                                 In section .text, align 2, keep-with-next
    167          static void rsa_free_wrap( void *ctx )
    168          {
   \                     rsa_free_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    169              mbedtls_rsa_free( (mbedtls_rsa_context *) ctx );
   \        0x4   0x....'....        BL       mbedtls_rsa_free
    170              mbedtls_free( ctx );
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....'....        B.W      mbedtls_free
    171          }
    172          

   \                                 In section .text, align 2, keep-with-next
    173          static void rsa_debug( const void *ctx, mbedtls_pk_debug_item *items )
    174          {
    175              items->type = MBEDTLS_PK_DEBUG_MPI;
   \                     rsa_debug: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0x700A             STRB     R2,[R1, #+0]
    176              items->name = "rsa.N";
   \        0x4   0x....             LDR.N    R2,??DataTable8_4
   \        0x6   0x604A             STR      R2,[R1, #+4]
    177              items->value = &( ((mbedtls_rsa_context *) ctx)->N );
   \        0x8   0xF100 0x0208      ADD      R2,R0,#+8
   \        0xC   0x608A             STR      R2,[R1, #+8]
    178          
    179              items++;
    180          
    181              items->type = MBEDTLS_PK_DEBUG_MPI;
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0xF801 0x2F0C      STRB     R2,[R1, #+12]!
    182              items->name = "rsa.E";
   \       0x14   0x....             LDR.N    R2,??DataTable8_5
   \       0x16   0x604A             STR      R2,[R1, #+4]
    183              items->value = &( ((mbedtls_rsa_context *) ctx)->E );
   \       0x18   0x3014             ADDS     R0,R0,#+20
   \       0x1A   0x6088             STR      R0,[R1, #+8]
    184          }
   \       0x1C   0x4770             BX       LR               ;; return
    185          

   \                                 In section .rodata, align 4
    186          const mbedtls_pk_info_t mbedtls_rsa_info = {
   \                     mbedtls_rsa_info:
   \        0x0   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \        0x4   0x....'....        DC32 ?_0, rsa_get_bitlen, rsa_can_do, rsa_verify_wrap, rsa_sign_wrap
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \       0x18   0x....'....        DC32 rsa_decrypt_wrap, rsa_encrypt_wrap, rsa_check_pair_wrap
   \              0x....'....  
   \              0x....'....  
   \       0x24   0x....'....        DC32 rsa_alloc_wrap, rsa_free_wrap, rsa_debug
   \              0x....'....  
   \              0x....'....  
    187              MBEDTLS_PK_RSA,
    188              "RSA",
    189              rsa_get_bitlen,
    190              rsa_can_do,
    191              rsa_verify_wrap,
    192              rsa_sign_wrap,
    193              rsa_decrypt_wrap,
    194              rsa_encrypt_wrap,
    195              rsa_check_pair_wrap,
    196              rsa_alloc_wrap,
    197              rsa_free_wrap,
    198              rsa_debug,
    199          };
    200          #endif /* MBEDTLS_RSA_C */
    201          
    202          #if defined(MBEDTLS_ECP_C)
    203          /*
    204           * Generic EC key
    205           */

   \                                 In section .text, align 2, keep-with-next
    206          static int eckey_can_do( mbedtls_pk_type_t type )
    207          {
    208              return( type == MBEDTLS_PK_ECKEY ||
    209                      type == MBEDTLS_PK_ECKEY_DH ||
    210                      type == MBEDTLS_PK_ECDSA );
   \                     eckey_can_do: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x2902             CMP      R1,#+2
   \        0x4   0xD003             BEQ.N    ??eckey_can_do_0
   \        0x6   0x2903             CMP      R1,#+3
   \        0x8   0xD001             BEQ.N    ??eckey_can_do_0
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xD101             BNE.N    ??eckey_can_do_1
   \                     ??eckey_can_do_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR
   \                     ??eckey_can_do_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
    211          }
    212          

   \                                 In section .text, align 2, keep-with-next
    213          static size_t eckey_get_bitlen( const void *ctx )
    214          {
    215              return( ((mbedtls_ecp_keypair *) ctx)->grp.pbits );
   \                     eckey_get_bitlen: (+1)
   \        0x0   0x6D80             LDR      R0,[R0, #+88]
   \        0x2   0x4770             BX       LR               ;; return
    216          }
    217          
    218          #if defined(MBEDTLS_ECDSA_C)
    219          /* Forward declarations */
    220          static int ecdsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
    221                                 const unsigned char *hash, size_t hash_len,
    222                                 const unsigned char *sig, size_t sig_len );
    223          
    224          static int ecdsa_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    225                             const unsigned char *hash, size_t hash_len,
    226                             unsigned char *sig, size_t *sig_len,
    227                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
    228          

   \                                 In section .text, align 2, keep-with-next
    229          static int eckey_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
    230                                 const unsigned char *hash, size_t hash_len,
    231                                 const unsigned char *sig, size_t sig_len )
    232          {
   \                     eckey_verify_wrap: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB0AD             SUB      SP,SP,#+180
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    233              int ret;
    234              mbedtls_ecdsa_context ecdsa;
    235          
    236              mbedtls_ecdsa_init( &ecdsa );
   \        0xC   0xA802             ADD      R0,SP,#+8
   \        0xE   0x....'....        BL       mbedtls_ecdsa_init
    237          
    238              if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
   \       0x12   0x4621             MOV      R1,R4
   \       0x14   0xA802             ADD      R0,SP,#+8
   \       0x16   0x....'....        BL       mbedtls_ecdsa_from_keypair
   \       0x1A   0x0004             MOVS     R4,R0
   \       0x1C   0xD10A             BNE.N    ??eckey_verify_wrap_0
   \       0x1E   0x9933             LDR      R1,[SP, #+204]
   \       0x20   0x9832             LDR      R0,[SP, #+200]
    239                  ret = ecdsa_verify_wrap( &ecdsa, md_alg, hash, hash_len, sig, sig_len );
   \       0x22   0x9101             STR      R1,[SP, #+4]
   \       0x24   0x9000             STR      R0,[SP, #+0]
   \       0x26   0x463B             MOV      R3,R7
   \       0x28   0x4632             MOV      R2,R6
   \       0x2A   0x4629             MOV      R1,R5
   \       0x2C   0xA802             ADD      R0,SP,#+8
   \       0x2E   0x....'....        BL       ecdsa_verify_wrap
   \       0x32   0x4604             MOV      R4,R0
    240          
    241              mbedtls_ecdsa_free( &ecdsa );
   \                     ??eckey_verify_wrap_0: (+1)
   \       0x34   0xA802             ADD      R0,SP,#+8
   \       0x36   0x....'....        BL       mbedtls_ecdsa_free
    242          
    243              return( ret );
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0xB02D             ADD      SP,SP,#+180
   \       0x3E   0xBDF0             POP      {R4-R7,PC}       ;; return
    244          }
    245          

   \                                 In section .text, align 2, keep-with-next
    246          static int eckey_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    247                             const unsigned char *hash, size_t hash_len,
    248                             unsigned char *sig, size_t *sig_len,
    249                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    250          {
   \                     eckey_sign_wrap: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB0AF             SUB      SP,SP,#+188
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    251              int ret;
    252              mbedtls_ecdsa_context ecdsa;
    253          
    254              mbedtls_ecdsa_init( &ecdsa );
   \        0xC   0xA804             ADD      R0,SP,#+16
   \        0xE   0x....'....        BL       mbedtls_ecdsa_init
    255          
    256              if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
   \       0x12   0x4621             MOV      R1,R4
   \       0x14   0xA804             ADD      R0,SP,#+16
   \       0x16   0x....'....        BL       mbedtls_ecdsa_from_keypair
   \       0x1A   0x0004             MOVS     R4,R0
   \       0x1C   0xD10E             BNE.N    ??eckey_sign_wrap_0
   \       0x1E   0x9B37             LDR      R3,[SP, #+220]
   \       0x20   0x9A36             LDR      R2,[SP, #+216]
   \       0x22   0x9935             LDR      R1,[SP, #+212]
   \       0x24   0x9834             LDR      R0,[SP, #+208]
    257                  ret = ecdsa_sign_wrap( &ecdsa, md_alg, hash, hash_len, sig, sig_len,
    258                                         f_rng, p_rng );
   \       0x26   0x9303             STR      R3,[SP, #+12]
   \       0x28   0x9202             STR      R2,[SP, #+8]
   \       0x2A   0x9101             STR      R1,[SP, #+4]
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \       0x2E   0x463B             MOV      R3,R7
   \       0x30   0x4632             MOV      R2,R6
   \       0x32   0x4629             MOV      R1,R5
   \       0x34   0xA804             ADD      R0,SP,#+16
   \       0x36   0x....'....        BL       ecdsa_sign_wrap
   \       0x3A   0x4604             MOV      R4,R0
    259          
    260              mbedtls_ecdsa_free( &ecdsa );
   \                     ??eckey_sign_wrap_0: (+1)
   \       0x3C   0xA804             ADD      R0,SP,#+16
   \       0x3E   0x....'....        BL       mbedtls_ecdsa_free
    261          
    262              return( ret );
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0xB02F             ADD      SP,SP,#+188
   \       0x46   0xBDF0             POP      {R4-R7,PC}       ;; return
    263          }
    264          
    265          #endif /* MBEDTLS_ECDSA_C */
    266          

   \                                 In section .text, align 2, keep-with-next
    267          static int eckey_check_pair( const void *pub, const void *prv )
    268          {
    269              return( mbedtls_ecp_check_pub_priv( (const mbedtls_ecp_keypair *) pub,
    270                                          (const mbedtls_ecp_keypair *) prv ) );
   \                     eckey_check_pair: (+1)
   \        0x0   0x....'....        B.W      mbedtls_ecp_check_pub_priv
    271          }
    272          

   \                                 In section .text, align 2, keep-with-next
    273          static void *eckey_alloc_wrap( void )
    274          {
   \                     eckey_alloc_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    275              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecp_keypair ) );
   \        0x2   0x21AC             MOVS     R1,#+172
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x....'....        BL       mbedtls_calloc
   \        0xA   0x0004             MOVS     R4,R0
    276          
    277              if( ctx != NULL )
   \        0xC   0xD001             BEQ.N    ??eckey_alloc_wrap_0
    278                  mbedtls_ecp_keypair_init( ctx );
   \        0xE   0x....'....        BL       mbedtls_ecp_keypair_init
    279          
    280              return( ctx );
   \                     ??eckey_alloc_wrap_0: (+1)
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
    281          }
    282          

   \                                 In section .text, align 2, keep-with-next
    283          static void eckey_free_wrap( void *ctx )
    284          {
   \                     eckey_free_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    285              mbedtls_ecp_keypair_free( (mbedtls_ecp_keypair *) ctx );
   \        0x4   0x....'....        BL       mbedtls_ecp_keypair_free
    286              mbedtls_free( ctx );
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....'....        B.W      mbedtls_free
    287          }
    288          

   \                                 In section .text, align 2, keep-with-next
    289          static void eckey_debug( const void *ctx, mbedtls_pk_debug_item *items )
    290          {
    291              items->type = MBEDTLS_PK_DEBUG_ECP;
   \                     eckey_debug: (+1)
   \        0x0   0x2202             MOVS     R2,#+2
   \        0x2   0x700A             STRB     R2,[R1, #+0]
    292              items->name = "eckey.Q";
   \        0x4   0x....             LDR.N    R2,??DataTable8_6
   \        0x6   0x604A             STR      R2,[R1, #+4]
    293              items->value = &( ((mbedtls_ecp_keypair *) ctx)->Q );
   \        0x8   0x3088             ADDS     R0,R0,#+136
   \        0xA   0x6088             STR      R0,[R1, #+8]
    294          }
   \        0xC   0x4770             BX       LR               ;; return
    295          

   \                                 In section .rodata, align 4
    296          const mbedtls_pk_info_t mbedtls_eckey_info = {
   \                     mbedtls_eckey_info:
   \        0x0   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \        0x4   0x....'....        DC32 ?_1, eckey_get_bitlen, eckey_can_do, eckey_verify_wrap
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \       0x14   0x....'....        DC32 eckey_sign_wrap, 0H, 0H, eckey_check_pair, eckey_alloc_wrap
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x....'....  
   \              0x....'....  
   \       0x28   0x....'....        DC32 eckey_free_wrap, eckey_debug
   \              0x....'....  
    297              MBEDTLS_PK_ECKEY,
    298              "EC",
    299              eckey_get_bitlen,
    300              eckey_can_do,
    301          #if defined(MBEDTLS_ECDSA_C)
    302              eckey_verify_wrap,
    303              eckey_sign_wrap,
    304          #else
    305              NULL,
    306              NULL,
    307          #endif
    308              NULL,
    309              NULL,
    310              eckey_check_pair,
    311              eckey_alloc_wrap,
    312              eckey_free_wrap,
    313              eckey_debug,
    314          };
    315          
    316          /*
    317           * EC key restricted to ECDH
    318           */

   \                                 In section .text, align 2, keep-with-next
    319          static int eckeydh_can_do( mbedtls_pk_type_t type )
    320          {
    321              return( type == MBEDTLS_PK_ECKEY ||
    322                      type == MBEDTLS_PK_ECKEY_DH );
   \                     eckeydh_can_do: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x2902             CMP      R1,#+2
   \        0x4   0xD001             BEQ.N    ??eckeydh_can_do_0
   \        0x6   0x2803             CMP      R0,#+3
   \        0x8   0xD101             BNE.N    ??eckeydh_can_do_1
   \                     ??eckeydh_can_do_0: (+1)
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x4770             BX       LR
   \                     ??eckeydh_can_do_1: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR               ;; return
    323          }
    324          

   \                                 In section .rodata, align 4
    325          const mbedtls_pk_info_t mbedtls_eckeydh_info = {
   \                     mbedtls_eckeydh_info:
   \        0x0   0x03 0x00          DC8 3, 0, 0, 0
   \              0x00 0x00    
   \        0x4   0x....'....        DC32 ?_2, eckey_get_bitlen, eckeydh_can_do, 0H, 0H, 0H, 0H
   \              0x....'....  
   \              0x....'....  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \       0x20   0x....'....        DC32 eckey_check_pair, eckey_alloc_wrap, eckey_free_wrap, eckey_debug
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
    326              MBEDTLS_PK_ECKEY_DH,
    327              "EC_DH",
    328              eckey_get_bitlen,         /* Same underlying key structure */
    329              eckeydh_can_do,
    330              NULL,
    331              NULL,
    332              NULL,
    333              NULL,
    334              eckey_check_pair,
    335              eckey_alloc_wrap,       /* Same underlying key structure */
    336              eckey_free_wrap,        /* Same underlying key structure */
    337              eckey_debug,            /* Same underlying key structure */
    338          };
    339          #endif /* MBEDTLS_ECP_C */
    340          
    341          #if defined(MBEDTLS_ECDSA_C)

   \                                 In section .text, align 2, keep-with-next
    342          static int ecdsa_can_do( mbedtls_pk_type_t type )
    343          {
    344              return( type == MBEDTLS_PK_ECDSA );
   \                     ecdsa_can_do: (+1)
   \        0x0   0x2804             CMP      R0,#+4
   \        0x2   0xD101             BNE.N    ??ecdsa_can_do_0
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x4770             BX       LR
   \                     ??ecdsa_can_do_0: (+1)
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR               ;; return
    345          }
    346          

   \                                 In section .text, align 2, keep-with-next
    347          static int ecdsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
    348                                 const unsigned char *hash, size_t hash_len,
    349                                 const unsigned char *sig, size_t sig_len )
    350          {
   \                     ecdsa_verify_wrap: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4611             MOV      R1,R2
   \        0x4   0x461A             MOV      R2,R3
   \        0x6   0x9B04             LDR      R3,[SP, #+16]
   \        0x8   0x9C05             LDR      R4,[SP, #+20]
    351              int ret;
    352              ((void) md_alg);
    353          
    354              ret = mbedtls_ecdsa_read_signature( (mbedtls_ecdsa_context *) ctx,
    355                                          hash, hash_len, sig, sig_len );
   \        0xA   0x9400             STR      R4,[SP, #+0]
   \        0xC   0x....'....        BL       mbedtls_ecdsa_read_signature
    356          
    357              if( ret == MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH )
   \       0x10   0xF510 0x4F98      CMN      R0,#+19456
   \       0x14   0xD100             BNE.N    ??ecdsa_verify_wrap_0
    358                  return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
   \       0x16   0x....             LDR.N    R0,??DataTable8_1  ;; 0xffffc700
    359          
    360              return( ret );
   \                     ??ecdsa_verify_wrap_0: (+1)
   \       0x18   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    361          }
    362          

   \                                 In section .text, align 2, keep-with-next
    363          static int ecdsa_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    364                             const unsigned char *hash, size_t hash_len,
    365                             unsigned char *sig, size_t *sig_len,
    366                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    367          {
   \                     ecdsa_sign_wrap: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x9C0A             LDR      R4,[SP, #+40]
   \        0x6   0x9D0B             LDR      R5,[SP, #+44]
   \        0x8   0x9E0C             LDR      R6,[SP, #+48]
   \        0xA   0x9F0D             LDR      R7,[SP, #+52]
    368              return( mbedtls_ecdsa_write_signature( (mbedtls_ecdsa_context *) ctx,
    369                          md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng ) );
   \        0xC   0x9703             STR      R7,[SP, #+12]
   \        0xE   0x9602             STR      R6,[SP, #+8]
   \       0x10   0x9501             STR      R5,[SP, #+4]
   \       0x12   0x9400             STR      R4,[SP, #+0]
   \       0x14   0x....'....        BL       mbedtls_ecdsa_write_signature
   \       0x18   0xB005             ADD      SP,SP,#+20
   \       0x1A   0xBDF0             POP      {R4-R7,PC}       ;; return
    370          }
    371          

   \                                 In section .text, align 2, keep-with-next
    372          static void *ecdsa_alloc_wrap( void )
    373          {
   \                     ecdsa_alloc_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    374              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecdsa_context ) );
   \        0x2   0x21AC             MOVS     R1,#+172
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x....'....        BL       mbedtls_calloc
   \        0xA   0x0004             MOVS     R4,R0
    375          
    376              if( ctx != NULL )
   \        0xC   0xD001             BEQ.N    ??ecdsa_alloc_wrap_0
    377                  mbedtls_ecdsa_init( (mbedtls_ecdsa_context *) ctx );
   \        0xE   0x....'....        BL       mbedtls_ecdsa_init
    378          
    379              return( ctx );
   \                     ??ecdsa_alloc_wrap_0: (+1)
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
    380          }
    381          

   \                                 In section .text, align 2, keep-with-next
    382          static void ecdsa_free_wrap( void *ctx )
    383          {
   \                     ecdsa_free_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    384              mbedtls_ecdsa_free( (mbedtls_ecdsa_context *) ctx );
   \        0x4   0x....'....        BL       mbedtls_ecdsa_free
    385              mbedtls_free( ctx );
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....'....        B.W      mbedtls_free
    386          }
    387          

   \                                 In section .rodata, align 4
    388          const mbedtls_pk_info_t mbedtls_ecdsa_info = {
   \                     mbedtls_ecdsa_info:
   \        0x0   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    
   \        0x4   0x....'....        DC32 ?_3, eckey_get_bitlen, ecdsa_can_do, ecdsa_verify_wrap
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \       0x14   0x....'....        DC32 ecdsa_sign_wrap, 0H, 0H, eckey_check_pair, ecdsa_alloc_wrap
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x....'....  
   \              0x....'....  
   \       0x28   0x....'....        DC32 ecdsa_free_wrap, eckey_debug
   \              0x....'....  
    389              MBEDTLS_PK_ECDSA,
    390              "ECDSA",
    391              eckey_get_bitlen,     /* Compatible key structures */
    392              ecdsa_can_do,
    393              ecdsa_verify_wrap,
    394              ecdsa_sign_wrap,
    395              NULL,
    396              NULL,
    397              eckey_check_pair,   /* Compatible key structures */
    398              ecdsa_alloc_wrap,
    399              ecdsa_free_wrap,
    400              eckey_debug,        /* Compatible key structures */
    401          };
    402          #endif /* MBEDTLS_ECDSA_C */
    403          
    404          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
    405          /*
    406           * Support for alternative RSA-private implementations
    407           */
    408          

   \                                 In section .text, align 2, keep-with-next
    409          static int rsa_alt_can_do( mbedtls_pk_type_t type )
    410          {
    411              return( type == MBEDTLS_PK_RSA );
   \                     rsa_alt_can_do: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xD101             BNE.N    ??rsa_alt_can_do_0
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x4770             BX       LR
   \                     ??rsa_alt_can_do_0: (+1)
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR               ;; return
    412          }
    413          

   \                                 In section .text, align 2, keep-with-next
    414          static size_t rsa_alt_get_bitlen( const void *ctx )
    415          {
   \                     rsa_alt_get_bitlen: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4601             MOV      R1,R0
    416              const mbedtls_rsa_alt_context *rsa_alt = (const mbedtls_rsa_alt_context *) ctx;
    417          
    418              return( 8 * rsa_alt->key_len_func( rsa_alt->key ) );
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x68C9             LDR      R1,[R1, #+12]
   \        0x8   0x4788             BLX      R1
   \        0xA   0x00C0             LSLS     R0,R0,#+3
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
    419          }
    420          

   \                                 In section .text, align 2, keep-with-next
    421          static int rsa_alt_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    422                             const unsigned char *hash, size_t hash_len,
    423                             unsigned char *sig, size_t *sig_len,
    424                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    425          {
   \                     rsa_alt_sign_wrap: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x461F             MOV      R7,R3
   \        0xE   0xF8DD 0x8038      LDR      R8,[SP, #+56]
   \       0x12   0xF8DD 0x903C      LDR      R9,[SP, #+60]
   \       0x16   0xF8DD 0xA040      LDR      R10,[SP, #+64]
   \       0x1A   0xF8DD 0xB044      LDR      R11,[SP, #+68]
    426              mbedtls_rsa_alt_context *rsa_alt = (mbedtls_rsa_alt_context *) ctx;
    427          
    428          #if SIZE_MAX > UINT_MAX
    429              if( UINT_MAX < hash_len )
    430                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    431          #endif /* SIZE_MAX > UINT_MAX */
    432          
    433              *sig_len = rsa_alt->key_len_func( rsa_alt->key );
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x68E1             LDR      R1,[R4, #+12]
   \       0x22   0x4788             BLX      R1
   \       0x24   0xF8C9 0x0000      STR      R0,[R9, #+0]
    434          
    435              return( rsa_alt->sign_func( rsa_alt->key, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
    436                          md_alg, (unsigned int) hash_len, hash, sig ) );
   \       0x28   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x2C   0x9602             STR      R6,[SP, #+8]
   \       0x2E   0x9701             STR      R7,[SP, #+4]
   \       0x30   0x9500             STR      R5,[SP, #+0]
   \       0x32   0x2301             MOVS     R3,#+1
   \       0x34   0x465A             MOV      R2,R11
   \       0x36   0x4651             MOV      R1,R10
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x68A4             LDR      R4,[R4, #+8]
   \       0x3C   0x47A0             BLX      R4
   \       0x3E   0xB005             ADD      SP,SP,#+20
   \       0x40   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    437          }
    438          

   \                                 In section .text, align 2, keep-with-next
    439          static int rsa_alt_decrypt_wrap( void *ctx,
    440                              const unsigned char *input, size_t ilen,
    441                              unsigned char *output, size_t *olen, size_t osize,
    442                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    443          {
   \                     rsa_alt_decrypt_wrap: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    444              mbedtls_rsa_alt_context *rsa_alt = (mbedtls_rsa_alt_context *) ctx;
    445          
    446              ((void) f_rng);
    447              ((void) p_rng);
    448          
    449              if( ilen != rsa_alt->key_len_func( rsa_alt->key ) )
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x68E1             LDR      R1,[R4, #+12]
   \        0xE   0x4788             BLX      R1
   \       0x10   0x4286             CMP      R6,R0
   \       0x12   0xD001             BEQ.N    ??rsa_alt_decrypt_wrap_0
    450                  return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
   \       0x14   0x....             LDR.N    R0,??DataTable8_2  ;; 0xffffbf80
   \       0x16   0xBDFE             POP      {R1-R7,PC}
   \                     ??rsa_alt_decrypt_wrap_0: (+1)
   \       0x18   0x9809             LDR      R0,[SP, #+36]
   \       0x1A   0x9A08             LDR      R2,[SP, #+32]
    451          
    452              return( rsa_alt->decrypt_func( rsa_alt->key,
    453                          MBEDTLS_RSA_PRIVATE, olen, input, output, osize ) );
   \       0x1C   0x9001             STR      R0,[SP, #+4]
   \       0x1E   0x9700             STR      R7,[SP, #+0]
   \       0x20   0x462B             MOV      R3,R5
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6864             LDR      R4,[R4, #+4]
   \       0x28   0x47A0             BLX      R4
   \       0x2A   0xBDFE             POP      {R1-R7,PC}       ;; return
    454          }
    455          
    456          #if defined(MBEDTLS_RSA_C)

   \                                 In section .text, align 2, keep-with-next
    457          static int rsa_alt_check_pair( const void *pub, const void *prv )
    458          {
   \                     rsa_alt_check_pair: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xF5AD 0x7D0D      SUB      SP,SP,#+564
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
    459              unsigned char sig[MBEDTLS_MPI_MAX_SIZE];
    460              unsigned char hash[32];
    461              size_t sig_len = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9004             STR      R0,[SP, #+16]
    462              int ret;
    463          
    464              if( rsa_alt_get_bitlen( prv ) != rsa_get_bitlen( pub ) )
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x....'....        BL       rsa_alt_get_bitlen
   \       0x14   0x4606             MOV      R6,R0
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x....'....        BL       rsa_get_bitlen
   \       0x1C   0x4286             CMP      R6,R0
   \       0x1E   0xD001             BEQ.N    ??rsa_alt_check_pair_0
    465                  return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
   \       0x20   0x....             LDR.N    R0,??DataTable8_7  ;; 0xffffbe00
   \       0x22   0xE022             B.N      ??rsa_alt_check_pair_1
    466          
    467              memset( hash, 0x2a, sizeof( hash ) );
   \                     ??rsa_alt_check_pair_0: (+1)
   \       0x24   0x222A             MOVS     R2,#+42
   \       0x26   0x2120             MOVS     R1,#+32
   \       0x28   0xA805             ADD      R0,SP,#+20
   \       0x2A   0x....'....        BL       __aeabi_memset4
    468          
    469              if( ( ret = rsa_alt_sign_wrap( (void *) prv, MBEDTLS_MD_NONE,
    470                                             hash, sizeof( hash ),
    471                                             sig, &sig_len, NULL, NULL ) ) != 0 )
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x9003             STR      R0,[SP, #+12]
   \       0x32   0x9002             STR      R0,[SP, #+8]
   \       0x34   0xA804             ADD      R0,SP,#+16
   \       0x36   0x9001             STR      R0,[SP, #+4]
   \       0x38   0xA80D             ADD      R0,SP,#+52
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0x2320             MOVS     R3,#+32
   \       0x3E   0xAA05             ADD      R2,SP,#+20
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0x....'....        BL       rsa_alt_sign_wrap
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD10E             BNE.N    ??rsa_alt_check_pair_1
    472              {
    473                  return( ret );
    474              }
    475          
    476              if( rsa_verify_wrap( (void *) pub, MBEDTLS_MD_NONE,
    477                                   hash, sizeof( hash ), sig, sig_len ) != 0 )
   \       0x4C   0x9804             LDR      R0,[SP, #+16]
   \       0x4E   0x9001             STR      R0,[SP, #+4]
   \       0x50   0xA80D             ADD      R0,SP,#+52
   \       0x52   0x9000             STR      R0,[SP, #+0]
   \       0x54   0x2320             MOVS     R3,#+32
   \       0x56   0xAA05             ADD      R2,SP,#+20
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x....'....        BL       rsa_verify_wrap
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD001             BEQ.N    ??rsa_alt_check_pair_2
    478              {
    479                  return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
   \       0x64   0x....             LDR.N    R0,??DataTable8_7  ;; 0xffffbe00
   \       0x66   0xE000             B.N      ??rsa_alt_check_pair_1
    480              }
    481          
    482              return( 0 );
   \                     ??rsa_alt_check_pair_2: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??rsa_alt_check_pair_1: (+1)
   \       0x6A   0xF50D 0x7D0E      ADD      SP,SP,#+568
   \       0x6E   0xBD70             POP      {R4-R6,PC}       ;; return
    483          }
    484          #endif /* MBEDTLS_RSA_C */
    485          

   \                                 In section .text, align 2, keep-with-next
    486          static void *rsa_alt_alloc_wrap( void )
    487          {
   \                     rsa_alt_alloc_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    488              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_rsa_alt_context ) );
   \        0x2   0x2110             MOVS     R1,#+16
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x....'....        BL       mbedtls_calloc
   \        0xA   0x0004             MOVS     R4,R0
    489          
    490              if( ctx != NULL )
   \        0xC   0xD003             BEQ.N    ??rsa_alt_alloc_wrap_0
    491                  memset( ctx, 0, sizeof( mbedtls_rsa_alt_context ) );
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x2110             MOVS     R1,#+16
   \       0x12   0x....'....        BL       __aeabi_memset
    492          
    493              return( ctx );
   \                     ??rsa_alt_alloc_wrap_0: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    494          }
    495          

   \                                 In section .text, align 2, keep-with-next
    496          static void rsa_alt_free_wrap( void *ctx )
    497          {
   \                     rsa_alt_free_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    498              mbedtls_platform_zeroize( ctx, sizeof( mbedtls_rsa_alt_context ) );
   \        0x4   0x2110             MOVS     R1,#+16
   \        0x6   0x....'....        BL       mbedtls_platform_zeroize
    499              mbedtls_free( ctx );
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0xE8BD 0x4010      POP      {R4,LR}
   \       0x10   0x....'....        B.W      mbedtls_free
    500          }
    501          

   \                                 In section .rodata, align 4
    502          const mbedtls_pk_info_t mbedtls_rsa_alt_info = {
   \                     mbedtls_rsa_alt_info:
   \        0x0   0x05 0x00          DC8 5, 0, 0, 0
   \              0x00 0x00    
   \        0x4   0x....'....        DC32 ?_4, rsa_alt_get_bitlen, rsa_alt_can_do, 0H, rsa_alt_sign_wrap
   \              0x....'....  
   \              0x....'....  
   \              0x0000'0000  
   \              0x....'....  
   \       0x18   0x....'....        DC32 rsa_alt_decrypt_wrap, 0H, rsa_alt_check_pair, rsa_alt_alloc_wrap
   \              0x0000'0000  
   \              0x....'....  
   \              0x....'....  
   \       0x28   0x....'....        DC32 rsa_alt_free_wrap, 0H
   \              0x0000'0000  

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0xFFFF'BC80        DC32     0xffffbc80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0xFFFF'C700        DC32     0xffffc700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0xFFFF'BF80        DC32     0xffffbf80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0xFFFF'BC00        DC32     0xffffbc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0xFFFF'BE00        DC32     0xffffbe00

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x52 0x53          DC8 "RSA"
   \              0x41 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x45 0x43          DC8 "EC"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x45 0x43          DC8 "EC_DH"
   \              0x5F 0x44    
   \              0x48 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x45 0x43          DC8 "ECDSA"
   \              0x44 0x53    
   \              0x41 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x52 0x53          DC8 "RSA-alt"
   \              0x41 0x2D    
   \              0x61 0x6C    
   \              0x74 0x00    

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x72 0x73          DC8 "rsa.N"
   \              0x61 0x2E    
   \              0x4E 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x72 0x73          DC8 "rsa.E"
   \              0x61 0x2E    
   \              0x45 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x65 0x63          DC8 "eckey.Q"
   \              0x6B 0x65    
   \              0x79 0x2E    
   \              0x51 0x00    
    503              MBEDTLS_PK_RSA_ALT,
    504              "RSA-alt",
    505              rsa_alt_get_bitlen,
    506              rsa_alt_can_do,
    507              NULL,
    508              rsa_alt_sign_wrap,
    509              rsa_alt_decrypt_wrap,
    510              NULL,
    511          #if defined(MBEDTLS_RSA_C)
    512              rsa_alt_check_pair,
    513          #else
    514              NULL,
    515          #endif
    516              rsa_alt_alloc_wrap,
    517              rsa_alt_free_wrap,
    518              NULL,
    519          };
    520          
    521          #endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
    522          
    523          #endif /* MBEDTLS_PK_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ecdsa_alloc_wrap
         8   -> mbedtls_calloc
         8   -> mbedtls_ecdsa_init
       0   ecdsa_can_do
       8   ecdsa_free_wrap
         8   -> mbedtls_ecdsa_free
         0   -> mbedtls_free
      40   ecdsa_sign_wrap
        40   -> mbedtls_ecdsa_write_signature
      16   ecdsa_verify_wrap
        16   -> mbedtls_ecdsa_read_signature
       8   eckey_alloc_wrap
         8   -> mbedtls_calloc
         8   -> mbedtls_ecp_keypair_init
       0   eckey_can_do
       0   eckey_check_pair
         0   -> mbedtls_ecp_check_pub_priv
       0   eckey_debug
       8   eckey_free_wrap
         8   -> mbedtls_ecp_keypair_free
         0   -> mbedtls_free
       0   eckey_get_bitlen
     208   eckey_sign_wrap
       208   -> ecdsa_sign_wrap
       208   -> mbedtls_ecdsa_free
       208   -> mbedtls_ecdsa_from_keypair
       208   -> mbedtls_ecdsa_init
     200   eckey_verify_wrap
       200   -> ecdsa_verify_wrap
       200   -> mbedtls_ecdsa_free
       200   -> mbedtls_ecdsa_from_keypair
       200   -> mbedtls_ecdsa_init
       0   eckeydh_can_do
       8   rsa_alloc_wrap
         8   -> mbedtls_calloc
         8   -> mbedtls_rsa_init
       8   rsa_alt_alloc_wrap
         8   -> __aeabi_memset
         8   -> mbedtls_calloc
       0   rsa_alt_can_do
     584   rsa_alt_check_pair
       584   -> __aeabi_memset4
       584   -> rsa_alt_get_bitlen
       584   -> rsa_alt_sign_wrap
       584   -> rsa_get_bitlen
       584   -> rsa_verify_wrap
      32   rsa_alt_decrypt_wrap
        32   -- Indirect call
       8   rsa_alt_free_wrap
         0   -> mbedtls_free
         8   -> mbedtls_platform_zeroize
       8   rsa_alt_get_bitlen
         8   -- Indirect call
      56   rsa_alt_sign_wrap
        56   -- Indirect call
       0   rsa_can_do
       0   rsa_check_pair_wrap
         0   -> mbedtls_rsa_check_pub_priv
       0   rsa_debug
      40   rsa_decrypt_wrap
        40   -> mbedtls_rsa_get_len
        40   -> mbedtls_rsa_pkcs1_decrypt
      40   rsa_encrypt_wrap
        40   -> mbedtls_rsa_get_len
        40   -> mbedtls_rsa_pkcs1_encrypt
       8   rsa_free_wrap
         0   -> mbedtls_free
         8   -> mbedtls_rsa_free
       8   rsa_get_bitlen
         8   -> mbedtls_rsa_get_len
      56   rsa_sign_wrap
        56   -> mbedtls_rsa_get_len
        56   -> mbedtls_rsa_pkcs1_sign
      48   rsa_verify_wrap
        48   -> mbedtls_rsa_get_len
        48   -> mbedtls_rsa_pkcs1_verify


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ?_0
       4  ?_1
       8  ?_2
       8  ?_3
       8  ?_4
       8  ?_5
       8  ?_6
       8  ?_7
      22  ecdsa_alloc_wrap
      12  ecdsa_can_do
      18  ecdsa_free_wrap
      28  ecdsa_sign_wrap
      26  ecdsa_verify_wrap
      22  eckey_alloc_wrap
      22  eckey_can_do
       4  eckey_check_pair
      14  eckey_debug
      18  eckey_free_wrap
       4  eckey_get_bitlen
      72  eckey_sign_wrap
      64  eckey_verify_wrap
      18  eckeydh_can_do
      48  mbedtls_ecdsa_info
      48  mbedtls_eckey_info
      48  mbedtls_eckeydh_info
      48  mbedtls_rsa_alt_info
      48  mbedtls_rsa_info
      26  rsa_alloc_wrap
      26  rsa_alt_alloc_wrap
      12  rsa_alt_can_do
     112  rsa_alt_check_pair
      44  rsa_alt_decrypt_wrap
      20  rsa_alt_free_wrap
      14  rsa_alt_get_bitlen
      68  rsa_alt_sign_wrap
      18  rsa_can_do
       4  rsa_check_pair_wrap
      30  rsa_debug
      52  rsa_decrypt_wrap
      58  rsa_encrypt_wrap
      18  rsa_free_wrap
      10  rsa_get_bitlen
      66  rsa_sign_wrap
      76  rsa_verify_wrap

 
   296 bytes in section .rodata
 1 030 bytes in section .text
 
 1 030 bytes of CODE  memory
   296 bytes of CONST memory

Errors: none
Warnings: none
