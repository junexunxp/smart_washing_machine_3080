###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  18:40:34
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\source\fsl_lpuart_freertos.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW6B69.tmp
#        (C:\Development\smart_washing_machine_3080\source\fsl_lpuart_freertos.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\fsl_lpuart_freertos.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\fsl_lpuart_freertos.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\source\fsl_lpuart_freertos.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           * All rights reserved.
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           */
      8          
      9          #include "fsl_lpuart_freertos.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LPUART_EnableTx(LPUART_Type *, bool)
   \                     LPUART_EnableTx: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0x6981             LDR      R1,[R0, #+24]
   \        0x4   0xD003             BEQ.N    ??LPUART_EnableTx_0
   \        0x6   0xF441 0x2100      ORR      R1,R1,#0x80000
   \        0xA   0x6181             STR      R1,[R0, #+24]
   \        0xC   0x4770             BX       LR
   \                     ??LPUART_EnableTx_0: (+1)
   \        0xE   0xF421 0x2100      BIC      R1,R1,#0x80000
   \       0x12   0x6181             STR      R1,[R0, #+24]
   \       0x14   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LPUART_EnableRx(LPUART_Type *, bool)
   \                     LPUART_EnableRx: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0x6981             LDR      R1,[R0, #+24]
   \        0x4   0xD003             BEQ.N    ??LPUART_EnableRx_0
   \        0x6   0xF441 0x2180      ORR      R1,R1,#0x40000
   \        0xA   0x6181             STR      R1,[R0, #+24]
   \        0xC   0x4770             BX       LR
   \                     ??LPUART_EnableRx_0: (+1)
   \        0xE   0xF421 0x2180      BIC      R1,R1,#0x40000
   \       0x12   0x6181             STR      R1,[R0, #+24]
   \       0x14   0x4770             BX       LR               ;; return
     10          #include <FreeRTOS.h>
     11          #include <event_groups.h>
     12          #include <semphr.h>
     13          
     14          /* Component ID definition, used by tools. */
     15          #ifndef FSL_COMPONENT_ID
     16          #define FSL_COMPONENT_ID "platform.drivers.lpuart_freertos"
     17          #endif
     18          

   \                                 In section .text, align 2, keep-with-next
     19          static void LPUART_RTOS_Callback(LPUART_Type *base, lpuart_handle_t *state, status_t status, void *param)
     20          {
   \                     LPUART_RTOS_Callback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x461D             MOV      R5,R3
     21              lpuart_rtos_handle_t *handle = (lpuart_rtos_handle_t *)param;
     22              BaseType_t xHigherPriorityTaskWoken, xResult;
     23          
     24              xHigherPriorityTaskWoken = pdFALSE;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9000             STR      R0,[SP, #+0]
     25              xResult                  = pdFAIL;
     26          
     27              if (status == kStatus_LPUART_RxIdle)
   \        0xA   0xF240 0x5117      MOVW     R1,#+1303
   \        0xE   0x428A             CMP      R2,R1
   \       0x10   0xD105             BNE.N    ??LPUART_RTOS_Callback_0
     28              {
     29                  xResult = xEventGroupSetBitsFromISR(handle->rxEvent, RTOS_LPUART_COMPLETE, &xHigherPriorityTaskWoken);
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x69E8             LDR      R0,[R5, #+28]
   \       0x18   0x....'....        BL       xEventGroupSetBitsFromISR
   \       0x1C   0xE021             B.N      ??LPUART_RTOS_Callback_1
     30              }
     31              else if (status == kStatus_LPUART_TxIdle)
   \                     ??LPUART_RTOS_Callback_0: (+1)
   \       0x1E   0xF240 0x5116      MOVW     R1,#+1302
   \       0x22   0x428A             CMP      R2,R1
   \       0x24   0xD105             BNE.N    ??LPUART_RTOS_Callback_2
     32              {
     33                  xResult = xEventGroupSetBitsFromISR(handle->txEvent, RTOS_LPUART_COMPLETE, &xHigherPriorityTaskWoken);
   \       0x26   0x466A             MOV      R2,SP
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x6A28             LDR      R0,[R5, #+32]
   \       0x2C   0x....'....        BL       xEventGroupSetBitsFromISR
   \       0x30   0xE017             B.N      ??LPUART_RTOS_Callback_1
     34              }
     35              else if (status == kStatus_LPUART_RxRingBufferOverrun)
   \                     ??LPUART_RTOS_Callback_2: (+1)
   \       0x32   0xF240 0x511C      MOVW     R1,#+1308
   \       0x36   0x428A             CMP      R2,R1
   \       0x38   0xD105             BNE.N    ??LPUART_RTOS_Callback_3
     36              {
     37                  xResult =
     38                      xEventGroupSetBitsFromISR(handle->rxEvent, RTOS_LPUART_RING_BUFFER_OVERRUN, &xHigherPriorityTaskWoken);
   \       0x3A   0x466A             MOV      R2,SP
   \       0x3C   0x2102             MOVS     R1,#+2
   \       0x3E   0x69E8             LDR      R0,[R5, #+28]
   \       0x40   0x....'....        BL       xEventGroupSetBitsFromISR
   \       0x44   0xE00D             B.N      ??LPUART_RTOS_Callback_1
     39              }
     40              else if (status == kStatus_LPUART_RxHardwareOverrun)
   \                     ??LPUART_RTOS_Callback_3: (+1)
   \       0x46   0xF240 0x511D      MOVW     R1,#+1309
   \       0x4A   0x428A             CMP      R2,R1
   \       0x4C   0xD109             BNE.N    ??LPUART_RTOS_Callback_1
     41              {
     42                  /* Clear Overrun flag (OR) in LPUART STAT register */
     43                  LPUART_ClearStatusFlags(base, kLPUART_RxOverrunFlag);
   \       0x4E   0xF44F 0x2100      MOV      R1,#+524288
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x....'....        BL       LPUART_ClearStatusFlags
     44                  xResult =
     45                      xEventGroupSetBitsFromISR(handle->rxEvent, RTOS_LPUART_HARDWARE_BUFFER_OVERRUN, &xHigherPriorityTaskWoken);
   \       0x58   0x466A             MOV      R2,SP
   \       0x5A   0x2104             MOVS     R1,#+4
   \       0x5C   0x69E8             LDR      R0,[R5, #+28]
   \       0x5E   0x....'....        BL       xEventGroupSetBitsFromISR
     46              }
     47          
     48              if (xResult != pdFAIL)
   \                     ??LPUART_RTOS_Callback_1: (+1)
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD00A             BEQ.N    ??LPUART_RTOS_Callback_4
     49              {
     50                  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   \       0x66   0x9800             LDR      R0,[SP, #+0]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD007             BEQ.N    ??LPUART_RTOS_Callback_4
   \       0x6C   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x70   0x....             LDR.N    R1,??DataTable2  ;; 0xe000ed04
   \       0x72   0x6008             STR      R0,[R1, #+0]
   \       0x74   0xF3BF 0x8F4F      DSB      SY
   \       0x78   0xF3BF 0x8F6F      ISB      SY
     51              }
     52          }
   \                     ??LPUART_RTOS_Callback_4: (+1)
   \       0x7C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     53          
     54          /*FUNCTION**********************************************************************
     55           *
     56           * Function Name : LPUART_RTOS_Init
     57           * Description   : Initializes the LPUART instance for application
     58           *
     59           *END**************************************************************************/
     60          /*!
     61           * brief Initializes an LPUART instance for operation in RTOS.
     62           *
     63           * param handle The RTOS LPUART handle, the pointer to an allocated space for RTOS context.
     64           * param t_handle The pointer to an allocated space to store the transactional layer internal state.
     65           * param cfg The pointer to the parameters required to configure the LPUART after initialization.
     66           * return 0 succeed, others failed
     67           */

   \                                 In section .text, align 2, keep-with-next
     68          int LPUART_RTOS_Init(lpuart_rtos_handle_t *handle, lpuart_handle_t *t_handle, const lpuart_rtos_config_t *cfg)
     69          {
   \                     LPUART_RTOS_Init: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4615             MOV      R5,R2
     70              lpuart_config_t defcfg;
     71          
     72              if (NULL == handle)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD00C             BEQ.N    ??LPUART_RTOS_Init_0
     73              {
     74                  return kStatus_InvalidArgument;
     75              }
     76              if (NULL == t_handle)
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD00A             BEQ.N    ??LPUART_RTOS_Init_0
     77              {
     78                  return kStatus_InvalidArgument;
     79              }
     80              if (NULL == cfg)
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD008             BEQ.N    ??LPUART_RTOS_Init_0
     81              {
     82                  return kStatus_InvalidArgument;
     83              }
     84              if (NULL == cfg->base)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD005             BEQ.N    ??LPUART_RTOS_Init_0
     85              {
     86                  return kStatus_InvalidArgument;
     87              }
     88              if (0 == cfg->srcclk)
   \       0x1A   0x6868             LDR      R0,[R5, #+4]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD002             BEQ.N    ??LPUART_RTOS_Init_0
     89              {
     90                  return kStatus_InvalidArgument;
     91              }
     92              if (0 == cfg->baudrate)
   \       0x20   0x68A8             LDR      R0,[R5, #+8]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD101             BNE.N    ??LPUART_RTOS_Init_1
     93              {
     94                  return kStatus_InvalidArgument;
   \                     ??LPUART_RTOS_Init_0: (+1)
   \       0x26   0x2004             MOVS     R0,#+4
   \       0x28   0xE057             B.N      ??LPUART_RTOS_Init_2
     95              }
     96          
     97              handle->base    = cfg->base;
   \                     ??LPUART_RTOS_Init_1: (+1)
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x6020             STR      R0,[R4, #+0]
     98              handle->t_state = t_handle;
   \       0x2E   0x6261             STR      R1,[R4, #+36]
     99          #if (configSUPPORT_STATIC_ALLOCATION == 1)
    100              handle->txSemaphore = xSemaphoreCreateMutexStatic(&handle->txSemaphoreBuffer);
    101          #else
    102              handle->txSemaphore = xSemaphoreCreateMutex();
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x....'....        BL       xQueueCreateMutex
   \       0x36   0x61A0             STR      R0,[R4, #+24]
    103          #endif
    104              if (NULL == handle->txSemaphore)
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD101             BNE.N    ??LPUART_RTOS_Init_3
    105              {
    106                  return kStatus_Fail;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xE04C             B.N      ??LPUART_RTOS_Init_2
    107              }
    108          #if (configSUPPORT_STATIC_ALLOCATION == 1)
    109              handle->rxSemaphore = xSemaphoreCreateMutexStatic(&handle->rxSemaphoreBuffer);
    110          #else
    111              handle->rxSemaphore = xSemaphoreCreateMutex();
   \                     ??LPUART_RTOS_Init_3: (+1)
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0x....'....        BL       xQueueCreateMutex
   \       0x46   0x6160             STR      R0,[R4, #+20]
    112          #endif
    113              if (NULL == handle->rxSemaphore)
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD104             BNE.N    ??LPUART_RTOS_Init_4
    114              {
    115                  vSemaphoreDelete(handle->txSemaphore);
   \       0x4C   0x69A0             LDR      R0,[R4, #+24]
   \       0x4E   0x....'....        BL       vQueueDelete
    116                  return kStatus_Fail;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xE041             B.N      ??LPUART_RTOS_Init_2
    117              }
    118          #if (configSUPPORT_STATIC_ALLOCATION == 1)
    119              handle->txEvent = xEventGroupCreateStatic(&handle->txEventBuffer);
    120          #else
    121              handle->txEvent     = xEventGroupCreate();
   \                     ??LPUART_RTOS_Init_4: (+1)
   \       0x56   0x....'....        BL       xEventGroupCreate
   \       0x5A   0x6220             STR      R0,[R4, #+32]
    122          #endif
    123              if (NULL == handle->txEvent)
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD107             BNE.N    ??LPUART_RTOS_Init_5
    124              {
    125                  vSemaphoreDelete(handle->rxSemaphore);
   \       0x60   0x6960             LDR      R0,[R4, #+20]
   \       0x62   0x....'....        BL       vQueueDelete
    126                  vSemaphoreDelete(handle->txSemaphore);
   \       0x66   0x69A0             LDR      R0,[R4, #+24]
   \       0x68   0x....'....        BL       vQueueDelete
    127                  return kStatus_Fail;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xE034             B.N      ??LPUART_RTOS_Init_2
    128              }
    129          #if (configSUPPORT_STATIC_ALLOCATION == 1)
    130              handle->rxEvent = xEventGroupCreateStatic(&handle->rxEventBuffer);
    131          #else
    132              handle->rxEvent     = xEventGroupCreate();
   \                     ??LPUART_RTOS_Init_5: (+1)
   \       0x70   0x....'....        BL       xEventGroupCreate
   \       0x74   0x61E0             STR      R0,[R4, #+28]
    133          #endif
    134              if (NULL == handle->rxEvent)
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD10A             BNE.N    ??LPUART_RTOS_Init_6
    135              {
    136                  vEventGroupDelete(handle->txEvent);
   \       0x7A   0x6A20             LDR      R0,[R4, #+32]
   \       0x7C   0x....'....        BL       vEventGroupDelete
    137                  vSemaphoreDelete(handle->rxSemaphore);
   \       0x80   0x6960             LDR      R0,[R4, #+20]
   \       0x82   0x....'....        BL       vQueueDelete
    138                  vSemaphoreDelete(handle->txSemaphore);
   \       0x86   0x69A0             LDR      R0,[R4, #+24]
   \       0x88   0x....'....        BL       vQueueDelete
    139                  return kStatus_Fail;
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xE024             B.N      ??LPUART_RTOS_Init_2
    140              }
    141              LPUART_GetDefaultConfig(&defcfg);
   \                     ??LPUART_RTOS_Init_6: (+1)
   \       0x90   0x4668             MOV      R0,SP
   \       0x92   0x....'....        BL       LPUART_GetDefaultConfig
    142          
    143              defcfg.baudRate_Bps = cfg->baudrate;
   \       0x96   0x68A8             LDR      R0,[R5, #+8]
   \       0x98   0x9000             STR      R0,[SP, #+0]
    144              defcfg.parityMode   = cfg->parity;
   \       0x9A   0x7B28             LDRB     R0,[R5, #+12]
   \       0x9C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    145              defcfg.stopBitCount = cfg->stopbits;
   \       0xA0   0x7B68             LDRB     R0,[R5, #+13]
   \       0xA2   0xF88D 0x0007      STRB     R0,[SP, #+7]
    146          
    147              LPUART_Init(handle->base, &defcfg, cfg->srcclk);
   \       0xA6   0x686A             LDR      R2,[R5, #+4]
   \       0xA8   0x4669             MOV      R1,SP
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x....'....        BL       LPUART_Init
    148              LPUART_TransferCreateHandle(handle->base, handle->t_state, LPUART_RTOS_Callback, handle);
   \       0xB0   0x4623             MOV      R3,R4
   \       0xB2   0x....             LDR.N    R2,??DataTable2_1
   \       0xB4   0x6A61             LDR      R1,[R4, #+36]
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x....'....        BL       LPUART_TransferCreateHandle
    149              LPUART_TransferStartRingBuffer(handle->base, handle->t_state, cfg->buffer, cfg->buffer_size);
   \       0xBC   0x696B             LDR      R3,[R5, #+20]
   \       0xBE   0x692A             LDR      R2,[R5, #+16]
   \       0xC0   0x6A61             LDR      R1,[R4, #+36]
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x....'....        BL       LPUART_TransferStartRingBuffer
    150          
    151              LPUART_EnableTx(handle->base, true);
   \       0xC8   0x2101             MOVS     R1,#+1
   \       0xCA   0x6820             LDR      R0,[R4, #+0]
   \       0xCC   0x....'....        BL       LPUART_EnableTx
    152              LPUART_EnableRx(handle->base, true);
   \       0xD0   0x2101             MOVS     R1,#+1
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x....'....        BL       LPUART_EnableRx
    153          
    154              return 0;
   \       0xD8   0x2000             MOVS     R0,#+0
   \                     ??LPUART_RTOS_Init_2: (+1)
   \       0xDA   0xB005             ADD      SP,SP,#+20
   \       0xDC   0xBD30             POP      {R4,R5,PC}       ;; return
    155          }
    156          
    157          /*FUNCTION**********************************************************************
    158           *
    159           * Function Name : LPUART_RTOS_Deinit
    160           * Description   : Deinitializes the LPUART instance and frees resources
    161           *
    162           *END**************************************************************************/
    163          /*!
    164           * brief Deinitializes an LPUART instance for operation.
    165           *
    166           * This function deinitializes the LPUART module, sets all register value to the reset value,
    167           * and releases the resources.
    168           *
    169           * param handle The RTOS LPUART handle.
    170           */

   \                                 In section .text, align 2, keep-with-next
    171          int LPUART_RTOS_Deinit(lpuart_rtos_handle_t *handle)
    172          {
   \                     LPUART_RTOS_Deinit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    173              LPUART_Deinit(handle->base);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x....'....        BL       LPUART_Deinit
    174          
    175              vEventGroupDelete(handle->txEvent);
   \        0xA   0x6A20             LDR      R0,[R4, #+32]
   \        0xC   0x....'....        BL       vEventGroupDelete
    176              vEventGroupDelete(handle->rxEvent);
   \       0x10   0x69E0             LDR      R0,[R4, #+28]
   \       0x12   0x....'....        BL       vEventGroupDelete
    177          
    178              /* Give the semaphore. This is for functional safety */
    179              xSemaphoreGive(handle->txSemaphore);
   \       0x16   0x2300             MOVS     R3,#+0
   \       0x18   0x461A             MOV      R2,R3
   \       0x1A   0x4611             MOV      R1,R2
   \       0x1C   0x69A0             LDR      R0,[R4, #+24]
   \       0x1E   0x....'....        BL       xQueueGenericSend
    180              xSemaphoreGive(handle->rxSemaphore);
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x461A             MOV      R2,R3
   \       0x26   0x4611             MOV      R1,R2
   \       0x28   0x6960             LDR      R0,[R4, #+20]
   \       0x2A   0x....'....        BL       xQueueGenericSend
    181          
    182              vSemaphoreDelete(handle->txSemaphore);
   \       0x2E   0x69A0             LDR      R0,[R4, #+24]
   \       0x30   0x....'....        BL       vQueueDelete
    183              vSemaphoreDelete(handle->rxSemaphore);
   \       0x34   0x6960             LDR      R0,[R4, #+20]
   \       0x36   0x....'....        BL       vQueueDelete
    184          
    185              /* Invalidate the handle */
    186              handle->base    = NULL;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x6020             STR      R0,[R4, #+0]
    187              handle->t_state = NULL;
   \       0x3E   0x6260             STR      R0,[R4, #+36]
    188          
    189              return 0;
   \       0x40   0xBD10             POP      {R4,PC}          ;; return
    190          }
    191          
    192          /*FUNCTION**********************************************************************
    193           *
    194           * Function Name : UART_RTOS_Send
    195           * Description   : Initializes the UART instance for application
    196           *
    197           *END**************************************************************************/
    198          /*!
    199           * brief Sends data in the background.
    200           *
    201           * This function sends data. It is an synchronous API.
    202           * If the hardware buffer is full, the task is in the blocked state.
    203           *
    204           * param handle The RTOS LPUART handle.
    205           * param buffer The pointer to buffer to send.
    206           * param length The number of bytes to send.
    207           */

   \                                 In section .text, align 2, keep-with-next
    208          int LPUART_RTOS_Send(lpuart_rtos_handle_t *handle, const uint8_t *buffer, uint32_t length, uint32_t timeout)
    209          {
   \                     LPUART_RTOS_Send: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461F             MOV      R7,R3
    210              EventBits_t ev;
    211              int retval = kStatus_Success;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    212          
    213              if (NULL == handle->base)
   \       0x10   0x6830             LDR      R0,[R6, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD00D             BEQ.N    ??LPUART_RTOS_Send_0
    214              {
    215                  /* Invalid handle. */
    216                  return kStatus_Fail;
    217              }
    218              if (0 == length)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD101             BNE.N    ??LPUART_RTOS_Send_1
    219              {
    220                  return 0;
   \       0x1A   0x4640             MOV      R0,R8
   \       0x1C   0xE028             B.N      ??LPUART_RTOS_Send_2
    221              }
    222              if (NULL == buffer)
   \                     ??LPUART_RTOS_Send_1: (+1)
   \       0x1E   0x2D00             CMP      R5,#+0
   \       0x20   0xD101             BNE.N    ??LPUART_RTOS_Send_3
    223              {
    224                  return kStatus_InvalidArgument;
   \       0x22   0x2004             MOVS     R0,#+4
   \       0x24   0xE024             B.N      ??LPUART_RTOS_Send_2
    225              }
    226          
    227              if (pdFALSE == xSemaphoreTake(handle->txSemaphore, timeout))
   \                     ??LPUART_RTOS_Send_3: (+1)
   \       0x26   0x4639             MOV      R1,R7
   \       0x28   0x69B0             LDR      R0,[R6, #+24]
   \       0x2A   0x....'....        BL       xQueueSemaphoreTake
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD101             BNE.N    ??LPUART_RTOS_Send_4
    228              {
    229                  /* We could not take the semaphore, exit with 0 data received */
    230                  return kStatus_Fail;
   \                     ??LPUART_RTOS_Send_0: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xE01C             B.N      ??LPUART_RTOS_Send_2
    231              }
    232          
    233              handle->txTransfer.data     = (uint8_t *)buffer;
   \                     ??LPUART_RTOS_Send_4: (+1)
   \       0x36   0x6075             STR      R5,[R6, #+4]
    234              handle->txTransfer.dataSize = (uint32_t)length;
   \       0x38   0x60B4             STR      R4,[R6, #+8]
    235          
    236              /* Non-blocking call */
    237              LPUART_TransferSendNonBlocking(handle->base, handle->t_state, &handle->txTransfer);
   \       0x3A   0x1D32             ADDS     R2,R6,#+4
   \       0x3C   0x6A71             LDR      R1,[R6, #+36]
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0x....'....        BL       LPUART_TransferSendNonBlocking
    238          
    239              ev = xEventGroupWaitBits(handle->txEvent, RTOS_LPUART_COMPLETE, pdTRUE, pdFALSE, timeout);
    240              if (!(ev & RTOS_LPUART_COMPLETE))
   \       0x44   0x9700             STR      R7,[SP, #+0]
   \       0x46   0x4643             MOV      R3,R8
   \       0x48   0x2201             MOVS     R2,#+1
   \       0x4A   0x4611             MOV      R1,R2
   \       0x4C   0x6A30             LDR      R0,[R6, #+32]
   \       0x4E   0x....'....        BL       xEventGroupWaitBits
   \       0x52   0x07C0             LSLS     R0,R0,#+31
   \       0x54   0xD401             BMI.N    ??LPUART_RTOS_Send_5
    241              {
    242                  retval = kStatus_Fail;
   \       0x56   0xF04F 0x0801      MOV      R8,#+1
    243              }
    244          
    245              if (pdFALSE == xSemaphoreGive(handle->txSemaphore))
   \                     ??LPUART_RTOS_Send_5: (+1)
   \       0x5A   0x2300             MOVS     R3,#+0
   \       0x5C   0x461A             MOV      R2,R3
   \       0x5E   0x4611             MOV      R1,R2
   \       0x60   0x69B0             LDR      R0,[R6, #+24]
   \       0x62   0x....'....        BL       xQueueGenericSend
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD101             BNE.N    ??LPUART_RTOS_Send_6
    246              {
    247                  /* We could not post the semaphore, exit with error */
    248                  retval = kStatus_Fail;
   \       0x6A   0xF04F 0x0801      MOV      R8,#+1
    249              }
    250          
    251              return retval;
   \                     ??LPUART_RTOS_Send_6: (+1)
   \       0x6E   0x4640             MOV      R0,R8
   \                     ??LPUART_RTOS_Send_2: (+1)
   \       0x70   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    252          }
    253          
    254          /*FUNCTION**********************************************************************
    255           *
    256           * Function Name : LPUART_RTOS_Recv
    257           * Description   : Receives chars for the application
    258           *
    259           *END**************************************************************************/
    260          /*!
    261           * brief Receives data.
    262           *
    263           * This function receives data from LPUART. It is an synchronous API. If any data is immediately available
    264           * it is returned immediately and the number of bytes received.
    265           *
    266           * param handle The RTOS LPUART handle.
    267           * param buffer The pointer to buffer where to write received data.
    268           * param length The number of bytes to receive.
    269           * param received The pointer to a variable of size_t where the number of received data is filled.
    270           */

   \                                 In section .text, align 2, keep-with-next
    271          int LPUART_RTOS_Receive(lpuart_rtos_handle_t *handle, uint8_t *buffer, uint32_t length, size_t *received, uint32_t timeout)
    272          {
   \                     LPUART_RTOS_Receive: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461C             MOV      R4,R3
    273              EventBits_t ev;
    274              size_t n              = 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9001             STR      R0,[SP, #+4]
    275              int retval            = kStatus_Success;
   \       0x10   0x4680             MOV      R8,R0
    276              size_t local_received = 0;
   \       0x12   0x4681             MOV      R9,R0
    277          
    278              if (NULL == handle->base)
   \       0x14   0x6838             LDR      R0,[R7, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD012             BEQ.N    ??LPUART_RTOS_Receive_0
    279              {
    280                  /* Invalid handle. */
    281                  return kStatus_Fail;
    282              }
    283              if (0 == length)
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD105             BNE.N    ??LPUART_RTOS_Receive_1
    284              {
    285                  if (received != NULL)
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD001             BEQ.N    ??LPUART_RTOS_Receive_2
    286                  {
    287                      *received = n;
   \       0x22   0x4640             MOV      R0,R8
   \       0x24   0x6020             STR      R0,[R4, #+0]
    288                  }
    289                  return 0;
   \                     ??LPUART_RTOS_Receive_2: (+1)
   \       0x26   0x4640             MOV      R0,R8
   \       0x28   0xE04B             B.N      ??LPUART_RTOS_Receive_3
    290              }
    291              if (NULL == buffer)
   \                     ??LPUART_RTOS_Receive_1: (+1)
   \       0x2A   0x2E00             CMP      R6,#+0
   \       0x2C   0xD101             BNE.N    ??LPUART_RTOS_Receive_4
    292              {
    293                  return kStatus_InvalidArgument;
   \       0x2E   0x2004             MOVS     R0,#+4
   \       0x30   0xE047             B.N      ??LPUART_RTOS_Receive_3
    294              }
    295          
    296              /* New transfer can be performed only after current one is finished */
    297              if (pdFALSE == xSemaphoreTake(handle->rxSemaphore, portMAX_DELAY))
   \                     ??LPUART_RTOS_Receive_4: (+1)
   \       0x32   0xF04F 0x31FF      MOV      R1,#-1
   \       0x36   0x6978             LDR      R0,[R7, #+20]
   \       0x38   0x....'....        BL       xQueueSemaphoreTake
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD101             BNE.N    ??LPUART_RTOS_Receive_5
    298              {
    299                  /* We could not take the semaphore, exit with 0 data received */
    300                  return kStatus_Fail;
   \                     ??LPUART_RTOS_Receive_0: (+1)
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xE03E             B.N      ??LPUART_RTOS_Receive_3
    301              }
   \                     ??LPUART_RTOS_Receive_5: (+1)
   \       0x44   0xF8DD 0xA028      LDR      R10,[SP, #+40]
    302          
    303              handle->rxTransfer.data     = buffer;
   \       0x48   0x60FE             STR      R6,[R7, #+12]
    304              handle->rxTransfer.dataSize = (uint32_t)length;
   \       0x4A   0x613D             STR      R5,[R7, #+16]
    305          
    306              /* Non-blocking call */
    307              LPUART_TransferReceiveNonBlocking(handle->base, handle->t_state, &handle->rxTransfer, &n);
   \       0x4C   0xAB01             ADD      R3,SP,#+4
   \       0x4E   0xF107 0x020C      ADD      R2,R7,#+12
   \       0x52   0x6A79             LDR      R1,[R7, #+36]
   \       0x54   0x6838             LDR      R0,[R7, #+0]
   \       0x56   0x....'....        BL       LPUART_TransferReceiveNonBlocking
    308          
    309              ev = xEventGroupWaitBits(
    310                  handle->rxEvent, RTOS_LPUART_COMPLETE | RTOS_LPUART_RING_BUFFER_OVERRUN | RTOS_LPUART_HARDWARE_BUFFER_OVERRUN,
    311                  pdTRUE, pdFALSE, timeout);
   \       0x5A   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \       0x5E   0x4643             MOV      R3,R8
   \       0x60   0x2201             MOVS     R2,#+1
   \       0x62   0x2107             MOVS     R1,#+7
   \       0x64   0x69F8             LDR      R0,[R7, #+28]
   \       0x66   0x....'....        BL       xEventGroupWaitBits
    312              if (ev & RTOS_LPUART_HARDWARE_BUFFER_OVERRUN)
   \       0x6A   0x0741             LSLS     R1,R0,#+29
   \       0x6C   0xD50A             BPL.N    ??LPUART_RTOS_Receive_6
    313              {
    314                  /* Stop data transfer to application buffer, ring buffer is still active */
    315                  LPUART_TransferAbortReceive(handle->base, handle->t_state);
   \       0x6E   0x6A79             LDR      R1,[R7, #+36]
   \       0x70   0x6838             LDR      R0,[R7, #+0]
   \       0x72   0x....'....        BL       LPUART_TransferAbortReceive
    316                  /* Prevent false indication of successful transfer in next call of LPUART_RTOS_Receive.
    317                     RTOS_LPUART_COMPLETE flag could be set meanwhile overrun is handled */
    318                  xEventGroupClearBits(handle->rxEvent, RTOS_LPUART_COMPLETE);
   \       0x76   0x2101             MOVS     R1,#+1
   \       0x78   0x69F8             LDR      R0,[R7, #+28]
   \       0x7A   0x....'....        BL       xEventGroupClearBits
    319                  retval         = kStatus_LPUART_RxHardwareOverrun;
   \       0x7E   0xF240 0x581D      MOVW     R8,#+1309
    320                  local_received = 0;
   \       0x82   0xE00F             B.N      ??LPUART_RTOS_Receive_7
    321              }
    322              else if (ev & RTOS_LPUART_RING_BUFFER_OVERRUN)
   \                     ??LPUART_RTOS_Receive_6: (+1)
   \       0x84   0x0781             LSLS     R1,R0,#+30
   \       0x86   0xD50A             BPL.N    ??LPUART_RTOS_Receive_8
    323              {
    324                  /* Stop data transfer to application buffer, ring buffer is still active */
    325                  LPUART_TransferAbortReceive(handle->base, handle->t_state);
   \       0x88   0x6A79             LDR      R1,[R7, #+36]
   \       0x8A   0x6838             LDR      R0,[R7, #+0]
   \       0x8C   0x....'....        BL       LPUART_TransferAbortReceive
    326                  /* Prevent false indication of successful transfer in next call of LPUART_RTOS_Receive.
    327                     RTOS_LPUART_COMPLETE flag could be set meanwhile overrun is handled */
    328                  xEventGroupClearBits(handle->rxEvent, RTOS_LPUART_COMPLETE);
   \       0x90   0x2101             MOVS     R1,#+1
   \       0x92   0x69F8             LDR      R0,[R7, #+28]
   \       0x94   0x....'....        BL       xEventGroupClearBits
    329                  retval         = kStatus_LPUART_RxRingBufferOverrun;
   \       0x98   0xF240 0x581C      MOVW     R8,#+1308
    330                  local_received = 0;
   \       0x9C   0xE002             B.N      ??LPUART_RTOS_Receive_7
    331              }
    332              else if (ev & RTOS_LPUART_COMPLETE)
   \                     ??LPUART_RTOS_Receive_8: (+1)
   \       0x9E   0x07C0             LSLS     R0,R0,#+31
   \       0xA0   0xD500             BPL.N    ??LPUART_RTOS_Receive_7
    333              {
    334                  retval         = kStatus_Success;
    335                  local_received = length;
   \       0xA2   0x46A9             MOV      R9,R5
    336              }
    337          
    338              /* Prevent repetitive NULL check */
    339              if (received != NULL)
   \                     ??LPUART_RTOS_Receive_7: (+1)
   \       0xA4   0x2C00             CMP      R4,#+0
   \       0xA6   0xD001             BEQ.N    ??LPUART_RTOS_Receive_9
    340              {
    341                  *received = local_received;
   \       0xA8   0xF8C4 0x9000      STR      R9,[R4, #+0]
    342              }
    343          
    344              /* Enable next transfer. Current one is finished */
    345              if (pdFALSE == xSemaphoreGive(handle->rxSemaphore))
   \                     ??LPUART_RTOS_Receive_9: (+1)
   \       0xAC   0x2300             MOVS     R3,#+0
   \       0xAE   0x461A             MOV      R2,R3
   \       0xB0   0x4611             MOV      R1,R2
   \       0xB2   0x6978             LDR      R0,[R7, #+20]
   \       0xB4   0x....'....        BL       xQueueGenericSend
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD101             BNE.N    ??LPUART_RTOS_Receive_10
    346              {
    347                  /* We could not post the semaphore, exit with error */
    348                  retval = kStatus_Fail;
   \       0xBC   0xF04F 0x0801      MOV      R8,#+1
    349              }
    350              return retval;
   \                     ??LPUART_RTOS_Receive_10: (+1)
   \       0xC0   0x4640             MOV      R0,R8
   \                     ??LPUART_RTOS_Receive_3: (+1)
   \       0xC2   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    351          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     LPUART_RTOS_Callback

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LPUART_EnableRx
       0   LPUART_EnableTx
      16   LPUART_RTOS_Callback
        16   -> LPUART_ClearStatusFlags
        16   -> xEventGroupSetBitsFromISR
       8   LPUART_RTOS_Deinit
         8   -> LPUART_Deinit
         8   -> vEventGroupDelete
         8   -> vQueueDelete
         8   -> xQueueGenericSend
      32   LPUART_RTOS_Init
        32   -> LPUART_EnableRx
        32   -> LPUART_EnableTx
        32   -> LPUART_GetDefaultConfig
        32   -> LPUART_Init
        32   -> LPUART_TransferCreateHandle
        32   -> LPUART_TransferStartRingBuffer
        32   -> vEventGroupDelete
        32   -> vQueueDelete
        32   -> xEventGroupCreate
        32   -> xQueueCreateMutex
      40   LPUART_RTOS_Receive
        40   -> LPUART_TransferAbortReceive
        40   -> LPUART_TransferReceiveNonBlocking
        40   -> xEventGroupClearBits
        40   -> xEventGroupWaitBits
        40   -> xQueueGenericSend
        40   -> xQueueSemaphoreTake
      32   LPUART_RTOS_Send
        32   -> LPUART_TransferSendNonBlocking
        32   -> xEventGroupWaitBits
        32   -> xQueueGenericSend
        32   -> xQueueSemaphoreTake


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
      22  LPUART_EnableRx
      22  LPUART_EnableTx
     126  LPUART_RTOS_Callback
      66  LPUART_RTOS_Deinit
     222  LPUART_RTOS_Init
     198  LPUART_RTOS_Receive
     116  LPUART_RTOS_Send

 
 780 bytes in section .text
 
 780 bytes of CODE memory

Errors: none
Warnings: none
