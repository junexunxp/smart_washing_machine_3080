###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:55
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\amazon-freertos\freertos\timers.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW676A.tmp
#        (C:\Development\smart_washing_machine_3080\amazon-freertos\freertos\timers.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\timers.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\timers.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\amazon-freertos\freertos\timers.c
      1          /*
      2           * FreeRTOS Kernel V10.2.0
      3           * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * http://www.FreeRTOS.org
     23           * http://aws.amazon.com/freertos
     24           *
     25           * 1 tab == 4 spaces!
     26           */
     27          
     28          /* Standard includes. */
     29          #include <stdlib.h>
     30          
     31          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     32          all the API functions to use the MPU wrappers.  That should only be done when
     33          task.h is included from an application file. */
     34          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     35          
     36          #include "FreeRTOS.h"
     37          #include "task.h"
     38          #include "queue.h"
     39          #include "timers.h"
     40          
     41          #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
     42          	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
     43          #endif
     44          
     45          /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
     46          because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     47          for the header files above, but not in this file, in order to generate the
     48          correct privileged Vs unprivileged linkage and placement. */
     49          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e9021 !e961 !e750. */
     50          
     51          
     52          /* This entire source file will be skipped if the application is not configured
     53          to include software timer functionality.  This #if is closed at the very bottom
     54          of this file.  If you want to include software timer functionality then ensure
     55          configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
     56          #if ( configUSE_TIMERS == 1 )
     57          
     58          /* Misc definitions. */
     59          #define tmrNO_DELAY		( TickType_t ) 0U
     60          
     61          /* The name assigned to the timer service task.  This can be overridden by
     62          defining trmTIMER_SERVICE_TASK_NAME in FreeRTOSConfig.h. */
     63          #ifndef configTIMER_SERVICE_TASK_NAME
     64          	#define configTIMER_SERVICE_TASK_NAME "Tmr Svc"
     65          #endif
     66          
     67          /* Bit definitions used in the ucStatus member of a timer structure. */
     68          #define tmrSTATUS_IS_ACTIVE					( ( uint8_t ) 0x01 )
     69          #define tmrSTATUS_IS_STATICALLY_ALLOCATED	( ( uint8_t ) 0x02 )
     70          #define tmrSTATUS_IS_AUTORELOAD				( ( uint8_t ) 0x04 )
     71          
     72          /* The definition of the timers themselves. */
     73          typedef struct tmrTimerControl /* The old naming convention is used to prevent breaking kernel aware debuggers. */
     74          {
     75          	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
     76          	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
     77          	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
     78          	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
     79          	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
     80          	#if( configUSE_TRACE_FACILITY == 1 )
     81          		UBaseType_t			uxTimerNumber;		/*<< An ID assigned by trace tools such as FreeRTOS+Trace */
     82          	#endif
     83          	uint8_t 				ucStatus;			/*<< Holds bits to say if the timer was statically allocated or not, and if it is active or not. */
     84          } xTIMER;
     85          
     86          /* The old xTIMER name is maintained above then typedefed to the new Timer_t
     87          name below to enable the use of older kernel aware debuggers. */
     88          typedef xTIMER Timer_t;
     89          
     90          /* The definition of messages that can be sent and received on the timer queue.
     91          Two types of message can be queued - messages that manipulate a software timer,
     92          and messages that request the execution of a non-timer related callback.  The
     93          two message types are defined in two separate structures, xTimerParametersType
     94          and xCallbackParametersType respectively. */
     95          typedef struct tmrTimerParameters
     96          {
     97          	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
     98          	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
     99          } TimerParameter_t;
    100          
    101          
    102          typedef struct tmrCallbackParameters
    103          {
    104          	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
    105          	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
    106          	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
    107          } CallbackParameters_t;
    108          
    109          /* The structure that contains the two message types, along with an identifier
    110          that is used to determine which message type is valid. */
    111          typedef struct tmrTimerQueueMessage
    112          {
    113          	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
    114          	union
    115          	{
    116          		TimerParameter_t xTimerParameters;
    117          
    118          		/* Don't include xCallbackParameters if it is not going to be used as
    119          		it makes the structure (and therefore the timer queue) larger. */
    120          		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
    121          			CallbackParameters_t xCallbackParameters;
    122          		#endif /* INCLUDE_xTimerPendFunctionCall */
    123          	} u;
    124          } DaemonTaskMessage_t;
    125          
    126          /*lint -save -e956 A manual analysis and inspection has been used to determine
    127          which static variables must be declared volatile. */
    128          
    129          /* The list in which active timers are stored.  Timers are referenced in expire
    130          time order, with the nearest expiry time at the front of the list.  Only the
    131          timer service task is allowed to access these lists.
    132          xActiveTimerList1 and xActiveTimerList2 could be at function scope but that
    133          breaks some kernel aware debuggers, and debuggers that reply on removing the
    134          static qualifier. */

   \                                 In section .bss, align 4
    135          PRIVILEGED_DATA static List_t xActiveTimerList1;
   \                     xActiveTimerList1:
   \        0x0                      DS8 20

   \                                 In section .bss, align 4
    136          PRIVILEGED_DATA static List_t xActiveTimerList2;
   \                     xActiveTimerList2:
   \        0x0                      DS8 20

   \                                 In section .bss, align 4
    137          PRIVILEGED_DATA static List_t *pxCurrentTimerList;
   \                     pxCurrentTimerList:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    138          PRIVILEGED_DATA static List_t *pxOverflowTimerList;
   \                     pxOverflowTimerList:
   \        0x0                      DS8 4
    139          
    140          /* A queue that is used to send commands to the timer service task. */

   \                                 In section .bss, align 4
    141          PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
   \                     xTimerQueue:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    142          PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
   \                     xTimerTaskHandle:
   \        0x0                      DS8 4
    143          
    144          /*lint -restore */
    145          
    146          /*-----------------------------------------------------------*/
    147          
    148          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    149          
    150          	/* If static allocation is supported then the application must provide the
    151          	following callback function - which enables the application to optionally
    152          	provide the memory that will be used by the timer task as the task's stack
    153          	and TCB. */
    154          	extern void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize );
    155          
    156          #endif
    157          
    158          /*
    159           * Initialise the infrastructure used by the timer service task if it has not
    160           * been initialised already.
    161           */
    162          static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
    163          
    164          /*
    165           * The timer service task (daemon).  Timer functionality is controlled by this
    166           * task.  Other tasks communicate with the timer service task using the
    167           * xTimerQueue queue.
    168           */
    169          static portTASK_FUNCTION_PROTO( prvTimerTask, pvParameters ) PRIVILEGED_FUNCTION;
    170          
    171          /*
    172           * Called by the timer service task to interpret and process a command it
    173           * received on the timer queue.
    174           */
    175          static void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
    176          
    177          /*
    178           * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
    179           * depending on if the expire time causes a timer counter overflow.
    180           */
    181          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
    182          
    183          /*
    184           * An active timer has reached its expire time.  Reload the timer if it is an
    185           * auto reload timer, then call its callback.
    186           */
    187          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
    188          
    189          /*
    190           * The tick count has overflowed.  Switch the timer lists after ensuring the
    191           * current timer list does not still reference some timers.
    192           */
    193          static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
    194          
    195          /*
    196           * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
    197           * if a tick count overflow occurred since prvSampleTimeNow() was last called.
    198           */
    199          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
    200          
    201          /*
    202           * If the timer list contains any active timers then return the expire time of
    203           * the timer that will expire first and set *pxListWasEmpty to false.  If the
    204           * timer list does not contain any timers then return 0 and set *pxListWasEmpty
    205           * to pdTRUE.
    206           */
    207          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
    208          
    209          /*
    210           * If a timer has expired, process it.  Otherwise, block the timer service task
    211           * until either a timer does expire or a command is received.
    212           */
    213          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
    214          
    215          /*
    216           * Called after a Timer_t structure has been allocated either statically or
    217           * dynamically to fill in the structure's members.
    218           */
    219          static void prvInitialiseNewTimer(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    220          									const TickType_t xTimerPeriodInTicks,
    221          									const UBaseType_t uxAutoReload,
    222          									void * const pvTimerID,
    223          									TimerCallbackFunction_t pxCallbackFunction,
    224          									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
    225          /*-----------------------------------------------------------*/
    226          

   \                                 In section .text, align 2, keep-with-next
    227          BaseType_t xTimerCreateTimerTask( void )
    228          {
   \                     xTimerCreateTimerTask: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    229          BaseType_t xReturn = pdFAIL;
   \        0x2   0x2400             MOVS     R4,#+0
    230          
    231          	/* This function is called when the scheduler is started if
    232          	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
    233          	timer service task has been created/initialised.  If timers have already
    234          	been created then the initialisation will already have been performed. */
    235          	prvCheckForValidListAndQueue();
   \        0x4   0x....'....        BL       prvCheckForValidListAndQueue
    236          
    237          	if( xTimerQueue != NULL )
   \        0x8   0x....'....        LDR.W    R0,??DataTable12
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD00E             BEQ.N    ??xTimerCreateTimerTask_0
    238          	{
    239          		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    240          		{
    241          			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
    242          			StackType_t *pxTimerTaskStackBuffer = NULL;
    243          			uint32_t ulTimerTaskStackSize;
    244          
    245          			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
    246          			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
    247          													configTIMER_SERVICE_TASK_NAME,
    248          													ulTimerTaskStackSize,
    249          													NULL,
    250          													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
    251          													pxTimerTaskStackBuffer,
    252          													pxTimerTaskTCBBuffer );
    253          
    254          			if( xTimerTaskHandle != NULL )
    255          			{
    256          				xReturn = pdPASS;
    257          			}
    258          		}
    259          		#else
    260          		{
    261          			xReturn = xTaskCreate(	prvTimerTask,
    262          									configTIMER_SERVICE_TASK_NAME,
    263          									configTIMER_TASK_STACK_DEPTH,
    264          									NULL,
    265          									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
    266          									&xTimerTaskHandle );
   \       0x12   0x....'....        LDR.W    R0,??DataTable12_1
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x2004             MOVS     R0,#+4
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x4623             MOV      R3,R4
   \       0x1E   0xF44F 0x7200      MOV      R2,#+512
   \       0x22   0x....'....        LDR.W    R1,??DataTable12_2
   \       0x26   0x....'....        ADR.W    R0,prvTimerTask
   \       0x2A   0x....'....        BL       xTaskCreate
   \       0x2E   0x4604             MOV      R4,R0
    267          		}
    268          		#endif /* configSUPPORT_STATIC_ALLOCATION */
    269          	}
    270          	else
    271          	{
    272          		mtCOVERAGE_TEST_MARKER();
    273          	}
    274          
    275          	configASSERT( xReturn );
   \                     ??xTimerCreateTimerTask_0: (+1)
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD107             BNE.N    ??xTimerCreateTimerTask_1
   \       0x34   0x2020             MOVS     R0,#+32
   \       0x36   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x3A   0xF3BF 0x8F4F      DSB      SY
   \       0x3E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerCreateTimerTask_2: (+1)
   \       0x42   0xE7FE             B.N      ??xTimerCreateTimerTask_2
    276          	return xReturn;
   \                     ??xTimerCreateTimerTask_1: (+1)
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    277          }
    278          /*-----------------------------------------------------------*/
    279          
    280          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    281          

   \                                 In section .text, align 2, keep-with-next
    282          	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    283          								const TickType_t xTimerPeriodInTicks,
    284          								const UBaseType_t uxAutoReload,
    285          								void * const pvTimerID,
    286          								TimerCallbackFunction_t pxCallbackFunction )
    287          	{
   \                     xTimerCreate: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x4698             MOV      R8,R3
    288          	Timer_t *pxNewTimer;
    289          
    290          		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
   \        0xC   0x202C             MOVS     R0,#+44
   \        0xE   0x....'....        BL       pvPortMalloc
   \       0x12   0x0004             MOVS     R4,R0
    291          
    292          		if( pxNewTimer != NULL )
   \       0x14   0xD00B             BEQ.N    ??xTimerCreate_0
   \       0x16   0x9808             LDR      R0,[SP, #+32]
    293          		{
    294          			/* Status is thus far zero as the timer is not created statically
    295          			and has not been started.  The autoreload bit may get set in
    296          			prvInitialiseNewTimer. */
    297          			pxNewTimer->ucStatus = 0x00;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0xF884 0x1028      STRB     R1,[R4, #+40]
    298          			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
   \       0x1E   0x9401             STR      R4,[SP, #+4]
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0x4643             MOV      R3,R8
   \       0x24   0x463A             MOV      R2,R7
   \       0x26   0x4631             MOV      R1,R6
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       prvInitialiseNewTimer
    299          		}
    300          
    301          		return pxNewTimer;
   \                     ??xTimerCreate_0: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    302          	}
    303          
    304          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    305          /*-----------------------------------------------------------*/
    306          
    307          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    308          
    309          	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    310          										const TickType_t xTimerPeriodInTicks,
    311          										const UBaseType_t uxAutoReload,
    312          										void * const pvTimerID,
    313          										TimerCallbackFunction_t pxCallbackFunction,
    314          										StaticTimer_t *pxTimerBuffer )
    315          	{
    316          	Timer_t *pxNewTimer;
    317          
    318          		#if( configASSERT_DEFINED == 1 )
    319          		{
    320          			/* Sanity check that the size of the structure used to declare a
    321          			variable of type StaticTimer_t equals the size of the real timer
    322          			structure. */
    323          			volatile size_t xSize = sizeof( StaticTimer_t );
    324          			configASSERT( xSize == sizeof( Timer_t ) );
    325          			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
    326          		}
    327          		#endif /* configASSERT_DEFINED */
    328          
    329          		/* A pointer to a StaticTimer_t structure MUST be provided, use it. */
    330          		configASSERT( pxTimerBuffer );
    331          		pxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 !e9087 StaticTimer_t is a pointer to a Timer_t, so guaranteed to be aligned and sized correctly (checked by an assert()), so this is safe. */
    332          
    333          		if( pxNewTimer != NULL )
    334          		{
    335          			/* Timers can be created statically or dynamically so note this
    336          			timer was created statically in case it is later deleted.  The
    337          			autoreload bit may get set in prvInitialiseNewTimer(). */
    338          			pxNewTimer->ucStatus = tmrSTATUS_IS_STATICALLY_ALLOCATED;
    339          
    340          			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    341          		}
    342          
    343          		return pxNewTimer;
    344          	}
    345          
    346          #endif /* configSUPPORT_STATIC_ALLOCATION */
    347          /*-----------------------------------------------------------*/
    348          

   \                                 In section .text, align 2, keep-with-next
    349          static void prvInitialiseNewTimer(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    350          									const TickType_t xTimerPeriodInTicks,
    351          									const UBaseType_t uxAutoReload,
    352          									void * const pvTimerID,
    353          									TimerCallbackFunction_t pxCallbackFunction,
    354          									Timer_t *pxNewTimer )
    355          {
   \                     prvInitialiseNewTimer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x4698             MOV      R8,R3
    356          	/* 0 is not a valid value for xTimerPeriodInTicks. */
    357          	configASSERT( ( xTimerPeriodInTicks > 0 ) );
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD107             BNE.N    ??prvInitialiseNewTimer_0
   \       0x10   0x2020             MOVS     R0,#+32
   \       0x12   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x16   0xF3BF 0x8F4F      DSB      SY
   \       0x1A   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvInitialiseNewTimer_1: (+1)
   \       0x1E   0xE7FE             B.N      ??prvInitialiseNewTimer_1
   \                     ??prvInitialiseNewTimer_0: (+1)
   \       0x20   0x9C09             LDR      R4,[SP, #+36]
    358          
    359          	if( pxNewTimer != NULL )
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD014             BEQ.N    ??prvInitialiseNewTimer_2
   \       0x26   0xF8DD 0x9020      LDR      R9,[SP, #+32]
    360          	{
    361          		/* Ensure the infrastructure used by the timer service task has been
    362          		created/initialised. */
    363          		prvCheckForValidListAndQueue();
   \       0x2A   0x....'....        BL       prvCheckForValidListAndQueue
    364          
    365          		/* Initialise the timer structure members using the function
    366          		parameters. */
    367          		pxNewTimer->pcTimerName = pcTimerName;
   \       0x2E   0x6027             STR      R7,[R4, #+0]
    368          		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
   \       0x30   0x61A6             STR      R6,[R4, #+24]
    369          		pxNewTimer->pvTimerID = pvTimerID;
   \       0x32   0xF8C4 0x801C      STR      R8,[R4, #+28]
    370          		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
   \       0x36   0xF8C4 0x9020      STR      R9,[R4, #+32]
    371          		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
   \       0x3A   0x1D20             ADDS     R0,R4,#+4
   \       0x3C   0x....'....        BL       vListInitialiseItem
    372          		if( uxAutoReload != pdFALSE )
   \       0x40   0x2D00             CMP      R5,#+0
   \       0x42   0xD005             BEQ.N    ??prvInitialiseNewTimer_2
    373          		{
    374          			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
   \       0x44   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \       0x48   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x4C   0xF884 0x0028      STRB     R0,[R4, #+40]
    375          		}
    376          		traceTIMER_CREATE( pxNewTimer );
    377          	}
    378          }
   \                     ??prvInitialiseNewTimer_2: (+1)
   \       0x50   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    379          /*-----------------------------------------------------------*/
    380          

   \                                 In section .text, align 2, keep-with-next
    381          BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
    382          {
   \                     xTimerGenericCommand: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x461D             MOV      R5,R3
    383          BaseType_t xReturn = pdFAIL;
   \        0x6   0x2000             MOVS     R0,#+0
    384          DaemonTaskMessage_t xMessage;
    385          
    386          	configASSERT( xTimer );
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD107             BNE.N    ??xTimerGenericCommand_0
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x12   0xF3BF 0x8F4F      DSB      SY
   \       0x16   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerGenericCommand_1: (+1)
   \       0x1A   0xE7FE             B.N      ??xTimerGenericCommand_1
    387          
    388          	/* Send a message to the timer service task to perform a particular action
    389          	on a particular timer definition. */
    390          	if( xTimerQueue != NULL )
   \                     ??xTimerGenericCommand_0: (+1)
   \       0x1C   0x....'....        LDR.W    R6,??DataTable12
   \       0x20   0x6833             LDR      R3,[R6, #+0]
   \       0x22   0x2B00             CMP      R3,#+0
   \       0x24   0xD01C             BEQ.N    ??xTimerGenericCommand_2
    391          	{
    392          		/* Send a command to the timer service task to start the xTimer timer. */
    393          		xMessage.xMessageID = xCommandID;
   \       0x26   0x9100             STR      R1,[SP, #+0]
    394          		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   \       0x28   0x9201             STR      R2,[SP, #+4]
    395          		xMessage.u.xTimerParameters.pxTimer = xTimer;
   \       0x2A   0x9402             STR      R4,[SP, #+8]
    396          
    397          		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   \       0x2C   0x2906             CMP      R1,#+6
   \       0x2E   0xDA11             BGE.N    ??xTimerGenericCommand_3
    398          		{
    399          			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   \       0x30   0x....'....        BL       xTaskGetSchedulerState
   \       0x34   0x2802             CMP      R0,#+2
   \       0x36   0xD106             BNE.N    ??xTimerGenericCommand_4
   \       0x38   0x9A08             LDR      R2,[SP, #+32]
    400          			{
    401          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   \       0x3A   0x2300             MOVS     R3,#+0
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0x....'....        BL       xQueueGenericSend
   \       0x44   0xE00C             B.N      ??xTimerGenericCommand_2
    402          			}
    403          			else
    404          			{
    405          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   \                     ??xTimerGenericCommand_4: (+1)
   \       0x46   0x2300             MOVS     R3,#+0
   \       0x48   0x461A             MOV      R2,R3
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x6830             LDR      R0,[R6, #+0]
   \       0x4E   0x....'....        BL       xQueueGenericSend
   \       0x52   0xE005             B.N      ??xTimerGenericCommand_2
    406          			}
    407          		}
    408          		else
    409          		{
    410          			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   \                     ??xTimerGenericCommand_3: (+1)
   \       0x54   0x4603             MOV      R3,R0
   \       0x56   0x462A             MOV      R2,R5
   \       0x58   0x4669             MOV      R1,SP
   \       0x5A   0x6830             LDR      R0,[R6, #+0]
   \       0x5C   0x....'....        BL       xQueueGenericSendFromISR
    411          		}
    412          
    413          		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
    414          	}
    415          	else
    416          	{
    417          		mtCOVERAGE_TEST_MARKER();
    418          	}
    419          
    420          	return xReturn;
   \                     ??xTimerGenericCommand_2: (+1)
   \       0x60   0xB004             ADD      SP,SP,#+16
   \       0x62   0xBD70             POP      {R4-R6,PC}       ;; return
    421          }
    422          /*-----------------------------------------------------------*/
    423          

   \                                 In section .text, align 2, keep-with-next
    424          TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    425          {
    426          	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
    427          	started, then xTimerTaskHandle will be NULL. */
    428          	configASSERT( ( xTimerTaskHandle != NULL ) );
   \                     xTimerGetTimerDaemonTaskHandle: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable12_1
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD107             BNE.N    ??xTimerGetTimerDaemonTaskHandle_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerGetTimerDaemonTaskHandle_1: (+1)
   \       0x18   0xE7FE             B.N      ??xTimerGetTimerDaemonTaskHandle_1
    429          	return xTimerTaskHandle;
   \                     ??xTimerGetTimerDaemonTaskHandle_0: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    430          }
    431          /*-----------------------------------------------------------*/
    432          

   \                                 In section .text, align 2, keep-with-next
    433          TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    434          {
    435          Timer_t *pxTimer = xTimer;
    436          
    437          	configASSERT( xTimer );
   \                     xTimerGetPeriod: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??xTimerGetPeriod_0
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerGetPeriod_1: (+1)
   \       0x12   0xE7FE             B.N      ??xTimerGetPeriod_1
    438          	return pxTimer->xTimerPeriodInTicks;
   \                     ??xTimerGetPeriod_0: (+1)
   \       0x14   0x6980             LDR      R0,[R0, #+24]
   \       0x16   0x4770             BX       LR               ;; return
    439          }
    440          /*-----------------------------------------------------------*/
    441          

   \                                 In section .text, align 2, keep-with-next
    442          void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
    443          {
   \                     vTimerSetReloadMode: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    444          Timer_t * pxTimer =  xTimer;
    445          
    446          	configASSERT( xTimer );
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD107             BNE.N    ??vTimerSetReloadMode_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTimerSetReloadMode_1: (+1)
   \       0x18   0xE7FE             B.N      ??vTimerSetReloadMode_1
    447          	taskENTER_CRITICAL();
   \                     ??vTimerSetReloadMode_0: (+1)
   \       0x1A   0x....'....        BL       vPortEnterCritical
    448          	{
    449          		if( uxAutoReload != pdFALSE )
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xF895 0x0028      LDRB     R0,[R5, #+40]
   \       0x24   0xD004             BEQ.N    ??vTimerSetReloadMode_2
    450          		{
    451          			pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
   \       0x26   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x2A   0xF885 0x0028      STRB     R0,[R5, #+40]
   \       0x2E   0xE003             B.N      ??vTimerSetReloadMode_3
    452          		}
    453          		else
    454          		{
    455          			pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
   \                     ??vTimerSetReloadMode_2: (+1)
   \       0x30   0xF000 0x00FB      AND      R0,R0,#0xFB
   \       0x34   0xF885 0x0028      STRB     R0,[R5, #+40]
    456          		}
    457          	}
    458          	taskEXIT_CRITICAL();
   \                     ??vTimerSetReloadMode_3: (+1)
   \       0x38   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x3C   0x....'....        B.W      vPortExitCritical
    459          }
    460          /*-----------------------------------------------------------*/
    461          

   \                                 In section .text, align 2, keep-with-next
    462          TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    463          {
    464          Timer_t * pxTimer =  xTimer;
    465          TickType_t xReturn;
    466          
    467          	configASSERT( xTimer );
   \                     xTimerGetExpiryTime: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??xTimerGetExpiryTime_0
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerGetExpiryTime_1: (+1)
   \       0x12   0xE7FE             B.N      ??xTimerGetExpiryTime_1
    468          	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    469          	return xReturn;
   \                     ??xTimerGetExpiryTime_0: (+1)
   \       0x14   0x6840             LDR      R0,[R0, #+4]
   \       0x16   0x4770             BX       LR               ;; return
    470          }
    471          /*-----------------------------------------------------------*/
    472          

   \                                 In section .text, align 2, keep-with-next
    473          const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    474          {
    475          Timer_t *pxTimer = xTimer;
    476          
    477          	configASSERT( xTimer );
   \                     pcTimerGetName: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??pcTimerGetName_0
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??pcTimerGetName_1: (+1)
   \       0x12   0xE7FE             B.N      ??pcTimerGetName_1
    478          	return pxTimer->pcTimerName;
   \                     ??pcTimerGetName_0: (+1)
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x4770             BX       LR               ;; return
    479          }
    480          /*-----------------------------------------------------------*/
    481          

   \                                 In section .text, align 2, keep-with-next
    482          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
    483          {
   \                     prvProcessExpiredTimer: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    484          BaseType_t xResult;
    485          Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   \        0x6   0x....'....        LDR.W    R0,??DataTable12_3
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x68C0             LDR      R0,[R0, #+12]
   \        0xE   0x68C6             LDR      R6,[R0, #+12]
    486          
    487          	/* Remove the timer from the list of active timers.  A check has already
    488          	been performed to ensure the list is not empty. */
    489          	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   \       0x10   0x1D30             ADDS     R0,R6,#+4
   \       0x12   0x....'....        BL       uxListRemove
    490          	traceTIMER_EXPIRED( pxTimer );
    491          
    492          	/* If the timer is an auto reload timer then calculate the next
    493          	expiry time and re-insert the timer in the list of active timers. */
    494          	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
   \       0x16   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \       0x1A   0x0740             LSLS     R0,R0,#+29
   \       0x1C   0xD51A             BPL.N    ??prvProcessExpiredTimer_0
    495          	{
    496          		/* The timer is inserted into a list using a time relative to anything
    497          		other than the current time.  It will therefore be inserted into the
    498          		correct list relative to the time this task thinks it is now. */
    499          		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
   \       0x1E   0x4623             MOV      R3,R4
   \       0x20   0x462A             MOV      R2,R5
   \       0x22   0x69B1             LDR      R1,[R6, #+24]
   \       0x24   0x1909             ADDS     R1,R1,R4
   \       0x26   0x4630             MOV      R0,R6
   \       0x28   0x....'....        BL       prvInsertTimerInActiveList
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD017             BEQ.N    ??prvProcessExpiredTimer_1
    500          		{
    501          			/* The timer expired before it was added to the active timer
    502          			list.  Reload it now.  */
    503          			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    504          			configASSERT( xResult );
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0x4603             MOV      R3,R0
   \       0x36   0x4622             MOV      R2,R4
   \       0x38   0x4601             MOV      R1,R0
   \       0x3A   0x4630             MOV      R0,R6
   \       0x3C   0x....'....        BL       xTimerGenericCommand
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD10D             BNE.N    ??prvProcessExpiredTimer_1
   \       0x44   0x2020             MOVS     R0,#+32
   \       0x46   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x4A   0xF3BF 0x8F4F      DSB      SY
   \       0x4E   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvProcessExpiredTimer_2: (+1)
   \       0x52   0xE7FE             B.N      ??prvProcessExpiredTimer_2
    505          			( void ) xResult;
    506          		}
    507          		else
    508          		{
    509          			mtCOVERAGE_TEST_MARKER();
    510          		}
    511          	}
    512          	else
    513          	{
    514          		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
   \                     ??prvProcessExpiredTimer_0: (+1)
   \       0x54   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \       0x58   0xF000 0x00FE      AND      R0,R0,#0xFE
   \       0x5C   0xF886 0x0028      STRB     R0,[R6, #+40]
    515          		mtCOVERAGE_TEST_MARKER();
    516          	}
    517          
    518          	/* Call the timer callback. */
    519          	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   \                     ??prvProcessExpiredTimer_1: (+1)
   \       0x60   0x4630             MOV      R0,R6
   \       0x62   0x6A31             LDR      R1,[R6, #+32]
   \       0x64   0xE8BD 0x407C      POP      {R2-R6,LR}
   \       0x68   0x4708             BX       R1
    520          }
    521          /*-----------------------------------------------------------*/
    522          

   \                                 In section .text, align 4, keep-with-next
    523          static portTASK_FUNCTION( prvTimerTask, pvParameters )
    524          {
   \                     prvTimerTask: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    525          TickType_t xNextExpireTime;
    526          BaseType_t xListWasEmpty;
    527          
    528          	/* Just to avoid compiler warnings. */
    529          	( void ) pvParameters;
    530          
    531          	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
    532          	{
    533          		extern void vApplicationDaemonTaskStartupHook( void );
    534          
    535          		/* Allow the application writer to execute some code in the context of
    536          		this task at the point the task starts executing.  This is useful if the
    537          		application includes initialisation code that would benefit from
    538          		executing after the scheduler has been started. */
    539          		vApplicationDaemonTaskStartupHook();
    540          	}
    541          	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
    542          
    543          	for( ;; )
    544          	{
    545          		/* Query the timers list to see if it contains any timers, and if so,
    546          		obtain the time at which the next timer will expire. */
    547          		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   \                     ??prvTimerTask_0: (+1)
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x....'....        BL       prvGetNextExpireTime
    548          
    549          		/* If a timer has expired, process it.  Otherwise, block this task
    550          		until either a timer does expire, or a command is received. */
    551          		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   \        0x8   0x9900             LDR      R1,[SP, #+0]
   \        0xA   0x....'....        BL       prvProcessTimerOrBlockTask
    552          
    553          		/* Empty the command queue. */
    554          		prvProcessReceivedCommands();
   \        0xE   0x....'....        BL       prvProcessReceivedCommands
   \       0x12   0xE7F6             B.N      ??prvTimerTask_0
    555          	}
    556          }
    557          /*-----------------------------------------------------------*/
    558          

   \                                 In section .text, align 2, keep-with-next
    559          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
    560          {
   \                     prvProcessTimerOrBlockTask: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    561          TickType_t xTimeNow;
    562          BaseType_t xTimerListsWereSwitched;
    563          
    564          	vTaskSuspendAll();
   \        0x6   0x....'....        BL       vTaskSuspendAll
    565          	{
    566          		/* Obtain the time now to make an assessment as to whether the timer
    567          		has expired or not.  If obtaining the time causes the lists to switch
    568          		then don't process this timer as any timers that remained in the list
    569          		when the lists were switched will have been processed within the
    570          		prvSampleTimeNow() function. */
    571          		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x....'....        BL       prvSampleTimeNow
   \       0x10   0x4606             MOV      R6,R0
    572          		if( xTimerListsWereSwitched == pdFALSE )
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD129             BNE.N    ??prvProcessTimerOrBlockTask_0
    573          		{
    574          			/* The tick count has not overflowed, has the timer expired? */
    575          			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD108             BNE.N    ??prvProcessTimerOrBlockTask_1
   \       0x1C   0x42AE             CMP      R6,R5
   \       0x1E   0xD306             BCC.N    ??prvProcessTimerOrBlockTask_1
    576          			{
    577          				( void ) xTaskResumeAll();
   \       0x20   0x....'....        BL       xTaskResumeAll
    578          				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   \       0x24   0x4631             MOV      R1,R6
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x....'....        BL       prvProcessExpiredTimer
   \       0x2C   0xBD73             POP      {R0,R1,R4-R6,PC}
    579          			}
    580          			else
    581          			{
    582          				/* The tick count has not overflowed, and the next expire
    583          				time has not been reached yet.  This task should therefore
    584          				block to wait for the next expire time or a command to be
    585          				received - whichever comes first.  The following line cannot
    586          				be reached unless xNextExpireTime > xTimeNow, except in the
    587          				case when the current timer list is empty. */
    588          				if( xListWasEmpty != pdFALSE )
   \                     ??prvProcessTimerOrBlockTask_1: (+1)
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD006             BEQ.N    ??prvProcessTimerOrBlockTask_2
    589          				{
    590          					/* The current timer list is empty - is the overflow list
    591          					also empty? */
    592          					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
   \       0x32   0x....'....        LDR.W    R0,??DataTable12_4
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x1E44             SUBS     R4,R0,#+1
   \       0x3C   0x41A4             SBCS     R4,R4,R4
   \       0x3E   0x0FE4             LSRS     R4,R4,#+31
    593          				}
    594          
    595          				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   \                     ??prvProcessTimerOrBlockTask_2: (+1)
   \       0x40   0x4622             MOV      R2,R4
   \       0x42   0x1BAD             SUBS     R5,R5,R6
   \       0x44   0x4629             MOV      R1,R5
   \       0x46   0x....'....        LDR.W    R0,??DataTable12
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0x....'....        BL       vQueueWaitForMessageRestricted
    596          
    597          				if( xTaskResumeAll() == pdFALSE )
   \       0x50   0x....'....        BL       xTaskResumeAll
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD10B             BNE.N    ??prvProcessTimerOrBlockTask_3
    598          				{
    599          					/* Yield to wait for either a command to arrive, or the
    600          					block time to expire.  If a command arrived between the
    601          					critical section being exited and this yield then the yield
    602          					will not cause the task to block. */
    603          					portYIELD_WITHIN_API();
   \       0x58   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x5C   0x....'....        LDR.W    R1,??DataTable12_5  ;; 0xe000ed04
   \       0x60   0x6008             STR      R0,[R1, #+0]
   \       0x62   0xF3BF 0x8F4F      DSB      SY
   \       0x66   0xF3BF 0x8F6F      ISB      SY
   \       0x6A   0xBD73             POP      {R0,R1,R4-R6,PC}
    604          				}
    605          				else
    606          				{
    607          					mtCOVERAGE_TEST_MARKER();
    608          				}
    609          			}
    610          		}
    611          		else
    612          		{
    613          			( void ) xTaskResumeAll();
   \                     ??prvProcessTimerOrBlockTask_0: (+1)
   \       0x6C   0x....'....        BL       xTaskResumeAll
    614          		}
    615          	}
    616          }
   \                     ??prvProcessTimerOrBlockTask_3: (+1)
   \       0x70   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    617          /*-----------------------------------------------------------*/
    618          

   \                                 In section .text, align 2, keep-with-next
    619          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    620          {
    621          TickType_t xNextExpireTime;
    622          
    623          	/* Timers are listed in expiry time order, with the head of the list
    624          	referencing the task that will expire first.  Obtain the time at which
    625          	the timer with the nearest expiry time will expire.  If there are no
    626          	active timers then just set the next expire time to 0.  That will cause
    627          	this task to unblock when the tick count overflows, at which point the
    628          	timer lists will be switched and the next expiry time can be
    629          	re-assessed.  */
    630          	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   \                     prvGetNextExpireTime: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable12_3
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x6812             LDR      R2,[R2, #+0]
   \        0x6   0x1E52             SUBS     R2,R2,#+1
   \        0x8   0x4192             SBCS     R2,R2,R2
   \        0xA   0x0FD2             LSRS     R2,R2,#+31
   \        0xC   0x6002             STR      R2,[R0, #+0]
    631          	if( *pxListWasEmpty == pdFALSE )
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD103             BNE.N    ??prvGetNextExpireTime_0
    632          	{
    633          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0x68C0             LDR      R0,[R0, #+12]
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x4770             BX       LR
    634          	}
    635          	else
    636          	{
    637          		/* Ensure the task unblocks when the tick count rolls over. */
    638          		xNextExpireTime = ( TickType_t ) 0U;
   \                     ??prvGetNextExpireTime_0: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
    639          	}
    640          
    641          	return xNextExpireTime;
   \       0x1E   0x4770             BX       LR               ;; return
    642          }
    643          /*-----------------------------------------------------------*/
    644          

   \                                 In section .text, align 2, keep-with-next
    645          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    646          {
   \                     prvSampleTimeNow: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    647          TickType_t xTimeNow;
    648          PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
    649          
    650          	xTimeNow = xTaskGetTickCount();
   \        0x4   0x....'....        BL       xTaskGetTickCount
   \        0x8   0x4605             MOV      R5,R0
    651          
    652          	if( xTimeNow < xLastTime )
   \        0xA   0x....             LDR.N    R6,??DataTable12_6
   \        0xC   0x6830             LDR      R0,[R6, #+0]
   \        0xE   0x4285             CMP      R5,R0
   \       0x10   0xD204             BCS.N    ??prvSampleTimeNow_0
    653          	{
    654          		prvSwitchTimerLists();
   \       0x12   0x....'....        BL       prvSwitchTimerLists
    655          		*pxTimerListsWereSwitched = pdTRUE;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x6020             STR      R0,[R4, #+0]
   \       0x1A   0xE001             B.N      ??prvSampleTimeNow_1
    656          	}
    657          	else
    658          	{
    659          		*pxTimerListsWereSwitched = pdFALSE;
   \                     ??prvSampleTimeNow_0: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x6020             STR      R0,[R4, #+0]
    660          	}
    661          
    662          	xLastTime = xTimeNow;
   \                     ??prvSampleTimeNow_1: (+1)
   \       0x20   0x6035             STR      R5,[R6, #+0]
    663          
    664          	return xTimeNow;
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0xBD70             POP      {R4-R6,PC}       ;; return
    665          }

   \                                 In section .bss, align 4
   \                     `prvSampleTimeNow::xLastTime`:
   \        0x0                      DS8 4
    666          /*-----------------------------------------------------------*/
    667          

   \                                 In section .text, align 2, keep-with-next
    668          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
    669          {
   \                     prvInsertTimerInActiveList: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    670          BaseType_t xProcessTimerNow = pdFALSE;
   \        0x2   0x2400             MOVS     R4,#+0
    671          
    672          	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   \        0x4   0x6041             STR      R1,[R0, #+4]
    673          	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   \        0x6   0x6100             STR      R0,[R0, #+16]
    674          
    675          	if( xNextExpiryTime <= xTimeNow )
   \        0x8   0x428A             CMP      R2,R1
   \        0xA   0xD30B             BCC.N    ??prvInsertTimerInActiveList_0
    676          	{
    677          		/* Has the expiry time elapsed between the command to start/reset a
    678          		timer was issued, and the time the command was processed? */
    679          		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \        0xC   0x1AD2             SUBS     R2,R2,R3
   \        0xE   0x6981             LDR      R1,[R0, #+24]
   \       0x10   0x428A             CMP      R2,R1
   \       0x12   0xD301             BCC.N    ??prvInsertTimerInActiveList_1
    680          		{
    681          			/* The time between a command being issued and the command being
    682          			processed actually exceeds the timers period.  */
    683          			xProcessTimerNow = pdTRUE;
   \       0x14   0x2401             MOVS     R4,#+1
   \       0x16   0xE010             B.N      ??prvInsertTimerInActiveList_2
    684          		}
    685          		else
    686          		{
    687          			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   \                     ??prvInsertTimerInActiveList_1: (+1)
   \       0x18   0x1D01             ADDS     R1,R0,#+4
   \       0x1A   0x....             LDR.N    R0,??DataTable12_4
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0x....'....        BL       vListInsert
   \       0x22   0xE00A             B.N      ??prvInsertTimerInActiveList_2
    688          		}
    689          	}
    690          	else
    691          	{
    692          		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   \                     ??prvInsertTimerInActiveList_0: (+1)
   \       0x24   0x429A             CMP      R2,R3
   \       0x26   0xD203             BCS.N    ??prvInsertTimerInActiveList_3
   \       0x28   0x4299             CMP      R1,R3
   \       0x2A   0xD301             BCC.N    ??prvInsertTimerInActiveList_3
    693          		{
    694          			/* If, since the command was issued, the tick count has overflowed
    695          			but the expiry time has not, then the timer must have already passed
    696          			its expiry time and should be processed immediately. */
    697          			xProcessTimerNow = pdTRUE;
   \       0x2C   0x2401             MOVS     R4,#+1
   \       0x2E   0xE004             B.N      ??prvInsertTimerInActiveList_2
    698          		}
    699          		else
    700          		{
    701          			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   \                     ??prvInsertTimerInActiveList_3: (+1)
   \       0x30   0x1D01             ADDS     R1,R0,#+4
   \       0x32   0x....             LDR.N    R0,??DataTable12_3
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x....'....        BL       vListInsert
    702          		}
    703          	}
    704          
    705          	return xProcessTimerNow;
   \                     ??prvInsertTimerInActiveList_2: (+1)
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
    706          }
    707          /*-----------------------------------------------------------*/
    708          

   \                                 In section .text, align 4, keep-with-next
    709          static void	prvProcessReceivedCommands( void )
    710          {
   \                     prvProcessReceivedCommands: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0xE005             B.N      ??prvProcessReceivedCommands_1
    711          DaemonTaskMessage_t xMessage;
    712          Timer_t *pxTimer;
    713          BaseType_t xTimerListsWereSwitched, xResult;
    714          TickType_t xTimeNow;
    715          
    716          	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    717          	{
    718          		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
    719          		{
    720          			/* Negative commands are pended function calls rather than timer
    721          			commands. */
    722          			if( xMessage.xMessageID < ( BaseType_t ) 0 )
    723          			{
    724          				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
    725          
    726          				/* The timer uses the xCallbackParameters member to request a
    727          				callback be executed.  Check the callback is not NULL. */
    728          				configASSERT( pxCallback );
    729          
    730          				/* Call the function. */
    731          				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
    732          			}
    733          			else
    734          			{
    735          				mtCOVERAGE_TEST_MARKER();
    736          			}
    737          		}
    738          		#endif /* INCLUDE_xTimerPendFunctionCall */
    739          
    740          		/* Commands that are positive are timer commands rather than pended
    741          		function calls. */
    742          		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    743          		{
    744          			/* The messages uses the xTimerParameters member to work on a
    745          			software timer. */
    746          			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    747          
    748          			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    749          			{
    750          				/* The timer is in a list, remove it. */
    751          				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    752          			}
    753          			else
    754          			{
    755          				mtCOVERAGE_TEST_MARKER();
    756          			}
    757          
    758          			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
    759          
    760          			/* In this case the xTimerListsWereSwitched parameter is not used, but
    761          			it must be present in the function call.  prvSampleTimeNow() must be
    762          			called after the message is received from xTimerQueue so there is no
    763          			possibility of a higher priority task adding a message to the message
    764          			queue with a time that is ahead of the timer daemon task (because it
    765          			pre-empted the timer daemon task after the xTimeNow value was set). */
    766          			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    767          
    768          			switch( xMessage.xMessageID )
    769          			{
    770          				case tmrCOMMAND_START :
    771          				case tmrCOMMAND_START_FROM_ISR :
    772          				case tmrCOMMAND_RESET :
    773          				case tmrCOMMAND_RESET_FROM_ISR :
    774          				case tmrCOMMAND_START_DONT_TRACE :
    775          					/* Start or restart a timer. */
    776          					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    777          					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    778          					{
    779          						/* The timer expired before it was added to the active
    780          						timer list.  Process it now. */
    781          						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    782          						traceTIMER_EXPIRED( pxTimer );
    783          
    784          						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    785          						{
    786          							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    787          							configASSERT( xResult );
    788          							( void ) xResult;
    789          						}
    790          						else
    791          						{
    792          							mtCOVERAGE_TEST_MARKER();
    793          						}
    794          					}
    795          					else
    796          					{
    797          						mtCOVERAGE_TEST_MARKER();
    798          					}
    799          					break;
    800          
    801          				case tmrCOMMAND_STOP :
    802          				case tmrCOMMAND_STOP_FROM_ISR :
    803          					/* The timer has already been removed from the active list. */
    804          					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    805          					break;
    806          
    807          				case tmrCOMMAND_CHANGE_PERIOD :
    808          				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
    809          					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    810          					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    811          					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    812          
    813          					/* The new period does not really have a reference, and can
    814          					be longer or shorter than the old one.  The command time is
    815          					therefore set to the current time, and as the period cannot
    816          					be zero the next expiry time can only be in the future,
    817          					meaning (unlike for the xTimerStart() case above) there is
    818          					no fail case that needs to be handled here. */
    819          					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   \                     ??prvProcessReceivedCommands_2: (+1)
   \        0x6   0x460B             MOV      R3,R1
   \        0x8   0x460A             MOV      R2,R1
   \        0xA   0x1841             ADDS     R1,R0,R1
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x....'....        BL       prvInsertTimerInActiveList
    820          					break;
   \                     ??prvProcessReceivedCommands_1: (+1)
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0xA902             ADD      R1,SP,#+8
   \       0x16   0x....             LDR.N    R0,??DataTable12
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x....'....        BL       xQueueReceive
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD06C             BEQ.N    ??prvProcessReceivedCommands_3
   \       0x22   0x9802             LDR      R0,[SP, #+8]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD504             BPL.N    ??prvProcessReceivedCommands_4
   \       0x28   0xAA03             ADD      R2,SP,#+12
   \       0x2A   0x6891             LDR      R1,[R2, #+8]
   \       0x2C   0x6850             LDR      R0,[R2, #+4]
   \       0x2E   0x6812             LDR      R2,[R2, #+0]
   \       0x30   0x4790             BLX      R2
   \                     ??prvProcessReceivedCommands_4: (+1)
   \       0x32   0x9802             LDR      R0,[SP, #+8]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD4EC             BMI.N    ??prvProcessReceivedCommands_1
   \       0x38   0x9C04             LDR      R4,[SP, #+16]
   \       0x3A   0x6960             LDR      R0,[R4, #+20]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD002             BEQ.N    ??prvProcessReceivedCommands_5
   \       0x40   0x1D20             ADDS     R0,R4,#+4
   \       0x42   0x....'....        BL       uxListRemove
   \                     ??prvProcessReceivedCommands_5: (+1)
   \       0x46   0xA801             ADD      R0,SP,#+4
   \       0x48   0x....'....        BL       prvSampleTimeNow
   \       0x4C   0x4601             MOV      R1,R0
   \       0x4E   0x9802             LDR      R0,[SP, #+8]
   \       0x50   0x2809             CMP      R0,#+9
   \       0x52   0xD8DE             BHI.N    ??prvProcessReceivedCommands_1
   \       0x54   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??prvProcessReceivedCommands_0:
   \       0x58   0x06 0x06          DC8      0x6,0x6,0x6,0x4B
   \              0x06 0x4B    
   \       0x5C   0x31 0x43          DC8      0x31,0x43,0x6,0x6
   \              0x06 0x06    
   \       0x60   0x4B 0x31          DC8      0x4B,0x31
   \                     ??prvProcessReceivedCommands_6: (+1)
   \       0x62   0xE7D6             B.N      ??prvProcessReceivedCommands_1
   \                     ??prvProcessReceivedCommands_7: (+1)
   \       0x64   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \       0x68   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x6C   0xF884 0x0028      STRB     R0,[R4, #+40]
   \       0x70   0x9B03             LDR      R3,[SP, #+12]
   \       0x72   0x460A             MOV      R2,R1
   \       0x74   0x4619             MOV      R1,R3
   \       0x76   0x69A0             LDR      R0,[R4, #+24]
   \       0x78   0x1841             ADDS     R1,R0,R1
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0x....'....        BL       prvInsertTimerInActiveList
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD0C6             BEQ.N    ??prvProcessReceivedCommands_1
   \       0x84   0x4620             MOV      R0,R4
   \       0x86   0x6A21             LDR      R1,[R4, #+32]
   \       0x88   0x4788             BLX      R1
   \       0x8A   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \       0x8E   0x0740             LSLS     R0,R0,#+29
   \       0x90   0xD5BF             BPL.N    ??prvProcessReceivedCommands_1
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x9000             STR      R0,[SP, #+0]
   \       0x96   0x4603             MOV      R3,R0
   \       0x98   0x9A03             LDR      R2,[SP, #+12]
   \       0x9A   0x69A0             LDR      R0,[R4, #+24]
   \       0x9C   0x1882             ADDS     R2,R0,R2
   \       0x9E   0x4619             MOV      R1,R3
   \       0xA0   0x4620             MOV      R0,R4
   \       0xA2   0x....'....        BL       xTimerGenericCommand
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD1B3             BNE.N    ??prvProcessReceivedCommands_1
   \       0xAA   0x2020             MOVS     R0,#+32
   \       0xAC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xB0   0xF3BF 0x8F4F      DSB      SY
   \       0xB4   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvProcessReceivedCommands_8: (+1)
   \       0xB8   0xE7FE             B.N      ??prvProcessReceivedCommands_8
   \                     ??prvProcessReceivedCommands_9: (+1)
   \       0xBA   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \       0xBE   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0xC2   0xF884 0x0028      STRB     R0,[R4, #+40]
   \       0xC6   0x9803             LDR      R0,[SP, #+12]
   \       0xC8   0x61A0             STR      R0,[R4, #+24]
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD19B             BNE.N    ??prvProcessReceivedCommands_2
   \       0xCE   0x2020             MOVS     R0,#+32
   \       0xD0   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xD4   0xF3BF 0x8F4F      DSB      SY
   \       0xD8   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvProcessReceivedCommands_10: (+1)
   \       0xDC   0xE7FE             B.N      ??prvProcessReceivedCommands_10
    821          
    822          				case tmrCOMMAND_DELETE :
    823          					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    824          					{
    825          						/* The timer has already been removed from the active list,
    826          						just free up the memory if the memory was dynamically
    827          						allocated. */
    828          						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
   \                     ??prvProcessReceivedCommands_11: (+1)
   \       0xDE   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \       0xE2   0x0780             LSLS     R0,R0,#+30
   \       0xE4   0xD403             BMI.N    ??prvProcessReceivedCommands_12
    829          						{
    830          							vPortFree( pxTimer );
   \       0xE6   0x4620             MOV      R0,R4
   \       0xE8   0x....'....        BL       vPortFree
   \       0xEC   0xE791             B.N      ??prvProcessReceivedCommands_1
    831          						}
    832          						else
    833          						{
    834          							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
   \                     ??prvProcessReceivedCommands_12: (+1)
   \       0xEE   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \       0xF2   0xF000 0x00FE      AND      R0,R0,#0xFE
   \       0xF6   0xF884 0x0028      STRB     R0,[R4, #+40]
   \       0xFA   0xE78A             B.N      ??prvProcessReceivedCommands_1
    835          						}
    836          					}
    837          					#else
    838          					{
    839          						/* If dynamic allocation is not enabled, the memory
    840          						could not have been dynamically allocated. So there is
    841          						no need to free the memory - just mark the timer as
    842          						"not active". */
    843          						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    844          					}
    845          					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    846          					break;
    847          
    848          				default	:
    849          					/* Don't expect to get here. */
    850          					break;
    851          			}
    852          		}
    853          	}
    854          }
   \                     ??prvProcessReceivedCommands_3: (+1)
   \       0xFC   0xB006             ADD      SP,SP,#+24
   \       0xFE   0xBD10             POP      {R4,PC}          ;; return
    855          /*-----------------------------------------------------------*/
    856          

   \                                 In section .text, align 2, keep-with-next
    857          static void prvSwitchTimerLists( void )
    858          {
   \                     prvSwitchTimerLists: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x....             LDR.N    R4,??DataTable12_3
   \        0x4   0xE005             B.N      ??prvSwitchTimerLists_0
    859          TickType_t xNextExpireTime, xReloadTime;
    860          List_t *pxTemp;
    861          Timer_t *pxTimer;
    862          BaseType_t xResult;
    863          
    864          	/* The tick count has overflowed.  The timer lists must be switched.
    865          	If there are any timers still referenced from the current timer list
    866          	then they must have expired and should be processed before the lists
    867          	are switched. */
    868          	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    869          	{
    870          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    871          
    872          		/* Remove the timer from the list. */
    873          		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    874          		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    875          		traceTIMER_EXPIRED( pxTimer );
    876          
    877          		/* Execute its callback, then send a command to restart the timer if
    878          		it is an auto-reload timer.  It cannot be restarted here as the lists
    879          		have not yet been switched. */
    880          		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    881          
    882          		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    883          		{
    884          			/* Calculate the reload value, and if the reload value results in
    885          			the timer going into the same timer list then it has already expired
    886          			and the timer should be re-inserted into the current list so it is
    887          			processed again within this loop.  Otherwise a command should be sent
    888          			to restart the timer to ensure it is only inserted into a list after
    889          			the lists have been swapped. */
    890          			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    891          			if( xReloadTime > xNextExpireTime )
    892          			{
    893          				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   \                     ??prvSwitchTimerLists_1: (+1)
   \        0x6   0x6070             STR      R0,[R6, #+4]
    894          				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   \        0x8   0x6136             STR      R6,[R6, #+16]
    895          				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   \        0xA   0x1D31             ADDS     R1,R6,#+4
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x....'....        BL       vListInsert
    896          			}
   \                     ??prvSwitchTimerLists_0: (+1)
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0xD024             BEQ.N    ??prvSwitchTimerLists_2
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x6805             LDR      R5,[R0, #+0]
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x68C0             LDR      R0,[R0, #+12]
   \       0x24   0x68C6             LDR      R6,[R0, #+12]
   \       0x26   0x1D30             ADDS     R0,R6,#+4
   \       0x28   0x....'....        BL       uxListRemove
   \       0x2C   0x4630             MOV      R0,R6
   \       0x2E   0x6A31             LDR      R1,[R6, #+32]
   \       0x30   0x4788             BLX      R1
   \       0x32   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \       0x36   0x0740             LSLS     R0,R0,#+29
   \       0x38   0xD5EB             BPL.N    ??prvSwitchTimerLists_0
   \       0x3A   0x69B0             LDR      R0,[R6, #+24]
   \       0x3C   0x1940             ADDS     R0,R0,R5
   \       0x3E   0x4285             CMP      R5,R0
   \       0x40   0xD3E1             BCC.N    ??prvSwitchTimerLists_1
    897          			else
    898          			{
    899          				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    900          				configASSERT( xResult );
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x9000             STR      R0,[SP, #+0]
   \       0x46   0x4603             MOV      R3,R0
   \       0x48   0x462A             MOV      R2,R5
   \       0x4A   0x4601             MOV      R1,R0
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x....'....        BL       xTimerGenericCommand
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD1DD             BNE.N    ??prvSwitchTimerLists_0
   \       0x56   0x2020             MOVS     R0,#+32
   \       0x58   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x5C   0xF3BF 0x8F4F      DSB      SY
   \       0x60   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvSwitchTimerLists_3: (+1)
   \       0x64   0xE7FE             B.N      ??prvSwitchTimerLists_3
    901          				( void ) xResult;
    902          			}
    903          		}
    904          		else
    905          		{
    906          			mtCOVERAGE_TEST_MARKER();
    907          		}
    908          	}
    909          
    910          	pxTemp = pxCurrentTimerList;
    911          	pxCurrentTimerList = pxOverflowTimerList;
   \                     ??prvSwitchTimerLists_2: (+1)
   \       0x66   0x....             LDR.N    R1,??DataTable12_4
   \       0x68   0x680A             LDR      R2,[R1, #+0]
   \       0x6A   0x6022             STR      R2,[R4, #+0]
    912          	pxOverflowTimerList = pxTemp;
   \       0x6C   0x6008             STR      R0,[R1, #+0]
    913          }
   \       0x6E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    914          /*-----------------------------------------------------------*/
    915          

   \                                 In section .text, align 2, keep-with-next
    916          static void prvCheckForValidListAndQueue( void )
    917          {
   \                     prvCheckForValidListAndQueue: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    918          	/* Check that the list from which active timers are referenced, and the
    919          	queue used to communicate with the timer service, have been
    920          	initialised. */
    921          	taskENTER_CRITICAL();
   \        0x2   0x....'....        BL       vPortEnterCritical
    922          	{
    923          		if( xTimerQueue == NULL )
   \        0x6   0x....             LDR.N    R4,??DataTable12
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD116             BNE.N    ??prvCheckForValidListAndQueue_0
    924          		{
    925          			vListInitialise( &xActiveTimerList1 );
   \        0xE   0x....             LDR.N    R5,??DataTable12_7
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x....'....        BL       vListInitialise
    926          			vListInitialise( &xActiveTimerList2 );
   \       0x16   0x....             LDR.N    R6,??DataTable12_8
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0x....'....        BL       vListInitialise
    927          			pxCurrentTimerList = &xActiveTimerList1;
   \       0x1E   0x....             LDR.N    R0,??DataTable12_3
   \       0x20   0x6005             STR      R5,[R0, #+0]
    928          			pxOverflowTimerList = &xActiveTimerList2;
   \       0x22   0x....             LDR.N    R0,??DataTable12_4
   \       0x24   0x6006             STR      R6,[R0, #+0]
    929          
    930          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    931          			{
    932          				/* The timer queue is allocated statically in case
    933          				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
    934          				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
    935          				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
    936          
    937          				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
    938          			}
    939          			#else
    940          			{
    941          				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x2110             MOVS     R1,#+16
   \       0x2A   0x200A             MOVS     R0,#+10
   \       0x2C   0x....'....        BL       xQueueGenericCreate
   \       0x30   0x6020             STR      R0,[R4, #+0]
    942          			}
    943          			#endif
    944          
    945          			#if ( configQUEUE_REGISTRY_SIZE > 0 )
    946          			{
    947          				if( xTimerQueue != NULL )
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD002             BEQ.N    ??prvCheckForValidListAndQueue_0
    948          				{
    949          					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
   \       0x36   0x....             LDR.N    R1,??DataTable12_9
   \       0x38   0x....'....        BL       vQueueAddToRegistry
    950          				}
    951          				else
    952          				{
    953          					mtCOVERAGE_TEST_MARKER();
    954          				}
    955          			}
    956          			#endif /* configQUEUE_REGISTRY_SIZE */
    957          		}
    958          		else
    959          		{
    960          			mtCOVERAGE_TEST_MARKER();
    961          		}
    962          	}
    963          	taskEXIT_CRITICAL();
   \                     ??prvCheckForValidListAndQueue_0: (+1)
   \       0x3C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x40   0x....'....        B.W      vPortExitCritical
    964          }
    965          /*-----------------------------------------------------------*/
    966          

   \                                 In section .text, align 2, keep-with-next
    967          BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    968          {
   \                     xTimerIsTimerActive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    969          BaseType_t xReturn;
    970          Timer_t *pxTimer = xTimer;
    971          
    972          	configASSERT( xTimer );
   \        0x4   0xD107             BNE.N    ??xTimerIsTimerActive_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerIsTimerActive_1: (+1)
   \       0x14   0xE7FE             B.N      ??xTimerIsTimerActive_1
    973          
    974          	/* Is the timer in the list of active timers? */
    975          	taskENTER_CRITICAL();
   \                     ??xTimerIsTimerActive_0: (+1)
   \       0x16   0x....'....        BL       vPortEnterCritical
    976          	{
    977          		if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    978          		{
    979          			xReturn = pdFALSE;
   \       0x1A   0xF894 0x4028      LDRB     R4,[R4, #+40]
   \       0x1E   0xF004 0x0401      AND      R4,R4,#0x1
    980          		}
    981          		else
    982          		{
    983          			xReturn = pdTRUE;
    984          		}
    985          	}
    986          	taskEXIT_CRITICAL();
   \       0x22   0x....'....        BL       vPortExitCritical
    987          
    988          	return xReturn;
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0xBD10             POP      {R4,PC}          ;; return
    989          } /*lint !e818 Can't be pointer to const due to the typedef. */
    990          /*-----------------------------------------------------------*/
    991          

   \                                 In section .text, align 2, keep-with-next
    992          void *pvTimerGetTimerID( const TimerHandle_t xTimer )
    993          {
   \                     pvTimerGetTimerID: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    994          Timer_t * const pxTimer = xTimer;
    995          void *pvReturn;
    996          
    997          	configASSERT( xTimer );
   \        0x4   0xD107             BNE.N    ??pvTimerGetTimerID_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??pvTimerGetTimerID_1: (+1)
   \       0x14   0xE7FE             B.N      ??pvTimerGetTimerID_1
    998          
    999          	taskENTER_CRITICAL();
   \                     ??pvTimerGetTimerID_0: (+1)
   \       0x16   0x....'....        BL       vPortEnterCritical
   1000          	{
   1001          		pvReturn = pxTimer->pvTimerID;
   \       0x1A   0x69E4             LDR      R4,[R4, #+28]
   1002          	}
   1003          	taskEXIT_CRITICAL();
   \       0x1C   0x....'....        BL       vPortExitCritical
   1004          
   1005          	return pvReturn;
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
   1006          }
   1007          /*-----------------------------------------------------------*/
   1008          

   \                                 In section .text, align 2, keep-with-next
   1009          void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
   1010          {
   \                     vTimerSetTimerID: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1011          Timer_t * const pxTimer = xTimer;
   1012          
   1013          	configASSERT( xTimer );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??vTimerSetTimerID_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTimerSetTimerID_1: (+1)
   \       0x18   0xE7FE             B.N      ??vTimerSetTimerID_1
   1014          
   1015          	taskENTER_CRITICAL();
   \                     ??vTimerSetTimerID_0: (+1)
   \       0x1A   0x....'....        BL       vPortEnterCritical
   1016          	{
   1017          		pxTimer->pvTimerID = pvNewID;
   \       0x1E   0x61E5             STR      R5,[R4, #+28]
   1018          	}
   1019          	taskEXIT_CRITICAL();
   \       0x20   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x24   0x....'....        B.W      vPortExitCritical
   1020          }
   1021          /*-----------------------------------------------------------*/
   1022          
   1023          #if( INCLUDE_xTimerPendFunctionCall == 1 )
   1024          

   \                                 In section .text, align 2, keep-with-next
   1025          	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
   1026          	{
   \                     xTimerPendFunctionCallFromISR: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x461C             MOV      R4,R3
   1027          	DaemonTaskMessage_t xMessage;
   1028          	BaseType_t xReturn;
   1029          
   1030          		/* Complete the message with the function parameters and post it to the
   1031          		daemon task. */
   1032          		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
   \        0x4   0xF06F 0x0301      MVN      R3,#+1
   \        0x8   0x9300             STR      R3,[SP, #+0]
   1033          		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
   \        0xA   0x9001             STR      R0,[SP, #+4]
   1034          		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
   \        0xC   0x9102             STR      R1,[SP, #+8]
   1035          		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
   \        0xE   0x9203             STR      R2,[SP, #+12]
   1036          
   1037          		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   1038          
   1039          		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
   1040          
   1041          		return xReturn;
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x4622             MOV      R2,R4
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x....             LDR.N    R0,??DataTable12
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x....'....        BL       xQueueGenericSendFromISR
   \       0x1E   0xB004             ADD      SP,SP,#+16
   \       0x20   0xBD10             POP      {R4,PC}          ;; return
   1042          	}
   1043          
   1044          #endif /* INCLUDE_xTimerPendFunctionCall */
   1045          /*-----------------------------------------------------------*/
   1046          
   1047          #if( INCLUDE_xTimerPendFunctionCall == 1 )
   1048          

   \                                 In section .text, align 2, keep-with-next
   1049          	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
   1050          	{
   \                     xTimerPendFunctionCall: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x461C             MOV      R4,R3
   1051          	DaemonTaskMessage_t xMessage;
   1052          	BaseType_t xReturn;
   1053          
   1054          		/* This function can only be called after a timer has been created or
   1055          		after the scheduler has been started because, until then, the timer
   1056          		queue does not exist. */
   1057          		configASSERT( xTimerQueue );
   \        0x6   0x....             LDR.N    R5,??DataTable12
   \        0x8   0x682B             LDR      R3,[R5, #+0]
   \        0xA   0x2B00             CMP      R3,#+0
   \        0xC   0xD107             BNE.N    ??xTimerPendFunctionCall_0
   \        0xE   0x2020             MOVS     R0,#+32
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerPendFunctionCall_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xTimerPendFunctionCall_1
   1058          
   1059          		/* Complete the message with the function parameters and post it to the
   1060          		daemon task. */
   1061          		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
   \                     ??xTimerPendFunctionCall_0: (+1)
   \       0x1E   0xF04F 0x33FF      MOV      R3,#-1
   \       0x22   0x9300             STR      R3,[SP, #+0]
   1062          		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
   \       0x24   0x9001             STR      R0,[SP, #+4]
   1063          		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
   \       0x26   0x9102             STR      R1,[SP, #+8]
   1064          		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
   \       0x28   0x9203             STR      R2,[SP, #+12]
   1065          
   1066          		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   1067          
   1068          		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
   1069          
   1070          		return xReturn;
   \       0x2A   0x2300             MOVS     R3,#+0
   \       0x2C   0x4622             MOV      R2,R4
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x....'....        BL       xQueueGenericSend
   \       0x36   0xB005             ADD      SP,SP,#+20
   \       0x38   0xBD30             POP      {R4,R5,PC}       ;; return
   1071          	}
   1072          
   1073          #endif /* INCLUDE_xTimerPendFunctionCall */
   1074          /*-----------------------------------------------------------*/
   1075          
   1076          #if ( configUSE_TRACE_FACILITY == 1 )
   1077          

   \                                 In section .text, align 2, keep-with-next
   1078          	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
   1079          	{
   1080          		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
   \                     uxTimerGetTimerNumber: (+1)
   \        0x0   0x6A40             LDR      R0,[R0, #+36]
   \        0x2   0x4770             BX       LR               ;; return
   1081          	}
   1082          
   1083          #endif /* configUSE_TRACE_FACILITY */
   1084          /*-----------------------------------------------------------*/
   1085          
   1086          #if ( configUSE_TRACE_FACILITY == 1 )
   1087          

   \                                 In section .text, align 2, keep-with-next
   1088          	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
   1089          	{
   1090          		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
   \                     vTimerSetTimerNumber: (+1)
   \        0x0   0x6241             STR      R1,[R0, #+36]
   1091          	}
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     xTimerQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x....'....        DC32     xTimerTaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     pxCurrentTimerList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x....'....        DC32     pxOverflowTimerList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x....'....        DC32     `prvSampleTimeNow::xLastTime`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x....'....        DC32     xActiveTimerList1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x....'....        DC32     xActiveTimerList2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x54 0x6D          DC8 "Tmr Svc"
   \              0x72 0x20    
   \              0x53 0x76    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x54 0x6D          DC8 "TmrQ"
   \              0x72 0x51    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1092          
   1093          #endif /* configUSE_TRACE_FACILITY */
   1094          /*-----------------------------------------------------------*/
   1095          
   1096          /* This entire source file will be skipped if the application is not configured
   1097          to include software timer functionality.  If you want to include software timer
   1098          functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
   1099          #endif /* configUSE_TIMERS == 1 */
   1100          
   1101          
   1102          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   pcTimerGetName
      16   prvCheckForValidListAndQueue
        16   -> vListInitialise
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
        16   -> vQueueAddToRegistry
        16   -> xQueueGenericCreate
       0   prvGetNextExpireTime
      32   prvInitialiseNewTimer
        32   -> prvCheckForValidListAndQueue
        32   -> vListInitialiseItem
       8   prvInsertTimerInActiveList
         8   -> vListInsert
      24   prvProcessExpiredTimer
         0   -- Indirect call
        24   -> prvInsertTimerInActiveList
        24   -> uxListRemove
        24   -> xTimerGenericCommand
      32   prvProcessReceivedCommands
        32   -- Indirect call
        32   -> prvInsertTimerInActiveList
        32   -> prvSampleTimeNow
        32   -> uxListRemove
        32   -> vPortFree
        32   -> xQueueReceive
        32   -> xTimerGenericCommand
      24   prvProcessTimerOrBlockTask
        24   -> prvProcessExpiredTimer
        24   -> prvSampleTimeNow
        24   -> vQueueWaitForMessageRestricted
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
      16   prvSampleTimeNow
        16   -> prvSwitchTimerLists
        16   -> xTaskGetTickCount
      24   prvSwitchTimerLists
        24   -- Indirect call
        24   -> uxListRemove
        24   -> vListInsert
        24   -> xTimerGenericCommand
       8   prvTimerTask
         8   -> prvGetNextExpireTime
         8   -> prvProcessReceivedCommands
         8   -> prvProcessTimerOrBlockTask
       8   pvTimerGetTimerID
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       0   uxTimerGetTimerNumber
      16   vTimerSetReloadMode
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
      16   vTimerSetTimerID
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
       0   vTimerSetTimerNumber
      32   xTimerCreate
        32   -> prvInitialiseNewTimer
        32   -> pvPortMalloc
      16   xTimerCreateTimerTask
        16   -> prvCheckForValidListAndQueue
        16   -> xTaskCreate
      32   xTimerGenericCommand
        32   -> xQueueGenericSend
        32   -> xQueueGenericSendFromISR
        32   -> xTaskGetSchedulerState
       0   xTimerGetExpiryTime
       0   xTimerGetPeriod
       0   xTimerGetTimerDaemonTaskHandle
       8   xTimerIsTimerActive
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      32   xTimerPendFunctionCall
        32   -> xQueueGenericSend
      24   xTimerPendFunctionCallFromISR
        24   -> xQueueGenericSendFromISR


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       8  ?_0
       8  ?_1
      24  pcTimerGetName
      68  prvCheckForValidListAndQueue
      32  prvGetNextExpireTime
      84  prvInitialiseNewTimer
      62  prvInsertTimerInActiveList
     106  prvProcessExpiredTimer
     256  prvProcessReceivedCommands
     114  prvProcessTimerOrBlockTask
      38  prvSampleTimeNow
     112  prvSwitchTimerLists
      20  prvTimerTask
      36  pvTimerGetTimerID
       4  pxCurrentTimerList
       4  pxOverflowTimerList
       4  uxTimerGetTimerNumber
      64  vTimerSetReloadMode
      40  vTimerSetTimerID
       4  vTimerSetTimerNumber
      20  xActiveTimerList1
      20  xActiveTimerList2
       4  xLastTime
      52  xTimerCreate
      72  xTimerCreateTimerTask
     100  xTimerGenericCommand
      24  xTimerGetExpiryTime
      24  xTimerGetPeriod
      28  xTimerGetTimerDaemonTaskHandle
      42  xTimerIsTimerActive
      58  xTimerPendFunctionCall
      34  xTimerPendFunctionCallFromISR
       4  xTimerQueue
       4  xTimerTaskHandle

 
    60 bytes in section .bss
    16 bytes in section .rodata
 1 538 bytes in section .text
 
 1 538 bytes of CODE  memory
    16 bytes of CONST memory
    60 bytes of DATA  memory

Errors: none
Warnings: none
