###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:21
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\drivers\fsl_dcp.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWE188.tmp
#        (C:\Development\smart_washing_machine_3080\drivers\fsl_dcp.c -D DEBUG
#        -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1 -D
#        CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\fsl_dcp.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\fsl_dcp.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\drivers\fsl_dcp.c
      1          /*
      2           * Copyright 2017-2019 NXP
      3           * All rights reserved.
      4           *
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           */
      8          
      9          #include "fsl_dcp.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_ControlGate(clock_ip_name_t, clock_gate_value_t)
   \                     CLOCK_ControlGate: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4626             MOV      R6,R4
   \        0x8   0x0A36             LSRS     R6,R6,#+8
   \        0xA   0xF004 0x041F      AND      R4,R4,#0x1F
   \        0xE   0x2E07             CMP      R6,#+7
   \       0x10   0xD309             BCC.N    ??CLOCK_ControlGate_0
   \       0x12   0xF240 0x32C1      MOVW     R2,#+961
   \       0x16   0x....'....        LDR.W    R1,??DataTable6
   \       0x1A   0x....'....        LDR.W    R0,??DataTable6_1
   \       0x1E   0x....'....        BL       __aeabi_assert
   \       0x22   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??CLOCK_ControlGate_0: (+1)
   \       0x26   0x....'....        LDR.W    R0,??DataTable6_2  ;; 0x400fc068
   \       0x2A   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0x2203             MOVS     R2,#+3
   \       0x32   0x40A2             LSLS     R2,R2,R4
   \       0x34   0x4391             BICS     R1,R1,R2
   \       0x36   0xFA05 0xF404      LSL      R4,R5,R4
   \       0x3A   0x430C             ORRS     R4,R4,R1
   \       0x3C   0x6004             STR      R4,[R0, #+0]
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \        0x0   0x2103             MOVS     R1,#+3
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t DisableGlobalIRQ(void)
   \                     DisableGlobalIRQ: (+1)
   \        0x0   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x4   0xB672             CPSID    I
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableGlobalIRQ(uint32_t)
   \                     EnableGlobalIRQ: (+1)
   \        0x0   0xF380 0x8810      MSR      PRIMASK,R0
   \        0x4   0x4770             BX       LR               ;; return
     10          
     11          /*******************************************************************************
     12           * Definitions
     13           ******************************************************************************/
     14          
     15          /* Component ID definition, used by tools. */
     16          #ifndef FSL_COMPONENT_ID
     17          #define FSL_COMPONENT_ID "platform.drivers.dcp"
     18          #endif
     19          
     20          /*! Compile time sizeof() check */
     21          #define BUILD_ASSURE(condition, msg) extern int msg[1 - 2 * (!(condition))] __attribute__((unused))
     22          
     23          #define dcp_memcpy memcpy
     24          
     25          /*! Internal states of the HASH creation process */
     26          typedef enum _dcp_hash_algo_state
     27          {
     28              kDCP_StateHashInit = 1u, /*!< Init state. */
     29              kDCP_StateHashUpdate,    /*!< Update state. */
     30          } dcp_hash_algo_state_t;
     31          
     32          /*! multiple of 64-byte block represented as byte array of 32-bit words */
     33          typedef union _dcp_hash_block
     34          {
     35              uint32_t w[DCP_HASH_BLOCK_SIZE / 4]; /*!< array of 32-bit words */
     36              uint8_t b[DCP_HASH_BLOCK_SIZE];      /*!< byte array */
     37          } dcp_hash_block_t;
     38          
     39          /*! internal dcp_hash context structure */
     40          typedef struct _dcp_hash_ctx_internal
     41          {
     42              dcp_hash_block_t blk;        /*!< memory buffer. only full blocks are written to DCP during hash updates */
     43              size_t blksz;                /*!< number of valid bytes in memory buffer */
     44              dcp_hash_algo_t algo;        /*!< selected algorithm from the set of supported algorithms */
     45              dcp_hash_algo_state_t state; /*!< finite machine state of the hash software process */
     46              uint32_t fullMessageSize;    /*!< track message size */
     47              uint32_t ctrl0;              /*!< HASH_INIT and HASH_TERM flags */
     48              uint32_t runningHash[9];     /*!< running hash. up to SHA-256 plus size, that is 36 bytes. */
     49              dcp_handle_t *handle;
     50          } dcp_hash_ctx_internal_t;
     51          
     52          /*!< SHA-1/SHA-2 digest length in bytes  */
     53          enum _dcp_hash_digest_len
     54          {
     55              kDCP_OutLenSha1   = 20u,
     56              kDCP_OutLenSha256 = 32u,
     57              kDCP_OutLenCrc32  = 4u,
     58          };
     59          
     60          enum _dcp_work_packet_bit_definitions
     61          {
     62              kDCP_CONTROL0_DECR_SEMAPHOR      = 1u << 1,  /* DECR_SEMAPHOR */
     63              kDCP_CONTROL0_ENABLE_HASH        = 1u << 6,  /* ENABLE_HASH */
     64              kDCP_CONTROL0_HASH_INIT          = 1u << 12, /* HASH_INIT */
     65              kDCP_CONTROL0_HASH_TERM          = 1u << 13, /* HASH_TERM */
     66              kDCP_CONTROL1_HASH_SELECT_SHA256 = 2u << 16,
     67              kDCP_CONTROL1_HASH_SELECT_SHA1   = 0u << 16,
     68              kDCP_CONTROL1_HASH_SELECT_CRC32  = 1u << 16,
     69          };
     70          
     71          /*! 64-byte block represented as byte array of 16 32-bit words */
     72          typedef union _dcp_sha_block
     73          {
     74              uint32_t w[64 / 4]; /*!< array of 32-bit words */
     75              uint8_t b[64];      /*!< byte array */
     76          } dcp_sha_block_t;
     77          
     78          #if defined(DCP_HASH_CAVP_COMPATIBLE)
     79          /* result of sha1 hash for message with zero size */

   \                                 In section .data, align 4
     80          static uint8_t s_nullSha1[] = {0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55,
   \                     s_nullSha1:
   \        0x0   0xDA 0x39          DC8 218, 57, 163, 238, 94, 107, 75, 13, 50, 85, 191, 239, 149, 96, 24
   \              0xA3 0xEE    
   \              0x5E 0x6B    
   \              0x4B 0x0D    
   \              0x32 0x55    
   \              0xBF 0xEF    
   \              0x95 0x60    
   \              0x18         
   \        0xF   0x90 0xAF          DC8 144, 175, 216, 7, 9
   \              0xD8 0x07    
   \              0x09         
     81                                         0xbf, 0xef, 0x95, 0x60, 0x18, 0x90, 0xaf, 0xd8, 0x07, 0x09};
     82          /* result of sha256 hash for message with zero size */

   \                                 In section .data, align 4
     83          static uint8_t s_nullSha256[] = {0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4,
   \                     s_nullSha256:
   \        0x0   0xE3 0xB0          DC8 227, 176, 196, 66, 152, 252, 28, 20, 154, 251, 244, 200, 153, 111
   \              0xC4 0x42    
   \              0x98 0xFC    
   \              0x1C 0x14    
   \              0x9A 0xFB    
   \              0xF4 0xC8    
   \              0x99 0x6F    
   \        0xE   0xB9 0x24          DC8 185, 36, 39, 174, 65, 228, 100, 155, 147, 76, 164, 149, 153, 27
   \              0x27 0xAE    
   \              0x41 0xE4    
   \              0x64 0x9B    
   \              0x93 0x4C    
   \              0xA4 0x95    
   \              0x99 0x1B    
   \       0x1C   0x78 0x52          DC8 120, 82, 184, 85
   \              0xB8 0x55    
     84                                           0xc8, 0x99, 0x6f, 0xb9, 0x24, 0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b,
     85                                           0x93, 0x4c, 0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55};
     86          #endif /* DCP_HASH_CAVP_COMPATIBLE */
     87          
     88          /*******************************************************************************
     89           * Variables
     90           ******************************************************************************/

   \                                 In section .bss, align 4
     91          static dcp_context_t s_dcpContextSwitchingBuffer;
   \                     s_dcpContextSwitchingBuffer:
   \        0x0                      DS8 208
     92          
     93          /*******************************************************************************
     94           * Code
     95           ******************************************************************************/
     96          

   \                                 In section .text, align 2, keep-with-next
     97          static void dcp_reverse_and_copy(uint8_t *src, uint8_t *dest, size_t src_len)
     98          {
   \                     dcp_reverse_and_copy: (+1)
   \        0x0   0xB410             PUSH     {R4}
     99              for (int i = 0; i < src_len; i++)
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0xE004             B.N      ??dcp_reverse_and_copy_0
    100              {
    101                  dest[i] = src[src_len - 1 - i];
   \                     ??dcp_reverse_and_copy_1: (+1)
   \        0x6   0x1E54             SUBS     R4,R2,#+1
   \        0x8   0x1AE4             SUBS     R4,R4,R3
   \        0xA   0x5D04             LDRB     R4,[R0, R4]
   \        0xC   0x54CC             STRB     R4,[R1, R3]
    102              }
   \        0xE   0x1C5B             ADDS     R3,R3,#+1
   \                     ??dcp_reverse_and_copy_0: (+1)
   \       0x10   0x4293             CMP      R3,R2
   \       0x12   0xD3F8             BCC.N    ??dcp_reverse_and_copy_1
    103          }
   \       0x14   0xBC10             POP      {R4}
   \       0x16   0x4770             BX       LR               ;; return
    104          

   \                                 In section .text, align 2, keep-with-next
    105          static status_t dcp_get_channel_status(DCP_Type *base, dcp_channel_t channel)
    106          {
   \                     dcp_get_channel_status: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x4602             MOV      R2,R0
    107              uint32_t statReg = 0;
   \        0x4   0x2300             MOVS     R3,#+0
    108              uint32_t semaReg = 0;
   \        0x6   0x461C             MOV      R4,R3
    109              status_t status  = kStatus_Fail;
   \        0x8   0x2001             MOVS     R0,#+1
    110          
    111              switch (channel)
   \        0xA   0xF5B1 0x3F80      CMP      R1,#+65536
   \        0xE   0xD009             BEQ.N    ??dcp_get_channel_status_0
   \       0x10   0xF5B1 0x3F00      CMP      R1,#+131072
   \       0x14   0xD00B             BEQ.N    ??dcp_get_channel_status_1
   \       0x16   0xF5B1 0x2F80      CMP      R1,#+262144
   \       0x1A   0xD00D             BEQ.N    ??dcp_get_channel_status_2
   \       0x1C   0xF5B1 0x2F00      CMP      R1,#+524288
   \       0x20   0xD00F             BEQ.N    ??dcp_get_channel_status_3
   \       0x22   0xE012             B.N      ??dcp_get_channel_status_4
    112              {
    113                  case kDCP_Channel0:
    114                      statReg = base->CH0STAT;
   \                     ??dcp_get_channel_status_0: (+1)
   \       0x24   0xF8D2 0x3120      LDR      R3,[R2, #+288]
    115                      semaReg = base->CH0SEMA;
   \       0x28   0xF8D2 0x4110      LDR      R4,[R2, #+272]
    116                      break;
   \       0x2C   0xE00D             B.N      ??dcp_get_channel_status_4
    117          
    118                  case kDCP_Channel1:
    119                      statReg = base->CH1STAT;
   \                     ??dcp_get_channel_status_1: (+1)
   \       0x2E   0xF8D2 0x3160      LDR      R3,[R2, #+352]
    120                      semaReg = base->CH1SEMA;
   \       0x32   0xF8D2 0x4150      LDR      R4,[R2, #+336]
    121                      break;
   \       0x36   0xE008             B.N      ??dcp_get_channel_status_4
    122          
    123                  case kDCP_Channel2:
    124                      statReg = base->CH2STAT;
   \                     ??dcp_get_channel_status_2: (+1)
   \       0x38   0xF8D2 0x31A0      LDR      R3,[R2, #+416]
    125                      semaReg = base->CH2SEMA;
   \       0x3C   0xF8D2 0x4190      LDR      R4,[R2, #+400]
    126                      break;
   \       0x40   0xE003             B.N      ??dcp_get_channel_status_4
    127          
    128                  case kDCP_Channel3:
    129                      statReg = base->CH3STAT;
   \                     ??dcp_get_channel_status_3: (+1)
   \       0x42   0xF8D2 0x31E0      LDR      R3,[R2, #+480]
    130                      semaReg = base->CH3SEMA;
   \       0x46   0xF8D2 0x41D0      LDR      R4,[R2, #+464]
    131                      break;
    132          
    133                  default:
    134                      break;
    135              }
    136          
    137              if (!((semaReg & DCP_CH0SEMA_VALUE_MASK) || (statReg & DCP_CH0STAT_ERROR_CODE_MASK)))
   \                     ??dcp_get_channel_status_4: (+1)
   \       0x4A   0xF414 0x0F7F      TST      R4,#0xFF0000
   \       0x4E   0xD103             BNE.N    ??dcp_get_channel_status_5
   \       0x50   0xF413 0x0F7F      TST      R3,#0xFF0000
   \       0x54   0xD100             BNE.N    ??dcp_get_channel_status_5
    138              {
    139                  status = kStatus_Success;
   \       0x56   0x2000             MOVS     R0,#+0
    140              }
    141          
    142              return status;
   \                     ??dcp_get_channel_status_5: (+1)
   \       0x58   0xBC10             POP      {R4}
   \       0x5A   0x4770             BX       LR               ;; return
    143          }
    144          

   \                                 In section .text, align 2, keep-with-next
    145          static void dcp_clear_status(DCP_Type *base)
    146          {
    147              volatile uint32_t *dcpStatClrPtr = &base->STAT + 2u;
    148              *dcpStatClrPtr                   = 0xFFu;
   \                     dcp_clear_status: (+1)
   \        0x0   0x21FF             MOVS     R1,#+255
   \        0x2   0x6181             STR      R1,[R0, #+24]
    149          }
   \        0x4   0x4770             BX       LR               ;; return
    150          

   \                                 In section .text, align 2, keep-with-next
    151          static void dcp_clear_channel_status(DCP_Type *base, uint32_t mask)
    152          {
    153              volatile uint32_t *chStatClrPtr;
    154          
    155              if (mask & kDCP_Channel0)
   \                     dcp_clear_channel_status: (+1)
   \        0x0   0x03CA             LSLS     R2,R1,#+15
   \        0x2   0xD502             BPL.N    ??dcp_clear_channel_status_0
    156              {
    157                  chStatClrPtr  = &base->CH0STAT + 2u;
    158                  *chStatClrPtr = 0xFFu;
   \        0x4   0x22FF             MOVS     R2,#+255
   \        0x6   0xF8C0 0x2128      STR      R2,[R0, #+296]
    159              }
    160              if (mask & kDCP_Channel1)
   \                     ??dcp_clear_channel_status_0: (+1)
   \        0xA   0x038A             LSLS     R2,R1,#+14
   \        0xC   0xD502             BPL.N    ??dcp_clear_channel_status_1
    161              {
    162                  chStatClrPtr  = &base->CH1STAT + 2u;
    163                  *chStatClrPtr = 0xFFu;
   \        0xE   0x22FF             MOVS     R2,#+255
   \       0x10   0xF8C0 0x2168      STR      R2,[R0, #+360]
    164              }
    165              if (mask & kDCP_Channel2)
   \                     ??dcp_clear_channel_status_1: (+1)
   \       0x14   0x034A             LSLS     R2,R1,#+13
   \       0x16   0xD502             BPL.N    ??dcp_clear_channel_status_2
    166              {
    167                  chStatClrPtr  = &base->CH2STAT + 2u;
    168                  *chStatClrPtr = 0xFFu;
   \       0x18   0x22FF             MOVS     R2,#+255
   \       0x1A   0xF8C0 0x21A8      STR      R2,[R0, #+424]
    169              }
    170              if (mask & kDCP_Channel3)
   \                     ??dcp_clear_channel_status_2: (+1)
   \       0x1E   0x0309             LSLS     R1,R1,#+12
   \       0x20   0xD502             BPL.N    ??dcp_clear_channel_status_3
    171              {
    172                  chStatClrPtr  = &base->CH3STAT + 2u;
    173                  *chStatClrPtr = 0xFFu;
   \       0x22   0x21FF             MOVS     R1,#+255
   \       0x24   0xF8C0 0x11E8      STR      R1,[R0, #+488]
    174              }
    175          }
   \                     ??dcp_clear_channel_status_3: (+1)
   \       0x28   0x4770             BX       LR               ;; return
    176          

   \                                 In section .text, align 2, keep-with-next
    177          static status_t dcp_aes_set_sram_based_key(DCP_Type *base, dcp_handle_t *handle, const uint8_t *key)
    178          {
   \                     dcp_aes_set_sram_based_key: (+1)
   \        0x0   0xB410             PUSH     {R4}
    179              base->KEY = DCP_KEY_INDEX(handle->keySlot) | DCP_KEY_SUBWORD(0);
   \        0x2   0x7909             LDRB     R1,[R1, #+4]
   \        0x4   0x0109             LSLS     R1,R1,#+4
   \        0x6   0xF001 0x0130      AND      R1,R1,#0x30
   \        0xA   0x6601             STR      R1,[R0, #+96]
    180              /* move the key by 32-bit words */
    181              int i          = 0;
   \        0xC   0x2300             MOVS     R3,#+0
    182              size_t keySize = 16u;
   \        0xE   0x2110             MOVS     R1,#+16
   \       0x10   0xE004             B.N      ??dcp_aes_set_sram_based_key_0
    183              while (keySize)
    184              {
    185                  keySize -= sizeof(uint32_t);
   \                     ??dcp_aes_set_sram_based_key_1: (+1)
   \       0x12   0x1F09             SUBS     R1,R1,#+4
    186                  base->KEYDATA = ((uint32_t *)(uintptr_t)key)[i];
   \       0x14   0xF852 0x4023      LDR      R4,[R2, R3, LSL #+2]
   \       0x18   0x6704             STR      R4,[R0, #+112]
    187                  i++;
   \       0x1A   0x1C5B             ADDS     R3,R3,#+1
    188              }
   \                     ??dcp_aes_set_sram_based_key_0: (+1)
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD1F8             BNE.N    ??dcp_aes_set_sram_based_key_1
    189              return kStatus_Success;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBC10             POP      {R4}
   \       0x24   0x4770             BX       LR               ;; return
    190          }
    191          

   \                                 In section .text, align 2, keep-with-next
    192          static status_t dcp_schedule_work(DCP_Type *base, dcp_handle_t *handle, dcp_work_packet_t *dcpPacket)
    193          {
   \                     dcp_schedule_work: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    194              status_t status;
    195          
    196              /* check if our channel is active */
    197              if ((base->STAT & (uint32_t)handle->channel) != handle->channel)
   \        0x8   0x6921             LDR      R1,[R4, #+16]
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x4001             ANDS     R1,R0,R1
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xD037             BEQ.N    ??dcp_schedule_work_0
    198              {
    199                  /* disable global interrupt */
    200                  uint32_t currPriMask = DisableGlobalIRQ();
   \       0x12   0x....'....        BL       DisableGlobalIRQ
    201          
    202                  /* re-check if our channel is still available */
    203                  if ((base->STAT & (uint32_t)handle->channel) == 0)
   \       0x16   0x6921             LDR      R1,[R4, #+16]
   \       0x18   0x682A             LDR      R2,[R5, #+0]
   \       0x1A   0x4211             TST      R1,R2
   \       0x1C   0xD12B             BNE.N    ??dcp_schedule_work_1
    204                  {
    205                      volatile uint32_t *cmdptr = NULL;
   \       0x1E   0x2200             MOVS     R2,#+0
    206                      volatile uint32_t *chsema = NULL;
   \       0x20   0x4611             MOV      R1,R2
    207          
    208                      switch (handle->channel)
   \       0x22   0x682B             LDR      R3,[R5, #+0]
   \       0x24   0xF5B3 0x3F80      CMP      R3,#+65536
   \       0x28   0xD009             BEQ.N    ??dcp_schedule_work_2
   \       0x2A   0xF5B3 0x3F00      CMP      R3,#+131072
   \       0x2E   0xD00B             BEQ.N    ??dcp_schedule_work_3
   \       0x30   0xF5B3 0x2F80      CMP      R3,#+262144
   \       0x34   0xD00D             BEQ.N    ??dcp_schedule_work_4
   \       0x36   0xF5B3 0x2F00      CMP      R3,#+524288
   \       0x3A   0xD00F             BEQ.N    ??dcp_schedule_work_5
   \       0x3C   0xE012             B.N      ??dcp_schedule_work_6
    209                      {
    210                          case kDCP_Channel0:
    211                              cmdptr = &base->CH0CMDPTR;
   \                     ??dcp_schedule_work_2: (+1)
   \       0x3E   0xF504 0x7280      ADD      R2,R4,#+256
    212                              chsema = &base->CH0SEMA;
   \       0x42   0xF504 0x7188      ADD      R1,R4,#+272
    213                              break;
   \       0x46   0xE00D             B.N      ??dcp_schedule_work_6
    214          
    215                          case kDCP_Channel1:
    216                              cmdptr = &base->CH1CMDPTR;
   \                     ??dcp_schedule_work_3: (+1)
   \       0x48   0xF504 0x72A0      ADD      R2,R4,#+320
    217                              chsema = &base->CH1SEMA;
   \       0x4C   0xF504 0x71A8      ADD      R1,R4,#+336
    218                              break;
   \       0x50   0xE008             B.N      ??dcp_schedule_work_6
    219          
    220                          case kDCP_Channel2:
    221                              cmdptr = &base->CH2CMDPTR;
   \                     ??dcp_schedule_work_4: (+1)
   \       0x52   0xF504 0x72C0      ADD      R2,R4,#+384
    222                              chsema = &base->CH2SEMA;
   \       0x56   0xF504 0x71C8      ADD      R1,R4,#+400
    223                              break;
   \       0x5A   0xE003             B.N      ??dcp_schedule_work_6
    224          
    225                          case kDCP_Channel3:
    226                              cmdptr = &base->CH3CMDPTR;
   \                     ??dcp_schedule_work_5: (+1)
   \       0x5C   0xF504 0x72E0      ADD      R2,R4,#+448
    227                              chsema = &base->CH3SEMA;
   \       0x60   0xF504 0x71E8      ADD      R1,R4,#+464
    228                              break;
    229          
    230                          default:
    231                              break;
    232                      }
    233          
    234                      if (cmdptr && chsema)
   \                     ??dcp_schedule_work_6: (+1)
   \       0x64   0x2A00             CMP      R2,#+0
   \       0x66   0xD004             BEQ.N    ??dcp_schedule_work_7
   \       0x68   0x2900             CMP      R1,#+0
   \       0x6A   0xD002             BEQ.N    ??dcp_schedule_work_7
    235                      {
    236                          /* set out packet to DCP CMDPTR */
    237                          *cmdptr = (uint32_t)dcpPacket;
   \       0x6C   0x6016             STR      R6,[R2, #+0]
    238          
    239                          /* set the channel semaphore */
    240                          *chsema = 1u;
   \       0x6E   0x2201             MOVS     R2,#+1
   \       0x70   0x600A             STR      R2,[R1, #+0]
    241                      }
    242          
    243                      status = kStatus_Success;
   \                     ??dcp_schedule_work_7: (+1)
   \       0x72   0x2400             MOVS     R4,#+0
   \       0x74   0xE001             B.N      ??dcp_schedule_work_8
    244                  }
    245          
    246                  else
    247                  {
    248                      status = kStatus_DCP_Again;
   \                     ??dcp_schedule_work_1: (+1)
   \       0x76   0xF641 0x242C      MOVW     R4,#+6700
    249                  }
    250                  /* global interrupt enable */
    251                  EnableGlobalIRQ(currPriMask);
   \                     ??dcp_schedule_work_8: (+1)
   \       0x7A   0x....'....        BL       EnableGlobalIRQ
    252              }
    253          
    254              else
    255              {
    256                  return kStatus_DCP_Again;
    257              }
    258          
    259              return status;
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0xBD70             POP      {R4-R6,PC}
   \                     ??dcp_schedule_work_0: (+1)
   \       0x82   0xF641 0x202C      MOVW     R0,#+6700
   \       0x86   0xBD70             POP      {R4-R6,PC}       ;; return
    260          }
    261          
    262          /*!
    263           * brief Set AES key to dcp_handle_t struct and optionally to DCP.
    264           *
    265           * Sets the AES key for encryption/decryption with the dcp_handle_t structure.
    266           * The dcp_handle_t input argument specifies keySlot.
    267           * If the keySlot is kDCP_OtpKey, the function will check the OTP_KEY_READY bit and will return it's ready to use
    268           * status.
    269           * For other keySlot selections, the function will copy and hold the key in dcp_handle_t struct.
    270           * If the keySlot is one of the four DCP SRAM-based keys (one of kDCP_KeySlot0, kDCP_KeySlot1, kDCP_KeySlot2,
    271           * kDCP_KeySlot3),
    272           * this function will also load the supplied key to the specified keySlot in DCP.
    273           *
    274           * param   base DCP peripheral base address.
    275           * param   handle Handle used for the request.
    276           * param   key 0-mod-4 aligned pointer to AES key.
    277           * param   keySize AES key size in bytes. Shall equal 16.
    278           * return  status from set key operation
    279           */

   \                                 In section .text, align 2, keep-with-next
    280          status_t DCP_AES_SetKey(DCP_Type *base, dcp_handle_t *handle, const uint8_t *key, size_t keySize)
    281          {
   \                     DCP_AES_SetKey: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    282              status_t status = kStatus_Fail;
   \        0x2   0x2401             MOVS     R4,#+1
    283          
    284              if ((kDCP_OtpKey == handle->keySlot) || (kDCP_OtpUniqueKey == handle->keySlot))
   \        0x4   0x790D             LDRB     R5,[R1, #+4]
   \        0x6   0x2D04             CMP      R5,#+4
   \        0x8   0xD001             BEQ.N    ??DCP_AES_SetKey_0
   \        0xA   0x2D05             CMP      R5,#+5
   \        0xC   0xD104             BNE.N    ??DCP_AES_SetKey_1
    285              {
    286                  /* for AES OTP and unique key, check and return read from fuses status */
    287                  if ((base->STAT & DCP_STAT_OTP_KEY_READY_MASK) == DCP_STAT_OTP_KEY_READY_MASK)
   \                     ??DCP_AES_SetKey_0: (+1)
   \        0xE   0x6900             LDR      R0,[R0, #+16]
   \       0x10   0x00C0             LSLS     R0,R0,#+3
   \       0x12   0xD51B             BPL.N    ??DCP_AES_SetKey_2
    288                  {
    289                      status = kStatus_Success;
   \       0x14   0x2400             MOVS     R4,#+0
   \       0x16   0xE019             B.N      ??DCP_AES_SetKey_2
    290                  }
    291              }
    292              else
    293              {
    294                  /* only work with aligned key[] */
    295                  if (0x3U & (uintptr_t)key)
   \                     ??DCP_AES_SetKey_1: (+1)
   \       0x18   0xF012 0x0403      ANDS     R4,R2,#0x3
   \       0x1C   0xD101             BNE.N    ??DCP_AES_SetKey_3
    296                  {
    297                      return kStatus_InvalidArgument;
    298                  }
    299          
    300                  /* keySize must be 16. */
    301                  if (keySize != 16U)
   \       0x1E   0x2B10             CMP      R3,#+16
   \       0x20   0xD001             BEQ.N    ??DCP_AES_SetKey_4
    302                  {
    303                      return kStatus_InvalidArgument;
   \                     ??DCP_AES_SetKey_3: (+1)
   \       0x22   0x2004             MOVS     R0,#+4
   \       0x24   0xBD70             POP      {R4-R6,PC}
    304                  }
    305          
    306                  /* move the key by 32-bit words */
    307                  int i = 0;
   \                     ??DCP_AES_SetKey_4: (+1)
   \       0x26   0x2400             MOVS     R4,#+0
   \       0x28   0xE006             B.N      ??DCP_AES_SetKey_5
    308                  while (keySize)
    309                  {
    310                      keySize -= sizeof(uint32_t);
   \                     ??DCP_AES_SetKey_6: (+1)
   \       0x2A   0x1F1B             SUBS     R3,R3,#+4
    311                      handle->keyWord[i] = ((uint32_t *)(uintptr_t)key)[i];
   \       0x2C   0xF852 0x5024      LDR      R5,[R2, R4, LSL #+2]
   \       0x30   0xEB01 0x0684      ADD      R6,R1,R4, LSL #+2
   \       0x34   0x60F5             STR      R5,[R6, #+12]
    312                      i++;
   \       0x36   0x1C64             ADDS     R4,R4,#+1
    313                  }
   \                     ??DCP_AES_SetKey_5: (+1)
   \       0x38   0x2B00             CMP      R3,#+0
   \       0x3A   0xD1F6             BNE.N    ??DCP_AES_SetKey_6
    314          
    315                  if (kDCP_PayloadKey != handle->keySlot)
   \       0x3C   0x790B             LDRB     R3,[R1, #+4]
   \       0x3E   0x2B06             CMP      R3,#+6
   \       0x40   0xD003             BEQ.N    ??DCP_AES_SetKey_7
    316                  {
    317                      /* move the key by 32-bit words to DCP SRAM-based key storage */
    318                      status = dcp_aes_set_sram_based_key(base, handle, key);
   \       0x42   0x....'....        BL       dcp_aes_set_sram_based_key
   \       0x46   0x4604             MOV      R4,R0
   \       0x48   0xE000             B.N      ??DCP_AES_SetKey_2
    319                  }
    320                  else
    321                  {
    322                      /* for PAYLOAD_KEY, just return Ok status now */
    323                      status = kStatus_Success;
   \                     ??DCP_AES_SetKey_7: (+1)
   \       0x4A   0x2400             MOVS     R4,#+0
    324                  }
    325              }
    326          
    327              return status;
   \                     ??DCP_AES_SetKey_2: (+1)
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0xBD70             POP      {R4-R6,PC}       ;; return
    328          }
    329          
    330          /*!
    331           * brief Encrypts AES on one or multiple 128-bit block(s).
    332           *
    333           * Encrypts AES.
    334           * The source plaintext and destination ciphertext can overlap in system memory.
    335           *
    336           * param base DCP peripheral base address
    337           * param handle Handle used for this request.
    338           * param plaintext Input plain text to encrypt
    339           * param[out] ciphertext Output cipher text
    340           * param size Size of input and output data in bytes. Must be multiple of 16 bytes.
    341           * return Status from encrypt operation
    342           */

   \                                 In section .text, align 2, keep-with-next
    343          status_t DCP_AES_EncryptEcb(
    344              DCP_Type *base, dcp_handle_t *handle, const uint8_t *plaintext, uint8_t *ciphertext, size_t size)
    345          {
   \                     DCP_AES_EncryptEcb: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4617             MOV      R7,R2
   \        0xC   0x461E             MOV      R6,R3
   \        0xE   0xF8DD 0x8040      LDR      R8,[SP, #+64]
    346              status_t completionStatus = kStatus_Fail;
    347              dcp_work_packet_t dcpWork = {0};
   \       0x12   0xA802             ADD      R0,SP,#+8
   \       0x14   0x2120             MOVS     R1,#+32
   \       0x16   0x....'....        BL       __aeabi_memclr4
    348          
    349              do
    350              {
    351                  completionStatus = DCP_AES_EncryptEcbNonBlocking(base, handle, &dcpWork, plaintext, ciphertext, size);
   \                     ??DCP_AES_EncryptEcb_0: (+1)
   \       0x1A   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x1E   0x9600             STR      R6,[SP, #+0]
   \       0x20   0x463B             MOV      R3,R7
   \       0x22   0xAA02             ADD      R2,SP,#+8
   \       0x24   0x4629             MOV      R1,R5
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       DCP_AES_EncryptEcbNonBlocking
    352              } while (completionStatus == kStatus_DCP_Again);
   \       0x2C   0xF641 0x212C      MOVW     R1,#+6700
   \       0x30   0x4288             CMP      R0,R1
   \       0x32   0xD0F2             BEQ.N    ??DCP_AES_EncryptEcb_0
    353          
    354              if (completionStatus != kStatus_Success)
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD103             BNE.N    ??DCP_AES_EncryptEcb_1
    355              {
    356                  return completionStatus;
    357              }
    358          
    359              return DCP_WaitForChannelComplete(base, handle);
   \       0x38   0x4629             MOV      R1,R5
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x....'....        BL       DCP_WaitForChannelComplete
   \                     ??DCP_AES_EncryptEcb_1: (+1)
   \       0x40   0xB00A             ADD      SP,SP,#+40
   \       0x42   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    360          }
    361          
    362          /*!
    363           * brief Encrypts AES using the ECB block mode.
    364           *
    365           * Puts AES ECB encrypt work packet to DCP channel.
    366           *
    367           * param base DCP peripheral base address
    368           * param handle Handle used for this request.
    369           * param[out] dcpPacket Memory for the DCP work packet.
    370           * param plaintext Input plain text to encrypt.
    371           * param[out] ciphertext Output cipher text
    372           * param size Size of input and output data in bytes. Must be multiple of 16 bytes.
    373           * return kStatus_Success The work packet has been scheduled at DCP channel.
    374           * return kStatus_DCP_Again The DCP channel is busy processing previous request.
    375           */

   \                                 In section .text, align 2, keep-with-next
    376          status_t DCP_AES_EncryptEcbNonBlocking(DCP_Type *base,
    377                                                 dcp_handle_t *handle,
    378                                                 dcp_work_packet_t *dcpPacket,
    379                                                 const uint8_t *plaintext,
    380                                                 uint8_t *ciphertext,
    381                                                 size_t size)
    382          {
   \                     DCP_AES_EncryptEcbNonBlocking: (+1)
   \        0x0   0xB478             PUSH     {R3-R6}
   \        0x2   0x9D05             LDR      R5,[SP, #+20]
    383              /* Size must be 16-byte multiple */
    384              if ((size < 16u) || (size % 16u))
   \        0x4   0x2D10             CMP      R5,#+16
   \        0x6   0xD302             BCC.N    ??DCP_AES_EncryptEcbNonBlocking_0
   \        0x8   0xF015 0x0F0F      TST      R5,#0xF
   \        0xC   0xD001             BEQ.N    ??DCP_AES_EncryptEcbNonBlocking_1
    385              {
    386                  return kStatus_InvalidArgument;
   \                     ??DCP_AES_EncryptEcbNonBlocking_0: (+1)
   \        0xE   0x2004             MOVS     R0,#+4
   \       0x10   0xE02C             B.N      ??DCP_AES_EncryptEcbNonBlocking_2
    387              }
   \                     ??DCP_AES_EncryptEcbNonBlocking_1: (+1)
   \       0x12   0x9C04             LDR      R4,[SP, #+16]
    388          
    389              dcpPacket->control0 =
    390                  0x122u | (handle->swapConfig & 0xFC0000u); /* CIPHER_ENCRYPT | ENABLE_CIPHER | DECR_SEMAPHORE */
   \       0x14   0x688E             LDR      R6,[R1, #+8]
   \       0x16   0xF406 0x067C      AND      R6,R6,#0xFC0000
   \       0x1A   0xF446 0x7691      ORR      R6,R6,#0x122
   \       0x1E   0x6056             STR      R6,[R2, #+4]
    391              dcpPacket->sourceBufferAddress      = (uint32_t)plaintext;
   \       0x20   0x60D3             STR      R3,[R2, #+12]
    392              dcpPacket->destinationBufferAddress = (uint32_t)ciphertext;
   \       0x22   0x6114             STR      R4,[R2, #+16]
    393              dcpPacket->bufferSize               = (uint32_t)size;
   \       0x24   0x6155             STR      R5,[R2, #+20]
    394          
    395              if (handle->keySlot == kDCP_OtpKey)
   \       0x26   0x790B             LDRB     R3,[R1, #+4]
   \       0x28   0x2B04             CMP      R3,#+4
   \       0x2A   0xD107             BNE.N    ??DCP_AES_EncryptEcbNonBlocking_3
    396              {
    397                  dcpPacket->control0 |= (1u << 10);  /* OTP_KEY */
   \       0x2C   0x6853             LDR      R3,[R2, #+4]
   \       0x2E   0xF443 0x6380      ORR      R3,R3,#0x400
   \       0x32   0x6053             STR      R3,[R2, #+4]
    398                  dcpPacket->control1 = (0xFFu << 8); /* KEY_SELECT = OTP_KEY */
   \       0x34   0xF44F 0x437F      MOV      R3,#+65280
   \       0x38   0x6093             STR      R3,[R2, #+8]
   \       0x3A   0xE015             B.N      ??DCP_AES_EncryptEcbNonBlocking_4
    399              }
    400              else if (handle->keySlot == kDCP_OtpUniqueKey)
   \                     ??DCP_AES_EncryptEcbNonBlocking_3: (+1)
   \       0x3C   0x2B05             CMP      R3,#+5
   \       0x3E   0xD107             BNE.N    ??DCP_AES_EncryptEcbNonBlocking_5
    401              {
    402                  dcpPacket->control0 |= (1u << 10);  /* OTP_KEY */
   \       0x40   0x6853             LDR      R3,[R2, #+4]
   \       0x42   0xF443 0x6380      ORR      R3,R3,#0x400
   \       0x46   0x6053             STR      R3,[R2, #+4]
    403                  dcpPacket->control1 = (0xFEu << 8); /* KEY_SELECT = UNIQUE_KEY */
   \       0x48   0xF44F 0x437E      MOV      R3,#+65024
   \       0x4C   0x6093             STR      R3,[R2, #+8]
   \       0x4E   0xE00B             B.N      ??DCP_AES_EncryptEcbNonBlocking_4
    404              }
    405              else if (handle->keySlot == kDCP_PayloadKey)
   \                     ??DCP_AES_EncryptEcbNonBlocking_5: (+1)
   \       0x50   0x2B06             CMP      R3,#+6
   \       0x52   0xD107             BNE.N    ??DCP_AES_EncryptEcbNonBlocking_6
    406              {
    407                  /* ECB does not have IV, so we can point payload directly to keyWord[] stored in handle. */
    408                  dcpPacket->payloadPointer = (uint32_t)&handle->keyWord[0];
   \       0x54   0xF101 0x030C      ADD      R3,R1,#+12
   \       0x58   0x6193             STR      R3,[R2, #+24]
    409                  dcpPacket->control0 |= (1u << 11); /* PAYLOAD_KEY */
   \       0x5A   0x6853             LDR      R3,[R2, #+4]
   \       0x5C   0xF443 0x6300      ORR      R3,R3,#0x800
   \       0x60   0x6053             STR      R3,[R2, #+4]
   \       0x62   0xE001             B.N      ??DCP_AES_EncryptEcbNonBlocking_4
    410              }
    411              else
    412              {
    413                  dcpPacket->control1 = (handle->keySlot << 8); /* KEY_SELECT = keySlot */
   \                     ??DCP_AES_EncryptEcbNonBlocking_6: (+1)
   \       0x64   0x021B             LSLS     R3,R3,#+8
   \       0x66   0x6093             STR      R3,[R2, #+8]
    414              }
    415          
    416              return dcp_schedule_work(base, handle, dcpPacket);
   \                     ??DCP_AES_EncryptEcbNonBlocking_4: (+1)
   \       0x68   0xBC78             POP      {R3-R6}
   \       0x6A   0x....             B.N      dcp_schedule_work
   \                     ??DCP_AES_EncryptEcbNonBlocking_2: (+1)
   \       0x6C   0xBC72             POP      {R1,R4-R6}
   \       0x6E   0x4770             BX       LR               ;; return
    417          }
    418          
    419          /*!
    420           * brief Decrypts AES on one or multiple 128-bit block(s).
    421           *
    422           * Decrypts AES.
    423           * The source ciphertext and destination plaintext can overlap in system memory.
    424           *
    425           * param base DCP peripheral base address
    426           * param handle Handle used for this request.
    427           * param ciphertext Input plain text to encrypt
    428           * param[out] plaintext Output cipher text
    429           * param size Size of input and output data in bytes. Must be multiple of 16 bytes.
    430           * return Status from decrypt operation
    431           */

   \                                 In section .text, align 2, keep-with-next
    432          status_t DCP_AES_DecryptEcb(
    433              DCP_Type *base, dcp_handle_t *handle, const uint8_t *ciphertext, uint8_t *plaintext, size_t size)
    434          {
   \                     DCP_AES_DecryptEcb: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4617             MOV      R7,R2
   \        0xC   0x461E             MOV      R6,R3
   \        0xE   0xF8DD 0x8040      LDR      R8,[SP, #+64]
    435              status_t completionStatus = kStatus_Fail;
    436              dcp_work_packet_t dcpWork = {0};
   \       0x12   0xA802             ADD      R0,SP,#+8
   \       0x14   0x2120             MOVS     R1,#+32
   \       0x16   0x....'....        BL       __aeabi_memclr4
    437          
    438              do
    439              {
    440                  completionStatus = DCP_AES_DecryptEcbNonBlocking(base, handle, &dcpWork, ciphertext, plaintext, size);
   \                     ??DCP_AES_DecryptEcb_0: (+1)
   \       0x1A   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x1E   0x9600             STR      R6,[SP, #+0]
   \       0x20   0x463B             MOV      R3,R7
   \       0x22   0xAA02             ADD      R2,SP,#+8
   \       0x24   0x4629             MOV      R1,R5
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       DCP_AES_DecryptEcbNonBlocking
    441              } while (completionStatus == kStatus_DCP_Again);
   \       0x2C   0xF641 0x212C      MOVW     R1,#+6700
   \       0x30   0x4288             CMP      R0,R1
   \       0x32   0xD0F2             BEQ.N    ??DCP_AES_DecryptEcb_0
    442          
    443              if (completionStatus != kStatus_Success)
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD103             BNE.N    ??DCP_AES_DecryptEcb_1
    444              {
    445                  return completionStatus;
    446              }
    447          
    448              return DCP_WaitForChannelComplete(base, handle);
   \       0x38   0x4629             MOV      R1,R5
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x....'....        BL       DCP_WaitForChannelComplete
   \                     ??DCP_AES_DecryptEcb_1: (+1)
   \       0x40   0xB00A             ADD      SP,SP,#+40
   \       0x42   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    449          }
    450          
    451          /*!
    452           * brief Decrypts AES using ECB block mode.
    453           *
    454           * Puts AES ECB decrypt dcpPacket to DCP input job ring.
    455           *
    456           * param base DCP peripheral base address
    457           * param handle Handle used for this request.
    458           * param[out] dcpPacket Memory for the DCP work packet.
    459           * param ciphertext Input cipher text to decrypt
    460           * param[out] plaintext Output plain text
    461           * param size Size of input and output data in bytes. Must be multiple of 16 bytes.
    462           * return kStatus_Success The work packet has been scheduled at DCP channel.
    463           * return kStatus_DCP_Again The DCP channel is busy processing previous request.
    464           */

   \                                 In section .text, align 2, keep-with-next
    465          status_t DCP_AES_DecryptEcbNonBlocking(DCP_Type *base,
    466                                                 dcp_handle_t *handle,
    467                                                 dcp_work_packet_t *dcpPacket,
    468                                                 const uint8_t *ciphertext,
    469                                                 uint8_t *plaintext,
    470                                                 size_t size)
    471          {
   \                     DCP_AES_DecryptEcbNonBlocking: (+1)
   \        0x0   0xB478             PUSH     {R3-R6}
   \        0x2   0x9D05             LDR      R5,[SP, #+20]
    472              /* Size must be 16-byte multiple */
    473              if ((size < 16u) || (size % 16u))
   \        0x4   0x2D10             CMP      R5,#+16
   \        0x6   0xD302             BCC.N    ??DCP_AES_DecryptEcbNonBlocking_0
   \        0x8   0xF015 0x0F0F      TST      R5,#0xF
   \        0xC   0xD001             BEQ.N    ??DCP_AES_DecryptEcbNonBlocking_1
    474              {
    475                  return kStatus_InvalidArgument;
   \                     ??DCP_AES_DecryptEcbNonBlocking_0: (+1)
   \        0xE   0x2004             MOVS     R0,#+4
   \       0x10   0xE02C             B.N      ??DCP_AES_DecryptEcbNonBlocking_2
    476              }
   \                     ??DCP_AES_DecryptEcbNonBlocking_1: (+1)
   \       0x12   0x9C04             LDR      R4,[SP, #+16]
    477          
    478              dcpPacket->control0                 = 0x22u | (handle->swapConfig & 0xFC0000u); /* ENABLE_CIPHER | DECR_SEMAPHORE */
   \       0x14   0x688E             LDR      R6,[R1, #+8]
   \       0x16   0xF406 0x067C      AND      R6,R6,#0xFC0000
   \       0x1A   0xF046 0x0622      ORR      R6,R6,#0x22
   \       0x1E   0x6056             STR      R6,[R2, #+4]
    479              dcpPacket->sourceBufferAddress      = (uint32_t)ciphertext;
   \       0x20   0x60D3             STR      R3,[R2, #+12]
    480              dcpPacket->destinationBufferAddress = (uint32_t)plaintext;
   \       0x22   0x6114             STR      R4,[R2, #+16]
    481              dcpPacket->bufferSize               = (uint32_t)size;
   \       0x24   0x6155             STR      R5,[R2, #+20]
    482          
    483              if (handle->keySlot == kDCP_OtpKey)
   \       0x26   0x790B             LDRB     R3,[R1, #+4]
   \       0x28   0x2B04             CMP      R3,#+4
   \       0x2A   0xD107             BNE.N    ??DCP_AES_DecryptEcbNonBlocking_3
    484              {
    485                  dcpPacket->control0 |= (1u << 10);  /* OTP_KEY */
   \       0x2C   0x6853             LDR      R3,[R2, #+4]
   \       0x2E   0xF443 0x6380      ORR      R3,R3,#0x400
   \       0x32   0x6053             STR      R3,[R2, #+4]
    486                  dcpPacket->control1 = (0xFFu << 8); /* KEY_SELECT = OTP_KEY */
   \       0x34   0xF44F 0x437F      MOV      R3,#+65280
   \       0x38   0x6093             STR      R3,[R2, #+8]
   \       0x3A   0xE015             B.N      ??DCP_AES_DecryptEcbNonBlocking_4
    487              }
    488              else if (handle->keySlot == kDCP_OtpUniqueKey)
   \                     ??DCP_AES_DecryptEcbNonBlocking_3: (+1)
   \       0x3C   0x2B05             CMP      R3,#+5
   \       0x3E   0xD107             BNE.N    ??DCP_AES_DecryptEcbNonBlocking_5
    489              {
    490                  dcpPacket->control0 |= (1u << 10);  /* OTP_KEY */
   \       0x40   0x6853             LDR      R3,[R2, #+4]
   \       0x42   0xF443 0x6380      ORR      R3,R3,#0x400
   \       0x46   0x6053             STR      R3,[R2, #+4]
    491                  dcpPacket->control1 = (0xFEu << 8); /* KEY_SELECT = UNIQUE_KEY */
   \       0x48   0xF44F 0x437E      MOV      R3,#+65024
   \       0x4C   0x6093             STR      R3,[R2, #+8]
   \       0x4E   0xE00B             B.N      ??DCP_AES_DecryptEcbNonBlocking_4
    492              }
    493              else if (handle->keySlot == kDCP_PayloadKey)
   \                     ??DCP_AES_DecryptEcbNonBlocking_5: (+1)
   \       0x50   0x2B06             CMP      R3,#+6
   \       0x52   0xD107             BNE.N    ??DCP_AES_DecryptEcbNonBlocking_6
    494              {
    495                  /* ECB does not have IV, so we can point payload directly to keyWord[] stored in handle. */
    496                  dcpPacket->payloadPointer = (uint32_t)&handle->keyWord[0];
   \       0x54   0xF101 0x030C      ADD      R3,R1,#+12
   \       0x58   0x6193             STR      R3,[R2, #+24]
    497                  dcpPacket->control0 |= (1u << 11); /* PAYLOAD_KEY */
   \       0x5A   0x6853             LDR      R3,[R2, #+4]
   \       0x5C   0xF443 0x6300      ORR      R3,R3,#0x800
   \       0x60   0x6053             STR      R3,[R2, #+4]
   \       0x62   0xE001             B.N      ??DCP_AES_DecryptEcbNonBlocking_4
    498              }
    499              else
    500              {
    501                  dcpPacket->control1 = (handle->keySlot << 8); /* KEY_SELECT = keySlot */
   \                     ??DCP_AES_DecryptEcbNonBlocking_6: (+1)
   \       0x64   0x021B             LSLS     R3,R3,#+8
   \       0x66   0x6093             STR      R3,[R2, #+8]
    502              }
    503          
    504              return dcp_schedule_work(base, handle, dcpPacket);
   \                     ??DCP_AES_DecryptEcbNonBlocking_4: (+1)
   \       0x68   0xBC78             POP      {R3-R6}
   \       0x6A   0x....             B.N      dcp_schedule_work
   \                     ??DCP_AES_DecryptEcbNonBlocking_2: (+1)
   \       0x6C   0xBC72             POP      {R1,R4-R6}
   \       0x6E   0x4770             BX       LR               ;; return
    505          }
    506          
    507          /*!
    508           * brief Encrypts AES using CBC block mode.
    509           *
    510           * Encrypts AES using CBC block mode.
    511           * The source plaintext and destination ciphertext can overlap in system memory.
    512           *
    513           * param base DCP peripheral base address
    514           * param handle Handle used for this request.
    515           * param plaintext Input plain text to encrypt
    516           * param[out] ciphertext Output cipher text
    517           * param size Size of input and output data in bytes. Must be multiple of 16 bytes.
    518           * param iv Input initial vector to combine with the first input block.
    519           * return Status from encrypt operation
    520           */

   \                                 In section .text, align 2, keep-with-next
    521          status_t DCP_AES_EncryptCbc(DCP_Type *base,
    522                                      dcp_handle_t *handle,
    523                                      const uint8_t *plaintext,
    524                                      uint8_t *ciphertext,
    525                                      size_t size,
    526                                      const uint8_t iv[16])
    527          {
   \                     DCP_AES_EncryptCbc: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x461F             MOV      R7,R3
   \        0xE   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \       0x12   0xF8DD 0x904C      LDR      R9,[SP, #+76]
    528              status_t completionStatus = kStatus_Fail;
    529              dcp_work_packet_t dcpWork = {0};
   \       0x16   0xA803             ADD      R0,SP,#+12
   \       0x18   0x2120             MOVS     R1,#+32
   \       0x1A   0x....'....        BL       __aeabi_memclr4
    530          
    531              do
    532              {
    533                  completionStatus = DCP_AES_EncryptCbcNonBlocking(base, handle, &dcpWork, plaintext, ciphertext, size, iv);
   \                     ??DCP_AES_EncryptCbc_0: (+1)
   \       0x1E   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0x22   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x26   0x9700             STR      R7,[SP, #+0]
   \       0x28   0x4633             MOV      R3,R6
   \       0x2A   0xAA03             ADD      R2,SP,#+12
   \       0x2C   0x4629             MOV      R1,R5
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       DCP_AES_EncryptCbcNonBlocking
    534              } while (completionStatus == kStatus_DCP_Again);
   \       0x34   0xF641 0x212C      MOVW     R1,#+6700
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD0F0             BEQ.N    ??DCP_AES_EncryptCbc_0
   \       0x3C   0x4629             MOV      R1,R5
    535          
    536              if (completionStatus != kStatus_Success)
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD102             BNE.N    ??DCP_AES_EncryptCbc_1
    537              {
    538                  return completionStatus;
    539              }
    540          
    541              return DCP_WaitForChannelComplete(base, handle);
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0x....'....        BL       DCP_WaitForChannelComplete
   \                     ??DCP_AES_EncryptCbc_1: (+1)
   \       0x48   0xB00B             ADD      SP,SP,#+44
   \       0x4A   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    542          }
    543          
    544          /*!
    545           * brief Encrypts AES using CBC block mode.
    546           *
    547           * Puts AES CBC encrypt dcpPacket to DCP input job ring.
    548           *
    549           * param base DCP peripheral base address
    550           * param handle Handle used for this request. Specifies jobRing.
    551           * param[out] dcpPacket Memory for the DCP work packet.
    552           * param plaintext Input plain text to encrypt
    553           * param[out] ciphertext Output cipher text
    554           * param size Size of input and output data in bytes. Must be multiple of 16 bytes.
    555           * param iv Input initial vector to combine with the first input block.
    556           * return kStatus_Success The work packet has been scheduled at DCP channel.
    557           * return kStatus_DCP_Again The DCP channel is busy processing previous request.
    558           */

   \                                 In section .text, align 2, keep-with-next
    559          status_t DCP_AES_EncryptCbcNonBlocking(DCP_Type *base,
    560                                                 dcp_handle_t *handle,
    561                                                 dcp_work_packet_t *dcpPacket,
    562                                                 const uint8_t *plaintext,
    563                                                 uint8_t *ciphertext,
    564                                                 size_t size,
    565                                                 const uint8_t *iv)
    566          {
   \                     DCP_AES_EncryptCbcNonBlocking: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x9A07             LDR      R2,[SP, #+28]
    567              /* Size must be 16-byte multiple */
    568              if ((size < 16u) || (size % 16u))
   \        0xA   0x2A10             CMP      R2,#+16
   \        0xC   0xD302             BCC.N    ??DCP_AES_EncryptCbcNonBlocking_0
   \        0xE   0xF012 0x0F0F      TST      R2,#0xF
   \       0x12   0xD001             BEQ.N    ??DCP_AES_EncryptCbcNonBlocking_1
    569              {
    570                  return kStatus_InvalidArgument;
   \                     ??DCP_AES_EncryptCbcNonBlocking_0: (+1)
   \       0x14   0x2004             MOVS     R0,#+4
   \       0x16   0xBDF2             POP      {R1,R4-R7,PC}
    571              }
   \                     ??DCP_AES_EncryptCbcNonBlocking_1: (+1)
   \       0x18   0x9906             LDR      R1,[SP, #+24]
    572          
    573              dcpPacket->control0 =
    574                  0x322u | (handle->swapConfig & 0xFC0000u); /* CIPHER_INIT | CIPHER_ENCRYPT | ENABLE_CIPHER | DECR_SEMAPHORE */
   \       0x1A   0x68AF             LDR      R7,[R5, #+8]
   \       0x1C   0xF407 0x077C      AND      R7,R7,#0xFC0000
   \       0x20   0xF240 0x3022      MOVW     R0,#+802
   \       0x24   0x4307             ORRS     R7,R0,R7
   \       0x26   0x6077             STR      R7,[R6, #+4]
    575              dcpPacket->control1                 = 0x10u;   /* CBC */
   \       0x28   0x2010             MOVS     R0,#+16
   \       0x2A   0x60B0             STR      R0,[R6, #+8]
    576              dcpPacket->sourceBufferAddress      = (uint32_t)plaintext;
   \       0x2C   0x60F3             STR      R3,[R6, #+12]
    577              dcpPacket->destinationBufferAddress = (uint32_t)ciphertext;
   \       0x2E   0x6131             STR      R1,[R6, #+16]
    578              dcpPacket->bufferSize               = (uint32_t)size;
   \       0x30   0x6172             STR      R2,[R6, #+20]
   \       0x32   0x9908             LDR      R1,[SP, #+32]
    579          
    580              if (handle->keySlot == kDCP_OtpKey)
   \       0x34   0x7928             LDRB     R0,[R5, #+4]
   \       0x36   0x2804             CMP      R0,#+4
   \       0x38   0xD109             BNE.N    ??DCP_AES_EncryptCbcNonBlocking_2
    581              {
    582                  dcpPacket->payloadPointer = (uint32_t)iv;
   \       0x3A   0x61B1             STR      R1,[R6, #+24]
    583                  dcpPacket->control0 |= (1u << 10);   /* OTP_KEY */
   \       0x3C   0x6870             LDR      R0,[R6, #+4]
   \       0x3E   0xF440 0x6080      ORR      R0,R0,#0x400
   \       0x42   0x6070             STR      R0,[R6, #+4]
    584                  dcpPacket->control1 |= (0xFFu << 8); /* KEY_SELECT = OTP_KEY */
   \       0x44   0x68B0             LDR      R0,[R6, #+8]
   \       0x46   0xF440 0x407F      ORR      R0,R0,#0xFF00
   \       0x4A   0x60B0             STR      R0,[R6, #+8]
   \       0x4C   0xE020             B.N      ??DCP_AES_EncryptCbcNonBlocking_3
    585              }
    586              else if (handle->keySlot == kDCP_OtpUniqueKey)
   \                     ??DCP_AES_EncryptCbcNonBlocking_2: (+1)
   \       0x4E   0x2805             CMP      R0,#+5
   \       0x50   0xD109             BNE.N    ??DCP_AES_EncryptCbcNonBlocking_4
    587              {
    588                  dcpPacket->payloadPointer = (uint32_t)iv;
   \       0x52   0x61B1             STR      R1,[R6, #+24]
    589                  dcpPacket->control0 |= (1u << 10);   /* OTP_KEY */
   \       0x54   0x6870             LDR      R0,[R6, #+4]
   \       0x56   0xF440 0x6080      ORR      R0,R0,#0x400
   \       0x5A   0x6070             STR      R0,[R6, #+4]
    590                  dcpPacket->control1 |= (0xFEu << 8); /* KEY_SELECT = UNIQUE_KEY */
   \       0x5C   0x68B0             LDR      R0,[R6, #+8]
   \       0x5E   0xF440 0x407E      ORR      R0,R0,#0xFE00
   \       0x62   0x60B0             STR      R0,[R6, #+8]
   \       0x64   0xE014             B.N      ??DCP_AES_EncryptCbcNonBlocking_3
    591              }
    592              else if (handle->keySlot == kDCP_PayloadKey)
   \                     ??DCP_AES_EncryptCbcNonBlocking_4: (+1)
   \       0x66   0x2806             CMP      R0,#+6
   \       0x68   0xD10C             BNE.N    ??DCP_AES_EncryptCbcNonBlocking_5
    593              {
    594                  /* In this case payload must contain key & iv in one array. */
    595                  /* Copy iv into handle right behind the keyWord[] so we can point payload to keyWord[]. */
    596                  dcp_memcpy(handle->iv, iv, 16);
   \       0x6A   0x2210             MOVS     R2,#+16
   \       0x6C   0xF105 0x001C      ADD      R0,R5,#+28
   \       0x70   0x....'....        BL       __aeabi_memcpy
    597                  dcpPacket->payloadPointer = (uint32_t)&handle->keyWord[0];
   \       0x74   0xF105 0x000C      ADD      R0,R5,#+12
   \       0x78   0x61B0             STR      R0,[R6, #+24]
    598                  dcpPacket->control0 |= (1u << 11); /* PAYLOAD_KEY */
   \       0x7A   0x6870             LDR      R0,[R6, #+4]
   \       0x7C   0xF440 0x6000      ORR      R0,R0,#0x800
   \       0x80   0x6070             STR      R0,[R6, #+4]
   \       0x82   0xE005             B.N      ??DCP_AES_EncryptCbcNonBlocking_3
    599              }
    600              else
    601              {
    602                  dcpPacket->payloadPointer = (uint32_t)iv;
   \                     ??DCP_AES_EncryptCbcNonBlocking_5: (+1)
   \       0x84   0x61B1             STR      R1,[R6, #+24]
    603                  dcpPacket->control1 |= ((uint32_t)handle->keySlot << 8); /* KEY_SELECT = keySlot */
   \       0x86   0x68B0             LDR      R0,[R6, #+8]
   \       0x88   0x7929             LDRB     R1,[R5, #+4]
   \       0x8A   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \       0x8E   0x60B0             STR      R0,[R6, #+8]
    604              }
    605          
    606              return dcp_schedule_work(base, handle, dcpPacket);
   \                     ??DCP_AES_EncryptCbcNonBlocking_3: (+1)
   \       0x90   0x4632             MOV      R2,R6
   \       0x92   0x4629             MOV      R1,R5
   \       0x94   0x4620             MOV      R0,R4
   \       0x96   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \       0x9A   0x....             B.N      dcp_schedule_work
    607          }
    608          
    609          /*!
    610           * brief Decrypts AES using CBC block mode.
    611           *
    612           * Decrypts AES using CBC block mode.
    613           * The source ciphertext and destination plaintext can overlap in system memory.
    614           *
    615           * param base DCP peripheral base address
    616           * param handle Handle used for this request.
    617           * param ciphertext Input cipher text to decrypt
    618           * param[out] plaintext Output plain text
    619           * param size Size of input and output data in bytes. Must be multiple of 16 bytes.
    620           * param iv Input initial vector to combine with the first input block.
    621           * return Status from decrypt operation
    622           */

   \                                 In section .text, align 2, keep-with-next
    623          status_t DCP_AES_DecryptCbc(DCP_Type *base,
    624                                      dcp_handle_t *handle,
    625                                      const uint8_t *ciphertext,
    626                                      uint8_t *plaintext,
    627                                      size_t size,
    628                                      const uint8_t iv[16])
    629          {
   \                     DCP_AES_DecryptCbc: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x461F             MOV      R7,R3
   \        0xE   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \       0x12   0xF8DD 0x904C      LDR      R9,[SP, #+76]
    630              status_t completionStatus = kStatus_Fail;
    631              dcp_work_packet_t dcpWork = {0};
   \       0x16   0xA803             ADD      R0,SP,#+12
   \       0x18   0x2120             MOVS     R1,#+32
   \       0x1A   0x....'....        BL       __aeabi_memclr4
    632          
    633              do
    634              {
    635                  completionStatus = DCP_AES_DecryptCbcNonBlocking(base, handle, &dcpWork, ciphertext, plaintext, size, iv);
   \                     ??DCP_AES_DecryptCbc_0: (+1)
   \       0x1E   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0x22   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x26   0x9700             STR      R7,[SP, #+0]
   \       0x28   0x4633             MOV      R3,R6
   \       0x2A   0xAA03             ADD      R2,SP,#+12
   \       0x2C   0x4629             MOV      R1,R5
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       DCP_AES_DecryptCbcNonBlocking
    636              } while (completionStatus == kStatus_DCP_Again);
   \       0x34   0xF641 0x212C      MOVW     R1,#+6700
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD0F0             BEQ.N    ??DCP_AES_DecryptCbc_0
   \       0x3C   0x4629             MOV      R1,R5
    637          
    638              if (completionStatus != kStatus_Success)
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD102             BNE.N    ??DCP_AES_DecryptCbc_1
    639              {
    640                  return completionStatus;
    641              }
    642          
    643              return DCP_WaitForChannelComplete(base, handle);
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0x....'....        BL       DCP_WaitForChannelComplete
   \                     ??DCP_AES_DecryptCbc_1: (+1)
   \       0x48   0xB00B             ADD      SP,SP,#+44
   \       0x4A   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    644          }
    645          
    646          /*!
    647           * brief Decrypts AES using CBC block mode.
    648           *
    649           * Puts AES CBC decrypt dcpPacket to DCP input job ring.
    650           *
    651           * param base DCP peripheral base address
    652           * param handle Handle used for this request. Specifies jobRing.
    653           * param[out] dcpPacket Memory for the DCP work packet.
    654           * param ciphertext Input cipher text to decrypt
    655           * param[out] plaintext Output plain text
    656           * param size Size of input and output data in bytes. Must be multiple of 16 bytes.
    657           * param iv Input initial vector to combine with the first input block.
    658           * return kStatus_Success The work packet has been scheduled at DCP channel.
    659           * return kStatus_DCP_Again The DCP channel is busy processing previous request.
    660           */

   \                                 In section .text, align 2, keep-with-next
    661          status_t DCP_AES_DecryptCbcNonBlocking(DCP_Type *base,
    662                                                 dcp_handle_t *handle,
    663                                                 dcp_work_packet_t *dcpPacket,
    664                                                 const uint8_t *ciphertext,
    665                                                 uint8_t *plaintext,
    666                                                 size_t size,
    667                                                 const uint8_t *iv)
    668          {
   \                     DCP_AES_DecryptCbcNonBlocking: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x9A07             LDR      R2,[SP, #+28]
    669              /* Size must be 16-byte multiple */
    670              if ((size < 16u) || (size % 16u))
   \        0xA   0x2A10             CMP      R2,#+16
   \        0xC   0xD302             BCC.N    ??DCP_AES_DecryptCbcNonBlocking_0
   \        0xE   0xF012 0x0F0F      TST      R2,#0xF
   \       0x12   0xD001             BEQ.N    ??DCP_AES_DecryptCbcNonBlocking_1
    671              {
    672                  return kStatus_InvalidArgument;
   \                     ??DCP_AES_DecryptCbcNonBlocking_0: (+1)
   \       0x14   0x2004             MOVS     R0,#+4
   \       0x16   0xBDF2             POP      {R1,R4-R7,PC}
    673              }
   \                     ??DCP_AES_DecryptCbcNonBlocking_1: (+1)
   \       0x18   0x9906             LDR      R1,[SP, #+24]
    674          
    675              dcpPacket->control0 = 0x222u | (handle->swapConfig & 0xFC0000u); /* CIPHER_INIT | ENABLE_CIPHER | DECR_SEMAPHORE */
   \       0x1A   0x68AF             LDR      R7,[R5, #+8]
   \       0x1C   0xF407 0x077C      AND      R7,R7,#0xFC0000
   \       0x20   0xF240 0x2022      MOVW     R0,#+546
   \       0x24   0x4307             ORRS     R7,R0,R7
   \       0x26   0x6077             STR      R7,[R6, #+4]
    676              dcpPacket->control1 = 0x10u;                                     /* CBC */
   \       0x28   0x2010             MOVS     R0,#+16
   \       0x2A   0x60B0             STR      R0,[R6, #+8]
    677              dcpPacket->sourceBufferAddress      = (uint32_t)ciphertext;
   \       0x2C   0x60F3             STR      R3,[R6, #+12]
    678              dcpPacket->destinationBufferAddress = (uint32_t)plaintext;
   \       0x2E   0x6131             STR      R1,[R6, #+16]
    679              dcpPacket->bufferSize               = (uint32_t)size;
   \       0x30   0x6172             STR      R2,[R6, #+20]
   \       0x32   0x9908             LDR      R1,[SP, #+32]
    680          
    681              if (handle->keySlot == kDCP_OtpKey)
   \       0x34   0x7928             LDRB     R0,[R5, #+4]
   \       0x36   0x2804             CMP      R0,#+4
   \       0x38   0xD109             BNE.N    ??DCP_AES_DecryptCbcNonBlocking_2
    682              {
    683                  dcpPacket->payloadPointer = (uint32_t)iv;
   \       0x3A   0x61B1             STR      R1,[R6, #+24]
    684                  dcpPacket->control0 |= (1u << 10);   /* OTP_KEY */
   \       0x3C   0x6870             LDR      R0,[R6, #+4]
   \       0x3E   0xF440 0x6080      ORR      R0,R0,#0x400
   \       0x42   0x6070             STR      R0,[R6, #+4]
    685                  dcpPacket->control1 |= (0xFFu << 8); /* OTP_KEY */
   \       0x44   0x68B0             LDR      R0,[R6, #+8]
   \       0x46   0xF440 0x407F      ORR      R0,R0,#0xFF00
   \       0x4A   0x60B0             STR      R0,[R6, #+8]
   \       0x4C   0xE020             B.N      ??DCP_AES_DecryptCbcNonBlocking_3
    686              }
    687              else if (handle->keySlot == kDCP_OtpUniqueKey)
   \                     ??DCP_AES_DecryptCbcNonBlocking_2: (+1)
   \       0x4E   0x2805             CMP      R0,#+5
   \       0x50   0xD109             BNE.N    ??DCP_AES_DecryptCbcNonBlocking_4
    688              {
    689                  dcpPacket->payloadPointer = (uint32_t)iv;
   \       0x52   0x61B1             STR      R1,[R6, #+24]
    690                  dcpPacket->control0 |= (1u << 10);   /* OTP_KEY */
   \       0x54   0x6870             LDR      R0,[R6, #+4]
   \       0x56   0xF440 0x6080      ORR      R0,R0,#0x400
   \       0x5A   0x6070             STR      R0,[R6, #+4]
    691                  dcpPacket->control1 |= (0xFEu << 8); /* UNIQUE_KEY */
   \       0x5C   0x68B0             LDR      R0,[R6, #+8]
   \       0x5E   0xF440 0x407E      ORR      R0,R0,#0xFE00
   \       0x62   0x60B0             STR      R0,[R6, #+8]
   \       0x64   0xE014             B.N      ??DCP_AES_DecryptCbcNonBlocking_3
    692              }
    693              else if (handle->keySlot == kDCP_PayloadKey)
   \                     ??DCP_AES_DecryptCbcNonBlocking_4: (+1)
   \       0x66   0x2806             CMP      R0,#+6
   \       0x68   0xD10C             BNE.N    ??DCP_AES_DecryptCbcNonBlocking_5
    694              {
    695                  /* in this case payload must contain KEY + IV together */
    696                  /* copy iv into handle struct so we can point payload directly to keyWord[]. */
    697                  dcp_memcpy(handle->iv, iv, 16);
   \       0x6A   0x2210             MOVS     R2,#+16
   \       0x6C   0xF105 0x001C      ADD      R0,R5,#+28
   \       0x70   0x....'....        BL       __aeabi_memcpy
    698                  dcpPacket->payloadPointer = (uint32_t)&handle->keyWord[0];
   \       0x74   0xF105 0x000C      ADD      R0,R5,#+12
   \       0x78   0x61B0             STR      R0,[R6, #+24]
    699                  dcpPacket->control0 |= (1u << 11); /* PAYLOAD_KEY */
   \       0x7A   0x6870             LDR      R0,[R6, #+4]
   \       0x7C   0xF440 0x6000      ORR      R0,R0,#0x800
   \       0x80   0x6070             STR      R0,[R6, #+4]
   \       0x82   0xE005             B.N      ??DCP_AES_DecryptCbcNonBlocking_3
    700              }
    701              else
    702              {
    703                  dcpPacket->payloadPointer = (uint32_t)iv;
   \                     ??DCP_AES_DecryptCbcNonBlocking_5: (+1)
   \       0x84   0x61B1             STR      R1,[R6, #+24]
    704                  dcpPacket->control1 |= ((uint32_t)handle->keySlot << 8); /* KEY_SELECT */
   \       0x86   0x68B0             LDR      R0,[R6, #+8]
   \       0x88   0x7929             LDRB     R1,[R5, #+4]
   \       0x8A   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \       0x8E   0x60B0             STR      R0,[R6, #+8]
    705              }
    706          
    707              return dcp_schedule_work(base, handle, dcpPacket);
   \                     ??DCP_AES_DecryptCbcNonBlocking_3: (+1)
   \       0x90   0x4632             MOV      R2,R6
   \       0x92   0x4629             MOV      R1,R5
   \       0x94   0x4620             MOV      R0,R4
   \       0x96   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \       0x9A   0x....             B.N      dcp_schedule_work
    708          }
    709          
    710          /*!
    711           * brief Gets the default configuration structure.
    712           *
    713           * This function initializes the DCP configuration structure to a default value. The default
    714           * values are as follows.
    715           *   dcpConfig->gatherResidualWrites = true;
    716           *   dcpConfig->enableContextCaching = true;
    717           *   dcpConfig->enableContextSwitching = true;
    718           *   dcpConfig->enableChannnel = kDCP_chEnableAll;
    719           *   dcpConfig->enableChannelInterrupt = kDCP_chIntDisable;
    720           *
    721           * param[out] config Pointer to configuration structure.
    722           */

   \                                 In section .text, align 2, keep-with-next
    723          void DCP_GetDefaultConfig(dcp_config_t *config)
    724          {
   \                     DCP_GetDefaultConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    725              /* ENABLE_CONTEXT_CACHING is disabled by default as the DCP Hash driver uses
    726               * dcp_hash_save_running_hash() and dcp_hash_restore_running_hash() to support
    727               * Hash context switch (different messages interleaved) on the same channel.
    728               */
    729          
    730              /* Initializes the configure structure to zero. */
    731              memset(config, 0, sizeof(*config));
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2105             MOVS     R1,#+5
   \        0x8   0x....'....        BL       __aeabi_memset
    732          
    733              dcp_config_t userConfig = {
    734                  true, false, true, kDCP_chEnableAll, kDCP_chIntDisable,
    735              };
    736          
    737              *config = userConfig;
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x....'....        LDR.W    R1,??DataTable6_3
   \       0x12   0x2205             MOVS     R2,#+5
   \       0x14   0xE8BD 0x4010      POP      {R4,LR}
   \       0x18   0x....'....        B.W      __aeabi_memcpy
    738          }
    739          
    740          /*!
    741           * brief   Enables clock to and enables DCP
    742           *
    743           * Enable DCP clock and configure DCP.
    744           *
    745           * param base DCP base address
    746           * param config Pointer to configuration structure.
    747           */

   \                                 In section .text, align 2, keep-with-next
    748          void DCP_Init(DCP_Type *base, const dcp_config_t *config)
    749          {
   \                     DCP_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    750          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    751              CLOCK_EnableClock(kCLOCK_Dcp);
   \        0x6   0x200A             MOVS     R0,#+10
   \        0x8   0x....'....        BL       CLOCK_EnableClock
    752          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    753          
    754              base->CTRL = 0xF0800000u; /* reset value */
   \        0xC   0x....'....        LDR.W    R0,??DataTable6_4  ;; 0xf0800000
   \       0x10   0x6020             STR      R0,[R4, #+0]
    755              base->CTRL = 0x30800000u; /* default value */
   \       0x12   0xF04F 0x5042      MOV      R0,#+813694976
   \       0x16   0x6020             STR      R0,[R4, #+0]
    756          
    757              dcp_clear_status(base);
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x....'....        BL       dcp_clear_status
    758              dcp_clear_channel_status(base, kDCP_Channel0 | kDCP_Channel1 | kDCP_Channel2 | kDCP_Channel3);
   \       0x1E   0xF44F 0x2170      MOV      R1,#+983040
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x....'....        BL       dcp_clear_channel_status
    759          
    760              base->CTRL = DCP_CTRL_GATHER_RESIDUAL_WRITES(config->gatherResidualWrites) |
    761                           DCP_CTRL_ENABLE_CONTEXT_CACHING(config->enableContextCaching) |
    762                           DCP_CTRL_ENABLE_CONTEXT_SWITCHING(config->enableContextSwitching) |
    763                           DCP_CTRL_CHANNEL_INTERRUPT_ENABLE(config->enableChannelInterrupt);
   \       0x28   0x7828             LDRB     R0,[R5, #+0]
   \       0x2A   0x7869             LDRB     R1,[R5, #+1]
   \       0x2C   0x0589             LSLS     R1,R1,#+22
   \       0x2E   0xEA41 0x51C0      ORR      R1,R1,R0, LSL #+23
   \       0x32   0x78A8             LDRB     R0,[R5, #+2]
   \       0x34   0xEA41 0x5140      ORR      R1,R1,R0, LSL #+21
   \       0x38   0x7928             LDRB     R0,[R5, #+4]
   \       0x3A   0x4301             ORRS     R1,R0,R1
   \       0x3C   0x6021             STR      R1,[R4, #+0]
    764          
    765              /* enable DCP channels */
    766              base->CHANNELCTRL = DCP_CHANNELCTRL_ENABLE_CHANNEL(config->enableChannel);
   \       0x3E   0x78E8             LDRB     R0,[R5, #+3]
   \       0x40   0x6220             STR      R0,[R4, #+32]
    767          
    768              /* use context switching buffer */
    769              base->CONTEXT = (uint32_t)&s_dcpContextSwitchingBuffer;
   \       0x42   0x....'....        LDR.W    R0,??DataTable6_5
   \       0x46   0x6520             STR      R0,[R4, #+80]
    770          }
   \       0x48   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    771          
    772          /*!
    773           * brief   Disable DCP clock
    774           *
    775           * Reset DCP and Disable DCP clock.
    776           *
    777           * param base DCP base address
    778           */

   \                                 In section .text, align 2, keep-with-next
    779          void DCP_Deinit(DCP_Type *base)
    780          {
   \                     DCP_Deinit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    781              base->CTRL = 0xF0800000u; /* reset value */
   \        0x2   0x....'....        LDR.W    R1,??DataTable6_4  ;; 0xf0800000
   \        0x6   0x6001             STR      R1,[R0, #+0]
    782              memset(&s_dcpContextSwitchingBuffer, 0, sizeof(s_dcpContextSwitchingBuffer));
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x21D0             MOVS     R1,#+208
   \        0xC   0x....'....        LDR.W    R0,??DataTable6_5
   \       0x10   0x....'....        BL       __aeabi_memset4
    783          
    784          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    785              CLOCK_DisableClock(kCLOCK_Dcp);
   \       0x14   0x200A             MOVS     R0,#+10
   \       0x16   0xE8BD 0x4002      POP      {R1,LR}
   \       0x1A   0x....             B.N      CLOCK_DisableClock
    786          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    787          }
    788          
    789          /*!
    790           * brief Poll and wait on DCP channel.
    791           *
    792           * Polls the specified DCP channel until current it completes activity.
    793           *
    794           * param   base DCP peripheral base address.
    795           * param   handle Specifies DCP channel.
    796           * return  kStatus_Success When data processing completes without error.
    797           * return  kStatus_Fail When error occurs.
    798           */

   \                                 In section .text, align 2, keep-with-next
    799          status_t DCP_WaitForChannelComplete(DCP_Type *base, dcp_handle_t *handle)
    800          {
   \                     DCP_WaitForChannelComplete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    801              /* wait if our channel is still active */
    802              while ((base->STAT & (uint32_t)handle->channel) == handle->channel)
   \                     ??DCP_WaitForChannelComplete_0: (+1)
   \        0x6   0x6920             LDR      R0,[R4, #+16]
   \        0x8   0x6829             LDR      R1,[R5, #+0]
   \        0xA   0x4008             ANDS     R0,R1,R0
   \        0xC   0x4288             CMP      R0,R1
   \        0xE   0xD0FA             BEQ.N    ??DCP_WaitForChannelComplete_0
    803              {
    804              }
    805          
    806              if (dcp_get_channel_status(base, handle->channel) != kStatus_Success)
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       dcp_get_channel_status
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0xD007             BEQ.N    ??DCP_WaitForChannelComplete_1
    807              {
    808                  dcp_clear_status(base);
   \       0x1C   0x....'....        BL       dcp_clear_status
    809                  dcp_clear_channel_status(base, handle->channel);
   \       0x20   0x6829             LDR      R1,[R5, #+0]
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x....'....        BL       dcp_clear_channel_status
    810                  return kStatus_Fail;
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}
    811              }
    812          
    813              dcp_clear_status(base);
   \                     ??DCP_WaitForChannelComplete_1: (+1)
   \       0x2C   0x....'....        BL       dcp_clear_status
    814              return kStatus_Success;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    815          }
    816          
    817          /*!
    818           * @brief Check validity of algoritm.
    819           *
    820           * This function checks the validity of input argument.
    821           *
    822           * @param algo Tested algorithm value.
    823           * @return kStatus_Success if valid, kStatus_InvalidArgument otherwise.
    824           */

   \                                 In section .text, align 2, keep-with-next
    825          static status_t dcp_hash_check_input_alg(dcp_hash_algo_t algo)
    826          {
    827              if ((algo != kDCP_Sha256) && (algo != kDCP_Sha1) && (algo != kDCP_Crc32))
   \                     dcp_hash_check_input_alg: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x2901             CMP      R1,#+1
   \        0x4   0xD005             BEQ.N    ??dcp_hash_check_input_alg_0
   \        0x6   0x0001             MOVS     R1,R0
   \        0x8   0xD003             BEQ.N    ??dcp_hash_check_input_alg_0
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD001             BEQ.N    ??dcp_hash_check_input_alg_0
    828              {
    829                  return kStatus_InvalidArgument;
   \        0xE   0x2004             MOVS     R0,#+4
   \       0x10   0x4770             BX       LR
    830              }
    831              return kStatus_Success;
   \                     ??dcp_hash_check_input_alg_0: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
    832          }
    833          
    834          /*!
    835           * @brief Check validity of input arguments.
    836           *
    837           * This function checks the validity of input arguments.
    838           *
    839           * @param base DCP peripheral base address.
    840           * @param ctx Memory buffer given by user application where the DCP_HASH_Init/DCP_HASH_Update/DCP_HASH_Finish store
    841           * context.
    842           * @param algo Tested algorithm value.
    843           * @return kStatus_Success if valid, kStatus_InvalidArgument otherwise.
    844           */

   \                                 In section .text, align 2, keep-with-next
    845          static status_t dcp_hash_check_input_args(DCP_Type *base, dcp_hash_ctx_t *ctx, dcp_hash_algo_t algo)
    846          {
   \                     dcp_hash_check_input_args: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4610             MOV      R0,R2
    847              /* Check validity of input algorithm */
    848              if (kStatus_Success != dcp_hash_check_input_alg(algo))
   \        0x8   0x....'....        BL       dcp_hash_check_input_alg
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD103             BNE.N    ??dcp_hash_check_input_args_0
    849              {
    850                  return kStatus_InvalidArgument;
    851              }
    852          
    853              if ((NULL == ctx) || (NULL == base))
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD001             BEQ.N    ??dcp_hash_check_input_args_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD101             BNE.N    ??dcp_hash_check_input_args_1
    854              {
    855                  return kStatus_InvalidArgument;
   \                     ??dcp_hash_check_input_args_0: (+1)
   \       0x18   0x2004             MOVS     R0,#+4
   \       0x1A   0xBD32             POP      {R1,R4,R5,PC}
    856              }
    857          
    858              return kStatus_Success;
   \                     ??dcp_hash_check_input_args_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    859          }
    860          
    861          /*!
    862           * @brief Check validity of internal software context.
    863           *
    864           * This function checks if the internal context structure looks correct.
    865           *
    866           * @param ctxInternal Internal context.
    867           * @param message Input message address.
    868           * @return kStatus_Success if valid, kStatus_InvalidArgument otherwise.
    869           */

   \                                 In section .text, align 2, keep-with-next
    870          static status_t dcp_hash_check_context(dcp_hash_ctx_internal_t *ctxInternal, const uint8_t *message)
    871          {
   \                     dcp_hash_check_context: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    872              if ((NULL == message) || (NULL == ctxInternal) || (kStatus_Success != dcp_hash_check_input_alg(ctxInternal->algo)))
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD007             BEQ.N    ??dcp_hash_check_context_0
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD005             BEQ.N    ??dcp_hash_check_context_0
   \        0xA   0xF890 0x0084      LDRB     R0,[R0, #+132]
   \        0xE   0x....'....        BL       dcp_hash_check_input_alg
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD001             BEQ.N    ??dcp_hash_check_context_1
    873              {
    874                  return kStatus_InvalidArgument;
   \                     ??dcp_hash_check_context_0: (+1)
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0xBD02             POP      {R1,PC}
    875              }
    876              return kStatus_Success;
   \                     ??dcp_hash_check_context_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD02             POP      {R1,PC}          ;; return
    877          }
    878          
    879          /*!
    880           * @brief Initialize the SHA engine for new hash.
    881           *
    882           * This function sets kDCP_CONTROL0_HASH_INIT for control0 in work packet to start a new hash.
    883           *
    884           * @param base SHA peripheral base address.
    885           * @param ctxInternal Internal context.
    886           */

   \                                 In section .text, align 2, keep-with-next
    887          static status_t dcp_hash_engine_init(DCP_Type *base, dcp_hash_ctx_internal_t *ctxInternal)
    888          {
    889              status_t status;
    890          
    891              status = kStatus_InvalidArgument;
   \                     dcp_hash_engine_init: (+1)
   \        0x0   0x2004             MOVS     R0,#+4
    892          
    893              if ((kDCP_Sha256 == ctxInternal->algo) || (kDCP_Sha1 == ctxInternal->algo) || (kDCP_Crc32 == ctxInternal->algo))
   \        0x2   0xF891 0x2084      LDRB     R2,[R1, #+132]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD003             BEQ.N    ??dcp_hash_engine_init_0
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD001             BEQ.N    ??dcp_hash_engine_init_0
   \        0xE   0x2A02             CMP      R2,#+2
   \       0x10   0xD104             BNE.N    ??dcp_hash_engine_init_1
    894              {
    895                  ctxInternal->ctrl0 = kDCP_CONTROL0_HASH_INIT;
   \                     ??dcp_hash_engine_init_0: (+1)
   \       0x12   0xF44F 0x5080      MOV      R0,#+4096
   \       0x16   0xF8C1 0x008C      STR      R0,[R1, #+140]
    896                  status             = kStatus_Success;
   \       0x1A   0x2000             MOVS     R0,#+0
    897              }
    898          
    899              return status;
   \                     ??dcp_hash_engine_init_1: (+1)
   \       0x1C   0x4770             BX       LR               ;; return
    900          }
    901          

   \                                 In section .text, align 2, keep-with-next
    902          static status_t dcp_hash_update_non_blocking(
    903              DCP_Type *base, dcp_hash_ctx_internal_t *ctxInternal, dcp_work_packet_t *dcpPacket, const uint8_t *msg, size_t size)
    904          {
   \                     dcp_hash_update_non_blocking: (+1)
   \        0x0   0xB43C             PUSH     {R2-R5}
    905              dcpPacket->control0 = ctxInternal->ctrl0 | (ctxInternal->handle->swapConfig & 0xFC0000u) |
    906                                    kDCP_CONTROL0_ENABLE_HASH | kDCP_CONTROL0_DECR_SEMAPHOR;
   \        0x2   0xF8D1 0x408C      LDR      R4,[R1, #+140]
   \        0x6   0xF8D1 0x50B4      LDR      R5,[R1, #+180]
   \        0xA   0x68AD             LDR      R5,[R5, #+8]
   \        0xC   0xF405 0x057C      AND      R5,R5,#0xFC0000
   \       0x10   0x432C             ORRS     R4,R5,R4
   \       0x12   0xF044 0x0442      ORR      R4,R4,#0x42
   \       0x16   0x6054             STR      R4,[R2, #+4]
    907              if (ctxInternal->algo == kDCP_Sha256)
   \       0x18   0xF891 0x4084      LDRB     R4,[R1, #+132]
   \       0x1C   0x2C01             CMP      R4,#+1
   \       0x1E   0xD111             BNE.N    ??dcp_hash_update_non_blocking_0
    908              {
    909                  dcpPacket->control1 = kDCP_CONTROL1_HASH_SELECT_SHA256;
   \       0x20   0xF44F 0x3400      MOV      R4,#+131072
   \       0x24   0x6094             STR      R4,[R2, #+8]
   \                     ??dcp_hash_update_non_blocking_1: (+1)
   \       0x26   0x9C04             LDR      R4,[SP, #+16]
    910              }
    911              else if (ctxInternal->algo == kDCP_Sha1)
    912              {
    913                  dcpPacket->control1 = kDCP_CONTROL1_HASH_SELECT_SHA1;
    914              }
    915              else if (ctxInternal->algo == kDCP_Crc32)
    916              {
    917                  dcpPacket->control1 = kDCP_CONTROL1_HASH_SELECT_CRC32;
    918              }
    919              else
    920              {
    921                  return kStatus_Fail;
    922              }
    923              dcpPacket->sourceBufferAddress      = (uint32_t)msg;
   \       0x28   0x60D3             STR      R3,[R2, #+12]
    924              dcpPacket->destinationBufferAddress = 0;
   \       0x2A   0x2300             MOVS     R3,#+0
   \       0x2C   0x6113             STR      R3,[R2, #+16]
    925              dcpPacket->bufferSize               = size;
   \       0x2E   0x6154             STR      R4,[R2, #+20]
    926              dcpPacket->payloadPointer           = (uint32_t)ctxInternal->runningHash;
   \       0x30   0xF101 0x0390      ADD      R3,R1,#+144
   \       0x34   0x6193             STR      R3,[R2, #+24]
    927          
    928              return dcp_schedule_work(base, ctxInternal->handle, dcpPacket);
   \       0x36   0xF8D1 0x10B4      LDR      R1,[R1, #+180]
   \       0x3A   0xB002             ADD      SP,SP,#+8
   \       0x3C   0xBC30             POP      {R4,R5}
   \       0x3E   0x....             B.N      dcp_schedule_work
   \                     ??dcp_hash_update_non_blocking_2: (+1)
   \       0x40   0xBC36             POP      {R1,R2,R4,R5}
   \       0x42   0x4770             BX       LR               ;; return
   \                     ??dcp_hash_update_non_blocking_0: (+1)
   \       0x44   0x2C00             CMP      R4,#+0
   \       0x46   0xD102             BNE.N    ??dcp_hash_update_non_blocking_3
   \       0x48   0x2400             MOVS     R4,#+0
   \       0x4A   0x6094             STR      R4,[R2, #+8]
   \       0x4C   0xE7EB             B.N      ??dcp_hash_update_non_blocking_1
   \                     ??dcp_hash_update_non_blocking_3: (+1)
   \       0x4E   0x2C02             CMP      R4,#+2
   \       0x50   0xD103             BNE.N    ??dcp_hash_update_non_blocking_4
   \       0x52   0xF44F 0x3480      MOV      R4,#+65536
   \       0x56   0x6094             STR      R4,[R2, #+8]
   \       0x58   0xE7E5             B.N      ??dcp_hash_update_non_blocking_1
   \                     ??dcp_hash_update_non_blocking_4: (+1)
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0xE7F0             B.N      ??dcp_hash_update_non_blocking_2
    929          }
    930          

   \                                 In section .text, align 2, keep-with-next
    931          static status_t dcp_hash_update(DCP_Type *base, dcp_hash_ctx_internal_t *ctxInternal, const uint8_t *msg, size_t size)
    932          {
   \                     dcp_hash_update: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    933              status_t completionStatus = kStatus_Fail;
    934              dcp_work_packet_t dcpWork = {0};
   \        0xC   0xA801             ADD      R0,SP,#+4
   \        0xE   0x2120             MOVS     R1,#+32
   \       0x10   0x....'....        BL       __aeabi_memclr4
    935          
    936              do
    937              {
    938                  completionStatus = dcp_hash_update_non_blocking(base, ctxInternal, &dcpWork, msg, size);
    939              } while (completionStatus == kStatus_DCP_Again);
   \                     ??dcp_hash_update_0: (+1)
   \       0x14   0x9700             STR      R7,[SP, #+0]
   \       0x16   0x4633             MOV      R3,R6
   \       0x18   0xAA01             ADD      R2,SP,#+4
   \       0x1A   0x4621             MOV      R1,R4
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x....'....        BL       dcp_hash_update_non_blocking
   \       0x22   0xF641 0x212C      MOVW     R1,#+6700
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD0F4             BEQ.N    ??dcp_hash_update_0
    940          
    941              completionStatus = DCP_WaitForChannelComplete(base, ctxInternal->handle);
   \       0x2A   0xF8D4 0x10B4      LDR      R1,[R4, #+180]
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x....'....        BL       DCP_WaitForChannelComplete
    942          
    943              ctxInternal->ctrl0 = 0; /* clear kDCP_CONTROL0_HASH_INIT and kDCP_CONTROL0_HASH_TERM flags */
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0xF8C4 0x108C      STR      R1,[R4, #+140]
    944              return (completionStatus);
   \       0x3A   0xB009             ADD      SP,SP,#+36
   \       0x3C   0xBDF0             POP      {R4-R7,PC}       ;; return
    945          }
    946          
    947          /*!
    948           * @brief Adds message to current hash.
    949           *
    950           * This function merges the message to fill the internal buffer, empties the internal buffer if
    951           * it becomes full, then process all remaining message data.
    952           *
    953           *
    954           * @param base DCP peripheral base address.
    955           * @param ctxInternal Internal context.
    956           * @param message Input message.
    957           * @param messageSize Size of input message in bytes.
    958           * @return kStatus_Success.
    959           */

   \                                 In section .text, align 2, keep-with-next
    960          static status_t dcp_hash_process_message_data(DCP_Type *base,
    961                                                        dcp_hash_ctx_internal_t *ctxInternal,
    962                                                        const uint8_t *message,
    963                                                        size_t messageSize)
    964          {
   \                     dcp_hash_process_message_data: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
    965              status_t status = kStatus_Fail;
   \        0xC   0x2401             MOVS     R4,#+1
    966          
    967              /* if there is partially filled internal buffer, fill it to full block */
    968              if (ctxInternal->blksz > 0)
   \        0xE   0xF8D7 0x0080      LDR      R0,[R7, #+128]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD012             BEQ.N    ??dcp_hash_process_message_data_0
    969              {
    970                  size_t toCopy = DCP_HASH_BLOCK_SIZE - ctxInternal->blksz;
   \       0x16   0x4604             MOV      R4,R0
   \       0x18   0xF1C4 0x0480      RSB      R4,R4,#+128
    971                  dcp_memcpy(&ctxInternal->blk.b[ctxInternal->blksz], message, toCopy);
   \       0x1C   0x4622             MOV      R2,R4
   \       0x1E   0x4641             MOV      R1,R8
   \       0x20   0x4438             ADD      R0,R7,R0
   \       0x22   0x....'....        BL       __aeabi_memcpy
    972                  message += toCopy;
   \       0x26   0x44A0             ADD      R8,R8,R4
    973                  messageSize -= toCopy;
   \       0x28   0xEBA9 0x0904      SUB      R9,R9,R4
    974          
    975                  /* process full internal block */
    976                  status = dcp_hash_update(base, ctxInternal, &ctxInternal->blk.b[0], DCP_HASH_BLOCK_SIZE);
   \       0x2C   0x2380             MOVS     R3,#+128
   \       0x2E   0x463A             MOV      R2,R7
   \       0x30   0x4639             MOV      R1,R7
   \       0x32   0x4630             MOV      R0,R6
   \       0x34   0x....'....        BL       dcp_hash_update
   \       0x38   0x0004             MOVS     R4,R0
    977                  if (kStatus_Success != status)
   \       0x3A   0xD10B             BNE.N    ??dcp_hash_process_message_data_1
    978                  {
    979                      return status;
    980                  }
    981              }
    982          
    983              /* process all full blocks in message[] */
    984              uint32_t fullBlocksSize = ((messageSize >> 6) << 6); /* (X / 64) * 64 */
   \                     ??dcp_hash_process_message_data_0: (+1)
   \       0x3C   0xEA4F 0x1599      LSR      R5,R9,#+6
   \       0x40   0x01AD             LSLS     R5,R5,#+6
    985              if (fullBlocksSize > 0)
   \       0x42   0xD00C             BEQ.N    ??dcp_hash_process_message_data_2
    986              {
    987                  status = dcp_hash_update(base, ctxInternal, message, fullBlocksSize);
   \       0x44   0x462B             MOV      R3,R5
   \       0x46   0x4642             MOV      R2,R8
   \       0x48   0x4639             MOV      R1,R7
   \       0x4A   0x4630             MOV      R0,R6
   \       0x4C   0x....'....        BL       dcp_hash_update
   \       0x50   0x0004             MOVS     R4,R0
    988                  if (kStatus_Success != status)
   \       0x52   0xD001             BEQ.N    ??dcp_hash_process_message_data_3
    989                  {
    990                      return status;
   \                     ??dcp_hash_process_message_data_1: (+1)
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0xE00A             B.N      ??dcp_hash_process_message_data_4
    991                  }
    992                  message += fullBlocksSize;
   \                     ??dcp_hash_process_message_data_3: (+1)
   \       0x58   0x44A8             ADD      R8,R8,R5
    993                  messageSize -= fullBlocksSize;
   \       0x5A   0xEBA9 0x0905      SUB      R9,R9,R5
    994              }
    995          
    996              /* copy last incomplete message bytes into internal block */
    997              dcp_memcpy(&ctxInternal->blk.b[0], message, messageSize);
   \                     ??dcp_hash_process_message_data_2: (+1)
   \       0x5E   0x464A             MOV      R2,R9
   \       0x60   0x4641             MOV      R1,R8
   \       0x62   0x4638             MOV      R0,R7
   \       0x64   0x....'....        BL       __aeabi_memcpy
    998              ctxInternal->blksz = messageSize;
   \       0x68   0xF8C7 0x9080      STR      R9,[R7, #+128]
    999          
   1000              return status;
   \       0x6C   0x4620             MOV      R0,R4
   \                     ??dcp_hash_process_message_data_4: (+1)
   \       0x6E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1001          }
   1002          
   1003          /*!
   1004           * @brief Finalize the running hash to make digest.
   1005           *
   1006           * This function empties the internal buffer, adds padding bits, and generates final digest.
   1007           *
   1008           * @param base SHA peripheral base address.
   1009           * @param ctxInternal Internal context.
   1010           * @return kStatus_Success.
   1011           */

   \                                 In section .text, align 2, keep-with-next
   1012          static status_t dcp_hash_finalize(DCP_Type *base, dcp_hash_ctx_internal_t *ctxInternal)
   1013          {
   \                     dcp_hash_finalize: (+1)
   \        0x0   0x460A             MOV      R2,R1
   1014              status_t status;
   1015          
   1016              ctxInternal->ctrl0 |= kDCP_CONTROL0_HASH_TERM;
   \        0x2   0xF8D2 0x108C      LDR      R1,[R2, #+140]
   \        0x6   0xF441 0x5100      ORR      R1,R1,#0x2000
   \        0xA   0xF8C2 0x108C      STR      R1,[R2, #+140]
   1017              status = dcp_hash_update(base, ctxInternal, &ctxInternal->blk.b[0], ctxInternal->blksz);
   1018          
   1019              return status;
   \        0xE   0xF8D2 0x3080      LDR      R3,[R2, #+128]
   \       0x12   0x4611             MOV      R1,R2
   \       0x14   0x....             B.N      dcp_hash_update
   1020          }
   1021          

   \                                 In section .text, align 2, keep-with-next
   1022          static void dcp_hash_save_running_hash(dcp_hash_ctx_internal_t *ctxInternal)
   1023          {
   1024              uint32_t *srcAddr = NULL;
   \                     dcp_hash_save_running_hash: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1025          
   1026              switch (ctxInternal->handle->channel)
   \        0x2   0xF8D0 0x20B4      LDR      R2,[R0, #+180]
   \        0x6   0x6812             LDR      R2,[R2, #+0]
   \        0x8   0xF5B2 0x3F80      CMP      R2,#+65536
   \        0xC   0xD009             BEQ.N    ??dcp_hash_save_running_hash_0
   \        0xE   0xF5B2 0x3F00      CMP      R2,#+131072
   \       0x12   0xD008             BEQ.N    ??dcp_hash_save_running_hash_1
   \       0x14   0xF5B2 0x2F80      CMP      R2,#+262144
   \       0x18   0xD007             BEQ.N    ??dcp_hash_save_running_hash_2
   \       0x1A   0xF5B2 0x2F00      CMP      R2,#+524288
   \       0x1E   0xD006             BEQ.N    ??dcp_hash_save_running_hash_3
   \       0x20   0xE006             B.N      ??dcp_hash_save_running_hash_4
   1027              {
   1028                  case kDCP_Channel0:
   1029                      srcAddr = &s_dcpContextSwitchingBuffer.x[43];
   \                     ??dcp_hash_save_running_hash_0: (+1)
   \       0x22   0x....             LDR.N    R1,??DataTable6_6
   1030                      break;
   \       0x24   0xE004             B.N      ??dcp_hash_save_running_hash_4
   1031          
   1032                  case kDCP_Channel1:
   1033                      srcAddr = &s_dcpContextSwitchingBuffer.x[30];
   \                     ??dcp_hash_save_running_hash_1: (+1)
   \       0x26   0x....             LDR.N    R1,??DataTable6_7
   1034                      break;
   \       0x28   0xE002             B.N      ??dcp_hash_save_running_hash_4
   1035          
   1036                  case kDCP_Channel2:
   1037                      srcAddr = &s_dcpContextSwitchingBuffer.x[17];
   \                     ??dcp_hash_save_running_hash_2: (+1)
   \       0x2A   0x....             LDR.N    R1,??DataTable6_8
   1038                      break;
   \       0x2C   0xE000             B.N      ??dcp_hash_save_running_hash_4
   1039          
   1040                  case kDCP_Channel3:
   1041                      srcAddr = &s_dcpContextSwitchingBuffer.x[4];
   \                     ??dcp_hash_save_running_hash_3: (+1)
   \       0x2E   0x....             LDR.N    R1,??DataTable6_9
   1042                      break;
   1043          
   1044                  default:
   1045                      break;
   1046              }
   1047              if (srcAddr)
   \                     ??dcp_hash_save_running_hash_4: (+1)
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD003             BEQ.N    ??dcp_hash_save_running_hash_5
   1048              {
   1049                  dcp_memcpy(ctxInternal->runningHash, srcAddr, sizeof(ctxInternal->runningHash));
   \       0x34   0x2224             MOVS     R2,#+36
   \       0x36   0x3090             ADDS     R0,R0,#+144
   \       0x38   0x....'....        B.W      __aeabi_memcpy4
   1050              }
   1051          }
   \                     ??dcp_hash_save_running_hash_5: (+1)
   \       0x3C   0x4770             BX       LR               ;; return
   1052          

   \                                 In section .text, align 2, keep-with-next
   1053          static void dcp_hash_restore_running_hash(dcp_hash_ctx_internal_t *ctxInternal)
   1054          {
   1055              uint32_t *destAddr = NULL;
   \                     dcp_hash_restore_running_hash: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   1056          
   1057              switch (ctxInternal->handle->channel)
   \        0x2   0xF8D0 0x10B4      LDR      R1,[R0, #+180]
   \        0x6   0x6809             LDR      R1,[R1, #+0]
   \        0x8   0xF5B1 0x3F80      CMP      R1,#+65536
   \        0xC   0xD009             BEQ.N    ??dcp_hash_restore_running_hash_0
   \        0xE   0xF5B1 0x3F00      CMP      R1,#+131072
   \       0x12   0xD008             BEQ.N    ??dcp_hash_restore_running_hash_1
   \       0x14   0xF5B1 0x2F80      CMP      R1,#+262144
   \       0x18   0xD007             BEQ.N    ??dcp_hash_restore_running_hash_2
   \       0x1A   0xF5B1 0x2F00      CMP      R1,#+524288
   \       0x1E   0xD006             BEQ.N    ??dcp_hash_restore_running_hash_3
   \       0x20   0xE006             B.N      ??dcp_hash_restore_running_hash_4
   1058              {
   1059                  case kDCP_Channel0:
   1060                      destAddr = &s_dcpContextSwitchingBuffer.x[43];
   \                     ??dcp_hash_restore_running_hash_0: (+1)
   \       0x22   0x....             LDR.N    R3,??DataTable6_6
   1061                      break;
   \       0x24   0xE004             B.N      ??dcp_hash_restore_running_hash_4
   1062          
   1063                  case kDCP_Channel1:
   1064                      destAddr = &s_dcpContextSwitchingBuffer.x[30];
   \                     ??dcp_hash_restore_running_hash_1: (+1)
   \       0x26   0x....             LDR.N    R3,??DataTable6_7
   1065                      break;
   \       0x28   0xE002             B.N      ??dcp_hash_restore_running_hash_4
   1066          
   1067                  case kDCP_Channel2:
   1068                      destAddr = &s_dcpContextSwitchingBuffer.x[17];
   \                     ??dcp_hash_restore_running_hash_2: (+1)
   \       0x2A   0x....             LDR.N    R3,??DataTable6_8
   1069                      break;
   \       0x2C   0xE000             B.N      ??dcp_hash_restore_running_hash_4
   1070          
   1071                  case kDCP_Channel3:
   1072                      destAddr = &s_dcpContextSwitchingBuffer.x[4];
   \                     ??dcp_hash_restore_running_hash_3: (+1)
   \       0x2E   0x....             LDR.N    R3,??DataTable6_9
   1073                      break;
   1074          
   1075                  default:
   1076                      break;
   1077              }
   1078              if (destAddr)
   \                     ??dcp_hash_restore_running_hash_4: (+1)
   \       0x30   0x2B00             CMP      R3,#+0
   \       0x32   0xD005             BEQ.N    ??dcp_hash_restore_running_hash_5
   1079              {
   1080                  dcp_memcpy(destAddr, ctxInternal->runningHash, sizeof(ctxInternal->runningHash));
   \       0x34   0x2224             MOVS     R2,#+36
   \       0x36   0xF100 0x0190      ADD      R1,R0,#+144
   \       0x3A   0x4618             MOV      R0,R3
   \       0x3C   0x....'....        B.W      __aeabi_memcpy4
   1081              }
   1082          }
   \                     ??dcp_hash_restore_running_hash_5: (+1)
   \       0x40   0x4770             BX       LR               ;; return
   1083          
   1084          /*!
   1085           * brief Initialize HASH context
   1086           *
   1087           * This function initializes the HASH.
   1088           *
   1089           * param base DCP peripheral base address
   1090           * param handle Specifies the DCP channel used for hashing.
   1091           * param[out] ctx Output hash context
   1092           * param algo Underlaying algorithm to use for hash computation.
   1093           * return Status of initialization
   1094           */

   \                                 In section .text, align 2, keep-with-next
   1095          status_t DCP_HASH_Init(DCP_Type *base, dcp_handle_t *handle, dcp_hash_ctx_t *ctx, dcp_hash_algo_t algo)
   1096          {
   \                     DCP_HASH_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x461E             MOV      R6,R3
   1097              status_t status;
   1098          
   1099              dcp_hash_ctx_internal_t *ctxInternal;
   1100              /* compile time check for the correct structure size */
   1101              BUILD_ASSURE(sizeof(dcp_hash_ctx_t) >= sizeof(dcp_hash_ctx_internal_t), dcp_hash_ctx_t_size);
   1102              uint32_t i;
   1103          
   1104              status = dcp_hash_check_input_args(base, ctx, algo);
   \        0x8   0x4632             MOV      R2,R6
   \        0xA   0x4629             MOV      R1,R5
   \        0xC   0x....'....        BL       dcp_hash_check_input_args
   1105              if (status != kStatus_Success)
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD112             BNE.N    ??DCP_HASH_Init_0
   1106              {
   1107                  return status;
   1108              }
   1109          
   1110              /* set algorithm in context struct for later use */
   1111              ctxInternal        = (dcp_hash_ctx_internal_t *)ctx;
   1112              ctxInternal->algo  = algo;
   \       0x14   0xF885 0x6084      STRB     R6,[R5, #+132]
   1113              ctxInternal->blksz = 0u;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF8C5 0x0080      STR      R0,[R5, #+128]
   1114              for (i = 0; i < sizeof(ctxInternal->blk.w) / sizeof(ctxInternal->blk.w[0]); i++)
   \       0x1E   0x4601             MOV      R1,R0
   \       0x20   0xE001             B.N      ??DCP_HASH_Init_1
   1115              {
   1116                  ctxInternal->blk.w[0] = 0u;
   \                     ??DCP_HASH_Init_2: (+1)
   \       0x22   0x6029             STR      R1,[R5, #+0]
   1117              }
   \       0x24   0x1C40             ADDS     R0,R0,#+1
   \                     ??DCP_HASH_Init_1: (+1)
   \       0x26   0x2820             CMP      R0,#+32
   \       0x28   0xD3FB             BCC.N    ??DCP_HASH_Init_2
   1118              ctxInternal->state           = kDCP_StateHashInit;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF885 0x0085      STRB     R0,[R5, #+133]
   1119              ctxInternal->fullMessageSize = 0;
   \       0x30   0x4608             MOV      R0,R1
   \       0x32   0xF8C5 0x0088      STR      R0,[R5, #+136]
   1120              ctxInternal->handle          = handle;
   \       0x36   0xF8C5 0x40B4      STR      R4,[R5, #+180]
   1121              return status;
   \                     ??DCP_HASH_Init_0: (+1)
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return
   1122          }
   1123          
   1124          /*!
   1125           * brief Add data to current HASH
   1126           *
   1127           * Add data to current HASH. This can be called repeatedly with an arbitrary amount of data to be
   1128           * hashed. The functions blocks. If it returns kStatus_Success, the running hash
   1129           * has been updated (DCP has processed the input data), so the memory at ref input pointer
   1130           * can be released back to system. The DCP context buffer is updated with the running hash
   1131           * and with all necessary information to support possible context switch.
   1132           *
   1133           * param base DCP peripheral base address
   1134           * param[in,out] ctx HASH context
   1135           * param input Input data
   1136           * param inputSize Size of input data in bytes
   1137           * return Status of the hash update operation
   1138           */

   \                                 In section .text, align 2, keep-with-next
   1139          status_t DCP_HASH_Update(DCP_Type *base, dcp_hash_ctx_t *ctx, const uint8_t *input, size_t inputSize)
   1140          {
   \                     DCP_HASH_Update: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4617             MOV      R7,R2
   \        0x8   0x001C             MOVS     R4,R3
   1141              bool isUpdateState;
   1142              status_t status;
   1143              dcp_hash_ctx_internal_t *ctxInternal;
   1144              size_t blockSize;
   1145          
   1146              if (inputSize == 0)
   \        0xA   0xD101             BNE.N    ??DCP_HASH_Update_0
   1147              {
   1148                  return kStatus_Success;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   1149              }
   1150          
   1151              ctxInternal = (dcp_hash_ctx_internal_t *)ctx;
   1152              status      = dcp_hash_check_context(ctxInternal, input);
   \                     ??DCP_HASH_Update_0: (+1)
   \       0x10   0x4639             MOV      R1,R7
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x....'....        BL       dcp_hash_check_context
   1153              if (kStatus_Success != status)
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD133             BNE.N    ??DCP_HASH_Update_1
   1154              {
   1155                  return status;
   1156              }
   1157          
   1158              ctxInternal->fullMessageSize += inputSize;
   \       0x1C   0xF8D5 0x0088      LDR      R0,[R5, #+136]
   \       0x20   0x1820             ADDS     R0,R4,R0
   \       0x22   0xF8C5 0x0088      STR      R0,[R5, #+136]
   1159              blockSize = DCP_HASH_BLOCK_SIZE;
   1160              /* if we are still less than DCP_HASH_BLOCK_SIZE bytes, keep only in context */
   1161              if ((ctxInternal->blksz + inputSize) <= blockSize)
   \       0x26   0xF8D5 0x0080      LDR      R0,[R5, #+128]
   \       0x2A   0x1820             ADDS     R0,R4,R0
   \       0x2C   0x2881             CMP      R0,#+129
   \       0x2E   0xD20D             BCS.N    ??DCP_HASH_Update_2
   1162              {
   1163                  dcp_memcpy((&ctxInternal->blk.b[0]) + ctxInternal->blksz, input, inputSize);
   \       0x30   0x4622             MOV      R2,R4
   \       0x32   0x4639             MOV      R1,R7
   \       0x34   0xF8D5 0x0080      LDR      R0,[R5, #+128]
   \       0x38   0x4428             ADD      R0,R5,R0
   \       0x3A   0x....'....        BL       __aeabi_memcpy
   1164                  ctxInternal->blksz += inputSize;
   \       0x3E   0xF8D5 0x0080      LDR      R0,[R5, #+128]
   \       0x42   0x1824             ADDS     R4,R4,R0
   \       0x44   0xF8C5 0x4080      STR      R4,[R5, #+128]
   1165                  return status;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xBDF2             POP      {R1,R4-R7,PC}
   1166              }
   1167              else
   1168              {
   1169                  isUpdateState = ctxInternal->state == kDCP_StateHashUpdate;
   \                     ??DCP_HASH_Update_2: (+1)
   \       0x4C   0xF895 0x0085      LDRB     R0,[R5, #+133]
   \       0x50   0x2802             CMP      R0,#+2
   \       0x52   0xD009             BEQ.N    ??DCP_HASH_Update_3
   1170                  if (!isUpdateState)
   1171                  {
   1172                      /* start NEW hash */
   1173                      status = dcp_hash_engine_init(base, ctxInternal);
   \       0x54   0x4629             MOV      R1,R5
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0x....'....        BL       dcp_hash_engine_init
   1174                      if (status != kStatus_Success)
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD111             BNE.N    ??DCP_HASH_Update_1
   1175                      {
   1176                          return status;
   1177                      }
   1178                      ctxInternal->state = kDCP_StateHashUpdate;
   \       0x60   0x2002             MOVS     R0,#+2
   \       0x62   0xF885 0x0085      STRB     R0,[R5, #+133]
   \       0x66   0xE002             B.N      ??DCP_HASH_Update_4
   1179                  }
   1180                  else
   1181                  {
   1182                      dcp_hash_restore_running_hash(ctxInternal);
   \                     ??DCP_HASH_Update_3: (+1)
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0x....'....        BL       dcp_hash_restore_running_hash
   1183                  }
   1184              }
   1185          
   1186              /* process input data */
   1187              status = dcp_hash_process_message_data(base, ctxInternal, input, inputSize);
   \                     ??DCP_HASH_Update_4: (+1)
   \       0x6E   0x4623             MOV      R3,R4
   \       0x70   0x463A             MOV      R2,R7
   \       0x72   0x4629             MOV      R1,R5
   \       0x74   0x4630             MOV      R0,R6
   \       0x76   0x....'....        BL       dcp_hash_process_message_data
   \       0x7A   0x4604             MOV      R4,R0
   1188              dcp_hash_save_running_hash(ctxInternal);
   \       0x7C   0x4628             MOV      R0,R5
   \       0x7E   0x....'....        BL       dcp_hash_save_running_hash
   1189              return status;
   \       0x82   0x4620             MOV      R0,R4
   \                     ??DCP_HASH_Update_1: (+1)
   \       0x84   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1190          }
   1191          
   1192          /*!
   1193           * brief Finalize hashing
   1194           *
   1195           * Outputs the final hash (computed by DCP_HASH_Update()) and erases the context.
   1196           *
   1197           * param[in,out] ctx Input hash context
   1198           * param[out] output Output hash data
   1199           * param[in,out] outputSize Optional parameter (can be passed as NULL). On function entry, it specifies the size of
   1200           * output[] buffer. On function return, it stores the number of updated output bytes.
   1201           * return Status of the hash finish operation
   1202           */

   \                                 In section .text, align 2, keep-with-next
   1203          status_t DCP_HASH_Finish(DCP_Type *base, dcp_hash_ctx_t *ctx, uint8_t *output, size_t *outputSize)
   1204          {
   \                     DCP_HASH_Finish: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461C             MOV      R4,R3
   1205              size_t algOutSize = 0;
   1206              status_t status;
   1207              dcp_hash_ctx_internal_t *ctxInternal;
   1208          
   1209              ctxInternal = (dcp_hash_ctx_internal_t *)ctx;
   1210              status      = dcp_hash_check_context(ctxInternal, output);
   \        0xC   0x4631             MOV      R1,R6
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x....'....        BL       dcp_hash_check_context
   1211              if (kStatus_Success != status)
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD14F             BNE.N    ??DCP_HASH_Finish_0
   1212              {
   1213                  return status;
   1214              }
   1215          
   1216              if (ctxInternal->state == kDCP_StateHashInit)
   \       0x18   0xF895 0x0085      LDRB     R0,[R5, #+133]
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD106             BNE.N    ??DCP_HASH_Finish_1
   1217              {
   1218                  status = dcp_hash_engine_init(base, ctxInternal);
   \       0x20   0x4629             MOV      R1,R5
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0x....'....        BL       dcp_hash_engine_init
   1219                  if (status != kStatus_Success)
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD003             BEQ.N    ??DCP_HASH_Finish_2
   1220                  {
   1221                      return status;
   \       0x2C   0xE044             B.N      ??DCP_HASH_Finish_0
   1222                  }
   1223              }
   1224              else
   1225              {
   1226                  dcp_hash_restore_running_hash(ctxInternal);
   \                     ??DCP_HASH_Finish_1: (+1)
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x....'....        BL       dcp_hash_restore_running_hash
   1227              }
   1228          
   1229              size_t outSize = 0u;
   \                     ??DCP_HASH_Finish_2: (+1)
   \       0x34   0xF04F 0x0800      MOV      R8,#+0
   1230          
   1231              /* compute algorithm output length */
   1232              switch (ctxInternal->algo)
   \       0x38   0xF895 0x0084      LDRB     R0,[R5, #+132]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD005             BEQ.N    ??DCP_HASH_Finish_3
   \       0x40   0x2802             CMP      R0,#+2
   \       0x42   0xD006             BEQ.N    ??DCP_HASH_Finish_4
   \       0x44   0xD207             BCS.N    ??DCP_HASH_Finish_5
   1233              {
   1234                  case kDCP_Sha256:
   1235                      outSize = kDCP_OutLenSha256;
   \       0x46   0xF04F 0x0820      MOV      R8,#+32
   1236                      break;
   \       0x4A   0xE004             B.N      ??DCP_HASH_Finish_5
   1237                  case kDCP_Sha1:
   1238                      outSize = kDCP_OutLenSha1;
   \                     ??DCP_HASH_Finish_3: (+1)
   \       0x4C   0xF04F 0x0814      MOV      R8,#+20
   1239                      break;
   \       0x50   0xE001             B.N      ??DCP_HASH_Finish_5
   1240                  case kDCP_Crc32:
   1241                      outSize = kDCP_OutLenCrc32;
   \                     ??DCP_HASH_Finish_4: (+1)
   \       0x52   0xF04F 0x0804      MOV      R8,#+4
   1242                      break;
   1243                  default:
   1244                      break;
   1245              }
   1246              algOutSize = outSize;
   1247          
   1248          #if defined(DCP_HASH_CAVP_COMPATIBLE)
   1249              if (ctxInternal->fullMessageSize == 0)
   \                     ??DCP_HASH_Finish_5: (+1)
   \       0x56   0xF8D5 0x0088      LDR      R0,[R5, #+136]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD112             BNE.N    ??DCP_HASH_Finish_6
   1250              {
   1251                  switch (ctxInternal->algo)
   \       0x5E   0xF895 0x0084      LDRB     R0,[R5, #+132]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD007             BEQ.N    ??DCP_HASH_Finish_7
   \       0x66   0x2801             CMP      R0,#+1
   \       0x68   0xD10A             BNE.N    ??DCP_HASH_Finish_8
   1252                  {
   1253                      case kDCP_Sha256:
   1254                          dcp_memcpy(&output[0], &s_nullSha256, 32);
   \       0x6A   0x2220             MOVS     R2,#+32
   \       0x6C   0x....             LDR.N    R1,??DataTable6_10
   \       0x6E   0x4630             MOV      R0,R6
   \       0x70   0x....'....        BL       __aeabi_memcpy
   1255                          break;
   \       0x74   0xE004             B.N      ??DCP_HASH_Finish_8
   1256                      case kDCP_Sha1:
   1257                          dcp_memcpy(&output[0], &s_nullSha1, 20);
   \                     ??DCP_HASH_Finish_7: (+1)
   \       0x76   0x2214             MOVS     R2,#+20
   \       0x78   0x....             LDR.N    R1,??DataTable6_11
   \       0x7A   0x4630             MOV      R0,R6
   \       0x7C   0x....'....        BL       __aeabi_memcpy
   1258                          break;
   1259                      default:
   1260                          break;
   1261                  }
   1262          
   1263                  return kStatus_Success;
   \                     ??DCP_HASH_Finish_8: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xE019             B.N      ??DCP_HASH_Finish_0
   1264              }
   1265          #endif /* DCP_HASH_CAVP_COMPATIBLE */
   1266          
   1267              /* flush message last incomplete block, if there is any, and add padding bits */
   1268              status = dcp_hash_finalize(base, ctxInternal);
   \                     ??DCP_HASH_Finish_6: (+1)
   \       0x84   0x4629             MOV      R1,R5
   \       0x86   0x4638             MOV      R0,R7
   \       0x88   0x....'....        BL       dcp_hash_finalize
   \       0x8C   0x4607             MOV      R7,R0
   1269          
   1270              if (outputSize)
   \       0x8E   0x2C00             CMP      R4,#+0
   \       0x90   0xD006             BEQ.N    ??DCP_HASH_Finish_9
   1271              {
   1272                  if (algOutSize < *outputSize)
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x4580             CMP      R8,R0
   \       0x96   0xD202             BCS.N    ??DCP_HASH_Finish_10
   1273                  {
   1274                      *outputSize = algOutSize;
   \       0x98   0xF8C4 0x8000      STR      R8,[R4, #+0]
   \       0x9C   0xE000             B.N      ??DCP_HASH_Finish_9
   1275                  }
   1276                  else
   1277                  {
   1278                      algOutSize = *outputSize;
   \                     ??DCP_HASH_Finish_10: (+1)
   \       0x9E   0x4680             MOV      R8,R0
   1279                  }
   1280              }
   1281          
   1282              /* Reverse and copy result to output[] */
   1283              dcp_reverse_and_copy((uint8_t *)ctxInternal->runningHash, &output[0], algOutSize);
   \                     ??DCP_HASH_Finish_9: (+1)
   \       0xA0   0x4642             MOV      R2,R8
   \       0xA2   0x4631             MOV      R1,R6
   \       0xA4   0xF105 0x0090      ADD      R0,R5,#+144
   \       0xA8   0x....'....        BL       dcp_reverse_and_copy
   1284          
   1285              memset(ctx, 0, sizeof(dcp_hash_ctx_t));
   \       0xAC   0x2200             MOVS     R2,#+0
   \       0xAE   0x21E8             MOVS     R1,#+232
   \       0xB0   0x4628             MOV      R0,R5
   \       0xB2   0x....'....        BL       __aeabi_memset4
   1286              return status;
   \       0xB6   0x4638             MOV      R0,R7
   \                     ??DCP_HASH_Finish_0: (+1)
   \       0xB8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1287          }
   1288          
   1289          /*!
   1290           * brief Create HASH on given data
   1291           *
   1292           * Perform the full SHA or CRC32 in one function call. The function is blocking.
   1293           *
   1294           * param base DCP peripheral base address
   1295           * param handle Handle used for the request.
   1296           * param algo Underlaying algorithm to use for hash computation.
   1297           * param input Input data
   1298           * param inputSize Size of input data in bytes
   1299           * param[out] output Output hash data
   1300           * param[out] outputSize Output parameter storing the size of the output hash in bytes
   1301           * return Status of the one call hash operation.
   1302           */

   \                                 In section .text, align 2, keep-with-next
   1303          status_t DCP_HASH(DCP_Type *base,
   1304                            dcp_handle_t *handle,
   1305                            dcp_hash_algo_t algo,
   1306                            const uint8_t *input,
   1307                            size_t inputSize,
   1308                            uint8_t *output,
   1309                            size_t *outputSize)
   1310          {
   \                     DCP_HASH: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB0BA             SUB      SP,SP,#+232
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x461D             MOV      R5,R3
   1311              dcp_hash_ctx_t hashCtx;
   1312              status_t status;
   1313          
   1314              status = DCP_HASH_Init(base, handle, &hashCtx, algo);
   \        0x8   0x4613             MOV      R3,R2
   \        0xA   0x466A             MOV      R2,SP
   \        0xC   0x....'....        BL       DCP_HASH_Init
   1315              if (status != kStatus_Success)
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD10D             BNE.N    ??DCP_HASH_0
   1316              {
   1317                  return status;
   \       0x14   0x9B3E             LDR      R3,[SP, #+248]
   1318              }
   1319          
   1320              status = DCP_HASH_Update(base, &hashCtx, input, inputSize);
   \       0x16   0x462A             MOV      R2,R5
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x....'....        BL       DCP_HASH_Update
   1321              if (status != kStatus_Success)
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD105             BNE.N    ??DCP_HASH_0
   1322              {
   1323                  return status;
   \       0x24   0x9B40             LDR      R3,[SP, #+256]
   \       0x26   0x9A3F             LDR      R2,[SP, #+252]
   1324              }
   1325          
   1326              status = DCP_HASH_Finish(base, &hashCtx, output, outputSize);
   1327          
   1328              return status;
   \       0x28   0x4669             MOV      R1,SP
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       DCP_HASH_Finish
   \                     ??DCP_HASH_0: (+1)
   \       0x30   0xB03B             ADD      SP,SP,#+236
   \       0x32   0xBD30             POP      {R4,R5,PC}       ;; return
   1329          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x400F'C068        DC32     0x400fc068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0xF080'0000        DC32     0xf0800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x....'....        DC32     s_dcpContextSwitchingBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x....'....        DC32     s_dcpContextSwitchingBuffer+0xAC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0x....'....        DC32     s_dcpContextSwitchingBuffer+0x78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \        0x0   0x....'....        DC32     s_dcpContextSwitchingBuffer+0x44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \        0x0   0x....'....        DC32     s_dcpContextSwitchingBuffer+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \        0x0   0x....'....        DC32     s_nullSha256

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \        0x0   0x....'....        DC32     s_nullSha1

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x6E          DC8 "index <= 6"
   \              0x64 0x65    
   \              0x78 0x20    
   \              0x3C 0x3D    
   \              0x20 0x36    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
   \              0x5C 0x44    
   \              0x65 0x76    
   \              0x65 0x6C    
   \        0x8   0x6F 0x70          DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73    
   \       0x10   0x6D 0x61          DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
   \              0x72 0x74    
   \              0x5F 0x77    
   \              0x61 0x73    
   \       0x18   0x68 0x69          DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
   \              0x6E 0x67    
   \              0x5F 0x6D    
   \              0x61 0x63    
   \       0x20   0x68 0x69          DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
   \              0x6E 0x65    
   \              0x5F 0x33    
   \              0x30 0x38    
   \       0x28   0x30 0x5C          DC8 30H, 5CH, 64H, 72H, 69H, 76H, 65H, 72H
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \       0x30   0x73 0x5C          DC8 73H, 5CH, 66H, 73H, 6CH, 5FH, 63H, 6CH
   \              0x66 0x73    
   \              0x6C 0x5F    
   \              0x63 0x6C    
   \       0x38   0x6F 0x63          DC8 6FH, 63H, 6BH, 2EH, 68H, 0
   \              0x6B 0x2E    
   \              0x68 0x00    
   \       0x3E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x01 0x00          DC8 1, 0, 1, 15, 0, 0, 0, 0
   \              0x01 0x0F    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CLOCK_ControlGate
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   CLOCK_DisableClock
         0   -> CLOCK_ControlGate
       0   CLOCK_EnableClock
         0   -> CLOCK_ControlGate
      72   DCP_AES_DecryptCbc
        72   -> DCP_AES_DecryptCbcNonBlocking
        72   -> DCP_WaitForChannelComplete
        72   -> __aeabi_memclr4
      24   DCP_AES_DecryptCbcNonBlocking
        24   -> __aeabi_memcpy
         0   -> dcp_schedule_work
      64   DCP_AES_DecryptEcb
        64   -> DCP_AES_DecryptEcbNonBlocking
        64   -> DCP_WaitForChannelComplete
        64   -> __aeabi_memclr4
      16   DCP_AES_DecryptEcbNonBlocking
         0   -> dcp_schedule_work
      72   DCP_AES_EncryptCbc
        72   -> DCP_AES_EncryptCbcNonBlocking
        72   -> DCP_WaitForChannelComplete
        72   -> __aeabi_memclr4
      24   DCP_AES_EncryptCbcNonBlocking
        24   -> __aeabi_memcpy
         0   -> dcp_schedule_work
      64   DCP_AES_EncryptEcb
        64   -> DCP_AES_EncryptEcbNonBlocking
        64   -> DCP_WaitForChannelComplete
        64   -> __aeabi_memclr4
      16   DCP_AES_EncryptEcbNonBlocking
         0   -> dcp_schedule_work
      16   DCP_AES_SetKey
        16   -> dcp_aes_set_sram_based_key
       8   DCP_Deinit
         0   -> CLOCK_DisableClock
         8   -> __aeabi_memset4
       8   DCP_GetDefaultConfig
         0   -> __aeabi_memcpy
         8   -> __aeabi_memset
     248   DCP_HASH
       248   -> DCP_HASH_Finish
       248   -> DCP_HASH_Init
       248   -> DCP_HASH_Update
      24   DCP_HASH_Finish
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset4
        24   -> dcp_hash_check_context
        24   -> dcp_hash_engine_init
        24   -> dcp_hash_finalize
        24   -> dcp_hash_restore_running_hash
        24   -> dcp_reverse_and_copy
      16   DCP_HASH_Init
        16   -> dcp_hash_check_input_args
      24   DCP_HASH_Update
        24   -> __aeabi_memcpy
        24   -> dcp_hash_check_context
        24   -> dcp_hash_engine_init
        24   -> dcp_hash_process_message_data
        24   -> dcp_hash_restore_running_hash
        24   -> dcp_hash_save_running_hash
      16   DCP_Init
        16   -> CLOCK_EnableClock
        16   -> dcp_clear_channel_status
        16   -> dcp_clear_status
      16   DCP_WaitForChannelComplete
        16   -> dcp_clear_channel_status
        16   -> dcp_clear_status
        16   -> dcp_get_channel_status
       0   DisableGlobalIRQ
       0   EnableGlobalIRQ
       4   dcp_aes_set_sram_based_key
       0   dcp_clear_channel_status
       0   dcp_clear_status
       4   dcp_get_channel_status
       8   dcp_hash_check_context
         8   -> dcp_hash_check_input_alg
       0   dcp_hash_check_input_alg
      16   dcp_hash_check_input_args
        16   -> dcp_hash_check_input_alg
       0   dcp_hash_engine_init
       0   dcp_hash_finalize
         0   -> dcp_hash_update
      32   dcp_hash_process_message_data
        32   -> __aeabi_memcpy
        32   -> dcp_hash_update
       0   dcp_hash_restore_running_hash
         0   -> __aeabi_memcpy4
       0   dcp_hash_save_running_hash
         0   -> __aeabi_memcpy4
      56   dcp_hash_update
        56   -> DCP_WaitForChannelComplete
        56   -> __aeabi_memclr4
        56   -> dcp_hash_update_non_blocking
      16   dcp_hash_update_non_blocking
         0   -> dcp_schedule_work
       4   dcp_reverse_and_copy
      16   dcp_schedule_work
        16   -> DisableGlobalIRQ
        16   -> EnableGlobalIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      12  ?_0
      64  ?_1
      32  ?_2
      32  ?_3
      32  ?_4
      32  ?_5
       8  ?_6
      32  ?_7
      64  CLOCK_ControlGate
       4  CLOCK_DisableClock
       4  CLOCK_EnableClock
      78  DCP_AES_DecryptCbc
     156  DCP_AES_DecryptCbcNonBlocking
      70  DCP_AES_DecryptEcb
     112  DCP_AES_DecryptEcbNonBlocking
      78  DCP_AES_EncryptCbc
     156  DCP_AES_EncryptCbcNonBlocking
      70  DCP_AES_EncryptEcb
     112  DCP_AES_EncryptEcbNonBlocking
      80  DCP_AES_SetKey
      28  DCP_Deinit
      28  DCP_GetDefaultConfig
      52  DCP_HASH
     188  DCP_HASH_Finish
      60  DCP_HASH_Init
     134  DCP_HASH_Update
      74  DCP_Init
      52  DCP_WaitForChannelComplete
       8  DisableGlobalIRQ
       6  EnableGlobalIRQ
      38  dcp_aes_set_sram_based_key
      42  dcp_clear_channel_status
       6  dcp_clear_status
      92  dcp_get_channel_status
      30  dcp_hash_check_context
      22  dcp_hash_check_input_alg
      32  dcp_hash_check_input_args
      30  dcp_hash_engine_init
      22  dcp_hash_finalize
     114  dcp_hash_process_message_data
      66  dcp_hash_restore_running_hash
      62  dcp_hash_save_running_hash
      62  dcp_hash_update
      94  dcp_hash_update_non_blocking
      24  dcp_reverse_and_copy
     136  dcp_schedule_work
     208  s_dcpContextSwitchingBuffer
      20  s_nullSha1
      32  s_nullSha256

 
   208 bytes in section .bss
    52 bytes in section .data
   244 bytes in section .rodata
 2 534 bytes in section .text
 
 2 534 bytes of CODE  memory
   244 bytes of CONST memory
   260 bytes of DATA  memory

Errors: none
Warnings: none
