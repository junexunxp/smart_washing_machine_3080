###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:22
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\drivers\fsl_flexspi.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWE487.tmp
#        (C:\Development\smart_washing_machine_3080\drivers\fsl_flexspi.c -D
#        DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1
#        -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE
#        -D "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\fsl_flexspi.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\fsl_flexspi.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\drivers\fsl_flexspi.c
      1          /*
      2           * Copyright (c) 2016, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           * All rights reserved.
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           */
      8          
      9          #include "fsl_flexspi.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xD408             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xF000 0x011F      AND      R1,R0,#0x1F
   \        0xA   0x408A             LSLS     R2,R2,R1
   \        0xC   0x....'....        LDR.W    R1,??DataTable11  ;; 0xe000e100
   \       0x10   0x0940             LSRS     R0,R0,#+5
   \       0x12   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_ControlGate(clock_ip_name_t, clock_gate_value_t)
   \                     CLOCK_ControlGate: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4626             MOV      R6,R4
   \        0x8   0x0A36             LSRS     R6,R6,#+8
   \        0xA   0xF004 0x041F      AND      R4,R4,#0x1F
   \        0xE   0x2E07             CMP      R6,#+7
   \       0x10   0xD309             BCC.N    ??CLOCK_ControlGate_0
   \       0x12   0xF240 0x32C1      MOVW     R2,#+961
   \       0x16   0x....'....        LDR.W    R1,??DataTable11_1
   \       0x1A   0x....'....        LDR.W    R0,??DataTable11_2
   \       0x1E   0x....'....        BL       __aeabi_assert
   \       0x22   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??CLOCK_ControlGate_0: (+1)
   \       0x26   0x....'....        LDR.W    R0,??DataTable11_3  ;; 0x400fc068
   \       0x2A   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0x2203             MOVS     R2,#+3
   \       0x32   0x40A2             LSLS     R2,R2,R4
   \       0x34   0x4391             BICS     R1,R1,R2
   \       0x36   0xFA05 0xF404      LSL      R4,R5,R4
   \       0x3A   0x430C             ORRS     R4,R4,R1
   \       0x3C   0x6004             STR      R4,[R0, #+0]
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \        0x0   0x2103             MOVS     R1,#+3
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int32_t EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0xF06F 0x027F      MVN      R2,#+127
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD101             BNE.N    ??EnableIRQ_0
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xBD02             POP      {R1,PC}
   \                     ??EnableIRQ_0: (+1)
   \       0x10   0x....'....        BL       __NVIC_EnableIRQ
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXSPI_SoftwareReset(FLEXSPI_Type *)
   \                     FLEXSPI_SoftwareReset: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \                     ??FLEXSPI_SoftwareReset_0: (+1)
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x07C9             LSLS     R1,R1,#+31
   \        0xC   0xD4FC             BMI.N    ??FLEXSPI_SoftwareReset_0
   \        0xE   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXSPI_EnableInterrupts(FLEXSPI_Type *, uint32_t)
   \                     FLEXSPI_EnableInterrupts: (+1)
   \        0x0   0x6902             LDR      R2,[R0, #+16]
   \        0x2   0x4311             ORRS     R1,R1,R2
   \        0x4   0x6101             STR      R1,[R0, #+16]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXSPI_DisableInterrupts(FLEXSPI_Type *, uint32_t)
   \                     FLEXSPI_DisableInterrupts: (+1)
   \        0x0   0x6902             LDR      R2,[R0, #+16]
   \        0x2   0xEA22 0x0101      BIC      R1,R2,R1
   \        0x6   0x6101             STR      R1,[R0, #+16]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXSPI_ClearInterruptStatusFlags(FLEXSPI_Type *, uint32_t)
   \                     FLEXSPI_ClearInterruptStatusFlags: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
   \        0x2   0x4311             ORRS     R1,R1,R2
   \        0x4   0x6141             STR      R1,[R0, #+20]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp bool FLEXSPI_GetBusIdleStatus(FLEXSPI_Type *)
   \                     FLEXSPI_GetBusIdleStatus: (+1)
   \        0x0   0xF8D0 0x10E0      LDR      R1,[R0, #+224]
   \        0x4   0x0789             LSLS     R1,R1,#+30
   \        0x6   0xD504             BPL.N    ??FLEXSPI_GetBusIdleStatus_0
   \        0x8   0xF8D0 0x00E0      LDR      R0,[R0, #+224]
   \        0xC   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x10   0x4770             BX       LR
   \                     ??FLEXSPI_GetBusIdleStatus_0: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
     10          
     11          /* Component ID definition, used by tools. */
     12          #ifndef FSL_COMPONENT_ID
     13          #define FSL_COMPONENT_ID "platform.drivers.flexspi"
     14          #endif
     15          
     16          /*******************************************************************************
     17           * Definitations
     18           ******************************************************************************/
     19          
     20          #define FREQ_1MHz (1000000UL)
     21          #define FLEXSPI_DLLCR_DEFAULT (0x100UL)
     22          #define FLEXSPI_LUT_KEY_VAL (0x5AF05AF0ul)
     23          
     24          enum
     25          {
     26              kFLEXSPI_DelayCellUnitMin = 75,  /* 75ps. */
     27              kFLEXSPI_DelayCellUnitMax = 225, /* 225ps. */
     28          };
     29          
     30          /*! @brief Common sets of flags used by the driver. */
     31          enum _flexspi_flag_constants
     32          {
     33              /*! IRQ sources enabled by the non-blocking transactional API. */
     34              kIrqFlags = kFLEXSPI_IpTxFifoWatermarkEmpltyFlag | kFLEXSPI_IpRxFifoWatermarkAvailableFlag |
     35                          kFLEXSPI_SequenceExecutionTimeoutFlag | kFLEXSPI_IpCommandSequenceErrorFlag |
     36                          kFLEXSPI_IpCommandGrantTimeoutFlag | kFLEXSPI_IpCommandExcutionDoneFlag,
     37          
     38              /*! Errors to check for. */
     39              kErrorFlags = kFLEXSPI_SequenceExecutionTimeoutFlag | kFLEXSPI_IpCommandSequenceErrorFlag |
     40                            kFLEXSPI_IpCommandGrantTimeoutFlag,
     41          };
     42          
     43          enum _flexspi_transfer_state
     44          {
     45              kFLEXSPI_Idle = 0x0U,      /*!< Transfer is done. */
     46              kFLEXSPI_BusyWrite = 0x1U, /*!< FLEXSPI is busy write transfer. */
     47              kFLEXSPI_BusyRead = 0x2U,  /*!< FLEXSPI is busy write transfer. */
     48          };
     49          
     50          /*! @brief Typedef for interrupt handler. */
     51          typedef void (*flexspi_isr_t)(FLEXSPI_Type *base, void *flexspiHandle);
     52          
     53          /*******************************************************************************
     54           * Prototypes
     55           ******************************************************************************/
     56          /*!
     57          * @brief Get the instance number for FLEXSPI.
     58          *
     59          * @param base FLEXSPI base pointer.
     60          */
     61          uint32_t FLEXSPI_GetInstance(FLEXSPI_Type *base);
     62          
     63          /*!
     64          * @brief Configure flash A/B sample clock DLL.
     65          *
     66          * @param base FLEXSPI base pointer.
     67          * @param config Flash configuration parameters.
     68          */
     69          static uint32_t FLEXSPI_ConfigureDll(FLEXSPI_Type *base, flexspi_device_config_t *config);
     70          
     71          /*!
     72          * @brief Check and clear IP command execution errors.
     73          *
     74          * @param base FLEXSPI base pointer.
     75          * @param status interrupt status.
     76          */
     77          status_t FLEXSPI_CheckAndClearError(FLEXSPI_Type *base, uint32_t status);
     78          
     79          /*******************************************************************************
     80           * Variables
     81           ******************************************************************************/
     82          /*! @brief Pointers to flexspi bases for each instance. */
     83          static FLEXSPI_Type *const s_flexspiBases[] = FLEXSPI_BASE_PTRS;
     84          
     85          /*! @brief Pointers to flexspi IRQ number for each instance. */

   \                                 In section .rodata, align 2
     86          static const IRQn_Type s_flexspiIrqs[] = FLEXSPI_IRQS;
   \                     s_flexspiIrqs:
   \        0x0   0x006C             DC16 108
     87          
     88          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
     89          /* Clock name array */

   \                                 In section .rodata, align 2
     90          static const clock_ip_name_t s_flexspiClock[] = FLEXSPI_CLOCKS;
   \                     s_flexspiClock:
   \        0x0   0x060A             DC16 1546
     91          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
     92          
     93          #if defined(FSL_DRIVER_TRANSFER_DOUBLE_WEAK_IRQ) && FSL_DRIVER_TRANSFER_DOUBLE_WEAK_IRQ
     94          /*! @brief Pointers to flexspi handles for each instance. */
     95          static void *s_flexspiHandle[ARRAY_SIZE(s_flexspiBases)];
     96          #endif
     97          
     98          /*******************************************************************************
     99           * Code
    100           ******************************************************************************/
    101          

   \                                 In section .text, align 2, keep-with-next
    102          uint32_t FLEXSPI_GetInstance(FLEXSPI_Type *base)
    103          {
   \                     FLEXSPI_GetInstance: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    104              uint32_t instance;
    105          
    106              /* Find the instance index from base address mappings. */
    107              for (instance = 0; instance < ARRAY_SIZE(s_flexspiBases); instance++)
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x....'....        LDR.W    R1,??DataTable11_4  ;; 0x402a8000
   \                     ??FLEXSPI_GetInstance_0: (+1)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD103             BNE.N    ??FLEXSPI_GetInstance_1
    108              {
    109                  if (s_flexspiBases[instance] == base)
   \        0xC   0x4288             CMP      R0,R1
   \        0xE   0xD001             BEQ.N    ??FLEXSPI_GetInstance_1
    110                  {
    111                      break;
    112                  }
    113              }
   \       0x10   0x2401             MOVS     R4,#+1
   \       0x12   0xE7F9             B.N      ??FLEXSPI_GetInstance_0
    114          
    115              assert(instance < ARRAY_SIZE(s_flexspiBases));
   \                     ??FLEXSPI_GetInstance_1: (+1)
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD008             BEQ.N    ??FLEXSPI_GetInstance_2
   \       0x18   0x2273             MOVS     R2,#+115
   \       0x1A   0x....'....        LDR.W    R1,??DataTable11_5
   \       0x1E   0x....'....        LDR.W    R0,??DataTable11_6
   \       0x22   0x....'....        BL       __aeabi_assert
   \       0x26   0x....'....        BL       __iar_EmptyStepPoint
    116          
    117              return instance;
   \                     ??FLEXSPI_GetInstance_2: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
    118          }
    119          

   \                                 In section .text, align 2, keep-with-next
    120          static uint32_t FLEXSPI_ConfigureDll(FLEXSPI_Type *base, flexspi_device_config_t *config)
    121          {
    122              bool isUnifiedConfig = true;
   \                     FLEXSPI_ConfigureDll: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
    123              uint32_t flexspiDllValue;
    124              uint32_t dllValue;
    125              uint32_t temp;
    126          
    127              uint8_t rxSampleClock = (base->MCR0 & FLEXSPI_MCR0_RXCLKSRC_MASK) >> FLEXSPI_MCR0_RXCLKSRC_SHIFT;
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF3C0 0x1001      UBFX     R0,R0,#+4,#+2
    128              switch (rxSampleClock)
   \        0x8   0x2803             CMP      R0,#+3
   \        0xA   0xD103             BNE.N    ??FLEXSPI_ConfigureDll_0
    129              {
    130                  case kFLEXSPI_ReadSampleClkLoopbackInternally:
    131                  case kFLEXSPI_ReadSampleClkLoopbackFromDqsPad:
    132                  case kFLEXSPI_ReadSampleClkLoopbackFromSckPad:
    133                      isUnifiedConfig = true;
    134                      break;
    135                  case kFLEXSPI_ReadSampleClkExternalInputFromDqsPad:
    136                      if (config->isSck2Enabled)
   \        0xC   0x7908             LDRB     R0,[R1, #+4]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD100             BNE.N    ??FLEXSPI_ConfigureDll_0
    137                      {
    138                          isUnifiedConfig = true;
    139                      }
    140                      else
    141                      {
    142                          isUnifiedConfig = false;
   \       0x12   0x2200             MOVS     R2,#+0
    143                      }
    144                      break;
    145                  default:
    146                      break;
    147              }
    148          
    149              if (isUnifiedConfig)
   \                     ??FLEXSPI_ConfigureDll_0: (+1)
   \       0x14   0x2A00             CMP      R2,#+0
   \       0x16   0xD002             BEQ.N    ??FLEXSPI_ConfigureDll_1
    150              {
    151                  flexspiDllValue = FLEXSPI_DLLCR_DEFAULT; /* 1 fixed delay cells in DLL delay chain) */
   \       0x18   0xF44F 0x7080      MOV      R0,#+256
   \       0x1C   0x4770             BX       LR
    152              }
    153              else
    154              {
    155                  if (config->flexspiRootClk >= 100 * FREQ_1MHz)
   \                     ??FLEXSPI_ConfigureDll_1: (+1)
   \       0x1E   0x6808             LDR      R0,[R1, #+0]
   \       0x20   0x....'....        LDR.W    R2,??DataTable11_7  ;; 0x5f5e100
   \       0x24   0x4290             CMP      R0,R2
   \       0x26   0xD301             BCC.N    ??FLEXSPI_ConfigureDll_2
    156                  {
    157                      /* DLLEN = 1, SLVDLYTARGET = 0xF, */
    158                      flexspiDllValue = FLEXSPI_DLLCR_DLLEN(1) | FLEXSPI_DLLCR_SLVDLYTARGET(0x0F);
   \       0x28   0x2079             MOVS     R0,#+121
   \       0x2A   0x4770             BX       LR
    159                  }
    160                  else
    161                  {
    162                      temp = config->dataValidTime * 1000; /* Convert data valid time in ns to ps. */
   \                     ??FLEXSPI_ConfigureDll_2: (+1)
   \       0x2C   0x7C89             LDRB     R1,[R1, #+18]
   \       0x2E   0xF44F 0x707A      MOV      R0,#+1000
   \       0x32   0xFB10 0xF101      SMULBB   R1,R0,R1
    163                      dllValue = temp / kFLEXSPI_DelayCellUnitMin;
   \       0x36   0x204B             MOVS     R0,#+75
   \       0x38   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    164                      if (dllValue * kFLEXSPI_DelayCellUnitMin < temp)
   \       0x3C   0x224B             MOVS     R2,#+75
   \       0x3E   0x4342             MULS     R2,R2,R0
   \       0x40   0x428A             CMP      R2,R1
   \       0x42   0xD200             BCS.N    ??FLEXSPI_ConfigureDll_3
    165                      {
    166                          dllValue++;
   \       0x44   0x1C40             ADDS     R0,R0,#+1
    167                      }
    168                      flexspiDllValue = FLEXSPI_DLLCR_OVRDEN(1) | FLEXSPI_DLLCR_OVRDVAL(dllValue);
   \                     ??FLEXSPI_ConfigureDll_3: (+1)
   \       0x46   0x0240             LSLS     R0,R0,#+9
   \       0x48   0xF400 0x40FC      AND      R0,R0,#0x7E00
   \       0x4C   0xF440 0x7080      ORR      R0,R0,#0x100
    169                  }
    170              }
    171              return flexspiDllValue;
   \       0x50   0x4770             BX       LR               ;; return
    172          }
    173          

   \                                 In section .text, align 2, keep-with-next
    174          status_t FLEXSPI_CheckAndClearError(FLEXSPI_Type *base, uint32_t status)
    175          {
   \                     FLEXSPI_CheckAndClearError: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
    176              status_t result = kStatus_Success;
   \        0x6   0x2500             MOVS     R5,#+0
    177          
    178              /* Check for error. */
    179              status &= kErrorFlags;
   \        0x8   0xF640 0x000A      MOVW     R0,#+2058
   \        0xC   0x4004             ANDS     R4,R0,R4
    180              if (status)
   \        0xE   0xD026             BEQ.N    ??FLEXSPI_CheckAndClearError_0
    181              {
    182                  /* Select the correct error code.. */
    183                  if (status & kFLEXSPI_SequenceExecutionTimeoutFlag)
   \       0x10   0x0520             LSLS     R0,R4,#+20
   \       0x12   0xD502             BPL.N    ??FLEXSPI_CheckAndClearError_1
    184                  {
    185                      result = kStatus_FLEXSPI_SequenceExecutionTimeout;
   \       0x14   0xF641 0x3559      MOVW     R5,#+7001
   \       0x18   0xE011             B.N      ??FLEXSPI_CheckAndClearError_2
    186                  }
    187                  else if (status & kFLEXSPI_IpCommandSequenceErrorFlag)
   \                     ??FLEXSPI_CheckAndClearError_1: (+1)
   \       0x1A   0x0720             LSLS     R0,R4,#+28
   \       0x1C   0xD502             BPL.N    ??FLEXSPI_CheckAndClearError_3
    188                  {
    189                      result = kStatus_FLEXSPI_IpCommandSequenceError;
   \       0x1E   0xF641 0x355A      MOVW     R5,#+7002
   \       0x22   0xE00C             B.N      ??FLEXSPI_CheckAndClearError_2
    190                  }
    191                  else if (status & kFLEXSPI_IpCommandGrantTimeoutFlag)
   \                     ??FLEXSPI_CheckAndClearError_3: (+1)
   \       0x24   0x07A0             LSLS     R0,R4,#+30
   \       0x26   0xD502             BPL.N    ??FLEXSPI_CheckAndClearError_4
    192                  {
    193                      result = kStatus_FLEXSPI_IpCommandGrantTimeout;
   \       0x28   0xF641 0x355B      MOVW     R5,#+7003
   \       0x2C   0xE007             B.N      ??FLEXSPI_CheckAndClearError_2
    194                  }
    195                  else
    196                  {
    197                      assert(false);
   \                     ??FLEXSPI_CheckAndClearError_4: (+1)
   \       0x2E   0x22C5             MOVS     R2,#+197
   \       0x30   0x....'....        LDR.W    R1,??DataTable11_5
   \       0x34   0x....             ADR.N    R0,??DataTable6  ;; "0"
   \       0x36   0x....'....        BL       __aeabi_assert
   \       0x3A   0x....'....        BL       __iar_EmptyStepPoint
    198                  }
    199          
    200                  /* Clear the flags. */
    201                  FLEXSPI_ClearInterruptStatusFlags(base, status);
   \                     ??FLEXSPI_CheckAndClearError_2: (+1)
   \       0x3E   0x4621             MOV      R1,R4
   \       0x40   0x4630             MOV      R0,R6
   \       0x42   0x....'....        BL       FLEXSPI_ClearInterruptStatusFlags
    202          
    203                  /* Reset fifos. These flags clear automatically. */
    204                  base->IPTXFCR |= FLEXSPI_IPTXFCR_CLRIPTXF_MASK;
   \       0x46   0xF8D6 0x00BC      LDR      R0,[R6, #+188]
   \       0x4A   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x4E   0xF8C6 0x00BC      STR      R0,[R6, #+188]
    205                  base->IPRXFCR |= FLEXSPI_IPRXFCR_CLRIPRXF_MASK;
   \       0x52   0xF8D6 0x00B8      LDR      R0,[R6, #+184]
   \       0x56   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x5A   0xF8C6 0x00B8      STR      R0,[R6, #+184]
    206              }
    207          
    208              return result;
   \                     ??FLEXSPI_CheckAndClearError_0: (+1)
   \       0x5E   0x4628             MOV      R0,R5
   \       0x60   0xBD70             POP      {R4-R6,PC}       ;; return
    209          }
    210          
    211          /*!
    212           * brief Initializes the FLEXSPI module and internal state.
    213           *
    214           * This function enables the clock for FLEXSPI and also configures the FLEXSPI with the
    215           * input configure parameters. Users should call this function before any FLEXSPI operations.
    216           *
    217           * param base FLEXSPI peripheral base address.
    218           * param config FLEXSPI configure structure.
    219           */

   \                                 In section .text, align 2, keep-with-next
    220          void FLEXSPI_Init(FLEXSPI_Type *base, const flexspi_config_t *config)
    221          {
   \                     FLEXSPI_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    222              uint32_t configValue = 0;
    223              uint8_t i = 0;
    224          
    225          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    226              /* Enable the flexspi clock */
    227              CLOCK_EnableClock(s_flexspiClock[FLEXSPI_GetInstance(base)]);
   \        0x6   0x....'....        BL       FLEXSPI_GetInstance
   \        0xA   0x....'....        LDR.W    R1,??DataTable11_8
   \        0xE   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x12   0x....'....        BL       CLOCK_EnableClock
    228          
    229          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    230          
    231              /* Reset peripheral before configuring it. */
    232              base->MCR0 &= ~FLEXSPI_MCR0_MDIS_MASK;
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0xF020 0x0002      BIC      R0,R0,#0x2
   \       0x1C   0x6020             STR      R0,[R4, #+0]
    233              FLEXSPI_SoftwareReset(base);
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x....'....        BL       FLEXSPI_SoftwareReset
    234          
    235              /* Configure MCR0 configuration items. */
    236              configValue = FLEXSPI_MCR0_RXCLKSRC(config->rxSampleClock) | FLEXSPI_MCR0_DOZEEN(config->enableDoze) |
    237                            FLEXSPI_MCR0_IPGRANTWAIT(config->ipGrantTimeoutCycle) |
    238                            FLEXSPI_MCR0_AHBGRANTWAIT(config->ahbConfig.ahbGrantTimeoutCycle) |
    239                            FLEXSPI_MCR0_SCKFREERUNEN(config->enableSckFreeRunning) |
    240                            FLEXSPI_MCR0_HSEN(config->enableHalfSpeedAccess) |
    241                            FLEXSPI_MCR0_COMBINATIONEN(config->enableCombination) |
    242                            FLEXSPI_MCR0_ATDFEN(config->ahbConfig.enableAHBWriteIpTxFifo) |
    243                            FLEXSPI_MCR0_ARDFEN(config->ahbConfig.enableAHBWriteIpRxFifo) | FLEXSPI_MCR0_MDIS_MASK;
    244              base->MCR0 = configValue;
   \       0x24   0x7828             LDRB     R0,[R5, #+0]
   \       0x26   0x0100             LSLS     R0,R0,#+4
   \       0x28   0xF000 0x0030      AND      R0,R0,#0x30
   \       0x2C   0x78E9             LDRB     R1,[R5, #+3]
   \       0x2E   0xEA40 0x3001      ORR      R0,R0,R1, LSL #+12
   \       0x32   0x7AA9             LDRB     R1,[R5, #+10]
   \       0x34   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \       0x38   0x7C29             LDRB     R1,[R5, #+16]
   \       0x3A   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \       0x3E   0x7869             LDRB     R1,[R5, #+1]
   \       0x40   0xEA40 0x3081      ORR      R0,R0,R1, LSL #+14
   \       0x44   0x7929             LDRB     R1,[R5, #+4]
   \       0x46   0xEA40 0x20C1      ORR      R0,R0,R1, LSL #+11
   \       0x4A   0x78A9             LDRB     R1,[R5, #+2]
   \       0x4C   0xEA40 0x3041      ORR      R0,R0,R1, LSL #+13
   \       0x50   0x7BA9             LDRB     R1,[R5, #+14]
   \       0x52   0xEA40 0x10C1      ORR      R0,R0,R1, LSL #+7
   \       0x56   0x7BE9             LDRB     R1,[R5, #+15]
   \       0x58   0xEA40 0x1081      ORR      R0,R0,R1, LSL #+6
   \       0x5C   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0x60   0x6020             STR      R0,[R4, #+0]
    245          
    246              /* Configure MCR1 configurations. */
    247              configValue =
    248                  FLEXSPI_MCR1_SEQWAIT(config->seqTimeoutCycle) | FLEXSPI_MCR1_AHBBUSWAIT(config->ahbConfig.ahbBusTimeoutCycle);
    249              base->MCR1 = configValue;
   \       0x62   0x8928             LDRH     R0,[R5, #+8]
   \       0x64   0x8A69             LDRH     R1,[R5, #+18]
   \       0x66   0xEA41 0x4100      ORR      R1,R1,R0, LSL #+16
   \       0x6A   0x6061             STR      R1,[R4, #+4]
    250          
    251              /* Configure MCR2 configurations. */
    252              configValue = base->MCR2;
   \       0x6C   0x68A1             LDR      R1,[R4, #+8]
    253              configValue &= ~(FLEXSPI_MCR2_RESUMEWAIT_MASK | FLEXSPI_MCR2_SCKBDIFFOPT_MASK | FLEXSPI_MCR2_SAMEDEVICEEN_MASK |
    254                               FLEXSPI_MCR2_CLRAHBBUFOPT_MASK);
    255              configValue |= FLEXSPI_MCR2_RESUMEWAIT(config->ahbConfig.resumeWaitCycle) |
    256                             FLEXSPI_MCR2_SCKBDIFFOPT(config->enableSckBDiffOpt) |
    257                             FLEXSPI_MCR2_SAMEDEVICEEN(config->enableSameConfigForAll) |
    258                             FLEXSPI_MCR2_CLRAHBBUFOPT(config->ahbConfig.enableClearAHBBufferOpt);
    259          
    260              base->MCR2 = configValue;
   \       0x6E   0x....'....        LDR.W    R0,??DataTable11_9  ;; 0xf777ff
   \       0x72   0x4001             ANDS     R1,R0,R1
   \       0x74   0x7D28             LDRB     R0,[R5, #+20]
   \       0x76   0xEA41 0x6100      ORR      R1,R1,R0, LSL #+24
   \       0x7A   0x7968             LDRB     R0,[R5, #+5]
   \       0x7C   0xEA41 0x41C0      ORR      R1,R1,R0, LSL #+19
   \       0x80   0x79A8             LDRB     R0,[R5, #+6]
   \       0x82   0xEA41 0x31C0      ORR      R1,R1,R0, LSL #+15
   \       0x86   0xF895 0x002E      LDRB     R0,[R5, #+46]
   \       0x8A   0xEA41 0x21C0      ORR      R1,R1,R0, LSL #+11
   \       0x8E   0x60A1             STR      R1,[R4, #+8]
    261          
    262              /* Configure AHB control items. */
    263              configValue = base->AHBCR;
   \       0x90   0x68E0             LDR      R0,[R4, #+12]
    264              configValue &= ~(FLEXSPI_AHBCR_READADDROPT_MASK | FLEXSPI_AHBCR_PREFETCHEN_MASK | FLEXSPI_AHBCR_BUFFERABLEEN_MASK |
    265                               FLEXSPI_AHBCR_CACHABLEEN_MASK);
    266              configValue |= FLEXSPI_AHBCR_READADDROPT(config->ahbConfig.enableReadAddressOpt) |
    267                             FLEXSPI_AHBCR_PREFETCHEN(config->ahbConfig.enableAHBPrefetch) |
    268                             FLEXSPI_AHBCR_BUFFERABLEEN(config->ahbConfig.enableAHBBufferable) |
    269                             FLEXSPI_AHBCR_CACHABLEEN(config->ahbConfig.enableAHBCachable);
    270              base->AHBCR = configValue;
   \       0x92   0xF020 0x0078      BIC      R0,R0,#0x78
   \       0x96   0xF895 0x102F      LDRB     R1,[R5, #+47]
   \       0x9A   0xEA40 0x1081      ORR      R0,R0,R1, LSL #+6
   \       0x9E   0xF895 0x1030      LDRB     R1,[R5, #+48]
   \       0xA2   0xEA40 0x1041      ORR      R0,R0,R1, LSL #+5
   \       0xA6   0xF895 0x1031      LDRB     R1,[R5, #+49]
   \       0xAA   0xEA40 0x1001      ORR      R0,R0,R1, LSL #+4
   \       0xAE   0xF895 0x1032      LDRB     R1,[R5, #+50]
   \       0xB2   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \       0xB6   0x60E0             STR      R0,[R4, #+12]
    271          
    272              /* Configure AHB rx buffers. */
    273              for (i = 0; i < FSL_FEATURE_FLEXSPI_AHB_BUFFER_COUNT; i++)
   \       0xB8   0x2200             MOVS     R2,#+0
   \       0xBA   0xE027             B.N      ??FLEXSPI_Init_0
    274              {
    275                  configValue = base->AHBRXBUFCR0[i];
   \                     ??FLEXSPI_Init_1: (+1)
   \       0xBC   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \       0xC0   0x6A01             LDR      R1,[R0, #+32]
    276          
    277                  configValue &= ~(FLEXSPI_AHBRXBUFCR0_PREFETCHEN_MASK | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK |
    278                                   FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
    279                  configValue |= FLEXSPI_AHBRXBUFCR0_PREFETCHEN(config->ahbConfig.buffer[i].enablePrefetch) |
    280                                 FLEXSPI_AHBRXBUFCR0_PRIORITY(config->ahbConfig.buffer[i].priority) |
    281                                 FLEXSPI_AHBRXBUFCR0_MSTRID(config->ahbConfig.buffer[i].masterIndex) |
    282                                 FLEXSPI_AHBRXBUFCR0_BUFSZ(config->ahbConfig.buffer[i].bufferSize / 8);
    283                  base->AHBRXBUFCR0[i] = configValue;
   \       0xC2   0x2006             MOVS     R0,#+6
   \       0xC4   0x....'....        LDR.W    R3,??DataTable11_10  ;; 0x7cf0ff00
   \       0xC8   0x4019             ANDS     R1,R3,R1
   \       0xCA   0xFB10 0xF302      SMULBB   R3,R0,R2
   \       0xCE   0x442B             ADD      R3,R5,R3
   \       0xD0   0x7E9B             LDRB     R3,[R3, #+26]
   \       0xD2   0xEA41 0x71C3      ORR      R1,R1,R3, LSL #+31
   \       0xD6   0xFB10 0xF302      SMULBB   R3,R0,R2
   \       0xDA   0x442B             ADD      R3,R5,R3
   \       0xDC   0x7D9B             LDRB     R3,[R3, #+22]
   \       0xDE   0x061B             LSLS     R3,R3,#+24
   \       0xE0   0xF003 0x7340      AND      R3,R3,#0x3000000
   \       0xE4   0x4319             ORRS     R1,R3,R1
   \       0xE6   0xFB10 0xF302      SMULBB   R3,R0,R2
   \       0xEA   0x442B             ADD      R3,R5,R3
   \       0xEC   0x7DDB             LDRB     R3,[R3, #+23]
   \       0xEE   0x041B             LSLS     R3,R3,#+16
   \       0xF0   0xF403 0x2370      AND      R3,R3,#0xF0000
   \       0xF4   0x4319             ORRS     R1,R3,R1
   \       0xF6   0xFB10 0xF002      SMULBB   R0,R0,R2
   \       0xFA   0x4428             ADD      R0,R5,R0
   \       0xFC   0x8B00             LDRH     R0,[R0, #+24]
   \       0xFE   0xF3C0 0x00C7      UBFX     R0,R0,#+3,#+8
   \      0x102   0x4301             ORRS     R1,R0,R1
   \      0x104   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \      0x108   0x6201             STR      R1,[R0, #+32]
    284              }
   \      0x10A   0x1C52             ADDS     R2,R2,#+1
   \                     ??FLEXSPI_Init_0: (+1)
   \      0x10C   0x2A04             CMP      R2,#+4
   \      0x10E   0xDBD5             BLT.N    ??FLEXSPI_Init_1
    285          
    286              /* Configure IP Fifo watermarks. */
    287              base->IPRXFCR &= ~FLEXSPI_IPRXFCR_RXWMRK_MASK;
   \      0x110   0xF8D4 0x00B8      LDR      R0,[R4, #+184]
   \      0x114   0xF020 0x003C      BIC      R0,R0,#0x3C
   \      0x118   0xF8C4 0x00B8      STR      R0,[R4, #+184]
    288              base->IPRXFCR |= FLEXSPI_IPRXFCR_RXWMRK(config->rxWatermark / 8 - 1);
   \      0x11C   0xF8D4 0x00B8      LDR      R0,[R4, #+184]
   \      0x120   0x7B29             LDRB     R1,[R5, #+12]
   \      0x122   0x08C9             LSRS     R1,R1,#+3
   \      0x124   0x1E49             SUBS     R1,R1,#+1
   \      0x126   0x0089             LSLS     R1,R1,#+2
   \      0x128   0xF001 0x013C      AND      R1,R1,#0x3C
   \      0x12C   0x4308             ORRS     R0,R1,R0
   \      0x12E   0xF8C4 0x00B8      STR      R0,[R4, #+184]
    289              base->IPTXFCR &= ~FLEXSPI_IPTXFCR_TXWMRK_MASK;
   \      0x132   0xF8D4 0x00BC      LDR      R0,[R4, #+188]
   \      0x136   0xF020 0x003C      BIC      R0,R0,#0x3C
   \      0x13A   0xF8C4 0x00BC      STR      R0,[R4, #+188]
    290              base->IPTXFCR |= FLEXSPI_IPTXFCR_TXWMRK(config->txWatermark / 8 - 1);
   \      0x13E   0xF8D4 0x00BC      LDR      R0,[R4, #+188]
   \      0x142   0x7AE9             LDRB     R1,[R5, #+11]
   \      0x144   0x08C9             LSRS     R1,R1,#+3
   \      0x146   0x1E49             SUBS     R1,R1,#+1
   \      0x148   0x0089             LSLS     R1,R1,#+2
   \      0x14A   0xF001 0x013C      AND      R1,R1,#0x3C
   \      0x14E   0x4308             ORRS     R0,R1,R0
   \      0x150   0xF8C4 0x00BC      STR      R0,[R4, #+188]
    291          
    292              /* Reset flash size on all ports */
    293              for (i = 0; i < kFLEXSPI_PortCount; i++)
   \      0x154   0x2000             MOVS     R0,#+0
   \      0x156   0x4601             MOV      R1,R0
   \      0x158   0xE003             B.N      ??FLEXSPI_Init_2
    294              {
    295                  base->FLSHCR0[i] = 0;
   \                     ??FLEXSPI_Init_3: (+1)
   \      0x15A   0xEB04 0x0280      ADD      R2,R4,R0, LSL #+2
   \      0x15E   0x6611             STR      R1,[R2, #+96]
    296              }
   \      0x160   0x1C40             ADDS     R0,R0,#+1
   \                     ??FLEXSPI_Init_2: (+1)
   \      0x162   0x2804             CMP      R0,#+4
   \      0x164   0xDBF9             BLT.N    ??FLEXSPI_Init_3
    297          }
   \      0x166   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    298          
    299          /*!
    300           * brief Gets default settings for FLEXSPI.
    301           *
    302           * param config FLEXSPI configuration structure.
    303           */

   \                                 In section .text, align 2, keep-with-next
    304          void FLEXSPI_GetDefaultConfig(flexspi_config_t *config)
    305          {
   \                     FLEXSPI_GetDefaultConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    306              /* Initializes the configure structure to zero. */
    307              memset(config, 0, sizeof(*config));
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2134             MOVS     R1,#+52
   \        0x8   0x....'....        BL       __aeabi_memset
    308          
    309              config->rxSampleClock = kFLEXSPI_ReadSampleClkLoopbackInternally;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x7020             STRB     R0,[R4, #+0]
    310              config->enableSckFreeRunning = false;
   \       0x10   0x7060             STRB     R0,[R4, #+1]
    311              config->enableCombination = false;
   \       0x12   0x70A0             STRB     R0,[R4, #+2]
    312              config->enableDoze = true;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x70E0             STRB     R0,[R4, #+3]
    313              config->enableHalfSpeedAccess = false;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x7120             STRB     R0,[R4, #+4]
    314              config->enableSckBDiffOpt = false;
   \       0x1C   0x7160             STRB     R0,[R4, #+5]
    315              config->enableSameConfigForAll = false;
   \       0x1E   0x71A0             STRB     R0,[R4, #+6]
    316              config->seqTimeoutCycle = 0xFFFFU;
   \       0x20   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x24   0x8120             STRH     R0,[R4, #+8]
    317              config->ipGrantTimeoutCycle = 0xFFU;
   \       0x26   0x21FF             MOVS     R1,#+255
   \       0x28   0x72A1             STRB     R1,[R4, #+10]
    318              config->txWatermark = 8;
   \       0x2A   0x2208             MOVS     R2,#+8
   \       0x2C   0x72E2             STRB     R2,[R4, #+11]
    319              config->rxWatermark = 8;
   \       0x2E   0x7322             STRB     R2,[R4, #+12]
    320              config->ahbConfig.enableAHBWriteIpTxFifo = false;
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x73A2             STRB     R2,[R4, #+14]
    321              config->ahbConfig.enableAHBWriteIpRxFifo = false;
   \       0x34   0x73E2             STRB     R2,[R4, #+15]
    322              config->ahbConfig.ahbGrantTimeoutCycle = 0xFFU;
   \       0x36   0x7421             STRB     R1,[R4, #+16]
    323              config->ahbConfig.ahbBusTimeoutCycle = 0xFFFFU;
   \       0x38   0x8260             STRH     R0,[R4, #+18]
    324              config->ahbConfig.resumeWaitCycle = 0x20U;
   \       0x3A   0x2020             MOVS     R0,#+32
   \       0x3C   0x7520             STRB     R0,[R4, #+20]
    325              memset(config->ahbConfig.buffer, 0, sizeof(config->ahbConfig.buffer));
   \       0x3E   0x2118             MOVS     R1,#+24
   \       0x40   0xF104 0x0016      ADD      R0,R4,#+22
   \       0x44   0x....'....        BL       __aeabi_memset
    326              for (uint8_t i = 0; i < FSL_FEATURE_FLEXSPI_AHB_BUFFER_COUNT; i++)
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xE009             B.N      ??FLEXSPI_GetDefaultConfig_0
    327              {
    328                  config->ahbConfig.buffer[i].bufferSize = 256; /* Default buffer size 256 bytes*/
   \                     ??FLEXSPI_GetDefaultConfig_1: (+1)
   \       0x4C   0xF44F 0x7180      MOV      R1,#+256
   \       0x50   0x4602             MOV      R2,R0
   \       0x52   0xB2D2             UXTB     R2,R2
   \       0x54   0xEB02 0x0342      ADD      R3,R2,R2, LSL #+1
   \       0x58   0xEB04 0x0243      ADD      R2,R4,R3, LSL #+1
   \       0x5C   0x8311             STRH     R1,[R2, #+24]
    329              }
   \       0x5E   0x1C40             ADDS     R0,R0,#+1
   \                     ??FLEXSPI_GetDefaultConfig_0: (+1)
   \       0x60   0x4601             MOV      R1,R0
   \       0x62   0xB2C9             UXTB     R1,R1
   \       0x64   0x2904             CMP      R1,#+4
   \       0x66   0xDBF1             BLT.N    ??FLEXSPI_GetDefaultConfig_1
    330              config->ahbConfig.enableClearAHBBufferOpt = false;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xF884 0x002E      STRB     R0,[R4, #+46]
    331              config->ahbConfig.enableReadAddressOpt = false;
   \       0x6E   0xF884 0x002F      STRB     R0,[R4, #+47]
    332              config->ahbConfig.enableAHBPrefetch = false;
   \       0x72   0xF884 0x0030      STRB     R0,[R4, #+48]
    333              config->ahbConfig.enableAHBBufferable = false;
   \       0x76   0xF884 0x0031      STRB     R0,[R4, #+49]
    334              config->ahbConfig.enableAHBCachable = false;
   \       0x7A   0xF884 0x0032      STRB     R0,[R4, #+50]
    335          }
   \       0x7E   0xBD10             POP      {R4,PC}          ;; return
    336          
    337          /*!
    338           * brief Deinitializes the FLEXSPI module.
    339           *
    340           * Clears the FLEXSPI state and  FLEXSPI module registers.
    341           * param base FLEXSPI peripheral base address.
    342           */

   \                                 In section .text, align 2, keep-with-next
    343          void FLEXSPI_Deinit(FLEXSPI_Type *base)
    344          {
    345              /* Reset peripheral. */
    346              FLEXSPI_SoftwareReset(base);
   \                     FLEXSPI_Deinit: (+1)
   \        0x0   0x....             B.N      FLEXSPI_SoftwareReset
    347          }
    348          
    349          /*!
    350           * brief Configures the connected device parameter.
    351           *
    352           * This function configures the connected device relevant parameters, such as the size, command, and so on.
    353           * The flash configuration value cannot have a default value. The user needs to configure it according to the
    354           * connected device.
    355           *
    356           * param base FLEXSPI peripheral base address.
    357           * param config Flash configuration parameters.
    358           * param port FLEXSPI Operation port.
    359           */

   \                                 In section .text, align 2, keep-with-next
    360          void FLEXSPI_SetFlashConfig(FLEXSPI_Type *base, flexspi_device_config_t *config, flexspi_port_t port)
    361          {
   \                     FLEXSPI_SetFlashConfig: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4617             MOV      R7,R2
    362              uint32_t configValue = 0;
    363              uint8_t index = port >> 1; /* PortA with index 0, PortB with index 1. */
   \        0x8   0x463C             MOV      R4,R7
   \        0xA   0x0864             LSRS     R4,R4,#+1
    364          
    365              /* Wait for bus idle before change flash configuration. */
    366              while (!FLEXSPI_GetBusIdleStatus(base))
   \                     ??FLEXSPI_SetFlashConfig_0: (+1)
   \        0xC   0x4630             MOV      R0,R6
   \        0xE   0x....'....        BL       FLEXSPI_GetBusIdleStatus
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD0FA             BEQ.N    ??FLEXSPI_SetFlashConfig_0
    367              {
    368              }
    369          
    370              /* Configure flash size. */
    371              base->FLSHCR0[port] = config->flashSize;
   \       0x16   0x68A8             LDR      R0,[R5, #+8]
   \       0x18   0x4639             MOV      R1,R7
   \       0x1A   0xEB06 0x0181      ADD      R1,R6,R1, LSL #+2
   \       0x1E   0x6608             STR      R0,[R1, #+96]
    372          
    373              /* Configure flash parameters. */
    374              base->FLSHCR1[port] = FLEXSPI_FLSHCR1_CSINTERVAL(config->CSInterval) |
    375                                    FLEXSPI_FLSHCR1_CSINTERVALUNIT(config->CSIntervalUnit) |
    376                                    FLEXSPI_FLSHCR1_TCSH(config->CSHoldTime) | FLEXSPI_FLSHCR1_TCSS(config->CSSetupTime) |
    377                                    FLEXSPI_FLSHCR1_CAS(config->columnspace) | FLEXSPI_FLSHCR1_WA(config->enableWordAddress);
   \       0x20   0x89E8             LDRH     R0,[R5, #+14]
   \       0x22   0x7B29             LDRB     R1,[R5, #+12]
   \       0x24   0x03C9             LSLS     R1,R1,#+15
   \       0x26   0xF401 0x4100      AND      R1,R1,#0x8000
   \       0x2A   0xEA41 0x4100      ORR      R1,R1,R0, LSL #+16
   \       0x2E   0x7C28             LDRB     R0,[R5, #+16]
   \       0x30   0x0140             LSLS     R0,R0,#+5
   \       0x32   0xF400 0x7078      AND      R0,R0,#0x3E0
   \       0x36   0x4301             ORRS     R1,R0,R1
   \       0x38   0x7C68             LDRB     R0,[R5, #+17]
   \       0x3A   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0x3E   0x4301             ORRS     R1,R0,R1
   \       0x40   0x7CE8             LDRB     R0,[R5, #+19]
   \       0x42   0x02C0             LSLS     R0,R0,#+11
   \       0x44   0xF400 0x40F0      AND      R0,R0,#0x7800
   \       0x48   0x4301             ORRS     R1,R0,R1
   \       0x4A   0x7D28             LDRB     R0,[R5, #+20]
   \       0x4C   0xEA41 0x2180      ORR      R1,R1,R0, LSL #+10
   \       0x50   0x4638             MOV      R0,R7
   \       0x52   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \       0x56   0x6701             STR      R1,[R0, #+112]
    378          
    379              /* Configure AHB operation items. */
    380              configValue = base->FLSHCR2[port];
   \       0x58   0x4638             MOV      R0,R7
   \       0x5A   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \       0x5E   0xF8D0 0x1080      LDR      R1,[R0, #+128]
    381          
    382              configValue &= ~(FLEXSPI_FLSHCR2_AWRWAITUNIT_MASK | FLEXSPI_FLSHCR2_AWRWAIT_MASK | FLEXSPI_FLSHCR2_AWRSEQNUM_MASK |
    383                               FLEXSPI_FLSHCR2_AWRSEQID_MASK | FLEXSPI_FLSHCR2_ARDSEQNUM_MASK | FLEXSPI_FLSHCR2_AWRSEQID_MASK);
    384          
    385              configValue |=
    386                  FLEXSPI_FLSHCR2_AWRWAITUNIT(config->AHBWriteWaitUnit) | FLEXSPI_FLSHCR2_AWRWAIT(config->AHBWriteWaitInterval);
   \       0x62   0x8B68             LDRH     R0,[R5, #+26]
   \       0x64   0xF360 0x411B      BFI      R1,R0,#+16,#+12
   \       0x68   0x7E68             LDRB     R0,[R5, #+25]
   \       0x6A   0xF360 0x711E      BFI      R1,R0,#+28,#+3
   \       0x6E   0x....'....        LDR.W    R0,??DataTable11_11  ;; 0xffff101f
   \       0x72   0x4001             ANDS     R1,R0,R1
    387          
    388              if (config->AWRSeqNumber > 0U)
   \       0x74   0x7DA8             LDRB     R0,[R5, #+22]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD00A             BEQ.N    ??FLEXSPI_SetFlashConfig_1
    389              {
    390                  configValue |=
    391                      FLEXSPI_FLSHCR2_AWRSEQID(config->AWRSeqIndex) | FLEXSPI_FLSHCR2_AWRSEQNUM(config->AWRSeqNumber - 1U);
   \       0x7A   0x7D68             LDRB     R0,[R5, #+21]
   \       0x7C   0x0200             LSLS     R0,R0,#+8
   \       0x7E   0xF400 0x6070      AND      R0,R0,#0xF00
   \       0x82   0x7DAA             LDRB     R2,[R5, #+22]
   \       0x84   0x1E52             SUBS     R2,R2,#+1
   \       0x86   0x0352             LSLS     R2,R2,#+13
   \       0x88   0xF402 0x4260      AND      R2,R2,#0xE000
   \       0x8C   0x4310             ORRS     R0,R2,R0
   \       0x8E   0x4301             ORRS     R1,R0,R1
    392              }
    393          
    394              if (config->ARDSeqNumber > 0U)
   \                     ??FLEXSPI_SetFlashConfig_1: (+1)
   \       0x90   0x7E28             LDRB     R0,[R5, #+24]
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD009             BEQ.N    ??FLEXSPI_SetFlashConfig_2
    395              {
    396                  configValue |=
    397                      FLEXSPI_FLSHCR2_ARDSEQID(config->ARDSeqIndex) | FLEXSPI_FLSHCR2_ARDSEQNUM(config->ARDSeqNumber - 1U);
   \       0x96   0x7DE8             LDRB     R0,[R5, #+23]
   \       0x98   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x9C   0x7E2A             LDRB     R2,[R5, #+24]
   \       0x9E   0x1E52             SUBS     R2,R2,#+1
   \       0xA0   0x0152             LSLS     R2,R2,#+5
   \       0xA2   0xF002 0x02E0      AND      R2,R2,#0xE0
   \       0xA6   0x4310             ORRS     R0,R2,R0
   \       0xA8   0x4301             ORRS     R1,R0,R1
    398              }
    399          
    400              base->FLSHCR2[port] = configValue;
   \                     ??FLEXSPI_SetFlashConfig_2: (+1)
   \       0xAA   0xEB06 0x0087      ADD      R0,R6,R7, LSL #+2
   \       0xAE   0xF8C0 0x1080      STR      R1,[R0, #+128]
    401          
    402              /* Configure DLL. */
    403              base->DLLCR[index] = FLEXSPI_ConfigureDll(base, config);
   \       0xB2   0x4629             MOV      R1,R5
   \       0xB4   0x4630             MOV      R0,R6
   \       0xB6   0x....'....        BL       FLEXSPI_ConfigureDll
   \       0xBA   0xEB06 0x0184      ADD      R1,R6,R4, LSL #+2
   \       0xBE   0xF8C1 0x00C0      STR      R0,[R1, #+192]
    404          
    405              /* Configure write mask. */
    406              if (config->enableWriteMask)
   \       0xC2   0x7F28             LDRB     R0,[R5, #+28]
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xF8D6 0x0094      LDR      R0,[R6, #+148]
   \       0xCA   0xD004             BEQ.N    ??FLEXSPI_SetFlashConfig_3
    407              {
    408                  base->FLSHCR4 &= ~FLEXSPI_FLSHCR4_WMOPT1_MASK;
   \       0xCC   0x0840             LSRS     R0,R0,#+1
   \       0xCE   0x0040             LSLS     R0,R0,#+1
   \       0xD0   0xF8C6 0x0094      STR      R0,[R6, #+148]
   \       0xD4   0xE003             B.N      ??FLEXSPI_SetFlashConfig_4
    409              }
    410              else
    411              {
    412                  base->FLSHCR4 |= FLEXSPI_FLSHCR4_WMOPT1_MASK;
   \                     ??FLEXSPI_SetFlashConfig_3: (+1)
   \       0xD6   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0xDA   0xF8C6 0x0094      STR      R0,[R6, #+148]
    413              }
    414          
    415              if (index == 0) /*PortA*/
   \                     ??FLEXSPI_SetFlashConfig_4: (+1)
   \       0xDE   0x2C00             CMP      R4,#+0
   \       0xE0   0xF8D6 0x0094      LDR      R0,[R6, #+148]
   \       0xE4   0xD10B             BNE.N    ??FLEXSPI_SetFlashConfig_5
    416              {
    417                  base->FLSHCR4 &= ~FLEXSPI_FLSHCR4_WMENA_MASK;
   \       0xE6   0xF020 0x0004      BIC      R0,R0,#0x4
   \       0xEA   0xF8C6 0x0094      STR      R0,[R6, #+148]
    418                  base->FLSHCR4 |= FLEXSPI_FLSHCR4_WMENA(config->enableWriteMask);
   \       0xEE   0xF8D6 0x0094      LDR      R0,[R6, #+148]
   \       0xF2   0x7F29             LDRB     R1,[R5, #+28]
   \       0xF4   0xEA40 0x0081      ORR      R0,R0,R1, LSL #+2
   \       0xF8   0xF8C6 0x0094      STR      R0,[R6, #+148]
   \       0xFC   0xE00A             B.N      ??FLEXSPI_SetFlashConfig_6
    419              }
    420              else
    421              {
    422                  base->FLSHCR4 &= ~FLEXSPI_FLSHCR4_WMENB_MASK;
   \                     ??FLEXSPI_SetFlashConfig_5: (+1)
   \       0xFE   0xF020 0x0008      BIC      R0,R0,#0x8
   \      0x102   0xF8C6 0x0094      STR      R0,[R6, #+148]
    423                  base->FLSHCR4 |= FLEXSPI_FLSHCR4_WMENB(config->enableWriteMask);
   \      0x106   0xF8D6 0x0094      LDR      R0,[R6, #+148]
   \      0x10A   0x7F29             LDRB     R1,[R5, #+28]
   \      0x10C   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \      0x110   0xF8C6 0x0094      STR      R0,[R6, #+148]
    424              }
    425          
    426              /* Exit stop mode. */
    427              base->MCR0 &= ~FLEXSPI_MCR0_MDIS_MASK;
   \                     ??FLEXSPI_SetFlashConfig_6: (+1)
   \      0x114   0x6830             LDR      R0,[R6, #+0]
   \      0x116   0xF020 0x0002      BIC      R0,R0,#0x2
   \      0x11A   0x6030             STR      R0,[R6, #+0]
    428          }
   \      0x11C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    429          
    430          /*! brief Updates the LUT table.
    431          *
    432          * param base FLEXSPI peripheral base address.
    433          * param index From which index start to update. It could be any index of the LUT table, which
    434          * also allows user to update command content inside a command. Each command consists of up to
    435          * 8 instructions and occupy 4*32-bit memory.
    436          * param cmd Command sequence array.
    437          * param count Number of sequences.
    438          */

   \                                 In section .text, align 2, keep-with-next
    439          void FLEXSPI_UpdateLUT(FLEXSPI_Type *base, uint32_t index, const uint32_t *cmd, uint32_t count)
    440          {
   \                     FLEXSPI_UpdateLUT: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461D             MOV      R5,R3
    441              assert(index < 64U);
   \        0xC   0xF1B8 0x0F40      CMP      R8,#+64
   \       0x10   0xD309             BCC.N    ??FLEXSPI_UpdateLUT_0
   \       0x12   0xF240 0x12B9      MOVW     R2,#+441
   \       0x16   0x....'....        LDR.W    R1,??DataTable11_5
   \       0x1A   0x....'....        LDR.W    R0,??DataTable11_12
   \       0x1E   0x....'....        BL       __aeabi_assert
   \       0x22   0x....'....        BL       __iar_EmptyStepPoint
    442          
    443              uint8_t i = 0;
   \                     ??FLEXSPI_UpdateLUT_0: (+1)
   \       0x26   0x2600             MOVS     R6,#+0
    444              volatile uint32_t *lutBase;
    445          
    446              /* Wait for bus idle before change flash configuration. */
    447              while (!FLEXSPI_GetBusIdleStatus(base))
   \                     ??FLEXSPI_UpdateLUT_1: (+1)
   \       0x28   0x4638             MOV      R0,R7
   \       0x2A   0x....'....        BL       FLEXSPI_GetBusIdleStatus
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD0FA             BEQ.N    ??FLEXSPI_UpdateLUT_1
    448              {
    449              }
    450          
    451              /* Unlock LUT for update. */
    452              base->LUTKEY = FLEXSPI_LUT_KEY_VAL;
   \       0x32   0x....'....        LDR.W    R0,??DataTable11_13  ;; 0x5af05af0
   \       0x36   0x61B8             STR      R0,[R7, #+24]
    453              base->LUTCR = 0x02;
   \       0x38   0x2102             MOVS     R1,#+2
   \       0x3A   0x61F9             STR      R1,[R7, #+28]
    454          
    455              lutBase = &base->LUT[index];
   \       0x3C   0xEB07 0x0188      ADD      R1,R7,R8, LSL #+2
   \       0x40   0xF501 0x7100      ADD      R1,R1,#+512
    456              for (i = 0; i < count; i++)
   \       0x44   0xE004             B.N      ??FLEXSPI_UpdateLUT_2
    457              {
    458                  *lutBase++ = *cmd++;
   \                     ??FLEXSPI_UpdateLUT_3: (+1)
   \       0x46   0xF854 0x2B04      LDR      R2,[R4], #+4
   \       0x4A   0xF841 0x2B04      STR      R2,[R1], #+4
    459              }
   \       0x4E   0x1C76             ADDS     R6,R6,#+1
   \                     ??FLEXSPI_UpdateLUT_2: (+1)
   \       0x50   0x4632             MOV      R2,R6
   \       0x52   0xB2D2             UXTB     R2,R2
   \       0x54   0x42AA             CMP      R2,R5
   \       0x56   0xD3F6             BCC.N    ??FLEXSPI_UpdateLUT_3
    460          
    461              /* Lock LUT. */
    462              base->LUTKEY = FLEXSPI_LUT_KEY_VAL;
   \       0x58   0x61B8             STR      R0,[R7, #+24]
    463              base->LUTCR = 0x01;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x61F8             STR      R0,[R7, #+28]
    464          }
   \       0x5E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    465          
    466          /*!
    467           * brief Sends a buffer of data bytes using blocking method.
    468           * note This function blocks via polling until all bytes have been sent.
    469           * param base FLEXSPI peripheral base address
    470           * param buffer The data bytes to send
    471           * param size The number of data bytes to send
    472           * retval kStatus_Success write success without error
    473           * retval kStatus_FLEXSPI_SequenceExecutionTimeout sequence execution timeout
    474           * retval kStatus_FLEXSPI_IpCommandSequenceError IP command sequencen error detected
    475           * retval kStatus_FLEXSPI_IpCommandGrantTimeout IP command grant timeout detected
    476           */

   \                                 In section .text, align 2, keep-with-next
    477          status_t FLEXSPI_WriteBlocking(FLEXSPI_Type *base, uint32_t *buffer, size_t size)
    478          {
   \                     FLEXSPI_WriteBlocking: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4614             MOV      R4,R2
    479              uint8_t txWatermark = ((base->IPTXFCR & FLEXSPI_IPTXFCR_TXWMRK_MASK) >> FLEXSPI_IPTXFCR_TXWMRK_SHIFT) + 1;
   \        0x8   0xF8D5 0x00BC      LDR      R0,[R5, #+188]
   \        0xC   0xF3C0 0x0783      UBFX     R7,R0,#+2,#+4
   \       0x10   0x1C7F             ADDS     R7,R7,#+1
   \       0x12   0xB2FF             UXTB     R7,R7
    480              uint32_t status;
    481              status_t result = kStatus_Success;
   \       0x14   0x2000             MOVS     R0,#+0
    482              uint32_t i = 0;
   \       0x16   0xE010             B.N      ??FLEXSPI_WriteBlocking_0
    483          
    484              /* Send data buffer */
    485              while (size)
    486              {
    487                  /* Wait until there is room in the fifo. This also checks for errors. */
    488                  while (!((status = base->INTR) & kFLEXSPI_IpTxFifoWatermarkEmpltyFlag))
    489                  {
    490                  }
    491          
    492                  result = FLEXSPI_CheckAndClearError(base, status);
    493          
    494                  if (result)
    495                  {
    496                      return result;
    497                  }
    498          
    499                  /* Write watermark level data into tx fifo . */
    500                  if (size >= 8 * txWatermark)
    501                  {
    502                      for (i = 0; i < 2 * txWatermark; i++)
    503                      {
    504                          base->TFDR[i] = *buffer++;
    505                      }
    506          
    507                      size = size - 8 * txWatermark;
    508                  }
    509                  else
    510                  {
    511                      for (i = 0; i < (size / 4 + 1); i++)
    512                      {
    513                          base->TFDR[i] = *buffer++;
   \                     ??FLEXSPI_WriteBlocking_1: (+1)
   \       0x18   0xF856 0x2B04      LDR      R2,[R6], #+4
   \       0x1C   0xEB05 0x0381      ADD      R3,R5,R1, LSL #+2
   \       0x20   0xF8C3 0x2180      STR      R2,[R3, #+384]
    514                      }
   \       0x24   0x1C49             ADDS     R1,R1,#+1
   \                     ??FLEXSPI_WriteBlocking_2: (+1)
   \       0x26   0x4622             MOV      R2,R4
   \       0x28   0x0892             LSRS     R2,R2,#+2
   \       0x2A   0x1C52             ADDS     R2,R2,#+1
   \       0x2C   0x4291             CMP      R1,R2
   \       0x2E   0xD3F3             BCC.N    ??FLEXSPI_WriteBlocking_1
    515                      size = 0;
   \       0x30   0x2400             MOVS     R4,#+0
    516                  }
    517          
    518                  /* Push a watermark level datas into IP TX FIFO. */
    519                  base->INTR |= kFLEXSPI_IpTxFifoWatermarkEmpltyFlag;
   \                     ??FLEXSPI_WriteBlocking_3: (+1)
   \       0x32   0x6969             LDR      R1,[R5, #+20]
   \       0x34   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x38   0x6169             STR      R1,[R5, #+20]
   \                     ??FLEXSPI_WriteBlocking_0: (+1)
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD01B             BEQ.N    ??FLEXSPI_WriteBlocking_4
   \                     ??FLEXSPI_WriteBlocking_5: (+1)
   \       0x3E   0x6969             LDR      R1,[R5, #+20]
   \       0x40   0x0648             LSLS     R0,R1,#+25
   \       0x42   0xD5FC             BPL.N    ??FLEXSPI_WriteBlocking_5
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x....'....        BL       FLEXSPI_CheckAndClearError
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD113             BNE.N    ??FLEXSPI_WriteBlocking_4
   \       0x4E   0xEBB4 0x0FC7      CMP      R4,R7, LSL #+3
   \       0x52   0xD30E             BCC.N    ??FLEXSPI_WriteBlocking_6
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0xE006             B.N      ??FLEXSPI_WriteBlocking_7
   \                     ??FLEXSPI_WriteBlocking_8: (+1)
   \       0x58   0xF856 0x2B04      LDR      R2,[R6], #+4
   \       0x5C   0xEB05 0x0381      ADD      R3,R5,R1, LSL #+2
   \       0x60   0xF8C3 0x2180      STR      R2,[R3, #+384]
   \       0x64   0x1C49             ADDS     R1,R1,#+1
   \                     ??FLEXSPI_WriteBlocking_7: (+1)
   \       0x66   0xEBB1 0x0F47      CMP      R1,R7, LSL #+1
   \       0x6A   0xD3F5             BCC.N    ??FLEXSPI_WriteBlocking_8
   \       0x6C   0xEBA4 0x04C7      SUB      R4,R4,R7, LSL #+3
   \       0x70   0xE7DF             B.N      ??FLEXSPI_WriteBlocking_3
   \                     ??FLEXSPI_WriteBlocking_6: (+1)
   \       0x72   0x2100             MOVS     R1,#+0
   \       0x74   0xE7D7             B.N      ??FLEXSPI_WriteBlocking_2
    520              }
    521          
    522              return result;
   \                     ??FLEXSPI_WriteBlocking_4: (+1)
   \       0x76   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    523          }
    524          
    525          /*!
    526           * brief Receives a buffer of data bytes using a blocking method.
    527           * note This function blocks via polling until all bytes have been sent.
    528           * param base FLEXSPI peripheral base address
    529           * param buffer The data bytes to send
    530           * param size The number of data bytes to receive
    531           * retval kStatus_Success read success without error
    532           * retval kStatus_FLEXSPI_SequenceExecutionTimeout sequence execution timeout
    533           * retval kStatus_FLEXSPI_IpCommandSequenceError IP command sequencen error detected
    534           * retval kStatus_FLEXSPI_IpCommandGrantTimeout IP command grant timeout detected
    535           */

   \                                 In section .text, align 2, keep-with-next
    536          status_t FLEXSPI_ReadBlocking(FLEXSPI_Type *base, uint32_t *buffer, size_t size)
    537          {
   \                     FLEXSPI_ReadBlocking: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4615             MOV      R5,R2
    538              uint8_t rxWatermark = ((base->IPRXFCR & FLEXSPI_IPRXFCR_RXWMRK_MASK) >> FLEXSPI_IPRXFCR_RXWMRK_SHIFT) + 1;
   \        0xA   0xF8D8 0x00B8      LDR      R0,[R8, #+184]
   \        0xE   0xF3C0 0x0683      UBFX     R6,R0,#+2,#+4
   \       0x12   0x1C76             ADDS     R6,R6,#+1
   \       0x14   0xB2F6             UXTB     R6,R6
    539              uint32_t status;
    540              status_t result = kStatus_Success;
   \       0x16   0x2400             MOVS     R4,#+0
    541              uint32_t i = 0;
   \       0x18   0xE012             B.N      ??FLEXSPI_ReadBlocking_0
    542          
    543              /* Send data buffer */
    544              while (size)
    545              {
    546                  if (size >= 8 * rxWatermark)
    547                  {
    548                      /* Wait until there is room in the fifo. This also checks for errors. */
    549                      while (!((status = base->INTR) & kFLEXSPI_IpRxFifoWatermarkAvailableFlag))
    550                      {
    551                          result = FLEXSPI_CheckAndClearError(base, status);
    552          
    553                          if (result)
    554                          {
    555                              return result;
    556                          }
    557                      }
    558                  }
    559                  else
    560                  {
    561                      /* Wait fill level. This also checks for errors. */
    562                      while (size > ((((base->IPRXFSTS) & FLEXSPI_IPRXFSTS_FILL_MASK) >> FLEXSPI_IPRXFSTS_FILL_SHIFT) * 8U))
    563                      {
    564                          result = FLEXSPI_CheckAndClearError(base, base->INTR);
    565          
    566                          if (result)
    567                          {
    568                              return result;
    569                          }
    570                      }
    571                  }
    572          
    573                  result = FLEXSPI_CheckAndClearError(base, base->INTR);
    574          
    575                  if (result)
    576                  {
    577                      return result;
    578                  }
    579          
    580                  /* Read watermark level data from rx fifo . */
    581                  if (size >= 8 * rxWatermark)
    582                  {
    583                      for (i = 0; i < 2 * rxWatermark; i++)
    584                      {
    585                          *buffer++ = base->RFDR[i];
    586                      }
    587          
    588                      size = size - 8 * rxWatermark;
    589                  }
    590                  else
    591                  {
    592                      for (i = 0; i < (size / 4 + 1); i++)
    593                      {
    594                          *buffer++ = base->RFDR[i];
   \                     ??FLEXSPI_ReadBlocking_1: (+1)
   \       0x1A   0xEB08 0x0180      ADD      R1,R8,R0, LSL #+2
   \       0x1E   0xF8D1 0x1100      LDR      R1,[R1, #+256]
   \       0x22   0xF847 0x1B04      STR      R1,[R7], #+4
    595                      }
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \                     ??FLEXSPI_ReadBlocking_2: (+1)
   \       0x28   0x4629             MOV      R1,R5
   \       0x2A   0x0889             LSRS     R1,R1,#+2
   \       0x2C   0x1C49             ADDS     R1,R1,#+1
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD3F3             BCC.N    ??FLEXSPI_ReadBlocking_1
    596                      size = 0;
   \       0x32   0x2500             MOVS     R5,#+0
    597                  }
    598          
    599                  /* Pop out a watermark level datas from IP RX FIFO. */
    600                  base->INTR |= kFLEXSPI_IpRxFifoWatermarkAvailableFlag;
   \                     ??FLEXSPI_ReadBlocking_3: (+1)
   \       0x34   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x38   0xF040 0x0020      ORR      R0,R0,#0x20
   \       0x3C   0xF8C8 0x0014      STR      R0,[R8, #+20]
   \                     ??FLEXSPI_ReadBlocking_0: (+1)
   \       0x40   0x2D00             CMP      R5,#+0
   \       0x42   0xD00B             BEQ.N    ??FLEXSPI_ReadBlocking_4
   \       0x44   0xEBB5 0x0FC6      CMP      R5,R6, LSL #+3
   \       0x48   0xD323             BCC.N    ??FLEXSPI_ReadBlocking_5
   \                     ??FLEXSPI_ReadBlocking_6: (+1)
   \       0x4A   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \       0x4E   0x0688             LSLS     R0,R1,#+26
   \       0x50   0xD426             BMI.N    ??FLEXSPI_ReadBlocking_7
   \       0x52   0x4640             MOV      R0,R8
   \       0x54   0x....'....        BL       FLEXSPI_CheckAndClearError
   \       0x58   0x0004             MOVS     R4,R0
   \       0x5A   0xD0F6             BEQ.N    ??FLEXSPI_ReadBlocking_6
    601              }
    602          
    603              return result;
   \                     ??FLEXSPI_ReadBlocking_4: (+1)
   \       0x5C   0x4620             MOV      R0,R4
   \       0x5E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??FLEXSPI_ReadBlocking_8: (+1)
   \       0x62   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \       0x66   0x4640             MOV      R0,R8
   \       0x68   0x....'....        BL       FLEXSPI_CheckAndClearError
   \       0x6C   0x0004             MOVS     R4,R0
   \       0x6E   0xD1F5             BNE.N    ??FLEXSPI_ReadBlocking_4
   \       0x70   0xE00F             B.N      ??FLEXSPI_ReadBlocking_5
   \                     ??FLEXSPI_ReadBlocking_9: (+1)
   \       0x72   0xEB08 0x0382      ADD      R3,R8,R2, LSL #+2
   \       0x76   0xF8D3 0x3100      LDR      R3,[R3, #+256]
   \       0x7A   0xF840 0x3B04      STR      R3,[R0], #+4
   \       0x7E   0x1C52             ADDS     R2,R2,#+1
   \                     ??FLEXSPI_ReadBlocking_10: (+1)
   \       0x80   0xEBB2 0x0F41      CMP      R2,R1, LSL #+1
   \       0x84   0xD3F5             BCC.N    ??FLEXSPI_ReadBlocking_9
   \       0x86   0x4607             MOV      R7,R0
   \       0x88   0xEBA5 0x05C6      SUB      R5,R5,R6, LSL #+3
   \       0x8C   0xE7D2             B.N      ??FLEXSPI_ReadBlocking_3
   \                     ??FLEXSPI_ReadBlocking_11: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xE7CA             B.N      ??FLEXSPI_ReadBlocking_2
   \                     ??FLEXSPI_ReadBlocking_5: (+1)
   \       0x92   0xF8D8 0x00F0      LDR      R0,[R8, #+240]
   \       0x96   0x00C0             LSLS     R0,R0,#+3
   \       0x98   0xF400 0x60FF      AND      R0,R0,#0x7F8
   \       0x9C   0x42A8             CMP      R0,R5
   \       0x9E   0xD3E0             BCC.N    ??FLEXSPI_ReadBlocking_8
   \                     ??FLEXSPI_ReadBlocking_7: (+1)
   \       0xA0   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \       0xA4   0x4640             MOV      R0,R8
   \       0xA6   0x....'....        BL       FLEXSPI_CheckAndClearError
   \       0xAA   0x0004             MOVS     R4,R0
   \       0xAC   0xD1D6             BNE.N    ??FLEXSPI_ReadBlocking_4
   \       0xAE   0xEBB5 0x0FC6      CMP      R5,R6, LSL #+3
   \       0xB2   0xD3EC             BCC.N    ??FLEXSPI_ReadBlocking_11
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x4638             MOV      R0,R7
   \       0xB8   0x4631             MOV      R1,R6
   \       0xBA   0xE7E1             B.N      ??FLEXSPI_ReadBlocking_10
    604          }
    605          
    606          /*!
    607           * brief Execute command to transfer a buffer data bytes using a blocking method.
    608           * param base FLEXSPI peripheral base address
    609           * param xfer pointer to the transfer structure.
    610           * retval kStatus_Success command transfer success without error
    611           * retval kStatus_FLEXSPI_SequenceExecutionTimeout sequence execution timeout
    612           * retval kStatus_FLEXSPI_IpCommandSequenceError IP command sequencen error detected
    613           * retval kStatus_FLEXSPI_IpCommandGrantTimeout IP command grant timeout detected
    614          */

   \                                 In section .text, align 2, keep-with-next
    615          status_t FLEXSPI_TransferBlocking(FLEXSPI_Type *base, flexspi_transfer_t *xfer)
    616          {
   \                     FLEXSPI_TransferBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
    617              uint32_t configValue = 0;
   \        0x6   0x2000             MOVS     R0,#+0
    618              status_t result = kStatus_Success;
   \        0x8   0x4605             MOV      R5,R0
    619          
    620              /* Clear sequence pointer before sending data to external devices. */
    621              base->FLSHCR2[xfer->port] |= FLEXSPI_FLSHCR2_CLRINSTRPTR_MASK;
   \        0xA   0x7931             LDRB     R1,[R6, #+4]
   \        0xC   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \       0x10   0x7932             LDRB     R2,[R6, #+4]
   \       0x12   0xEB04 0x0282      ADD      R2,R4,R2, LSL #+2
   \       0x16   0xF8D2 0x2080      LDR      R2,[R2, #+128]
   \       0x1A   0xF042 0x4200      ORR      R2,R2,#0x80000000
   \       0x1E   0xF8C1 0x2080      STR      R2,[R1, #+128]
    622          
    623              /* Clear former pending status before start this tranfer. */
    624              base->INTR |= FLEXSPI_INTR_AHBCMDERR_MASK | FLEXSPI_INTR_IPCMDERR_MASK | FLEXSPI_INTR_AHBCMDGE_MASK |
    625                            FLEXSPI_INTR_IPCMDGE_MASK;
   \       0x22   0x6961             LDR      R1,[R4, #+20]
   \       0x24   0xF041 0x011E      ORR      R1,R1,#0x1E
   \       0x28   0x6161             STR      R1,[R4, #+20]
    626          
    627              /* Configure base addresss. */
    628              base->IPCR0 = xfer->deviceAddress;
   \       0x2A   0x6831             LDR      R1,[R6, #+0]
   \       0x2C   0xF8C4 0x10A0      STR      R1,[R4, #+160]
    629          
    630              /* Reset fifos. */
    631              base->IPTXFCR |= FLEXSPI_IPTXFCR_CLRIPTXF_MASK;
   \       0x30   0xF8D4 0x10BC      LDR      R1,[R4, #+188]
   \       0x34   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0x38   0xF8C4 0x10BC      STR      R1,[R4, #+188]
    632              base->IPRXFCR |= FLEXSPI_IPRXFCR_CLRIPRXF_MASK;
   \       0x3C   0xF8D4 0x10B8      LDR      R1,[R4, #+184]
   \       0x40   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0x44   0xF8C4 0x10B8      STR      R1,[R4, #+184]
    633          
    634              /* Configure data size. */
    635              if ((xfer->cmdType == kFLEXSPI_Read) || (xfer->cmdType == kFLEXSPI_Write) || (xfer->cmdType == kFLEXSPI_Config))
   \       0x48   0x7971             LDRB     R1,[R6, #+5]
   \       0x4A   0x2902             CMP      R1,#+2
   \       0x4C   0xD003             BEQ.N    ??FLEXSPI_TransferBlocking_0
   \       0x4E   0x2903             CMP      R1,#+3
   \       0x50   0xD001             BEQ.N    ??FLEXSPI_TransferBlocking_0
   \       0x52   0x2901             CMP      R1,#+1
   \       0x54   0xD101             BNE.N    ??FLEXSPI_TransferBlocking_1
    636              {
    637                  configValue = FLEXSPI_IPCR1_IDATSZ(xfer->dataSize);
   \                     ??FLEXSPI_TransferBlocking_0: (+1)
   \       0x56   0x68F0             LDR      R0,[R6, #+12]
   \       0x58   0xB280             UXTH     R0,R0
    638              }
    639          
    640              /* Configure sequence ID. */
    641              configValue |= FLEXSPI_IPCR1_ISEQID(xfer->seqIndex) | FLEXSPI_IPCR1_ISEQNUM(xfer->SeqNumber - 1);
    642              base->IPCR1 = configValue;
   \                     ??FLEXSPI_TransferBlocking_1: (+1)
   \       0x5A   0x79B1             LDRB     R1,[R6, #+6]
   \       0x5C   0x0409             LSLS     R1,R1,#+16
   \       0x5E   0xF401 0x2170      AND      R1,R1,#0xF0000
   \       0x62   0x4308             ORRS     R0,R1,R0
   \       0x64   0x79F1             LDRB     R1,[R6, #+7]
   \       0x66   0x1E49             SUBS     R1,R1,#+1
   \       0x68   0x0609             LSLS     R1,R1,#+24
   \       0x6A   0xF001 0x61E0      AND      R1,R1,#0x7000000
   \       0x6E   0x4308             ORRS     R0,R1,R0
   \       0x70   0xF8C4 0x00A4      STR      R0,[R4, #+164]
    643          
    644              /* Start Transfer. */
    645              base->IPCMD |= FLEXSPI_IPCMD_TRG_MASK;
   \       0x74   0xF8D4 0x00B0      LDR      R0,[R4, #+176]
   \       0x78   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x7C   0xF8C4 0x00B0      STR      R0,[R4, #+176]
    646          
    647              if ((xfer->cmdType == kFLEXSPI_Write) || (xfer->cmdType == kFLEXSPI_Config))
   \       0x80   0x7970             LDRB     R0,[R6, #+5]
   \       0x82   0x2803             CMP      R0,#+3
   \       0x84   0xD001             BEQ.N    ??FLEXSPI_TransferBlocking_2
   \       0x86   0x2801             CMP      R0,#+1
   \       0x88   0xD114             BNE.N    ??FLEXSPI_TransferBlocking_3
    648              {
    649                  result = FLEXSPI_WriteBlocking(base, xfer->data, xfer->dataSize);
   \                     ??FLEXSPI_TransferBlocking_2: (+1)
   \       0x8A   0x68F2             LDR      R2,[R6, #+12]
   \       0x8C   0x68B1             LDR      R1,[R6, #+8]
   \       0x8E   0x4620             MOV      R0,R4
   \       0x90   0x....'....        BL       FLEXSPI_WriteBlocking
   \       0x94   0x4605             MOV      R5,R0
    650              }
    651              else if (xfer->cmdType == kFLEXSPI_Read)
    652              {
    653                  result = FLEXSPI_ReadBlocking(base, xfer->data, xfer->dataSize);
    654              }
    655              else
    656              {
    657              }
    658          
    659              /* Wait for bus idle. */
    660              while (!FLEXSPI_GetBusIdleStatus(base))
   \                     ??FLEXSPI_TransferBlocking_4: (+1)
   \       0x96   0x4620             MOV      R0,R4
   \       0x98   0x....'....        BL       FLEXSPI_GetBusIdleStatus
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD0FA             BEQ.N    ??FLEXSPI_TransferBlocking_4
    661              {
    662              }
    663          
    664              if (xfer->cmdType == kFLEXSPI_Command)
   \       0xA0   0x7970             LDRB     R0,[R6, #+5]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD104             BNE.N    ??FLEXSPI_TransferBlocking_5
    665              {
    666                  result = FLEXSPI_CheckAndClearError(base, base->INTR);
   \       0xA6   0x6961             LDR      R1,[R4, #+20]
   \       0xA8   0x4620             MOV      R0,R4
   \       0xAA   0x....'....        BL       FLEXSPI_CheckAndClearError
   \       0xAE   0x4605             MOV      R5,R0
    667              }
    668          
    669              return result;
   \                     ??FLEXSPI_TransferBlocking_5: (+1)
   \       0xB0   0x4628             MOV      R0,R5
   \       0xB2   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??FLEXSPI_TransferBlocking_3: (+1)
   \       0xB4   0x2802             CMP      R0,#+2
   \       0xB6   0xD1EE             BNE.N    ??FLEXSPI_TransferBlocking_4
   \       0xB8   0x68F2             LDR      R2,[R6, #+12]
   \       0xBA   0x68B1             LDR      R1,[R6, #+8]
   \       0xBC   0x4620             MOV      R0,R4
   \       0xBE   0x....'....        BL       FLEXSPI_ReadBlocking
   \       0xC2   0x4605             MOV      R5,R0
   \       0xC4   0xE7E7             B.N      ??FLEXSPI_TransferBlocking_4
    670          }
    671          
    672          /*!
    673           * brief Initializes the FLEXSPI handle which is used in transactional functions.
    674           *
    675           * param base FLEXSPI peripheral base address.
    676           * param handle pointer to flexspi_handle_t structure to store the transfer state.
    677           * param callback pointer to user callback function.
    678           * param userData user parameter passed to the callback function.
    679           */

   \                                 In section .text, align 2, keep-with-next
    680          void FLEXSPI_TransferCreateHandle(FLEXSPI_Type *base,
    681                                            flexspi_handle_t *handle,
    682                                            flexspi_transfer_callback_t callback,
    683                                            void *userData)
    684          {
   \                     FLEXSPI_TransferCreateHandle: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    685              assert(handle);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD107             BNE.N    ??FLEXSPI_TransferCreateHandle_0
   \        0xE   0xF240 0x22AD      MOVW     R2,#+685
   \       0x12   0x....             LDR.N    R1,??DataTable11_5
   \       0x14   0x....             LDR.N    R0,??DataTable11_14
   \       0x16   0x....'....        BL       __aeabi_assert
   \       0x1A   0x....'....        BL       __iar_EmptyStepPoint
    686          
    687              uint32_t instance = FLEXSPI_GetInstance(base);
   \                     ??FLEXSPI_TransferCreateHandle_0: (+1)
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x....'....        BL       FLEXSPI_GetInstance
   \       0x24   0x4605             MOV      R5,R0
    688          
    689              /* Zero handle. */
    690              memset(handle, 0, sizeof(*handle));
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x2118             MOVS     R1,#+24
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       __aeabi_memset4
    691          
    692              /* Set callback and userData. */
    693              handle->completionCallback = callback;
   \       0x30   0x6126             STR      R6,[R4, #+16]
    694              handle->userData = userData;
   \       0x32   0x6167             STR      R7,[R4, #+20]
    695          
    696          #if defined(FSL_DRIVER_TRANSFER_DOUBLE_WEAK_IRQ) && FSL_DRIVER_TRANSFER_DOUBLE_WEAK_IRQ
    697              /* Save the context in global variables to support the double weak mechanism. */
    698              s_flexspiHandle[instance] = handle;
    699          #endif
    700          
    701              /* Enable NVIC interrupt. */
    702              EnableIRQ(s_flexspiIrqs[instance]);
   \       0x34   0x....             LDR.N    R0,??DataTable11_15
   \       0x36   0xF930 0x0015      LDRSH    R0,[R0, R5, LSL #+1]
   \       0x3A   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x3E   0x....             B.N      EnableIRQ
    703          }
    704          
    705          /*!
    706           * brief Performs a interrupt non-blocking transfer on the FLEXSPI bus.
    707           *
    708           * note Calling the API returns immediately after transfer initiates. The user needs
    709           * to call FLEXSPI_GetTransferCount to poll the transfer status to check whether
    710           * the transfer is finished. If the return status is not kStatus_FLEXSPI_Busy, the transfer
    711           * is finished. For FLEXSPI_Read, the dataSize should be multiple of rx watermark levle, or
    712           * FLEXSPI could not read data properly.
    713           *
    714           * param base FLEXSPI peripheral base address.
    715           * param handle pointer to flexspi_handle_t structure which stores the transfer state.
    716           * param xfer pointer to flexspi_transfer_t structure.
    717           * retval kStatus_Success Successfully start the data transmission.
    718           * retval kStatus_FLEXSPI_Busy Previous transmission still not finished.
    719           */

   \                                 In section .text, align 2, keep-with-next
    720          status_t FLEXSPI_TransferNonBlocking(FLEXSPI_Type *base, flexspi_handle_t *handle, flexspi_transfer_t *xfer)
    721          {
   \                     FLEXSPI_TransferNonBlocking: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
    722              uint32_t configValue = 0;
   \        0xA   0xF04F 0x0800      MOV      R8,#+0
    723              status_t result = kStatus_Success;
   \        0xE   0x4646             MOV      R6,R8
    724          
    725              assert(handle);
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD107             BNE.N    ??FLEXSPI_TransferNonBlocking_0
   \       0x14   0xF240 0x22D5      MOVW     R2,#+725
   \       0x18   0x....             LDR.N    R1,??DataTable11_5
   \       0x1A   0x....             LDR.N    R0,??DataTable11_14
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    726              assert(xfer);
   \                     ??FLEXSPI_TransferNonBlocking_0: (+1)
   \       0x24   0x2D00             CMP      R5,#+0
   \       0x26   0xD107             BNE.N    ??FLEXSPI_TransferNonBlocking_1
   \       0x28   0xF240 0x22D6      MOVW     R2,#+726
   \       0x2C   0x....             LDR.N    R1,??DataTable11_5
   \       0x2E   0x....             LDR.N    R0,??DataTable11_16
   \       0x30   0x....'....        BL       __aeabi_assert
   \       0x34   0x....'....        BL       __iar_EmptyStepPoint
    727          
    728              /* Check if the I2C bus is idle - if not return busy status. */
    729              if (handle->state != kFLEXSPI_Idle)
   \                     ??FLEXSPI_TransferNonBlocking_1: (+1)
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD002             BEQ.N    ??FLEXSPI_TransferNonBlocking_2
    730              {
    731                  result = kStatus_FLEXSPI_Busy;
   \       0x3E   0xF641 0x3658      MOVW     R6,#+7000
   \       0x42   0xE057             B.N      ??FLEXSPI_TransferNonBlocking_3
    732              }
    733              else
    734              {
    735                  handle->data = xfer->data;
   \                     ??FLEXSPI_TransferNonBlocking_2: (+1)
   \       0x44   0x68A8             LDR      R0,[R5, #+8]
   \       0x46   0x6060             STR      R0,[R4, #+4]
    736                  handle->dataSize = xfer->dataSize;
   \       0x48   0x68E8             LDR      R0,[R5, #+12]
   \       0x4A   0x60A0             STR      R0,[R4, #+8]
    737                  handle->transferTotalSize = xfer->dataSize;
   \       0x4C   0x68E8             LDR      R0,[R5, #+12]
   \       0x4E   0x60E0             STR      R0,[R4, #+12]
    738                  handle->state = (xfer->cmdType == kFLEXSPI_Read) ? kFLEXSPI_BusyRead : kFLEXSPI_BusyWrite;
   \       0x50   0x7968             LDRB     R0,[R5, #+5]
   \       0x52   0x2802             CMP      R0,#+2
   \       0x54   0xD101             BNE.N    ??FLEXSPI_TransferNonBlocking_4
   \       0x56   0x2002             MOVS     R0,#+2
   \       0x58   0xE000             B.N      ??FLEXSPI_TransferNonBlocking_5
   \                     ??FLEXSPI_TransferNonBlocking_4: (+1)
   \       0x5A   0x2001             MOVS     R0,#+1
   \                     ??FLEXSPI_TransferNonBlocking_5: (+1)
   \       0x5C   0x6020             STR      R0,[R4, #+0]
    739          
    740                  /* Clear sequence pointer before sending data to external devices. */
    741                  base->FLSHCR2[xfer->port] |= FLEXSPI_FLSHCR2_CLRINSTRPTR_MASK;
   \       0x5E   0x7928             LDRB     R0,[R5, #+4]
   \       0x60   0xEB07 0x0080      ADD      R0,R7,R0, LSL #+2
   \       0x64   0x7929             LDRB     R1,[R5, #+4]
   \       0x66   0xEB07 0x0181      ADD      R1,R7,R1, LSL #+2
   \       0x6A   0xF8D1 0x1080      LDR      R1,[R1, #+128]
   \       0x6E   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \       0x72   0xF8C0 0x1080      STR      R1,[R0, #+128]
    742          
    743                  /* Clear former pending status before start this tranfer. */
    744                  base->INTR |= FLEXSPI_INTR_AHBCMDERR_MASK | FLEXSPI_INTR_IPCMDERR_MASK | FLEXSPI_INTR_AHBCMDGE_MASK |
    745                                FLEXSPI_INTR_IPCMDGE_MASK;
   \       0x76   0x6978             LDR      R0,[R7, #+20]
   \       0x78   0xF040 0x001E      ORR      R0,R0,#0x1E
   \       0x7C   0x6178             STR      R0,[R7, #+20]
    746          
    747                  /* Configure base addresss. */
    748                  base->IPCR0 = xfer->deviceAddress;
   \       0x7E   0x6828             LDR      R0,[R5, #+0]
   \       0x80   0xF8C7 0x00A0      STR      R0,[R7, #+160]
    749          
    750                  /* Reset fifos. */
    751                  base->IPTXFCR |= FLEXSPI_IPTXFCR_CLRIPTXF_MASK;
   \       0x84   0xF8D7 0x00BC      LDR      R0,[R7, #+188]
   \       0x88   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x8C   0xF8C7 0x00BC      STR      R0,[R7, #+188]
    752                  base->IPRXFCR |= FLEXSPI_IPRXFCR_CLRIPRXF_MASK;
   \       0x90   0xF8D7 0x00B8      LDR      R0,[R7, #+184]
   \       0x94   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x98   0xF8C7 0x00B8      STR      R0,[R7, #+184]
    753          
    754                  /* Configure data size. */
    755                  if ((xfer->cmdType == kFLEXSPI_Read) || (xfer->cmdType == kFLEXSPI_Write))
   \       0x9C   0x7968             LDRB     R0,[R5, #+5]
   \       0x9E   0x2802             CMP      R0,#+2
   \       0xA0   0xD001             BEQ.N    ??FLEXSPI_TransferNonBlocking_6
   \       0xA2   0x2803             CMP      R0,#+3
   \       0xA4   0xD103             BNE.N    ??FLEXSPI_TransferNonBlocking_7
    756                  {
    757                      configValue = FLEXSPI_IPCR1_IDATSZ(xfer->dataSize);
   \                     ??FLEXSPI_TransferNonBlocking_6: (+1)
   \       0xA6   0xF8D5 0x800C      LDR      R8,[R5, #+12]
   \       0xAA   0xFA1F 0xF888      UXTH     R8,R8
    758                  }
    759          
    760                  /* Configure sequence ID. */
    761                  configValue |= FLEXSPI_IPCR1_ISEQID(xfer->seqIndex) | FLEXSPI_IPCR1_ISEQNUM(xfer->SeqNumber - 1);
    762                  base->IPCR1 = configValue;
   \                     ??FLEXSPI_TransferNonBlocking_7: (+1)
   \       0xAE   0x79A8             LDRB     R0,[R5, #+6]
   \       0xB0   0x0400             LSLS     R0,R0,#+16
   \       0xB2   0xF400 0x2070      AND      R0,R0,#0xF0000
   \       0xB6   0xEA40 0x0808      ORR      R8,R0,R8
   \       0xBA   0x79E8             LDRB     R0,[R5, #+7]
   \       0xBC   0x1E40             SUBS     R0,R0,#+1
   \       0xBE   0x0600             LSLS     R0,R0,#+24
   \       0xC0   0xF000 0x60E0      AND      R0,R0,#0x7000000
   \       0xC4   0xEA40 0x0808      ORR      R8,R0,R8
   \       0xC8   0xF8C7 0x80A4      STR      R8,[R7, #+164]
    763          
    764                  /* Start Transfer. */
    765                  base->IPCMD |= FLEXSPI_IPCMD_TRG_MASK;
   \       0xCC   0xF8D7 0x00B0      LDR      R0,[R7, #+176]
   \       0xD0   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0xD4   0xF8C7 0x00B0      STR      R0,[R7, #+176]
    766          
    767                  if (handle->state == kFLEXSPI_BusyRead)
   \       0xD8   0x6820             LDR      R0,[R4, #+0]
   \       0xDA   0x2802             CMP      R0,#+2
   \       0xDC   0xD105             BNE.N    ??FLEXSPI_TransferNonBlocking_8
    768                  {
    769                      FLEXSPI_EnableInterrupts(base, kFLEXSPI_IpRxFifoWatermarkAvailableFlag |
    770                                                         kFLEXSPI_SequenceExecutionTimeoutFlag |
    771                                                         kFLEXSPI_IpCommandSequenceErrorFlag |
    772                                                         kFLEXSPI_IpCommandGrantTimeoutFlag | kFLEXSPI_IpCommandExcutionDoneFlag);
   \       0xDE   0xF640 0x012B      MOVW     R1,#+2091
   \       0xE2   0x4638             MOV      R0,R7
   \       0xE4   0x....'....        BL       FLEXSPI_EnableInterrupts
   \       0xE8   0xE004             B.N      ??FLEXSPI_TransferNonBlocking_3
    773                  }
    774                  else
    775                  {
    776                      FLEXSPI_EnableInterrupts(base, kFLEXSPI_IpTxFifoWatermarkEmpltyFlag |
    777                                                         kFLEXSPI_SequenceExecutionTimeoutFlag |
    778                                                         kFLEXSPI_IpCommandSequenceErrorFlag |
    779                                                         kFLEXSPI_IpCommandGrantTimeoutFlag | kFLEXSPI_IpCommandExcutionDoneFlag);
   \                     ??FLEXSPI_TransferNonBlocking_8: (+1)
   \       0xEA   0xF640 0x014B      MOVW     R1,#+2123
   \       0xEE   0x4638             MOV      R0,R7
   \       0xF0   0x....'....        BL       FLEXSPI_EnableInterrupts
    780                  }
    781              }
    782          
    783              return result;
   \                     ??FLEXSPI_TransferNonBlocking_3: (+1)
   \       0xF4   0x4630             MOV      R0,R6
   \       0xF6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    784          }
    785          
    786          /*!
    787           * brief Gets the master transfer status during a interrupt non-blocking transfer.
    788           *
    789           * param base FLEXSPI peripheral base address.
    790           * param handle pointer to flexspi_handle_t structure which stores the transfer state.
    791           * param count Number of bytes transferred so far by the non-blocking transaction.
    792           * retval kStatus_InvalidArgument count is Invalid.
    793           * retval kStatus_Success Successfully return the count.
    794           */

   \                                 In section .text, align 2, keep-with-next
    795          status_t FLEXSPI_TransferGetCount(FLEXSPI_Type *base, flexspi_handle_t *handle, size_t *count)
    796          {
   \                     FLEXSPI_TransferGetCount: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
    797              assert(handle);
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??FLEXSPI_TransferGetCount_0
   \        0xA   0xF240 0x321D      MOVW     R2,#+797
   \        0xE   0x....             LDR.N    R1,??DataTable11_5
   \       0x10   0x....             LDR.N    R0,??DataTable11_14
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
    798          
    799              status_t result = kStatus_Success;
   \                     ??FLEXSPI_TransferGetCount_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
    800          
    801              if (handle->state == kFLEXSPI_Idle)
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD101             BNE.N    ??FLEXSPI_TransferGetCount_1
    802              {
    803                  result = kStatus_NoTransferInProgress;
   \       0x22   0x2006             MOVS     R0,#+6
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
    804              }
    805              else
    806              {
    807                  *count = handle->transferTotalSize - handle->dataSize;
   \                     ??FLEXSPI_TransferGetCount_1: (+1)
   \       0x26   0x68E2             LDR      R2,[R4, #+12]
   \       0x28   0x68A1             LDR      R1,[R4, #+8]
   \       0x2A   0x1A52             SUBS     R2,R2,R1
   \       0x2C   0x602A             STR      R2,[R5, #+0]
    808              }
    809          
    810              return result;
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    811          }
    812          
    813          /*!
    814           * brief Aborts an interrupt non-blocking transfer early.
    815           *
    816           * note This API can be called at any time when an interrupt non-blocking transfer initiates
    817           * to abort the transfer early.
    818           *
    819           * param base FLEXSPI peripheral base address.
    820           * param handle pointer to flexspi_handle_t structure which stores the transfer state
    821           */

   \                                 In section .text, align 2, keep-with-next
    822          void FLEXSPI_TransferAbort(FLEXSPI_Type *base, flexspi_handle_t *handle)
    823          {
   \                     FLEXSPI_TransferAbort: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    824              assert(handle);
   \        0x6   0xD107             BNE.N    ??FLEXSPI_TransferAbort_0
   \        0x8   0xF44F 0x724E      MOV      R2,#+824
   \        0xC   0x....             LDR.N    R1,??DataTable11_5
   \        0xE   0x....             LDR.N    R0,??DataTable11_14
   \       0x10   0x....'....        BL       __aeabi_assert
   \       0x14   0x....'....        BL       __iar_EmptyStepPoint
    825          
    826              FLEXSPI_DisableInterrupts(base, kIrqFlags);
   \                     ??FLEXSPI_TransferAbort_0: (+1)
   \       0x18   0xF640 0x016B      MOVW     R1,#+2155
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x....'....        BL       FLEXSPI_DisableInterrupts
    827              handle->state = kFLEXSPI_Idle;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x6020             STR      R0,[R4, #+0]
    828          }
   \       0x26   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    829          
    830          /*!
    831           * brief Master interrupt handler.
    832           *
    833           * param base FLEXSPI peripheral base address.
    834           * param handle pointer to flexspi_handle_t structure.
    835           */

   \                                 In section .text, align 2, keep-with-next
    836          void FLEXSPI_TransferHandleIRQ(FLEXSPI_Type *base, flexspi_handle_t *handle)
    837          {
   \                     FLEXSPI_TransferHandleIRQ: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
    838              uint8_t status;
    839              status_t result;
    840              uint8_t txWatermark;
    841              uint8_t rxWatermark;
    842              uint8_t i = 0;
   \        0x8   0xF04F 0x0800      MOV      R8,#+0
    843          
    844              status = base->INTR;
   \        0xC   0x696F             LDR      R7,[R5, #+20]
   \        0xE   0xB2FF             UXTB     R7,R7
    845          
    846              result = FLEXSPI_CheckAndClearError(base, status);
   \       0x10   0x4639             MOV      R1,R7
   \       0x12   0x....'....        BL       FLEXSPI_CheckAndClearError
   \       0x16   0x0004             MOVS     R4,R0
    847          
    848              if ((result != kStatus_Success) && (handle->completionCallback != NULL))
   \       0x18   0xD011             BEQ.N    ??FLEXSPI_TransferHandleIRQ_0
   \       0x1A   0x6930             LDR      R0,[R6, #+16]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD00E             BEQ.N    ??FLEXSPI_TransferHandleIRQ_0
    849              {
    850                  FLEXSPI_TransferAbort(base, handle);
   \       0x20   0x4631             MOV      R1,R6
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0x....'....        BL       FLEXSPI_TransferAbort
    851                  if (handle->completionCallback)
   \       0x28   0x6930             LDR      R0,[R6, #+16]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xF000 0x809E      BEQ.W    ??FLEXSPI_TransferHandleIRQ_1
    852                  {
    853                      handle->completionCallback(base, handle, result, handle->userData);
   \       0x30   0x6973             LDR      R3,[R6, #+20]
   \       0x32   0x4622             MOV      R2,R4
   \       0x34   0x4631             MOV      R1,R6
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x6934             LDR      R4,[R6, #+16]
   \       0x3A   0x47A0             BLX      R4
    854                  }
    855                  return;
   \       0x3C   0xE096             B.N      ??FLEXSPI_TransferHandleIRQ_1
    856              }
    857          
    858              if ((status & kFLEXSPI_IpRxFifoWatermarkAvailableFlag) && (handle->state == kFLEXSPI_BusyRead))
   \                     ??FLEXSPI_TransferHandleIRQ_0: (+1)
   \       0x3E   0x4638             MOV      R0,R7
   \       0x40   0x0680             LSLS     R0,R0,#+26
   \       0x42   0xD53C             BPL.N    ??FLEXSPI_TransferHandleIRQ_2
   \       0x44   0x6830             LDR      R0,[R6, #+0]
   \       0x46   0x2802             CMP      R0,#+2
   \       0x48   0xD139             BNE.N    ??FLEXSPI_TransferHandleIRQ_2
    859              {
    860                  rxWatermark = ((base->IPRXFCR & FLEXSPI_IPRXFCR_RXWMRK_MASK) >> FLEXSPI_IPRXFCR_RXWMRK_SHIFT) + 1;
   \       0x4A   0xF8D5 0x00B8      LDR      R0,[R5, #+184]
   \       0x4E   0xF3C0 0x0083      UBFX     R0,R0,#+2,#+4
   \       0x52   0x1C40             ADDS     R0,R0,#+1
   \       0x54   0xB2C0             UXTB     R0,R0
    861          
    862                  /* Read watermark level data from rx fifo . */
    863                  if (handle->dataSize >= 8 * rxWatermark)
   \       0x56   0x68B1             LDR      R1,[R6, #+8]
   \       0x58   0xEBB1 0x0FC0      CMP      R1,R0, LSL #+3
   \       0x5C   0xD322             BCC.N    ??FLEXSPI_TransferHandleIRQ_3
   \       0x5E   0xE00B             B.N      ??FLEXSPI_TransferHandleIRQ_4
    864                  {
    865                      /* Read watermark level data from rx fifo . */
    866                      for (i = 0; i < 2 * rxWatermark; i++)
    867                      {
    868                          *handle->data++ = base->RFDR[i];
   \                     ??FLEXSPI_TransferHandleIRQ_5: (+1)
   \       0x60   0x6871             LDR      R1,[R6, #+4]
   \       0x62   0x1D0A             ADDS     R2,R1,#+4
   \       0x64   0x6072             STR      R2,[R6, #+4]
   \       0x66   0x4642             MOV      R2,R8
   \       0x68   0xB2D2             UXTB     R2,R2
   \       0x6A   0xEB05 0x0282      ADD      R2,R5,R2, LSL #+2
   \       0x6E   0xF8D2 0x2100      LDR      R2,[R2, #+256]
   \       0x72   0x600A             STR      R2,[R1, #+0]
    869                      }
   \       0x74   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??FLEXSPI_TransferHandleIRQ_4: (+1)
   \       0x78   0x4641             MOV      R1,R8
   \       0x7A   0xB2C9             UXTB     R1,R1
   \       0x7C   0xEBB1 0x0F40      CMP      R1,R0, LSL #+1
   \       0x80   0xDBEE             BLT.N    ??FLEXSPI_TransferHandleIRQ_5
    870          
    871                      handle->dataSize = handle->dataSize - 8 * rxWatermark;
   \       0x82   0x68B1             LDR      R1,[R6, #+8]
   \       0x84   0xEBA1 0x01C0      SUB      R1,R1,R0, LSL #+3
   \       0x88   0x60B1             STR      R1,[R6, #+8]
   \       0x8A   0xE014             B.N      ??FLEXSPI_TransferHandleIRQ_6
    872                  }
    873                  else
    874                  {
    875                      for (i = 0; i < (handle->dataSize / 4 + 1); i++)
    876                      {
    877                          *handle->data++ = base->RFDR[i];
   \                     ??FLEXSPI_TransferHandleIRQ_7: (+1)
   \       0x8C   0x6870             LDR      R0,[R6, #+4]
   \       0x8E   0x1D01             ADDS     R1,R0,#+4
   \       0x90   0x6071             STR      R1,[R6, #+4]
   \       0x92   0x4641             MOV      R1,R8
   \       0x94   0xB2C9             UXTB     R1,R1
   \       0x96   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \       0x9A   0xF8D1 0x1100      LDR      R1,[R1, #+256]
   \       0x9E   0x6001             STR      R1,[R0, #+0]
    878                      }
   \       0xA0   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??FLEXSPI_TransferHandleIRQ_3: (+1)
   \       0xA4   0x4640             MOV      R0,R8
   \       0xA6   0xB2C0             UXTB     R0,R0
   \       0xA8   0x68B1             LDR      R1,[R6, #+8]
   \       0xAA   0x0889             LSRS     R1,R1,#+2
   \       0xAC   0x1C49             ADDS     R1,R1,#+1
   \       0xAE   0x4288             CMP      R0,R1
   \       0xB0   0xD3EC             BCC.N    ??FLEXSPI_TransferHandleIRQ_7
    879                      handle->dataSize = 0;
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0x60B0             STR      R0,[R6, #+8]
    880                  }
    881                  /* Pop out a watermark level datas from IP RX FIFO. */
    882                  base->INTR |= kFLEXSPI_IpRxFifoWatermarkAvailableFlag;
   \                     ??FLEXSPI_TransferHandleIRQ_6: (+1)
   \       0xB6   0x6968             LDR      R0,[R5, #+20]
   \       0xB8   0xF040 0x0020      ORR      R0,R0,#0x20
   \       0xBC   0x6168             STR      R0,[R5, #+20]
    883              }
    884          
    885              if (status & kFLEXSPI_IpCommandExcutionDoneFlag)
   \                     ??FLEXSPI_TransferHandleIRQ_2: (+1)
   \       0xBE   0x4638             MOV      R0,R7
   \       0xC0   0x07C0             LSLS     R0,R0,#+31
   \       0xC2   0xD510             BPL.N    ??FLEXSPI_TransferHandleIRQ_8
    886              {
    887                  base->INTR |= kFLEXSPI_IpCommandExcutionDoneFlag;
   \       0xC4   0x6968             LDR      R0,[R5, #+20]
   \       0xC6   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0xCA   0x6168             STR      R0,[R5, #+20]
    888          
    889                  FLEXSPI_TransferAbort(base, handle);
   \       0xCC   0x4631             MOV      R1,R6
   \       0xCE   0x4628             MOV      R0,R5
   \       0xD0   0x....'....        BL       FLEXSPI_TransferAbort
    890          
    891                  if (handle->completionCallback)
   \       0xD4   0x6930             LDR      R0,[R6, #+16]
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD005             BEQ.N    ??FLEXSPI_TransferHandleIRQ_8
    892                  {
    893                      handle->completionCallback(base, handle, kStatus_Success, handle->userData);
   \       0xDA   0x6973             LDR      R3,[R6, #+20]
   \       0xDC   0x2200             MOVS     R2,#+0
   \       0xDE   0x4631             MOV      R1,R6
   \       0xE0   0x4628             MOV      R0,R5
   \       0xE2   0x6934             LDR      R4,[R6, #+16]
   \       0xE4   0x47A0             BLX      R4
    894                  }
    895              }
    896          
    897              /* TX FIFO empty interrupt, push watermark level data into tx FIFO. */
    898              if ((status & kFLEXSPI_IpTxFifoWatermarkEmpltyFlag) && (handle->state == kFLEXSPI_BusyWrite))
   \                     ??FLEXSPI_TransferHandleIRQ_8: (+1)
   \       0xE6   0x0678             LSLS     R0,R7,#+25
   \       0xE8   0xD540             BPL.N    ??FLEXSPI_TransferHandleIRQ_1
   \       0xEA   0x6830             LDR      R0,[R6, #+0]
   \       0xEC   0x2801             CMP      R0,#+1
   \       0xEE   0xD13D             BNE.N    ??FLEXSPI_TransferHandleIRQ_1
    899              {
    900                  if (handle->dataSize)
   \       0xF0   0x68B0             LDR      R0,[R6, #+8]
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xD03A             BEQ.N    ??FLEXSPI_TransferHandleIRQ_1
    901                  {
    902                      txWatermark = ((base->IPTXFCR & FLEXSPI_IPTXFCR_TXWMRK_MASK) >> FLEXSPI_IPTXFCR_TXWMRK_SHIFT) + 1;
   \       0xF6   0xF8D5 0x00BC      LDR      R0,[R5, #+188]
   \       0xFA   0xF3C0 0x0183      UBFX     R1,R0,#+2,#+4
   \       0xFE   0x1C49             ADDS     R1,R1,#+1
   \      0x100   0xB2C9             UXTB     R1,R1
    903                      /* Write watermark level data into tx fifo . */
    904                      if (handle->dataSize >= 8 * txWatermark)
   \      0x102   0x68B0             LDR      R0,[R6, #+8]
   \      0x104   0xEBB0 0x0FC1      CMP      R0,R1, LSL #+3
   \      0x108   0xD316             BCC.N    ??FLEXSPI_TransferHandleIRQ_9
    905                      {
    906                          for (i = 0; i < 2 * txWatermark; i++)
   \      0x10A   0x2000             MOVS     R0,#+0
   \      0x10C   0xE00A             B.N      ??FLEXSPI_TransferHandleIRQ_10
    907                          {
    908                              base->TFDR[i] = *handle->data++;
   \                     ??FLEXSPI_TransferHandleIRQ_11: (+1)
   \      0x10E   0x6872             LDR      R2,[R6, #+4]
   \      0x110   0x1D13             ADDS     R3,R2,#+4
   \      0x112   0x6073             STR      R3,[R6, #+4]
   \      0x114   0x6812             LDR      R2,[R2, #+0]
   \      0x116   0x4603             MOV      R3,R0
   \      0x118   0xB2DB             UXTB     R3,R3
   \      0x11A   0xEB05 0x0383      ADD      R3,R5,R3, LSL #+2
   \      0x11E   0xF8C3 0x2180      STR      R2,[R3, #+384]
    909                          }
   \      0x122   0x1C40             ADDS     R0,R0,#+1
   \                     ??FLEXSPI_TransferHandleIRQ_10: (+1)
   \      0x124   0x4602             MOV      R2,R0
   \      0x126   0xB2D2             UXTB     R2,R2
   \      0x128   0xEBB2 0x0F41      CMP      R2,R1, LSL #+1
   \      0x12C   0xDBEF             BLT.N    ??FLEXSPI_TransferHandleIRQ_11
    910          
    911                          handle->dataSize = handle->dataSize - 8 * txWatermark;
   \      0x12E   0x68B0             LDR      R0,[R6, #+8]
   \      0x130   0xEBA0 0x00C1      SUB      R0,R0,R1, LSL #+3
   \      0x134   0x60B0             STR      R0,[R6, #+8]
   \      0x136   0xE015             B.N      ??FLEXSPI_TransferHandleIRQ_12
    912                      }
    913                      else
    914                      {
    915                          for (i = 0; i < (handle->dataSize / 4 + 1); i++)
   \                     ??FLEXSPI_TransferHandleIRQ_9: (+1)
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0xE00A             B.N      ??FLEXSPI_TransferHandleIRQ_13
    916                          {
    917                              base->TFDR[i] = *handle->data++;
   \                     ??FLEXSPI_TransferHandleIRQ_14: (+1)
   \      0x13C   0x6871             LDR      R1,[R6, #+4]
   \      0x13E   0x1D0A             ADDS     R2,R1,#+4
   \      0x140   0x6072             STR      R2,[R6, #+4]
   \      0x142   0x6809             LDR      R1,[R1, #+0]
   \      0x144   0x4602             MOV      R2,R0
   \      0x146   0xB2D2             UXTB     R2,R2
   \      0x148   0xEB05 0x0282      ADD      R2,R5,R2, LSL #+2
   \      0x14C   0xF8C2 0x1180      STR      R1,[R2, #+384]
    918                          }
   \      0x150   0x1C40             ADDS     R0,R0,#+1
   \                     ??FLEXSPI_TransferHandleIRQ_13: (+1)
   \      0x152   0x4601             MOV      R1,R0
   \      0x154   0xB2C9             UXTB     R1,R1
   \      0x156   0x68B2             LDR      R2,[R6, #+8]
   \      0x158   0x0892             LSRS     R2,R2,#+2
   \      0x15A   0x1C52             ADDS     R2,R2,#+1
   \      0x15C   0x4291             CMP      R1,R2
   \      0x15E   0xD3ED             BCC.N    ??FLEXSPI_TransferHandleIRQ_14
    919                          handle->dataSize = 0;
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0x60B0             STR      R0,[R6, #+8]
    920                      }
    921          
    922                      /* Push a watermark level datas into IP TX FIFO. */
    923                      base->INTR |= kFLEXSPI_IpTxFifoWatermarkEmpltyFlag;
   \                     ??FLEXSPI_TransferHandleIRQ_12: (+1)
   \      0x164   0x6968             LDR      R0,[R5, #+20]
   \      0x166   0xF040 0x0040      ORR      R0,R0,#0x40
   \      0x16A   0x6168             STR      R0,[R5, #+20]
    924                  }
    925              }
    926              else
    927              {
    928              }
    929          }
   \                     ??FLEXSPI_TransferHandleIRQ_1: (+1)
   \      0x16C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x30 0x00          DC8      "0",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x400F'C068        DC32     0x400fc068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x402A'8000        DC32     0x402a8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x05F5'E100        DC32     0x5f5e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0x....'....        DC32     s_flexspiClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \        0x0   0x00F7'77FF        DC32     0xf777ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \        0x0   0x7CF0'FF00        DC32     0x7cf0ff00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \        0x0   0xFFFF'101F        DC32     0xffff101f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \        0x0   0x5AF0'5AF0        DC32     0x5af05af0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \        0x0   0x....'....        DC32     s_flexspiIrqs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x6E          DC8 "index <= 6"
   \              0x64 0x65    
   \              0x78 0x20    
   \              0x3C 0x3D    
   \              0x20 0x36    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
   \              0x5C 0x44    
   \              0x65 0x76    
   \              0x65 0x6C    
   \        0x8   0x6F 0x70          DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73    
   \       0x10   0x6D 0x61          DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
   \              0x72 0x74    
   \              0x5F 0x77    
   \              0x61 0x73    
   \       0x18   0x68 0x69          DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
   \              0x6E 0x67    
   \              0x5F 0x6D    
   \              0x61 0x63    
   \       0x20   0x68 0x69          DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
   \              0x6E 0x65    
   \              0x5F 0x33    
   \              0x30 0x38    
   \       0x28   0x30 0x5C          DC8 30H, 5CH, 64H, 72H, 69H, 76H, 65H, 72H
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \       0x30   0x73 0x5C          DC8 73H, 5CH, 66H, 73H, 6CH, 5FH, 63H, 6CH
   \              0x66 0x73    
   \              0x6C 0x5F    
   \              0x63 0x6C    
   \       0x38   0x6F 0x63          DC8 6FH, 63H, 6BH, 2EH, 68H, 0
   \              0x6B 0x2E    
   \              0x68 0x00    
   \       0x3E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x69 0x6E          DC8 69H, 6EH, 73H, 74H, 61H, 6EH, 63H, 65H
   \              0x73 0x74    
   \              0x61 0x6E    
   \              0x63 0x65    
   \        0x8   0x20 0x3C          DC8 20H, 3CH, 20H, 28H, 73H, 69H, 7AH, 65H
   \              0x20 0x28    
   \              0x73 0x69    
   \              0x7A 0x65    
   \       0x10   0x6F 0x66          DC8 6FH, 66H, 28H, 73H, 5FH, 66H, 6CH, 65H
   \              0x28 0x73    
   \              0x5F 0x66    
   \              0x6C 0x65    
   \       0x18   0x78 0x73          DC8 78H, 73H, 70H, 69H, 42H, 61H, 73H, 65H
   \              0x70 0x69    
   \              0x42 0x61    
   \              0x73 0x65    
   \       0x20   0x73 0x29          DC8 73H, 29H, 20H, 2FH, 20H, 73H, 69H, 7AH
   \              0x20 0x2F    
   \              0x20 0x73    
   \              0x69 0x7A    
   \       0x28   0x65 0x6F          DC8 65H, 6FH, 66H, 28H, 28H, 73H, 5FH, 66H
   \              0x66 0x28    
   \              0x28 0x73    
   \              0x5F 0x66    
   \       0x30   0x6C 0x65          DC8 6CH, 65H, 78H, 73H, 70H, 69H, 42H, 61H
   \              0x78 0x73    
   \              0x70 0x69    
   \              0x42 0x61    
   \       0x38   0x73 0x65          DC8 73H, 65H, 73H, 29H, 5BH, 30H, 5DH, 29H
   \              0x73 0x29    
   \              0x5B 0x30    
   \              0x5D 0x29    
   \       0x40   0x29 0x00          DC8 29H, 0
   \       0x42   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
   \              0x5C 0x44    
   \              0x65 0x76    
   \              0x65 0x6C    
   \        0x8   0x6F 0x70          DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73    
   \       0x10   0x6D 0x61          DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
   \              0x72 0x74    
   \              0x5F 0x77    
   \              0x61 0x73    
   \       0x18   0x68 0x69          DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
   \              0x6E 0x67    
   \              0x5F 0x6D    
   \              0x61 0x63    
   \       0x20   0x68 0x69          DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
   \              0x6E 0x65    
   \              0x5F 0x33    
   \              0x30 0x38    
   \       0x28   0x30 0x5C          DC8 30H, 5CH, 64H, 72H, 69H, 76H, 65H, 72H
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \       0x30   0x73 0x5C          DC8 73H, 5CH, 66H, 73H, 6CH, 5FH, 66H, 6CH
   \              0x66 0x73    
   \              0x6C 0x5F    
   \              0x66 0x6C    
   \       0x38   0x65 0x78          DC8 65H, 78H, 73H, 70H, 69H, 2EH, 63H, 0
   \              0x73 0x70    
   \              0x69 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 2
   \        0x0   0x30 0x00          DC8 "0"

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x69 0x6E          DC8 "index < 64U"
   \              0x64 0x65    
   \              0x78 0x20    
   \              0x3C 0x20    
   \              0x36 0x34    
   \              0x55 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x68 0x61          DC8 "handle"
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x78 0x66          DC8 "xfer"
   \              0x65 0x72    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    930          
    931          #if defined(FSL_DRIVER_TRANSFER_DOUBLE_WEAK_IRQ) && FSL_DRIVER_TRANSFER_DOUBLE_WEAK_IRQ
    932          #if defined(FLEXSPI)
    933          void FLEXSPI_DriverIRQHandler(void)
    934          {
    935              FLEXSPI_TransferHandleIRQ(FLEXSPI, s_flexspiHandle[0]);
    936          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
    937            exception return operation might vector to incorrect interrupt */
    938          #if defined __CORTEX_M && (__CORTEX_M == 4U)
    939              __DSB();
    940          #endif
    941          }
    942          #endif
    943          
    944          #if defined(FLEXSPI0)
    945          void FLEXSPI0_DriverIRQHandler(void)
    946          {
    947              FLEXSPI_TransferHandleIRQ(FLEXSPI0, s_flexspiHandle[0]);
    948          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
    949            exception return operation might vector to incorrect interrupt */
    950          #if defined __CORTEX_M && (__CORTEX_M == 4U)
    951              __DSB();
    952          #endif
    953          }
    954          #endif
    955          #if defined(FLEXSPI1)
    956          void FLEXSPI1_DriverIRQHandler(void)
    957          {
    958              FLEXSPI_TransferHandleIRQ(FLEXSPI1, s_flexspiHandle[1]);
    959          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
    960            exception return operation might vector to incorrect interrupt */
    961          #if defined __CORTEX_M && (__CORTEX_M == 4U)
    962              __DSB();
    963          #endif
    964          }
    965          #endif
    966          
    967          #if defined(LSIO__FLEXSPI0)
    968          void LSIO_OCTASPI0_INT_DriverIRQHandler(void)
    969          {
    970              FLEXSPI_TransferHandleIRQ(LSIO__FLEXSPI0, s_flexspiHandle[0]);
    971          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
    972            exception return operation might vector to incorrect interrupt */
    973          #if defined __CORTEX_M && (__CORTEX_M == 4U)
    974              __DSB();
    975          #endif
    976          }
    977          #endif
    978          #if defined(LSIO__FLEXSPI1)
    979          void LSIO_OCTASPI1_INT_DriverIRQHandler(void)
    980          {
    981              FLEXSPI_TransferHandleIRQ(LSIO__FLEXSPI1, s_flexspiHandle[1]);
    982          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
    983            exception return operation might vector to incorrect interrupt */
    984          #if defined __CORTEX_M && (__CORTEX_M == 4U)
    985              __DSB();
    986          #endif
    987          }
    988          #endif
    989          
    990          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CLOCK_ControlGate
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   CLOCK_EnableClock
         0   -> CLOCK_ControlGate
       8   EnableIRQ
         8   -> __NVIC_EnableIRQ
      16   FLEXSPI_CheckAndClearError
        16   -> FLEXSPI_ClearInterruptStatusFlags
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   FLEXSPI_ClearInterruptStatusFlags
       0   FLEXSPI_ConfigureDll
       0   FLEXSPI_Deinit
         0   -> FLEXSPI_SoftwareReset
       0   FLEXSPI_DisableInterrupts
       0   FLEXSPI_EnableInterrupts
       0   FLEXSPI_GetBusIdleStatus
       8   FLEXSPI_GetDefaultConfig
         8   -> __aeabi_memset
       8   FLEXSPI_GetInstance
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   FLEXSPI_Init
        16   -> CLOCK_EnableClock
        16   -> FLEXSPI_GetInstance
        16   -> FLEXSPI_SoftwareReset
      24   FLEXSPI_ReadBlocking
        24   -> FLEXSPI_CheckAndClearError
      24   FLEXSPI_SetFlashConfig
        24   -> FLEXSPI_ConfigureDll
        24   -> FLEXSPI_GetBusIdleStatus
       0   FLEXSPI_SoftwareReset
      16   FLEXSPI_TransferAbort
        16   -> FLEXSPI_DisableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   FLEXSPI_TransferBlocking
        16   -> FLEXSPI_CheckAndClearError
        16   -> FLEXSPI_GetBusIdleStatus
        16   -> FLEXSPI_ReadBlocking
        16   -> FLEXSPI_WriteBlocking
      24   FLEXSPI_TransferCreateHandle
         0   -> EnableIRQ
        24   -> FLEXSPI_GetInstance
        24   -> __aeabi_assert
        24   -> __aeabi_memset4
        24   -> __iar_EmptyStepPoint
      16   FLEXSPI_TransferGetCount
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   FLEXSPI_TransferHandleIRQ
        24   -- Indirect call
        24   -> FLEXSPI_CheckAndClearError
        24   -> FLEXSPI_TransferAbort
      24   FLEXSPI_TransferNonBlocking
        24   -> FLEXSPI_EnableInterrupts
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   FLEXSPI_UpdateLUT
        24   -> FLEXSPI_GetBusIdleStatus
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   FLEXSPI_WriteBlocking
        24   -> FLEXSPI_CheckAndClearError
       0   __NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable6
      12  ?_0
      64  ?_1
      68  ?_2
      64  ?_3
       2  ?_4
      12  ?_5
       8  ?_6
       8  ?_7
      64  CLOCK_ControlGate
       4  CLOCK_EnableClock
      24  EnableIRQ
      98  FLEXSPI_CheckAndClearError
       8  FLEXSPI_ClearInterruptStatusFlags
      82  FLEXSPI_ConfigureDll
       2  FLEXSPI_Deinit
      10  FLEXSPI_DisableInterrupts
       8  FLEXSPI_EnableInterrupts
      22  FLEXSPI_GetBusIdleStatus
     128  FLEXSPI_GetDefaultConfig
      46  FLEXSPI_GetInstance
     360  FLEXSPI_Init
     188  FLEXSPI_ReadBlocking
     286  FLEXSPI_SetFlashConfig
      16  FLEXSPI_SoftwareReset
      40  FLEXSPI_TransferAbort
     198  FLEXSPI_TransferBlocking
      64  FLEXSPI_TransferCreateHandle
      48  FLEXSPI_TransferGetCount
     368  FLEXSPI_TransferHandleIRQ
     250  FLEXSPI_TransferNonBlocking
      98  FLEXSPI_UpdateLUT
     120  FLEXSPI_WriteBlocking
      24  __NVIC_EnableIRQ
       2  s_flexspiClock
       2  s_flexspiIrqs

 
   242 bytes in section .rodata
 2 628 bytes in section .text
 
 2 628 bytes of CODE  memory
   242 bytes of CONST memory

Errors: none
Warnings: none
