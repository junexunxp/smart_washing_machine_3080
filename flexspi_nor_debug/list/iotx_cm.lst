###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:30
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\iotx_cm.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW474.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\iotx_cm.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\iotx_cm.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\iotx_cm.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\iotx_cm.c
      1          #include "iotx_cm_internal.h"
      2          
      3          #if defined(MQTT_COMM_ENABLED) || defined(MAL_ENABLED) 
      4          #include "iotx_cm_mqtt.h"
      5          #endif
      6          #ifdef COAP_COMM_ENABLED
      7          #include "iotx_cm_coap.h"
      8          #endif
      9          
     10          

   \                                 In section .bss, align 4
     11          static void *fd_lock = NULL;
   \                     fd_lock:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     12          static iotx_cm_connection_t *_cm_fd[CM_MAX_FD_NUM] = {NULL};
   \                     _cm_fd:
   \        0x0                      DS8 12
     13          static int _get_fd(iotx_cm_connection_t *handle);
     14          static int _recycle_fd(int fd);
     15          static int inline _fd_is_valid(int fd);

   \                                 In section .bss, align 4
     16          static int inited_conn_num = 0;
   \                     inited_conn_num:
   \        0x0                      DS8 4
     17          
     18          #ifdef DEVICE_MODEL_GATEWAY
     19              static void *_iotx_cm_yield_thread_func(void *params);
     20              static void *yield_thread = NULL;
     21              static int yield_task_leave = 1;
     22          #endif
     23          

   \                                 In section .rodata, align 4
     24          const char ERR_INVALID_PARAMS[] = "invalid parameter";
   \                     ERR_INVALID_PARAMS:
   \        0x0   0x69 0x6E          DC8 "invalid parameter"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x70 0x61    
   \              0x72 0x61    
   \              0x6D 0x65    
   \              0x74 0x65    
   \              0x72 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 2, keep-with-next
     25          int iotx_cm_open(iotx_cm_init_param_t *params)
     26          {
   \                     iotx_cm_open: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
     27              int fd;
     28              iotx_cm_connection_t *connection = NULL;
   \        0x2   0x2400             MOVS     R4,#+0
     29          
     30              switch (params->protocol_type) {
   \        0x4   0x7C01             LDRB     R1,[R0, #+16]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD102             BNE.N    ??iotx_cm_open_0
     31                  case IOTX_CM_PROTOCOL_TYPE_MQTT:
     32          #if defined(MQTT_COMM_ENABLED) || defined(MAL_ENABLED)
     33                      connection = iotx_cm_open_mqtt(params);
   \        0xA   0x....'....        BL       iotx_cm_open_mqtt
   \        0xE   0x4604             MOV      R4,R0
     34          #endif
     35                      break;
     36                  case IOTX_CM_PROTOCOL_TYPE_COAP:
     37          #ifdef COAP_COMM_ENABLED
     38                      connection = iotx_cm_open_coap(params);
     39          #endif
     40                      break;            
     41                  default:
     42                      break;
     43              }
     44          
     45              if (connection == NULL) {
   \                     ??iotx_cm_open_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD102             BNE.N    ??iotx_cm_open_1
     46                  cm_err("cm opon failed");
     47                  return -1;
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD10             POP      {R4,PC}
     48              }
     49              fd = _get_fd(connection);
   \                     ??iotx_cm_open_1: (+1)
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x....'....        BL       _get_fd
     50              if (fd < 0) {
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD504             BPL.N    ??iotx_cm_open_2
     51                  cm_err("get fd failed");
     52                  connection->close_func();
   \       0x24   0x6AA0             LDR      R0,[R4, #+40]
   \       0x26   0x4780             BLX      R0
     53                  return -1;
   \       0x28   0xF04F 0x30FF      MOV      R0,#-1
   \       0x2C   0xBD10             POP      {R4,PC}
     54              }
     55              connection->fd = fd;
   \                     ??iotx_cm_open_2: (+1)
   \       0x2E   0x6020             STR      R0,[R4, #+0]
     56              return fd;
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
     57          }
     58          

   \                                 In section .text, align 2, keep-with-next
     59          int iotx_cm_connect(int fd, uint32_t timeout)
     60          {
   \                     iotx_cm_connect: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
     61              iotx_cm_connect_fp connect_func;
     62              int ret;
     63          
     64              if (_fd_is_valid(fd) == -1) {
   \        0x6   0x....'....        BL       _fd_is_valid
   \        0xA   0xF110 0x0F01      CMN      R0,#+1
   \        0xE   0xD102             BNE.N    ??iotx_cm_connect_0
     65                  cm_err(ERR_INVALID_PARAMS);
     66                  return -1;
   \       0x10   0xF04F 0x30FF      MOV      R0,#-1
   \       0x14   0xBD70             POP      {R4-R6,PC}
     67              }
     68              HAL_MutexLock(fd_lock);
   \                     ??iotx_cm_connect_0: (+1)
   \       0x16   0x....             LDR.N    R6,??DataTable9
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x....'....        BL       HAL_MutexLock
     69              connect_func = _cm_fd[fd]->connect_func;
   \       0x1E   0x....             LDR.N    R0,??DataTable9_1
   \       0x20   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \       0x24   0x6944             LDR      R4,[R0, #+20]
     70              HAL_MutexUnlock(fd_lock);
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0x....'....        BL       HAL_MutexUnlock
     71          
     72              iotx_event_post(IOTX_CONN_CLOUD);
   \       0x2C   0xF44F 0x5000      MOV      R0,#+8192
   \       0x30   0x....'....        BL       iotx_event_post
     73          
     74              ret = connect_func(timeout);
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x47A0             BLX      R4
   \       0x38   0x0004             MOVS     R4,R0
     75          
     76              if (ret == 0) {
   \       0x3A   0xD108             BNE.N    ??iotx_cm_connect_1
     77                  inited_conn_num++;
   \       0x3C   0x....             LDR.N    R0,??DataTable9_2
   \       0x3E   0x6801             LDR      R1,[R0, #+0]
   \       0x40   0x1C49             ADDS     R1,R1,#+1
   \       0x42   0x6001             STR      R1,[R0, #+0]
     78                  if (inited_conn_num == 1) {
     79          
     80          #ifdef DEVICE_MODEL_GATEWAY
     81                      int stack_used;
     82                      hal_os_thread_param_t task_parms = {0};
     83                      task_parms.stack_size = 6144;
     84                      task_parms.name = "cm_yield";
     85                      ret = HAL_ThreadCreate(&yield_thread, _iotx_cm_yield_thread_func, NULL,
     86                                             &task_parms, &stack_used);
     87                      if (ret < 0) {
     88                          inited_conn_num--;
     89                      }
     90          #endif
     91                  }
     92                  iotx_event_post(IOTX_CONN_CLOUD_SUC);    
   \       0x44   0xF242 0x0002      MOVW     R0,#+8194
   \       0x48   0x....'....        BL       iotx_event_post
   \       0x4C   0xE003             B.N      ??iotx_cm_connect_2
     93              } else {
     94                  iotx_event_post(IOTX_CONN_CLOUD_FAIL);
   \                     ??iotx_cm_connect_1: (+1)
   \       0x4E   0xF242 0x0001      MOVW     R0,#+8193
   \       0x52   0x....'....        BL       iotx_event_post
     95              }
     96          
     97          
     98              return ret;
   \                     ??iotx_cm_connect_2: (+1)
   \       0x56   0x4620             MOV      R0,R4
   \       0x58   0xBD70             POP      {R4-R6,PC}       ;; return
     99          }
    100          

   \                                 In section .text, align 2, keep-with-next
    101          static int _iotx_cm_yield(int fd, unsigned int timeout)
    102          {
   \                     _iotx_cm_yield: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
    103              iotx_cm_yield_fp yield_func;
    104          
    105              if (fd_lock == NULL) {
   \        0x6   0x....             LDR.N    R4,??DataTable9
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD102             BNE.N    ??_iotx_cm_yield_0
    106                  return NULL_VALUE_ERROR;
   \        0xE   0xF06F 0x0001      MVN      R0,#+1
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
    107              }
    108          
    109              if (fd == -1) {
   \                     ??_iotx_cm_yield_0: (+1)
   \       0x14   0xF116 0x0F01      CMN      R6,#+1
   \       0x18   0xD117             BNE.N    ??_iotx_cm_yield_1
    110                  int i;
    111                  for (i = 0; i < CM_MAX_FD_NUM; i++) {
   \       0x1A   0x2600             MOVS     R6,#+0
   \       0x1C   0xE011             B.N      ??_iotx_cm_yield_2
    112                      yield_func = NULL;
   \                     ??_iotx_cm_yield_3: (+1)
   \       0x1E   0x2700             MOVS     R7,#+0
    113                      HAL_MutexLock(fd_lock);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x....'....        BL       HAL_MutexLock
    114                      if (_cm_fd[i] != NULL) {
   \       0x26   0x....             LDR.N    R1,??DataTable9_1
   \       0x28   0xF851 0x0026      LDR      R0,[R1, R6, LSL #+2]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD000             BEQ.N    ??_iotx_cm_yield_4
    115                          yield_func =  _cm_fd[i]->yield_func;
   \       0x30   0x6A47             LDR      R7,[R0, #+36]
    116                      }
    117                      HAL_MutexUnlock(fd_lock);
   \                     ??_iotx_cm_yield_4: (+1)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x....'....        BL       HAL_MutexUnlock
    118                      if (yield_func != NULL) {
   \       0x38   0x0038             MOVS     R0,R7
   \       0x3A   0xD001             BEQ.N    ??_iotx_cm_yield_5
    119                          yield_func(timeout);
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x47B8             BLX      R7
    120                      }
    121                  }
   \                     ??_iotx_cm_yield_5: (+1)
   \       0x40   0x1C76             ADDS     R6,R6,#+1
   \                     ??_iotx_cm_yield_2: (+1)
   \       0x42   0x2E03             CMP      R6,#+3
   \       0x44   0xDBEB             BLT.N    ??_iotx_cm_yield_3
    122                  return 0;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xBDF2             POP      {R1,R4-R7,PC}
    123              }
    124          
    125              if (_fd_is_valid(fd) == -1) {
   \                     ??_iotx_cm_yield_1: (+1)
   \       0x4A   0x4630             MOV      R0,R6
   \       0x4C   0x....'....        BL       _fd_is_valid
   \       0x50   0xF110 0x0F01      CMN      R0,#+1
   \       0x54   0xD102             BNE.N    ??_iotx_cm_yield_6
    126                  cm_err(ERR_INVALID_PARAMS);
    127                  return -1;
   \       0x56   0xF04F 0x30FF      MOV      R0,#-1
   \       0x5A   0xBDF2             POP      {R1,R4-R7,PC}
    128              }
    129          
    130              HAL_MutexLock(fd_lock);
   \                     ??_iotx_cm_yield_6: (+1)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x....'....        BL       HAL_MutexLock
    131              yield_func =  _cm_fd[fd]->yield_func;
   \       0x62   0x....             LDR.N    R0,??DataTable9_1
   \       0x64   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \       0x68   0x6A46             LDR      R6,[R0, #+36]
    132              HAL_MutexUnlock(fd_lock);
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x....'....        BL       HAL_MutexUnlock
    133              return yield_func(timeout);
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x47B0             BLX      R6
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    134          
    135          }
    136          #ifdef DEVICE_MODEL_GATEWAY
    137          static void *_iotx_cm_yield_thread_func(void *params)
    138          {
    139              yield_task_leave = 0;
    140              while (inited_conn_num > 0) {
    141                  _iotx_cm_yield(-1, CM_DEFAULT_YIELD_TIMEOUT);
    142              }
    143              yield_task_leave = 1;
    144              return NULL;
    145          }
    146          #endif
    147          

   \                                 In section .text, align 2, keep-with-next
    148          int iotx_cm_yield(int fd, unsigned int timeout)
    149          {
    150          #ifdef DEVICE_MODEL_GATEWAY
    151              return 0;
    152          #else
    153              return _iotx_cm_yield(fd, timeout);
   \                     iotx_cm_yield: (+1)
   \        0x0   0x....             B.N      _iotx_cm_yield
    154          #endif
    155          }
    156          
    157          

   \                                 In section .text, align 2, keep-with-next
    158          int iotx_cm_sub(int fd, iotx_cm_ext_params_t *ext, const char *topic,
    159                          iotx_cm_data_handle_cb topic_handle_func, void *pcontext)
    160          {
   \                     iotx_cm_sub: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x4698             MOV      R8,R3
    161              iotx_cm_sub_fp sub_func;
    162          
    163              if (_fd_is_valid(fd) == -1) {
   \        0xC   0x....'....        BL       _fd_is_valid
   \       0x10   0xF110 0x0F01      CMN      R0,#+1
   \       0x14   0xD102             BNE.N    ??iotx_cm_sub_0
    164                  cm_err(ERR_INVALID_PARAMS);
    165                  return -1;
   \       0x16   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1A   0xE011             B.N      ??iotx_cm_sub_1
    166              }
   \                     ??iotx_cm_sub_0: (+1)
   \       0x1C   0x9C08             LDR      R4,[SP, #+32]
    167          
    168              HAL_MutexLock(fd_lock);
   \       0x1E   0x....             LDR.N    R5,??DataTable9
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0x....'....        BL       HAL_MutexLock
    169              sub_func =  _cm_fd[fd]->sub_func;
   \       0x26   0x....             LDR.N    R0,??DataTable9_1
   \       0x28   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \       0x2C   0xF8D0 0x9018      LDR      R9,[R0, #+24]
    170              HAL_MutexUnlock(fd_lock);
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x....'....        BL       HAL_MutexUnlock
    171              return sub_func(ext, topic, topic_handle_func, pcontext);
   \       0x36   0x4623             MOV      R3,R4
   \       0x38   0x4642             MOV      R2,R8
   \       0x3A   0x4639             MOV      R1,R7
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x47C8             BLX      R9
   \                     ??iotx_cm_sub_1: (+1)
   \       0x40   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    172          }
    173          

   \                                 In section .text, align 2, keep-with-next
    174          int iotx_cm_unsub(int fd, const char *topic)
    175          {
   \                     iotx_cm_unsub: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    176              iotx_cm_unsub_fp unsub_func;
    177          
    178              if (_fd_is_valid(fd) == -1) {
   \        0x6   0x....'....        BL       _fd_is_valid
   \        0xA   0xF110 0x0F01      CMN      R0,#+1
   \        0xE   0xD102             BNE.N    ??iotx_cm_unsub_0
    179                  cm_err(ERR_INVALID_PARAMS);
    180                  return -1;
   \       0x10   0xF04F 0x30FF      MOV      R0,#-1
   \       0x14   0xBD70             POP      {R4-R6,PC}
    181              }
    182          
    183              HAL_MutexLock(fd_lock);
   \                     ??iotx_cm_unsub_0: (+1)
   \       0x16   0x....             LDR.N    R6,??DataTable9
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x....'....        BL       HAL_MutexLock
    184              unsub_func =  _cm_fd[fd]->unsub_func;
   \       0x1E   0x....             LDR.N    R0,??DataTable9_1
   \       0x20   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \       0x24   0x69C4             LDR      R4,[R0, #+28]
    185              HAL_MutexUnlock(fd_lock);
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0x....'....        BL       HAL_MutexUnlock
    186              return unsub_func(topic);
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x47A0             BLX      R4
   \       0x30   0xBD70             POP      {R4-R6,PC}       ;; return
    187          }
    188          
    189          
    190          

   \                                 In section .text, align 2, keep-with-next
    191          int iotx_cm_pub(int fd, iotx_cm_ext_params_t *ext, const char *topic, const char *payload, unsigned int payload_len)
    192          {
   \                     iotx_cm_pub: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x4698             MOV      R8,R3
    193              iotx_cm_pub_fp pub_func;
    194              
    195              if (_fd_is_valid(fd) == -1) {
   \        0xC   0x....'....        BL       _fd_is_valid
   \       0x10   0xF110 0x0F01      CMN      R0,#+1
   \       0x14   0xD102             BNE.N    ??iotx_cm_pub_0
    196                  cm_err(ERR_INVALID_PARAMS);
    197                  return -1;
   \       0x16   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1A   0xE011             B.N      ??iotx_cm_pub_1
    198              }
   \                     ??iotx_cm_pub_0: (+1)
   \       0x1C   0x9C08             LDR      R4,[SP, #+32]
    199          
    200              HAL_MutexLock(fd_lock);
   \       0x1E   0x....             LDR.N    R5,??DataTable9
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0x....'....        BL       HAL_MutexLock
    201              pub_func =  _cm_fd[fd]->pub_func;
   \       0x26   0x....             LDR.N    R0,??DataTable9_1
   \       0x28   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \       0x2C   0xF8D0 0x9020      LDR      R9,[R0, #+32]
    202              HAL_MutexUnlock(fd_lock);
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x....'....        BL       HAL_MutexUnlock
    203              return pub_func(ext, topic, payload, payload_len);
   \       0x36   0x4623             MOV      R3,R4
   \       0x38   0x4642             MOV      R2,R8
   \       0x3A   0x4639             MOV      R1,R7
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x47C8             BLX      R9
   \                     ??iotx_cm_pub_1: (+1)
   \       0x40   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    204          }
    205          

   \                                 In section .text, align 2, keep-with-next
    206          int iotx_cm_close(int fd)
    207          {
   \                     iotx_cm_close: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
    208              iotx_cm_close_fp close_func;
    209          
    210              if (_fd_is_valid(fd) != 0) {
   \        0x4   0x....'....        BL       _fd_is_valid
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD118             BNE.N    ??iotx_cm_close_0
    211                  cm_err(ERR_INVALID_PARAMS);
    212                  return -1;
    213              }
    214          
    215              if (inited_conn_num > 0) {
   \        0xC   0x....             LDR.N    R6,??DataTable9_2
   \        0xE   0x6830             LDR      R0,[R6, #+0]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xDB01             BLT.N    ??iotx_cm_close_1
    216                  inited_conn_num--;
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x6030             STR      R0,[R6, #+0]
    217              }
    218          
    219              if (inited_conn_num == 0) {
    220          #ifdef DEVICE_MODEL_GATEWAY
    221                  while (!yield_task_leave) {
    222                      HAL_SleepMs(10);
    223                  }
    224                  if (yield_thread != NULL) {
    225                      HAL_ThreadDelete(yield_thread);
    226                  }
    227          #endif
    228              }
    229          
    230              HAL_MutexLock(fd_lock);
   \                     ??iotx_cm_close_1: (+1)
   \       0x18   0x....             LDR.N    R4,??DataTable9
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x....'....        BL       HAL_MutexLock
    231              close_func = _cm_fd[fd]->close_func;
   \       0x20   0x....             LDR.N    R0,??DataTable9_1
   \       0x22   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \       0x26   0x6A87             LDR      R7,[R0, #+40]
    232              HAL_MutexUnlock(fd_lock);
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x....'....        BL       HAL_MutexUnlock
    233              if (close_func() != 0) {
   \       0x2E   0x47B8             BLX      R7
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD104             BNE.N    ??iotx_cm_close_0
    234                  return -1;
    235              }
    236              if (_recycle_fd(fd) != 0) {
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x....'....        BL       _recycle_fd
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD002             BEQ.N    ??iotx_cm_close_2
    237                  return -1;
   \                     ??iotx_cm_close_0: (+1)
   \       0x3E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}
    238              }
    239          
    240              if (inited_conn_num == 0) {
   \                     ??iotx_cm_close_2: (+1)
   \       0x44   0x6830             LDR      R0,[R6, #+0]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD106             BNE.N    ??iotx_cm_close_3
    241                  if (fd_lock != NULL) {
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD003             BEQ.N    ??iotx_cm_close_3
    242                      HAL_MutexDestroy(fd_lock);
   \       0x50   0x....'....        BL       HAL_MutexDestroy
    243                      fd_lock = NULL;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x6020             STR      R0,[R4, #+0]
    244                  }
    245              }
    246          
    247              return 0;
   \                     ??iotx_cm_close_3: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    248          }
    249          
    250          

   \                                 In section .text, align 2, keep-with-next
    251          static int inline _fd_is_valid(int fd)
    252          {
   \                     _fd_is_valid: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    253              int ret;
    254          
    255              if (fd_lock == NULL) {
   \        0x4   0x....             LDR.N    R5,??DataTable9
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD102             BNE.N    ??_fd_is_valid_0
    256                  return NULL_VALUE_ERROR;
   \        0xC   0xF06F 0x0001      MVN      R0,#+1
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
    257              }
    258          
    259              HAL_MutexLock(fd_lock);
   \                     ??_fd_is_valid_0: (+1)
   \       0x12   0x....'....        BL       HAL_MutexLock
    260              ret = (fd >= 0 && fd < CM_MAX_FD_NUM && _cm_fd[fd] != NULL) ? 0 : -1;
   \       0x16   0x2C03             CMP      R4,#+3
   \       0x18   0xD206             BCS.N    ??_fd_is_valid_1
   \       0x1A   0x....             LDR.N    R0,??DataTable9_1
   \       0x1C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD001             BEQ.N    ??_fd_is_valid_1
   \       0x24   0x2400             MOVS     R4,#+0
   \       0x26   0xE001             B.N      ??_fd_is_valid_2
   \                     ??_fd_is_valid_1: (+1)
   \       0x28   0xF04F 0x34FF      MOV      R4,#-1
    261              HAL_MutexUnlock(fd_lock);
   \                     ??_fd_is_valid_2: (+1)
   \       0x2C   0x6828             LDR      R0,[R5, #+0]
   \       0x2E   0x....'....        BL       HAL_MutexUnlock
    262              return ret;
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    263          }
    264          

   \                                 In section .text, align 2, keep-with-next
    265          static int _recycle_fd(int fd)
    266          {
   \                     _recycle_fd: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    267              if (fd_lock == NULL) {
   \        0x4   0x....             LDR.N    R5,??DataTable9
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD107             BNE.N    ??_recycle_fd_0
    268                  fd_lock = HAL_MutexCreate();
   \        0xC   0x....'....        BL       HAL_MutexCreate
   \       0x10   0x6028             STR      R0,[R5, #+0]
    269                  if (fd_lock == NULL) {
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??_recycle_fd_0
    270                      return -1;
   \       0x16   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1A   0xBD32             POP      {R1,R4,R5,PC}
    271                  }
    272              }
    273          
    274              if (fd < 0 || fd > CM_MAX_FD_NUM - 1) {
   \                     ??_recycle_fd_0: (+1)
   \       0x1C   0x2C03             CMP      R4,#+3
   \       0x1E   0xD302             BCC.N    ??_recycle_fd_1
    275                  return -1;
   \       0x20   0xF04F 0x30FF      MOV      R0,#-1
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
    276              }
    277          
    278              HAL_MutexLock(fd_lock);
   \                     ??_recycle_fd_1: (+1)
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x....'....        BL       HAL_MutexLock
    279              _cm_fd[fd] = NULL;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x....             LDR.N    R1,??DataTable9_1
   \       0x30   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
    280              HAL_MutexUnlock(fd_lock);
   \       0x34   0x6828             LDR      R0,[R5, #+0]
   \       0x36   0x....'....        BL       HAL_MutexUnlock
    281          
    282              return 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    283          }
    284          

   \                                 In section .text, align 2, keep-with-next
    285          static int _get_fd(iotx_cm_connection_t *handle)
    286          {
   \                     _get_fd: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    287              int i;
    288              if (handle == NULL) {
   \        0x4   0xD102             BNE.N    ??_get_fd_0
    289                  return NULL_VALUE_ERROR;
   \        0x6   0xF06F 0x0001      MVN      R0,#+1
   \        0xA   0xBD70             POP      {R4-R6,PC}
    290              }
    291          
    292              if (fd_lock == NULL) {
   \                     ??_get_fd_0: (+1)
   \        0xC   0x....             LDR.N    R5,??DataTable9
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD107             BNE.N    ??_get_fd_1
    293                  fd_lock = HAL_MutexCreate();
   \       0x14   0x....'....        BL       HAL_MutexCreate
   \       0x18   0x6028             STR      R0,[R5, #+0]
    294                  if (fd_lock == NULL) {
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??_get_fd_1
    295                      return -1;
   \       0x1E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x22   0xBD70             POP      {R4-R6,PC}
    296                  }
    297              }
    298          
    299              HAL_MutexLock(fd_lock);
   \                     ??_get_fd_1: (+1)
   \       0x24   0x6828             LDR      R0,[R5, #+0]
   \       0x26   0x....'....        BL       HAL_MutexLock
    300              for (i = 0; i < CM_MAX_FD_NUM; i++) {
   \       0x2A   0x2600             MOVS     R6,#+0
   \       0x2C   0x....             LDR.N    R1,??DataTable9_1
   \       0x2E   0xE000             B.N      ??_get_fd_2
   \                     ??_get_fd_3: (+1)
   \       0x30   0x1C76             ADDS     R6,R6,#+1
   \                     ??_get_fd_2: (+1)
   \       0x32   0x2E03             CMP      R6,#+3
   \       0x34   0xDA0A             BGE.N    ??_get_fd_4
    301                  if (_cm_fd[i] == NULL) {
   \       0x36   0xF851 0x0026      LDR      R0,[R1, R6, LSL #+2]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD1F8             BNE.N    ??_get_fd_3
    302                      _cm_fd[i] = handle;
   \       0x3E   0xF841 0x4026      STR      R4,[R1, R6, LSL #+2]
    303                      HAL_MutexUnlock(fd_lock);
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0x....'....        BL       HAL_MutexUnlock
    304                      return i;
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0xBD70             POP      {R4-R6,PC}
    305                  }
    306              }
    307              HAL_MutexUnlock(fd_lock);
   \                     ??_get_fd_4: (+1)
   \       0x4C   0x6828             LDR      R0,[R5, #+0]
   \       0x4E   0x....'....        BL       HAL_MutexUnlock
    308              cm_err("cm fd reached the limit");
    309              return -1;
   \       0x52   0xF04F 0x30FF      MOV      R0,#-1
   \       0x56   0xBD70             POP      {R4-R6,PC}       ;; return
    310          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     fd_lock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     _cm_fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     inited_conn_num

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _fd_is_valid
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      16   _get_fd
        16   -> HAL_MutexCreate
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      24   _iotx_cm_yield
        24   -- Indirect call
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> _fd_is_valid
      16   _recycle_fd
        16   -> HAL_MutexCreate
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      24   iotx_cm_close
        24   -- Indirect call
        24   -> HAL_MutexDestroy
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> _fd_is_valid
        24   -> _recycle_fd
      16   iotx_cm_connect
        16   -- Indirect call
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> _fd_is_valid
        16   -> iotx_event_post
       8   iotx_cm_open
         8   -- Indirect call
         8   -> _get_fd
         8   -> iotx_cm_open_mqtt
      32   iotx_cm_pub
        32   -- Indirect call
        32   -> HAL_MutexLock
        32   -> HAL_MutexUnlock
        32   -> _fd_is_valid
      32   iotx_cm_sub
        32   -- Indirect call
        32   -> HAL_MutexLock
        32   -> HAL_MutexUnlock
        32   -> _fd_is_valid
      16   iotx_cm_unsub
        16   -- Indirect call
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> _fd_is_valid
       0   iotx_cm_yield
         0   -> _iotx_cm_yield


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
      20  ERR_INVALID_PARAMS
      12  _cm_fd
      54  _fd_is_valid
      88  _get_fd
     118  _iotx_cm_yield
      62  _recycle_fd
       4  fd_lock
       4  inited_conn_num
      92  iotx_cm_close
      90  iotx_cm_connect
      50  iotx_cm_open
      68  iotx_cm_pub
      68  iotx_cm_sub
      50  iotx_cm_unsub
       2  iotx_cm_yield

 
  20 bytes in section .bss
  20 bytes in section .rodata
 754 bytes in section .text
 
 754 bytes of CODE  memory
  20 bytes of CONST memory
  20 bytes of DATA  memory

Errors: none
Warnings: none
