###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:29
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\infra_string.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW32A.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\infra\infra_string.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\infra_string.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\infra_string.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\infra\infra_string.c
      1          #include "infra_config.h"
      2          
      3          #ifdef INFRA_STRING
      4          
      5          #include <stdio.h>
      6          #include <string.h>
      7          #include "infra_types.h"
      8          #include "infra_string.h"
      9          

   \                                 In section .text, align 2, keep-with-next
     10          int8_t infra_hex2char(uint8_t hex)
     11          {
     12              hex = hex & 0xF;
   \                     infra_hex2char: (+1)
   \        0x0   0xF000 0x000F      AND      R0,R0,#0xF
     13              return (int8_t)(hex < 10 ? '0' + hex : hex - 10 + 'a');
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x290A             CMP      R1,#+10
   \        0x8   0xDA01             BGE.N    ??infra_hex2char_0
   \        0xA   0x3030             ADDS     R0,R0,#+48
   \        0xC   0xE000             B.N      ??infra_hex2char_1
   \                     ??infra_hex2char_0: (+1)
   \        0xE   0x3057             ADDS     R0,R0,#+87
   \                     ??infra_hex2char_1: (+1)
   \       0x10   0xB240             SXTB     R0,R0
   \       0x12   0x4770             BX       LR               ;; return
     14          }
     15          

   \                                 In section .text, align 2, keep-with-next
     16          void infra_hex2str(uint8_t *input, uint16_t input_len, char *output)
     17          {
   \                     infra_hex2str: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
     18              char *zEncode = "0123456789ABCDEF";
   \        0x2   0x....             LDR.N    R3,??DataTable3
     19              int i = 0, j = 0;
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x4625             MOV      R5,R4
     20          
     21              for (i = 0; i < input_len; i++) {
   \        0x8   0xE00B             B.N      ??infra_hex2str_0
     22                  output[j++] = zEncode[(input[i] >> 4) & 0xf];
   \                     ??infra_hex2str_1: (+1)
   \        0xA   0x5D06             LDRB     R6,[R0, R4]
   \        0xC   0x1136             ASRS     R6,R6,#+4
   \        0xE   0x5D9E             LDRB     R6,[R3, R6]
   \       0x10   0x5556             STRB     R6,[R2, R5]
   \       0x12   0x1C6D             ADDS     R5,R5,#+1
     23                  output[j++] = zEncode[(input[i]) & 0xf];
   \       0x14   0x5D06             LDRB     R6,[R0, R4]
   \       0x16   0xF006 0x060F      AND      R6,R6,#0xF
   \       0x1A   0x5D9E             LDRB     R6,[R3, R6]
   \       0x1C   0x5556             STRB     R6,[R2, R5]
   \       0x1E   0x1C6D             ADDS     R5,R5,#+1
     24              }
   \       0x20   0x1C64             ADDS     R4,R4,#+1
   \                     ??infra_hex2str_0: (+1)
   \       0x22   0x460E             MOV      R6,R1
   \       0x24   0x42B4             CMP      R4,R6
   \       0x26   0xDBF0             BLT.N    ??infra_hex2str_1
     25          }
   \       0x28   0xBC70             POP      {R4-R6}
   \       0x2A   0x4770             BX       LR               ;; return
     26          

   \                                 In section .text, align 2, keep-with-next
     27          void infra_int2str(uint32_t input, char output[10])
     28          {
   \                     infra_int2str: (+1)
   \        0x0   0xB4FE             PUSH     {R1-R7}
     29              uint8_t i = 0, j = 0;
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x461A             MOV      R2,R3
     30              char tmp[10] = {0};
   \        0x6   0x466C             MOV      R4,SP
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x4617             MOV      R7,R2
   \        0xE   0xE884 0x00E0      STM      R4,{R5-R7}
     31          
     32              do {
     33                  tmp[i++] = input%10 + '0';
   \                     ??infra_int2str_0: (+1)
   \       0x12   0x250A             MOVS     R5,#+10
   \       0x14   0xFBB0 0xF5F5      UDIV     R5,R0,R5
   \       0x18   0xEB05 0x0685      ADD      R6,R5,R5, LSL #+2
   \       0x1C   0xEBA0 0x0546      SUB      R5,R0,R6, LSL #+1
   \       0x20   0x3530             ADDS     R5,R5,#+48
   \       0x22   0x461E             MOV      R6,R3
   \       0x24   0xB2F6             UXTB     R6,R6
   \       0x26   0x55A5             STRB     R5,[R4, R6]
   \       0x28   0x1C5B             ADDS     R3,R3,#+1
     34              }while((input/=10)>0);
   \       0x2A   0x250A             MOVS     R5,#+10
   \       0x2C   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD1EE             BNE.N    ??infra_int2str_0
     35          
     36              do {
     37                  output[--i] = tmp[j++];
   \                     ??infra_int2str_1: (+1)
   \       0x34   0x1E5B             SUBS     R3,R3,#+1
   \       0x36   0x4610             MOV      R0,R2
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0x5C20             LDRB     R0,[R4, R0]
   \       0x3C   0x461D             MOV      R5,R3
   \       0x3E   0xB2ED             UXTB     R5,R5
   \       0x40   0x5548             STRB     R0,[R1, R5]
   \       0x42   0x1C52             ADDS     R2,R2,#+1
     38              }while(i > 0);
   \       0x44   0x4618             MOV      R0,R3
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD1F3             BNE.N    ??infra_int2str_1
     39          }
   \       0x4C   0xBCF7             POP      {R0-R2,R4-R7}
   \       0x4E   0x4770             BX       LR               ;; return
     40          

   \                                 In section .text, align 2, keep-with-next
     41          char *infra_strtok(char *str, const char *delim)
     42          {
   \                     infra_strtok: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x460C             MOV      R4,R1
     43              int only_delim = 1;
   \        0x6   0x2501             MOVS     R5,#+1
     44              static char *pos = NULL;
     45              static char *target = NULL;
     46          
     47              pos = (str == NULL)?(pos):(str);
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD001             BEQ.N    ??infra_strtok_0
   \        0xC   0x....             LDR.N    R1,??DataTable3_1
   \        0xE   0x6008             STR      R0,[R1, #+0]
     48          
     49              if (pos == NULL || delim == NULL ||
     50                  strlen(pos) <= strlen(delim)) {
   \                     ??infra_strtok_0: (+1)
   \       0x10   0x....             LDR.N    R6,??DataTable3_1
   \       0x12   0x6830             LDR      R0,[R6, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD00A             BEQ.N    ??infra_strtok_1
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD008             BEQ.N    ??infra_strtok_1
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       strlen
   \       0x22   0x4607             MOV      R7,R0
   \       0x24   0x6830             LDR      R0,[R6, #+0]
   \       0x26   0x....'....        BL       strlen
   \       0x2A   0x4287             CMP      R7,R0
   \       0x2C   0xD301             BCC.N    ??infra_strtok_2
     51                  return NULL;
   \                     ??infra_strtok_1: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xE04B             B.N      ??infra_strtok_3
     52              }
     53          
     54              target = pos;
   \                     ??infra_strtok_2: (+1)
   \       0x32   0x....             LDR.N    R7,??DataTable3_2
   \       0x34   0x6830             LDR      R0,[R6, #+0]
   \       0x36   0x6038             STR      R0,[R7, #+0]
   \       0x38   0xE003             B.N      ??infra_strtok_4
     55              while (strlen(pos) >= strlen(delim)) {
     56                  if (memcmp(pos,delim,strlen(delim)) != 0) {
     57                      only_delim = 0;
   \                     ??infra_strtok_5: (+1)
   \       0x3A   0x2500             MOVS     R5,#+0
     58                      pos++;
   \       0x3C   0x6830             LDR      R0,[R6, #+0]
   \       0x3E   0x1C40             ADDS     R0,R0,#+1
   \       0x40   0x6030             STR      R0,[R6, #+0]
     59                      continue;
     60                  }
   \                     ??infra_strtok_4: (+1)
   \       0x42   0x6830             LDR      R0,[R6, #+0]
   \       0x44   0x....'....        BL       strlen
   \       0x48   0x4680             MOV      R8,R0
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x....'....        BL       strlen
   \       0x50   0x4580             CMP      R8,R0
   \       0x52   0xD339             BCC.N    ??infra_strtok_6
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0x....'....        BL       strlen
   \       0x5A   0x4602             MOV      R2,R0
   \       0x5C   0x4621             MOV      R1,R4
   \       0x5E   0x6830             LDR      R0,[R6, #+0]
   \       0x60   0x....'....        BL       memcmp
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD1E8             BNE.N    ??infra_strtok_5
     61          
     62                  if (strlen(pos) == strlen(delim)) {
   \       0x68   0x6830             LDR      R0,[R6, #+0]
   \       0x6A   0x....'....        BL       strlen
   \       0x6E   0x4680             MOV      R8,R0
   \       0x70   0x4620             MOV      R0,R4
   \       0x72   0x....'....        BL       strlen
   \       0x76   0x4580             CMP      R8,R0
   \       0x78   0xD00B             BEQ.N    ??infra_strtok_7
     63                      memset(pos,0,strlen(delim));
     64                      if (only_delim) {
     65                          return NULL;
     66                      }
     67                      return target;
     68                  }
     69          
     70                  if (target == pos) {
   \       0x7A   0x6838             LDR      R0,[R7, #+0]
   \       0x7C   0x6831             LDR      R1,[R6, #+0]
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0xD114             BNE.N    ??infra_strtok_8
     71                      pos += strlen(delim);
   \       0x84   0x....'....        BL       strlen
   \       0x88   0x6831             LDR      R1,[R6, #+0]
   \       0x8A   0x4408             ADD      R0,R1,R0
   \       0x8C   0x6030             STR      R0,[R6, #+0]
     72                      target = pos;
   \       0x8E   0x6038             STR      R0,[R7, #+0]
   \       0x90   0xE7D7             B.N      ??infra_strtok_4
     73                  }else{
   \                     ??infra_strtok_7: (+1)
   \       0x92   0x4620             MOV      R0,R4
   \       0x94   0x....'....        BL       strlen
   \       0x98   0x2200             MOVS     R2,#+0
   \       0x9A   0x4601             MOV      R1,R0
   \       0x9C   0x6830             LDR      R0,[R6, #+0]
   \       0x9E   0x....'....        BL       __aeabi_memset
   \       0xA2   0x2D00             CMP      R5,#+0
   \       0xA4   0xD001             BEQ.N    ??infra_strtok_9
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xE00F             B.N      ??infra_strtok_3
   \                     ??infra_strtok_9: (+1)
   \       0xAA   0x6838             LDR      R0,[R7, #+0]
   \       0xAC   0xE00D             B.N      ??infra_strtok_3
     74                      memset(pos,0,strlen(delim));
   \                     ??infra_strtok_8: (+1)
   \       0xAE   0x....'....        BL       strlen
   \       0xB2   0x2200             MOVS     R2,#+0
   \       0xB4   0x4601             MOV      R1,R0
   \       0xB6   0x6830             LDR      R0,[R6, #+0]
   \       0xB8   0x....'....        BL       __aeabi_memset
     75                      pos += strlen(delim);
   \       0xBC   0x4620             MOV      R0,R4
   \       0xBE   0x....'....        BL       strlen
   \       0xC2   0x6831             LDR      R1,[R6, #+0]
   \       0xC4   0x4408             ADD      R0,R1,R0
   \       0xC6   0x6030             STR      R0,[R6, #+0]
     76                      break;
     77                  }
     78              }
     79          
     80              return target;
   \                     ??infra_strtok_6: (+1)
   \       0xC8   0x6838             LDR      R0,[R7, #+0]
   \                     ??infra_strtok_3: (+1)
   \       0xCA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     81          }

   \                                 In section .bss, align 4
   \                     `infra_strtok::pos`:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \                     `infra_strtok::target`:
   \        0x0                      DS8 4
     82          
     83          #define LITE_isdigit(c)             (((c) <= '9' && (c) >= '0') ? (1) : (0))
     84          

   \                                 In section .text, align 2, keep-with-next
     85          static uint8_t _hexval_of_char(char hex)
     86          {
     87              if (LITE_isdigit(hex)) {
   \                     _hexval_of_char: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x3930             SUBS     R1,R1,#+48
   \        0x4   0x290A             CMP      R1,#+10
   \        0x6   0x4189             SBCS     R1,R1,R1
   \        0x8   0x0FC9             LSRS     R1,R1,#+31
   \        0xA   0xD002             BEQ.N    ??_hexval_of_char_0
     88                  return (hex - '0');
   \        0xC   0x3830             SUBS     R0,R0,#+48
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4770             BX       LR
     89              }
     90              if (hex >= 'a' && hex <= 'f') {
   \                     ??_hexval_of_char_0: (+1)
   \       0x12   0x4601             MOV      R1,R0
   \       0x14   0x3961             SUBS     R1,R1,#+97
   \       0x16   0x2906             CMP      R1,#+6
   \       0x18   0xD202             BCS.N    ??_hexval_of_char_1
     91                  return (hex - 'a' + 10);
   \       0x1A   0x3857             SUBS     R0,R0,#+87
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x4770             BX       LR
     92              }
     93              if (hex >= 'A' && hex <= 'F') {
   \                     ??_hexval_of_char_1: (+1)
   \       0x20   0x4601             MOV      R1,R0
   \       0x22   0x3941             SUBS     R1,R1,#+65
   \       0x24   0x2906             CMP      R1,#+6
   \       0x26   0xD202             BCS.N    ??_hexval_of_char_2
     94                  return (hex - 'A' + 10);
   \       0x28   0x3837             SUBS     R0,R0,#+55
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x4770             BX       LR
     95              }
     96          
     97              return 0;
   \                     ??_hexval_of_char_2: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x4770             BX       LR               ;; return
     98          }
     99          

   \                                 In section .text, align 2, keep-with-next
    100          void LITE_hexstr_convert(char *input, int input_len, unsigned char *output, int output_len)
    101          {
   \                     LITE_hexstr_convert: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    102              int             i = 0;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    103              uint8_t         ch0, ch1;
    104          
    105              if (input_len % 2 != 0) {
   \       0x10   0xEB05 0x70D5      ADD      R0,R5,R5, LSR #+31
   \       0x14   0x1040             ASRS     R0,R0,#+1
   \       0x16   0xEBB5 0x0040      SUBS     R0,R5,R0, LSL #+1
   \       0x1A   0xD012             BEQ.N    ??LITE_hexstr_convert_0
    106                  return;
   \       0x1C   0xE016             B.N      ??LITE_hexstr_convert_1
    107              }
    108          
    109              while (i < input_len / 2 && i < output_len) {
   \                     ??LITE_hexstr_convert_2: (+1)
   \       0x1E   0x45B8             CMP      R8,R7
   \       0x20   0xDA14             BGE.N    ??LITE_hexstr_convert_1
    110                  ch0 = _hexval_of_char((char)input[2 * i]);
   \       0x22   0xF814 0x0018      LDRB     R0,[R4, R8, LSL #+1]
   \       0x26   0x....'....        BL       _hexval_of_char
   \       0x2A   0x4681             MOV      R9,R0
    111                  ch1 = _hexval_of_char((char)input[2 * i + 1]);
    112                  output[i] = (ch0 << 4 | ch1);
   \       0x2C   0xEB04 0x0048      ADD      R0,R4,R8, LSL #+1
   \       0x30   0x7840             LDRB     R0,[R0, #+1]
   \       0x32   0x....'....        BL       _hexval_of_char
   \       0x36   0xEA40 0x1009      ORR      R0,R0,R9, LSL #+4
   \       0x3A   0xF806 0x0008      STRB     R0,[R6, R8]
    113                  i++;
   \       0x3E   0xF108 0x0801      ADD      R8,R8,#+1
    114              }
   \                     ??LITE_hexstr_convert_0: (+1)
   \       0x42   0xEB05 0x70D5      ADD      R0,R5,R5, LSR #+31
   \       0x46   0xEBB8 0x0F60      CMP      R8,R0, ASR #+1
   \       0x4A   0xDBE8             BLT.N    ??LITE_hexstr_convert_2
    115          }
   \                     ??LITE_hexstr_convert_1: (+1)
   \       0x4C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    116          

   \                                 In section .text, align 2, keep-with-next
    117          void LITE_hexbuf_convert(unsigned char *digest, char *out, int in_len, int uppercase)
    118          {
   \                     LITE_hexbuf_convert: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    119              static char    *zEncode[] = {"0123456789abcdef", "0123456789ABCDEF"};
    120              int             j = 0;
   \        0x2   0x2400             MOVS     R4,#+0
    121              int             i = 0;
   \        0x4   0x4625             MOV      R5,R4
    122              int             idx = uppercase ? 1 : 0;
   \        0x6   0x1E5B             SUBS     R3,R3,#+1
   \        0x8   0x419B             SBCS     R3,R3,R3
   \        0xA   0x43DB             MVNS     R3,R3
   \        0xC   0x0FDB             LSRS     R3,R3,#+31
   \        0xE   0xE012             B.N      ??LITE_hexbuf_convert_0
    123          
    124              for (i = 0; i < in_len; i ++) {
    125                  int         a = digest[i];
   \                     ??LITE_hexbuf_convert_1: (+1)
   \       0x10   0x5D46             LDRB     R6,[R0, R5]
    126          
    127                  out[j++] = zEncode[idx][(a >> 4) & 0xf];
   \       0x12   0x....             LDR.N    R7,??DataTable3_3
   \       0x14   0xF857 0xC023      LDR      R12,[R7, R3, LSL #+2]
   \       0x18   0xF3C6 0x1E03      UBFX     LR,R6,#+4,#+4
   \       0x1C   0xF81C 0xC00E      LDRB     R12,[R12, LR]
   \       0x20   0xF801 0xC004      STRB     R12,[R1, R4]
   \       0x24   0x1C64             ADDS     R4,R4,#+1
    128                  out[j++] = zEncode[idx][a & 0xf];
   \       0x26   0xF857 0x7023      LDR      R7,[R7, R3, LSL #+2]
   \       0x2A   0xF006 0x060F      AND      R6,R6,#0xF
   \       0x2E   0x5DBE             LDRB     R6,[R7, R6]
   \       0x30   0x550E             STRB     R6,[R1, R4]
   \       0x32   0x1C64             ADDS     R4,R4,#+1
    129              }
   \       0x34   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LITE_hexbuf_convert_0: (+1)
   \       0x36   0x4295             CMP      R5,R2
   \       0x38   0xDBEA             BLT.N    ??LITE_hexbuf_convert_1
    130          }
   \       0x3A   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .data, align 4
   \                     `LITE_hexbuf_convert::zEncode`:
   \        0x0   0x....'....        DC32 ?_2, ?_0
   \              0x....'....  
    131          

   \                                 In section .text, align 2, keep-with-next
    132          int infra_str2int(const char *input, int *val)
    133          {
   \                     infra_str2int: (+1)
   \        0x0   0xB410             PUSH     {R4}
    134              int sign = 0;
   \        0x2   0x2300             MOVS     R3,#+0
    135              int temp = 0;
   \        0x4   0x461C             MOV      R4,R3
    136          
    137              if (input == NULL || val == NULL) {
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??infra_str2int_0
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD103             BNE.N    ??infra_str2int_1
    138                  return -1;
   \                     ??infra_str2int_0: (+1)
   \        0xE   0xF04F 0x30FF      MOV      R0,#-1
   \       0x12   0xE021             B.N      ??infra_str2int_2
    139              }
    140          
    141              while(*input == ' ') {  /* only support skipping space */
    142                  input++;
   \                     ??infra_str2int_3: (+1)
   \       0x14   0x1C40             ADDS     R0,R0,#+1
    143              }
   \                     ??infra_str2int_1: (+1)
   \       0x16   0x7802             LDRB     R2,[R0, #+0]
   \       0x18   0x2A20             CMP      R2,#+32
   \       0x1A   0xD0FB             BEQ.N    ??infra_str2int_3
    144          
    145              if (*input == '+') {
   \       0x1C   0x2A2B             CMP      R2,#+43
   \       0x1E   0xD10E             BNE.N    ??infra_str2int_4
    146                  input++;
   \       0x20   0x1C40             ADDS     R0,R0,#+1
    147              }
    148              else if (*input == '-') {
    149                  input++;
    150                  sign = -1;
    151              }
    152          
    153              while (*input != 0) {
   \                     ??infra_str2int_5: (+1)
   \       0x22   0x7802             LDRB     R2,[R0, #+0]
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0xD011             BEQ.N    ??infra_str2int_6
    154                  if (*input < '0' || *input > '9') {
   \       0x28   0x3A30             SUBS     R2,R2,#+48
   \       0x2A   0x2A0A             CMP      R2,#+10
   \       0x2C   0xD20E             BCS.N    ??infra_str2int_6
    155                      break;
    156                  }
    157          
    158                  temp = temp * 10 + (*input - '0');
   \       0x2E   0xEB04 0x0284      ADD      R2,R4,R4, LSL #+2
   \       0x32   0xF810 0x4B01      LDRB     R4,[R0], #+1
   \       0x36   0xEB04 0x0442      ADD      R4,R4,R2, LSL #+1
   \       0x3A   0x3C30             SUBS     R4,R4,#+48
    159                  input++;
   \       0x3C   0xE7F1             B.N      ??infra_str2int_5
    160              }
   \                     ??infra_str2int_4: (+1)
   \       0x3E   0x2A2D             CMP      R2,#+45
   \       0x40   0xD1EF             BNE.N    ??infra_str2int_5
   \       0x42   0x1C40             ADDS     R0,R0,#+1
   \       0x44   0xF04F 0x32FF      MOV      R2,#-1
   \       0x48   0x4613             MOV      R3,R2
   \       0x4A   0xE7EA             B.N      ??infra_str2int_5
    161          
    162              if (sign == -1) {
   \                     ??infra_str2int_6: (+1)
   \       0x4C   0xF113 0x0F01      CMN      R3,#+1
   \       0x50   0xD100             BNE.N    ??infra_str2int_7
    163                  temp = -temp;
   \       0x52   0x4264             RSBS     R4,R4,#+0
    164              }
    165          
    166              *val = temp;
   \                     ??infra_str2int_7: (+1)
   \       0x54   0x600C             STR      R4,[R1, #+0]
    167              return 0;
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??infra_str2int_2: (+1)
   \       0x58   0xBC10             POP      {R4}
   \       0x5A   0x4770             BX       LR               ;; return
    168          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     `infra_strtok::pos`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     `infra_strtok::target`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     `LITE_hexbuf_convert::zEncode`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x30 0x31          DC8 "0123456789ABCDEF"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x30 0x31          DC8 "0123456789abcdef"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x61 0x62    
   \              0x63 0x64    
   \              0x65 0x66    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    169          
    170          #endif
    171          
    172          #ifdef INFRA_RANDOM
    173          
    174          uint64_t HAL_UptimeMs(void);
    175          void HAL_Srandom(uint32_t seed);
    176          uint32_t HAL_Random(uint32_t region);
    177          
    178          int infra_randstr(char *random, int length)
    179          {
    180              int index = 0;
    181          
    182              HAL_Srandom(HAL_UptimeMs());
    183          
    184              for (index = 0; index < length; index++) {
    185                  switch (HAL_Random(3)) {
    186                      case 0: {
    187                          random[index] = 'A' + HAL_Random(26);
    188                      }
    189                      break;
    190                      case 1: {
    191                          random[index]  = 'a' + HAL_Random(26);
    192                      }
    193                      break;
    194                      case 2: {
    195                          random[index] = '0' + HAL_Random(10);
    196                      }
    197                      break;
    198                      default: {
    199                          return -1;
    200                      }
    201                  }
    202              }
    203          
    204              return 0;
    205          }
    206          #endif
    207          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      20   LITE_hexbuf_convert
      32   LITE_hexstr_convert
        32   -> _hexval_of_char
       0   _hexval_of_char
       0   infra_hex2char
      12   infra_hex2str
      28   infra_int2str
       4   infra_str2int
      24   infra_strtok
        24   -> __aeabi_memset
        24   -> memcmp
        24   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      20  ?_0
      12  ?_1
      20  ?_2
      60  LITE_hexbuf_convert
      80  LITE_hexstr_convert
      50  _hexval_of_char
      20  infra_hex2char
      44  infra_hex2str
      80  infra_int2str
      92  infra_str2int
     206  infra_strtok
       4  pos
       4  target
       8  zEncode

 
   8 bytes in section .bss
   8 bytes in section .data
  52 bytes in section .rodata
 648 bytes in section .text
 
 648 bytes of CODE  memory
  52 bytes of CONST memory
  16 bytes of DATA  memory

Errors: none
Warnings: none
