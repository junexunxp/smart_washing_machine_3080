###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:20
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\source\flexspi_hyper_flash_ops.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWDBF5.tmp
#        (C:\Development\smart_washing_machine_3080\source\flexspi_hyper_flash_ops.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\flexspi_hyper_flash_ops.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\flexspi_hyper_flash_ops.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\source\flexspi_hyper_flash_ops.c
      1          /*
      2           * Copyright (c) 2016, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2018 NXP
      4           * All rights reserved.
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           */
      8          
      9          #include "fsl_flexspi.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_SetMux(clock_mux_t, uint32_t)
   \                     CLOCK_SetMux: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xF3C0 0x6485      UBFX     R4,R0,#+26,#+6
   \        0x6   0x....'....        LDR.W    R2,??DataTable8  ;; 0x400fc000
   \        0xA   0xF000 0x03FF      AND      R3,R0,#0xFF
   \        0xE   0x18D3             ADDS     R3,R2,R3
   \       0x10   0x681B             LDR      R3,[R3, #+0]
   \       0x12   0xF3C0 0x354C      UBFX     R5,R0,#+13,#+13
   \       0x16   0x4606             MOV      R6,R0
   \       0x18   0x1236             ASRS     R6,R6,#+8
   \       0x1A   0xF006 0x061F      AND      R6,R6,#0x1F
   \       0x1E   0x40B5             LSLS     R5,R5,R6
   \       0x20   0x43AB             BICS     R3,R3,R5
   \       0x22   0xEA01 0x3160      AND      R1,R1,R0, ASR #+13
   \       0x26   0xF3C1 0x010C      UBFX     R1,R1,#+0,#+13
   \       0x2A   0x4605             MOV      R5,R0
   \       0x2C   0x122D             ASRS     R5,R5,#+8
   \       0x2E   0xF005 0x051F      AND      R5,R5,#0x1F
   \       0x32   0x40A9             LSLS     R1,R1,R5
   \       0x34   0x4319             ORRS     R1,R1,R3
   \       0x36   0xF000 0x00FF      AND      R0,R0,#0xFF
   \       0x3A   0x1810             ADDS     R0,R2,R0
   \       0x3C   0x6001             STR      R1,[R0, #+0]
   \       0x3E   0x2C21             CMP      R4,#+33
   \       0x40   0xD309             BCC.N    ??CLOCK_SetMux_0
   \       0x42   0xF240 0x327A      MOVW     R2,#+890
   \       0x46   0x....'....        LDR.W    R1,??DataTable8_1
   \       0x4A   0x....'....        LDR.W    R0,??DataTable8_2
   \       0x4E   0x....'....        BL       __aeabi_assert
   \       0x52   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??CLOCK_SetMux_0: (+1)
   \       0x56   0x2C20             CMP      R4,#+32
   \       0x58   0xD005             BEQ.N    ??CLOCK_SetMux_1
   \                     ??CLOCK_SetMux_2: (+1)
   \       0x5A   0x....'....        LDR.W    R0,??DataTable8_3  ;; 0x400fc048
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0x40E0             LSRS     R0,R0,R4
   \       0x62   0x07C0             LSLS     R0,R0,#+31
   \       0x64   0xD4F9             BMI.N    ??CLOCK_SetMux_2
   \                     ??CLOCK_SetMux_1: (+1)
   \       0x66   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_SetDiv(clock_div_t, uint32_t)
   \                     CLOCK_SetDiv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xF3C0 0x6485      UBFX     R4,R0,#+26,#+6
   \        0x6   0x....'....        LDR.W    R2,??DataTable8  ;; 0x400fc000
   \        0xA   0xF000 0x03FF      AND      R3,R0,#0xFF
   \        0xE   0x18D3             ADDS     R3,R2,R3
   \       0x10   0x681B             LDR      R3,[R3, #+0]
   \       0x12   0xF3C0 0x354C      UBFX     R5,R0,#+13,#+13
   \       0x16   0x4606             MOV      R6,R0
   \       0x18   0x1236             ASRS     R6,R6,#+8
   \       0x1A   0xF006 0x061F      AND      R6,R6,#0x1F
   \       0x1E   0x40B5             LSLS     R5,R5,R6
   \       0x20   0x43AB             BICS     R3,R3,R5
   \       0x22   0xEA01 0x3160      AND      R1,R1,R0, ASR #+13
   \       0x26   0xF3C1 0x010C      UBFX     R1,R1,#+0,#+13
   \       0x2A   0x4605             MOV      R5,R0
   \       0x2C   0x122D             ASRS     R5,R5,#+8
   \       0x2E   0xF005 0x051F      AND      R5,R5,#0x1F
   \       0x32   0x40A9             LSLS     R1,R1,R5
   \       0x34   0x4319             ORRS     R1,R1,R3
   \       0x36   0xF000 0x00FF      AND      R0,R0,#0xFF
   \       0x3A   0x1810             ADDS     R0,R2,R0
   \       0x3C   0x6001             STR      R1,[R0, #+0]
   \       0x3E   0x2C21             CMP      R4,#+33
   \       0x40   0xD309             BCC.N    ??CLOCK_SetDiv_0
   \       0x42   0xF240 0x329F      MOVW     R2,#+927
   \       0x46   0x....'....        LDR.W    R1,??DataTable8_1
   \       0x4A   0x....'....        LDR.W    R0,??DataTable8_2
   \       0x4E   0x....'....        BL       __aeabi_assert
   \       0x52   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??CLOCK_SetDiv_0: (+1)
   \       0x56   0x2C20             CMP      R4,#+32
   \       0x58   0xD005             BEQ.N    ??CLOCK_SetDiv_1
   \                     ??CLOCK_SetDiv_2: (+1)
   \       0x5A   0x....'....        LDR.W    R0,??DataTable8_3  ;; 0x400fc048
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0x40E0             LSRS     R0,R0,R4
   \       0x62   0x07C0             LSLS     R0,R0,#+31
   \       0x64   0xD4F9             BMI.N    ??CLOCK_SetDiv_2
   \                     ??CLOCK_SetDiv_1: (+1)
   \       0x66   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_ControlGate(clock_ip_name_t, clock_gate_value_t)
   \                     CLOCK_ControlGate: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4626             MOV      R6,R4
   \        0x8   0x0A36             LSRS     R6,R6,#+8
   \        0xA   0xF004 0x041F      AND      R4,R4,#0x1F
   \        0xE   0x2E07             CMP      R6,#+7
   \       0x10   0xD308             BCC.N    ??CLOCK_ControlGate_0
   \       0x12   0xF240 0x32C1      MOVW     R2,#+961
   \       0x16   0x....             LDR.N    R1,??DataTable8_1
   \       0x18   0x....'....        LDR.W    R0,??DataTable8_4
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??CLOCK_ControlGate_0: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable8_5  ;; 0x400fc068
   \       0x26   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x2203             MOVS     R2,#+3
   \       0x2E   0x40A2             LSLS     R2,R2,R4
   \       0x30   0x4391             BICS     R1,R1,R2
   \       0x32   0xFA05 0xF404      LSL      R4,R5,R4
   \       0x36   0x430C             ORRS     R4,R4,R1
   \       0x38   0x6004             STR      R4,[R0, #+0]
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \        0x0   0x2103             MOVS     R1,#+3
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXSPI_SoftwareReset(FLEXSPI_Type *)
   \                     FLEXSPI_SoftwareReset: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \                     ??FLEXSPI_SoftwareReset_0: (+1)
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x07C9             LSLS     R1,R1,#+31
   \        0xC   0xD4FC             BMI.N    ??FLEXSPI_SoftwareReset_0
   \        0xE   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXSPI_Enable(FLEXSPI_Type *, bool)
   \                     FLEXSPI_Enable: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xD003             BEQ.N    ??FLEXSPI_Enable_0
   \        0x6   0xF021 0x0102      BIC      R1,R1,#0x2
   \        0xA   0x6001             STR      R1,[R0, #+0]
   \        0xC   0x4770             BX       LR
   \                     ??FLEXSPI_Enable_0: (+1)
   \        0xE   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x12   0x6001             STR      R1,[R0, #+0]
   \       0x14   0x4770             BX       LR               ;; return
     10          
     11          /*******************************************************************************
     12          * Definitions
     13          ******************************************************************************/
     14          
     15          #define EXAMPLE_FLEXSPI FLEXSPI
     16          #define FLASH_SIZE 0x10000
     17          #define EXAMPLE_FLEXSPI_AMBA_BASE FlexSPI_AMBA_BASE
     18          #define FLASH_PAGE_SIZE 512
     19          #define EXAMPLE_SECTOR 101
     20          #define SECTOR_SIZE 0x40000
     21          #define EXAMPLE_FLEXSPI_CLOCK kCLOCK_FlexSpi
     22          #define HYPERFLASH_CMD_LUT_SEQ_IDX_READDATA 0
     23          #define HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEDATA 1
     24          #define HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS 2
     25          #define HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE 4
     26          #define HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR 6
     27          #define HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM 10
     28          #define HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP 12
     29          #define CUSTOM_LUT_LENGTH 64
     30          
     31          /*******************************************************************************
     32          * Prototypes
     33          ******************************************************************************/
     34          
     35          /*******************************************************************************
     36           * Variables
     37           ******************************************************************************/
     38          

   \                                 In section .data, align 4
     39          static flexspi_device_config_t deviceconfig = {
   \                     deviceconfig:
   \        0x0   0x0280'DE80        DC32 42000000
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \        0x8   0x0001'0000        DC32 65536
   \        0xC   0x00 0x00          DC8 0, 0
   \        0xE   0x0002             DC16 2
   \       0x10   0x00 0x03          DC8 0, 3, 1, 3, 1, 1, 1, 0, 1, 0
   \              0x01 0x03    
   \              0x01 0x01    
   \              0x01 0x00    
   \              0x01 0x00    
   \       0x1A   0x0014             DC16 20
   \       0x1C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
     40              .flexspiRootClk = 42000000, /* 42MHZ SPI serial clock */
     41              .isSck2Enabled = false,
     42              .flashSize = FLASH_SIZE,
     43              .CSIntervalUnit = kFLEXSPI_CsIntervalUnit1SckCycle,
     44              .CSInterval = 2,
     45              .CSHoldTime = 0,
     46              .CSSetupTime = 3,
     47              .dataValidTime = 1,
     48              .columnspace = 3,
     49              .enableWordAddress = true,
     50              .AWRSeqIndex = HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEDATA,
     51              .AWRSeqNumber = 1,
     52              .ARDSeqIndex = HYPERFLASH_CMD_LUT_SEQ_IDX_READDATA,
     53              .ARDSeqNumber = 1,
     54              .AHBWriteWaitUnit = kFLEXSPI_AhbWriteWaitUnit2AhbCycle,
     55              .AHBWriteWaitInterval = 20,
     56          };
     57          

   \                                 In section .data, align 4
     58          static uint32_t customLUT[CUSTOM_LUT_LENGTH] = {
   \                     customLUT:
   \        0x0   0x8B18'87A0        DC32 2333640608, 2802093840, 0, 0, 2333640480, 2734853904, 0, 0
   \              0xA704'8F10  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x8B18'8720  
   \              0xA302'8F10  
   \              0x0000'0000  
   \              0x0000'0000  
   \       0x20   0x8700'8700        DC32 2264958720, 2276099840, 2265286400, 2272298752, 2333640608
   \              0x87AA'8700  
   \              0x8705'8700  
   \              0x8770'8700  
   \              0x8B18'87A0  
   \       0x34   0xB70B'8F10        DC32 3070988048, 42756, 0, 2264958720, 2276099840, 2265286400
   \              0x0000'A704  
   \              0x0000'0000  
   \              0x8700'8700  
   \              0x87AA'8700  
   \              0x8705'8700  
   \       0x4C   0x87AA'8700        DC32 2276099840, 2264958720, 2270529280, 2265089792, 2270529280
   \              0x8700'8700  
   \              0x8755'8700  
   \              0x8702'8700  
   \              0x8755'8700  
   \       0x60   0x8700'8700        DC32 2264958720, 2276099840, 2265286400, 2273347328, 2264958720
   \              0x87AA'8700  
   \              0x8705'8700  
   \              0x8780'8700  
   \              0x8700'8700  
   \       0x74   0x87AA'8700        DC32 2276099840, 2265286400, 2276099840, 2264958720, 2270529280
   \              0x8705'8700  
   \              0x87AA'8700  
   \              0x8700'8700  
   \              0x8755'8700  
   \       0x88   0x8702'8700        DC32 2265089792, 2270529280, 2333640448, 2264960784, 34608, 0
   \              0x8755'8700  
   \              0x8B18'8700  
   \              0x8700'8F10  
   \              0x0000'8730  
   \              0x0000'0000  
   \       0xA0   0x8700'8700        DC32 2264958720, 2276099840, 2265286400, 2275444480, 2333640448
   \              0x87AA'8700  
   \              0x8705'8700  
   \              0x87A0'8700  
   \              0x8B18'8700  
   \       0xB4   0xA380'8F10        DC32 2743111440, 0, 0, 2264958720, 2276099840, 2265286400, 2273347328
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x8700'8700  
   \              0x87AA'8700  
   \              0x8705'8700  
   \              0x8780'8700  
   \       0xD0   0x8700'8700        DC32 2264958720, 2276099840, 2265286400, 2276099840, 2264958720
   \              0x87AA'8700  
   \              0x8705'8700  
   \              0x87AA'8700  
   \              0x8700'8700  
   \       0xE4   0x8755'8700        DC32 2270529280, 2265089792, 2270529280, 2264958720, 2276099840
   \              0x8702'8700  
   \              0x8755'8700  
   \              0x8700'8700  
   \              0x87AA'8700  
   \       0xF8   0x8705'8700        DC32 2265286400, 2266007296
   \              0x8710'8700  
     59                  /* Read Data */
     60                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_READDATA] =
     61                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xA0, kFLEXSPI_Command_RADDR_DDR, kFLEXSPI_8PAD, 0x18),
     62                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_READDATA + 1] = FLEXSPI_LUT_SEQ(
     63                      kFLEXSPI_Command_CADDR_DDR, kFLEXSPI_8PAD, 0x10, kFLEXSPI_Command_READ_DDR, kFLEXSPI_8PAD, 0x04),
     64          
     65                  /* Write Data */
     66                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEDATA] =
     67                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x20, kFLEXSPI_Command_RADDR_DDR, kFLEXSPI_8PAD, 0x18),
     68                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEDATA + 1] = FLEXSPI_LUT_SEQ(
     69                      kFLEXSPI_Command_CADDR_DDR, kFLEXSPI_8PAD, 0x10, kFLEXSPI_Command_WRITE_DDR, kFLEXSPI_8PAD, 0x02),
     70                  /* Read Status */
     71                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS] =
     72                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
     73                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS + 1] = FLEXSPI_LUT_SEQ(
     74                      kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA), // ADDR 0x555
     75                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS + 2] =
     76                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x05),
     77                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS + 3] = FLEXSPI_LUT_SEQ(
     78                      kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x70), // DATA 0x70
     79                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS + 4] =
     80                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xA0, kFLEXSPI_Command_RADDR_DDR, kFLEXSPI_8PAD, 0x18),
     81                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS + 5] = FLEXSPI_LUT_SEQ(
     82                      kFLEXSPI_Command_CADDR_DDR, kFLEXSPI_8PAD, 0x10, kFLEXSPI_Command_DUMMY_RWDS_DDR, kFLEXSPI_8PAD, 0x0B),
     83                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS + 6] =
     84                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_READ_DDR, kFLEXSPI_8PAD, 0x04, kFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0),
     85          
     86                  /* Write Enable */
     87                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE] =
     88                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
     89                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE + 1] = FLEXSPI_LUT_SEQ(
     90                      kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA), // ADDR 0x555
     91                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE + 2] =
     92                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x05),
     93                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE + 3] = FLEXSPI_LUT_SEQ(
     94                      kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA), // DATA 0xAA
     95                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE + 4] =
     96                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
     97                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE + 5] =
     98                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x55),
     99                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE + 6] =
    100                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x02),
    101                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE + 7] =
    102                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x55),
    103          
    104                  /* Erase Sector  */
    105                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR] =
    106                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
    107                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 1] = FLEXSPI_LUT_SEQ(
    108                      kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA), // ADDR 0x555
    109                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 2] =
    110                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x05),
    111                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 3] = FLEXSPI_LUT_SEQ(
    112                      kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x80), // DATA 0x80
    113                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 4] =
    114                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
    115                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 5] =
    116                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA),
    117                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 6] =
    118                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x05),
    119                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 7] = FLEXSPI_LUT_SEQ(
    120                      kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA), // ADDR 0x555
    121                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 8] =
    122                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
    123                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 9] =
    124                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x55),
    125                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 10] =
    126                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x02),
    127                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 11] =
    128                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x55),
    129                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 12] =
    130                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_RADDR_DDR, kFLEXSPI_8PAD, 0x18),
    131                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 13] =
    132                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_CADDR_DDR, kFLEXSPI_8PAD, 0x10, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
    133                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR + 14] =
    134                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x30, kFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x00),
    135          
    136                  /* program page */
    137                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM] =
    138                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
    139                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM + 1] = FLEXSPI_LUT_SEQ(
    140                      kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA), // ADDR 0x555
    141                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM + 2] =
    142                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x05),
    143                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM + 3] = FLEXSPI_LUT_SEQ(
    144                      kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xA0), // DATA 0xA0
    145                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM + 4] =
    146                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_RADDR_DDR, kFLEXSPI_8PAD, 0x18),
    147                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM + 5] = FLEXSPI_LUT_SEQ(
    148                      kFLEXSPI_Command_CADDR_DDR, kFLEXSPI_8PAD, 0x10, kFLEXSPI_Command_WRITE_DDR, kFLEXSPI_8PAD, 0x80),
    149          
    150                  /* Erase chip */
    151                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP] =
    152                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
    153                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 1] =
    154                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA),
    155                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 2] =
    156                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x05),
    157                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 3] =
    158                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x80),
    159                  // 1
    160                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 4] =
    161                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
    162                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 5] =
    163                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA),
    164                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 6] =
    165                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x05),
    166                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 7] =
    167                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA),
    168                  // 2
    169                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 8] =
    170                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
    171                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 9] =
    172                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x55),
    173                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 10] =
    174                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x02),
    175                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 11] =
    176                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x55),
    177                  // 3
    178                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 12] =
    179                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00),
    180                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 13] =
    181                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0xAA),
    182                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 14] =
    183                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x05),
    184                  [4 * HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP + 15] =
    185                      FLEXSPI_LUT_SEQ(kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x00, kFLEXSPI_Command_DDR, kFLEXSPI_8PAD, 0x10),
    186          };
    187          
    188          /*******************************************************************************
    189           * Code
    190           ******************************************************************************/
    191          

   \                                 In section .text, align 2, keep-with-next
    192          void flexspi_clock_init(void)
    193          {
   \                     flexspi_clock_init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    194              // Set flexspi root clock to 166MHZ.
    195              const clock_usb_pll_config_t g_ccmConfigUsbPll = {.loopDivider = 0U};
   \        0x2   0x....             LDR.N    R0,??DataTable8_6
   \        0x4   0x8800             LDRH     R0,[R0, #+0]
   \        0x6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    196          
    197              CLOCK_InitUsb1Pll(&g_ccmConfigUsbPll);
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x....'....        BL       CLOCK_InitUsb1Pll
    198              CLOCK_InitUsb1Pfd(kCLOCK_Pfd0, 26);   /* Set PLL3 PFD0 clock 332MHZ. */
   \       0x10   0x211A             MOVS     R1,#+26
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x....'....        BL       CLOCK_InitUsb1Pfd
    199              CLOCK_SetMux(kCLOCK_FlexspiMux, 0x3); /* Choose PLL3 PFD0 clock as flexspi source clock. */
   \       0x18   0x2103             MOVS     R1,#+3
   \       0x1A   0x....             LDR.N    R0,??DataTable8_7  ;; 0x80007d1c
   \       0x1C   0x....'....        BL       CLOCK_SetMux
    200              CLOCK_SetDiv(kCLOCK_FlexspiDiv, 3);   /* flexspi clock 83M, DDR mode, internal clock 42M. */
   \       0x20   0x2103             MOVS     R1,#+3
   \       0x22   0x....             LDR.N    R0,??DataTable8_8  ;; 0x8000f71c
   \       0x24   0x....'....        BL       CLOCK_SetDiv
    201          }
   \       0x28   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .rodata, align 2
   \                     ?_4:
   \        0x0   0x00 0x00          DC8 0, 0
    202          

   \                                 In section .text, align 2, keep-with-next
    203          void flexspi_clock_update(void)
    204          {
   \                     flexspi_clock_update: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    205              /* Program finished, speed the clock to 166M. */
    206              FLEXSPI_Enable(EXAMPLE_FLEXSPI, false);
   \        0x2   0x....             LDR.N    R4,??DataTable8_9  ;; 0x402a8000
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x....'....        BL       FLEXSPI_Enable
    207              CLOCK_DisableClock(EXAMPLE_FLEXSPI_CLOCK);
   \        0xC   0xF240 0x650A      MOVW     R5,#+1546
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x....'....        BL       CLOCK_DisableClock
    208              CLOCK_SetDiv(kCLOCK_FlexspiDiv, 0); /* flexspi clock 332M, DDR mode, internal clock 166M. */
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x....             LDR.N    R0,??DataTable8_8  ;; 0x8000f71c
   \       0x1A   0x....'....        BL       CLOCK_SetDiv
    209              CLOCK_EnableClock(EXAMPLE_FLEXSPI_CLOCK);
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x....'....        BL       CLOCK_EnableClock
    210              FLEXSPI_Enable(EXAMPLE_FLEXSPI, true);
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x2C   0x....             B.N      FLEXSPI_Enable
    211          }
    212          

   \                                 In section .text, align 2, keep-with-next
    213          void flexspi_hyper_flash_init(void)
    214          {
   \                     flexspi_hyper_flash_init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB08D             SUB      SP,SP,#+52
    215              flexspi_config_t config;
    216              
    217              //flexspi_clock_init();
    218          
    219              /*Get FLEXSPI default settings and configure the flexspi. */
    220              FLEXSPI_GetDefaultConfig(&config);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....'....        BL       FLEXSPI_GetDefaultConfig
    221          
    222              /*Set AHB buffer size for reading data through AHB bus. */
    223              config.ahbConfig.enableAHBPrefetch = true;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xF88D 0x0030      STRB     R0,[SP, #+48]
    224              /*Allow AHB read start address do not follow the alignment requirement. */
    225              config.ahbConfig.enableReadAddressOpt = true;
   \       0x10   0xF88D 0x002F      STRB     R0,[SP, #+47]
    226              config.ahbConfig.enableAHBBufferable  = true;
   \       0x14   0xF88D 0x0031      STRB     R0,[SP, #+49]
    227              config.ahbConfig.enableAHBCachable    = true;
   \       0x18   0xF88D 0x0032      STRB     R0,[SP, #+50]
    228              /* enable diff clock and DQS */
    229              config.enableSckBDiffOpt = true;
   \       0x1C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    230              config.rxSampleClock     = kFLEXSPI_ReadSampleClkExternalInputFromDqsPad;
   \       0x20   0x2003             MOVS     R0,#+3
   \       0x22   0xF88D 0x0000      STRB     R0,[SP, #+0]
    231              config.enableCombination = true;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xF88D 0x0002      STRB     R0,[SP, #+2]
    232              FLEXSPI_Init(EXAMPLE_FLEXSPI, &config);
   \       0x2C   0x....             LDR.N    R4,??DataTable8_9  ;; 0x402a8000
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       FLEXSPI_Init
    233          
    234              /* Configure flash settings according to serial flash feature. */
    235              FLEXSPI_SetFlashConfig(EXAMPLE_FLEXSPI, &deviceconfig, kFLEXSPI_PortA1);
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0x....             LDR.N    R1,??DataTable8_10
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x....'....        BL       FLEXSPI_SetFlashConfig
    236          
    237              /* Update LUT table. */
    238              FLEXSPI_UpdateLUT(EXAMPLE_FLEXSPI, 0, customLUT, CUSTOM_LUT_LENGTH);
   \       0x40   0x2340             MOVS     R3,#+64
   \       0x42   0x....             LDR.N    R2,??DataTable8_11
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x....'....        BL       FLEXSPI_UpdateLUT
    239          
    240              /* Do software reset. */
    241              FLEXSPI_SoftwareReset(EXAMPLE_FLEXSPI);
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x....'....        BL       FLEXSPI_SoftwareReset
    242          }
   \       0x52   0xB00E             ADD      SP,SP,#+56
   \       0x54   0xBD10             POP      {R4,PC}          ;; return
    243          

   \                                 In section .text, align 2, keep-with-next
    244          status_t flexspi_nor_hyperbus_read(FLEXSPI_Type *base, uint32_t addr, uint32_t *buffer, uint32_t bytes)
    245          {
   \                     flexspi_nor_hyperbus_read: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    246              flexspi_transfer_t flashXfer;
    247              status_t status;
    248          
    249              flashXfer.deviceAddress = addr * 2;
   \        0x2   0x0049             LSLS     R1,R1,#+1
   \        0x4   0x9100             STR      R1,[SP, #+0]
    250              flashXfer.port          = kFLEXSPI_PortA1;
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xF88D 0x1004      STRB     R1,[SP, #+4]
    251              flashXfer.cmdType       = kFLEXSPI_Read;
   \        0xC   0x2102             MOVS     R1,#+2
   \        0xE   0xF88D 0x1005      STRB     R1,[SP, #+5]
    252              flashXfer.SeqNumber     = 1;
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0xF88D 0x1007      STRB     R1,[SP, #+7]
    253              flashXfer.seqIndex      = HYPERFLASH_CMD_LUT_SEQ_IDX_READDATA;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0xF88D 0x1006      STRB     R1,[SP, #+6]
    254              flashXfer.data          = buffer;
   \       0x1E   0x9202             STR      R2,[SP, #+8]
    255              flashXfer.dataSize      = bytes;
   \       0x20   0x9303             STR      R3,[SP, #+12]
    256              status                  = FLEXSPI_TransferBlocking(base, &flashXfer);
   \       0x22   0x4669             MOV      R1,SP
   \       0x24   0x....'....        BL       FLEXSPI_TransferBlocking
    257          
    258              if (status != kStatus_Success)
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD100             BNE.N    ??flexspi_nor_hyperbus_read_0
    259              {
    260                  return status;
    261              }
    262          
    263              return status;
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??flexspi_nor_hyperbus_read_0: (+1)
   \       0x2E   0xB005             ADD      SP,SP,#+20
   \       0x30   0xBD00             POP      {PC}             ;; return
    264          }
    265          

   \                                 In section .text, align 2, keep-with-next
    266          status_t flexspi_nor_hyperbus_write(FLEXSPI_Type *base, uint32_t addr, uint32_t *buffer, uint32_t bytes)
    267          {
   \                     flexspi_nor_hyperbus_write: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    268              flexspi_transfer_t flashXfer;
    269              status_t status;
    270          
    271              flashXfer.deviceAddress = addr * 2;
   \        0x2   0x0049             LSLS     R1,R1,#+1
   \        0x4   0x9100             STR      R1,[SP, #+0]
    272              flashXfer.port          = kFLEXSPI_PortA1;
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xF88D 0x1004      STRB     R1,[SP, #+4]
    273              flashXfer.cmdType       = kFLEXSPI_Write;
   \        0xC   0x2103             MOVS     R1,#+3
   \        0xE   0xF88D 0x1005      STRB     R1,[SP, #+5]
    274              flashXfer.SeqNumber     = 1;
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0xF88D 0x1007      STRB     R1,[SP, #+7]
    275              flashXfer.seqIndex      = HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEDATA;
   \       0x18   0xF88D 0x1006      STRB     R1,[SP, #+6]
    276              flashXfer.data          = buffer;
   \       0x1C   0x9202             STR      R2,[SP, #+8]
    277              flashXfer.dataSize      = bytes;
   \       0x1E   0x9303             STR      R3,[SP, #+12]
    278              status                  = FLEXSPI_TransferBlocking(base, &flashXfer);
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x....'....        BL       FLEXSPI_TransferBlocking
    279          
    280              if (status != kStatus_Success)
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD100             BNE.N    ??flexspi_nor_hyperbus_write_0
    281              {
    282                  return status;
    283              }
    284          
    285              return status;
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??flexspi_nor_hyperbus_write_0: (+1)
   \       0x2C   0xB005             ADD      SP,SP,#+20
   \       0x2E   0xBD00             POP      {PC}             ;; return
    286          }
    287          

   \                                 In section .text, align 2, keep-with-next
    288          status_t flexspi_nor_write_enable(FLEXSPI_Type *base, uint32_t baseAddr)
    289          {
   \                     flexspi_nor_write_enable: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    290              flexspi_transfer_t flashXfer;
    291              status_t status;
    292          
    293              /* Write neable */
    294              flashXfer.deviceAddress = baseAddr;
   \        0x2   0x9100             STR      R1,[SP, #+0]
    295              flashXfer.port          = kFLEXSPI_PortA1;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0xF8AD 0x1004      STRH     R1,[SP, #+4]
    296              flashXfer.cmdType       = kFLEXSPI_Command;
    297              flashXfer.SeqNumber     = 2;
   \        0xA   0x2102             MOVS     R1,#+2
   \        0xC   0xF88D 0x1007      STRB     R1,[SP, #+7]
    298              flashXfer.seqIndex      = HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE;
   \       0x10   0x2104             MOVS     R1,#+4
   \       0x12   0xF88D 0x1006      STRB     R1,[SP, #+6]
    299          
    300              status = FLEXSPI_TransferBlocking(base, &flashXfer);
    301          
    302              return status;
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x....'....        BL       FLEXSPI_TransferBlocking
   \       0x1C   0xB005             ADD      SP,SP,#+20
   \       0x1E   0xBD00             POP      {PC}             ;; return
    303          }
    304          

   \                                 In section .text, align 2, keep-with-next
    305          status_t flexspi_nor_wait_bus_busy(FLEXSPI_Type *base)
    306          {
   \                     flexspi_nor_wait_bus_busy: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x4604             MOV      R4,R0
    307              /* Wait status ready. */
    308              bool isBusy;
    309              uint32_t readValue;
    310              status_t status;
    311              flexspi_transfer_t flashXfer;
    312          
    313              flashXfer.deviceAddress = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9001             STR      R0,[SP, #+4]
    314              flashXfer.port          = kFLEXSPI_PortA1;
   \        0xA   0xF88D 0x0008      STRB     R0,[SP, #+8]
    315              flashXfer.cmdType       = kFLEXSPI_Read;
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xF88D 0x0009      STRB     R0,[SP, #+9]
    316              flashXfer.SeqNumber     = 2;
   \       0x14   0xF88D 0x000B      STRB     R0,[SP, #+11]
    317              flashXfer.seqIndex      = HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS;
   \       0x18   0xF88D 0x000A      STRB     R0,[SP, #+10]
    318              flashXfer.data          = &readValue;
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x9003             STR      R0,[SP, #+12]
    319              flashXfer.dataSize      = 2;
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x9004             STR      R0,[SP, #+16]
    320          
    321              do
    322              {
    323                  status = FLEXSPI_TransferBlocking(base, &flashXfer);
   \                     ??flexspi_nor_wait_bus_busy_0: (+1)
   \       0x24   0xA901             ADD      R1,SP,#+4
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       FLEXSPI_TransferBlocking
    324          
    325                  if (status != kStatus_Success)
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD107             BNE.N    ??flexspi_nor_wait_bus_busy_1
    326                  {
    327                      return status;
    328                  }
    329                  if (readValue & 0x8000)
    330                  {
    331                      isBusy = false;
    332                  }
    333                  else
    334                  {
    335                      isBusy = true;
    336                  }
    337          
    338                  if (readValue & 0x3200)
   \       0x30   0x9900             LDR      R1,[SP, #+0]
   \       0x32   0xF411 0x5F48      TST      R1,#0x3200
   \       0x36   0xD102             BNE.N    ??flexspi_nor_wait_bus_busy_2
    339                  {
    340                      status = kStatus_Fail;
    341                      break;
    342                  }
    343          
    344              } while (isBusy);
   \       0x38   0x0409             LSLS     R1,R1,#+16
   \       0x3A   0xD5F3             BPL.N    ??flexspi_nor_wait_bus_busy_0
   \       0x3C   0xE000             B.N      ??flexspi_nor_wait_bus_busy_1
   \                     ??flexspi_nor_wait_bus_busy_2: (+1)
   \       0x3E   0x2001             MOVS     R0,#+1
    345          
    346              return status;
   \                     ??flexspi_nor_wait_bus_busy_1: (+1)
   \       0x40   0xB006             ADD      SP,SP,#+24
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
    347          }
    348          

   \                                 In section .text, align 2, keep-with-next
    349          status_t flexspi_nor_flash_erase_sector(FLEXSPI_Type *base, uint32_t address)
    350          {
   \                     flexspi_nor_flash_erase_sector: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
    351              status_t status;
    352              flexspi_transfer_t flashXfer;
    353          
    354              /* Write enable */
    355              status = flexspi_nor_write_enable(base, address);
   \        0x8   0x....'....        BL       flexspi_nor_write_enable
    356          
    357              if (status != kStatus_Success)
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD117             BNE.N    ??flexspi_nor_flash_erase_sector_0
    358              {
    359                  return status;
    360              }
    361          
    362              flashXfer.deviceAddress = address;
   \       0x10   0x9500             STR      R5,[SP, #+0]
    363              flashXfer.port          = kFLEXSPI_PortA1;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    364              flashXfer.cmdType       = kFLEXSPI_Command;
    365              flashXfer.SeqNumber     = 4;
   \       0x18   0x2004             MOVS     R0,#+4
   \       0x1A   0xF88D 0x0007      STRB     R0,[SP, #+7]
    366              flashXfer.seqIndex      = HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR;
   \       0x1E   0x2006             MOVS     R0,#+6
   \       0x20   0xF88D 0x0006      STRB     R0,[SP, #+6]
    367              status                  = FLEXSPI_TransferBlocking(base, &flashXfer);
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       FLEXSPI_TransferBlocking
    368          
    369              if (status != kStatus_Success)
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD107             BNE.N    ??flexspi_nor_flash_erase_sector_0
    370              {
    371                  return status;
    372              }
    373          
    374              status = flexspi_nor_wait_bus_busy(base);
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       flexspi_nor_wait_bus_busy
   \       0x36   0x4604             MOV      R4,R0
    375          
    376              /* Do software reset. */
    377              FLEXSPI_SoftwareReset(EXAMPLE_FLEXSPI);
   \       0x38   0x....             LDR.N    R0,??DataTable8_9  ;; 0x402a8000
   \       0x3A   0x....'....        BL       FLEXSPI_SoftwareReset
    378          
    379              return status;
   \       0x3E   0x4620             MOV      R0,R4
   \                     ??flexspi_nor_flash_erase_sector_0: (+1)
   \       0x40   0xB005             ADD      SP,SP,#+20
   \       0x42   0xBD30             POP      {R4,R5,PC}       ;; return
    380          }
    381          

   \                                 In section .text, align 2, keep-with-next
    382          status_t flexspi_nor_flash_page_program(FLEXSPI_Type *base, uint32_t address, const uint32_t *src)
    383          {
   \                     flexspi_nor_flash_page_program: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x4693             MOV      R11,R2
    384              //flexspi_clock_init();
    385              
    386              status_t status;
    387              flexspi_transfer_t flashXfer;
    388              
    389              FLEXSPI_Enable(EXAMPLE_FLEXSPI, false);
   \        0xA   0x....             LDR.N    R5,??DataTable8_9  ;; 0x402a8000
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x....'....        BL       FLEXSPI_Enable
    390              CLOCK_DisableClock(kCLOCK_FlexSpi);
   \       0x14   0xF240 0x600A      MOVW     R0,#+1546
   \       0x18   0x....'....        BL       CLOCK_DisableClock
    391          
    392              /* The clock should be max 50MHz during programming */
    393              /* Backup of CCM_ANALOG_PFD_480 register */
    394              uint32_t pfd480;
    395              pfd480 = CCM_ANALOG->PFD_480;
   \       0x1C   0x....             LDR.N    R6,??DataTable8_12  ;; 0x400d80f0
   \       0x1E   0x6837             LDR      R7,[R6, #+0]
    396              /* Disable the clock output first */
    397              CCM_ANALOG->PFD_480 |= CCM_ANALOG_PFD_480_PFD0_CLKGATE_MASK;
   \       0x20   0x6830             LDR      R0,[R6, #+0]
   \       0x22   0xF040 0x0080      ORR      R0,R0,#0x80
   \       0x26   0x6030             STR      R0,[R6, #+0]
    398              /* Set value of PFD0_FRAC to 26 - clock 332MHz */
    399              CCM_ANALOG->PFD_480 &= ~CCM_ANALOG_PFD_480_PFD0_FRAC_MASK;
   \       0x28   0x6830             LDR      R0,[R6, #+0]
   \       0x2A   0x0980             LSRS     R0,R0,#+6
   \       0x2C   0x0180             LSLS     R0,R0,#+6
   \       0x2E   0x6030             STR      R0,[R6, #+0]
    400              CCM_ANALOG->PFD_480 |= CCM_ANALOG_PFD_480_PFD0_FRAC(26);
   \       0x30   0x6830             LDR      R0,[R6, #+0]
   \       0x32   0xF040 0x001A      ORR      R0,R0,#0x1A
   \       0x36   0x6030             STR      R0,[R6, #+0]
    401              /* Enable output */
    402              CCM_ANALOG->PFD_480 &= ~CCM_ANALOG_PFD_480_PFD0_CLKGATE_MASK;
   \       0x38   0x6830             LDR      R0,[R6, #+0]
   \       0x3A   0xF020 0x0080      BIC      R0,R0,#0x80
   \       0x3E   0x6030             STR      R0,[R6, #+0]
    403          
    404              /* Backup of CCM_CSCMR1 register */
    405              uint32_t cscmr1;
    406              cscmr1 = CCM->CSCMR1;
   \       0x40   0x....'....        LDR.W    R8,??DataTable8_13  ;; 0x400fc01c
   \       0x44   0xF8D8 0x9000      LDR      R9,[R8, #+0]
    407              /* Set value of FLEXSPI_CLK_SEL to 3 - derive clock from PLL3 PFD0 */
    408              CCM->CSCMR1 |= CCM_CSCMR1_FLEXSPI_CLK_SEL(3);
   \       0x48   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x4C   0xF040 0x40C0      ORR      R0,R0,#0x60000000
   \       0x50   0xF8C8 0x0000      STR      R0,[R8, #+0]
    409              /* Set value of FLEXSPI_PODF to 3 - divide by 4, flexspi clock 83MHz, in DDR mode is half clock frequency on SCK - 42MHz */
    410              CCM->CSCMR1 &= ~CCM_CSCMR1_FLEXSPI_PODF_MASK;
   \       0x54   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x58   0xF020 0x7060      BIC      R0,R0,#0x3800000
   \       0x5C   0xF8C8 0x0000      STR      R0,[R8, #+0]
    411              CCM->CSCMR1 |= CCM_CSCMR1_FLEXSPI_PODF(3);
   \       0x60   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x64   0xF040 0x70C0      ORR      R0,R0,#0x1800000
   \       0x68   0xF8C8 0x0000      STR      R0,[R8, #+0]
    412          
    413              CLOCK_EnableClock(kCLOCK_FlexSpi);
   \       0x6C   0xF240 0x600A      MOVW     R0,#+1546
   \       0x70   0x....'....        BL       CLOCK_EnableClock
    414              FLEXSPI_Enable(EXAMPLE_FLEXSPI, true);
   \       0x74   0x2101             MOVS     R1,#+1
   \       0x76   0x4628             MOV      R0,R5
   \       0x78   0x....'....        BL       FLEXSPI_Enable
    415          
    416              /* Do software reset. */
    417              FLEXSPI_SoftwareReset(EXAMPLE_FLEXSPI);
   \       0x7C   0x4628             MOV      R0,R5
   \       0x7E   0x....'....        BL       FLEXSPI_SoftwareReset
    418              
    419              /* Write neable */
    420              status = flexspi_nor_write_enable(base, address);
   \       0x82   0x4651             MOV      R1,R10
   \       0x84   0x9804             LDR      R0,[SP, #+16]
   \       0x86   0x....'....        BL       flexspi_nor_write_enable
   \       0x8A   0x0004             MOVS     R4,R0
    421          
    422              if (status != kStatus_Success)
   \       0x8C   0xD11C             BNE.N    ??flexspi_nor_flash_page_program_0
    423              {
    424                  goto exit;
    425              }
    426          
    427              /* Prepare page program command */
    428              flashXfer.deviceAddress = address;
   \       0x8E   0xF8CD 0xA000      STR      R10,[SP, #+0]
    429              flashXfer.port          = kFLEXSPI_PortA1;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xF88D 0x0004      STRB     R0,[SP, #+4]
    430              flashXfer.cmdType       = kFLEXSPI_Write;
   \       0x98   0x2003             MOVS     R0,#+3
   \       0x9A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    431              flashXfer.SeqNumber     = 2;
   \       0x9E   0x2002             MOVS     R0,#+2
   \       0xA0   0xF88D 0x0007      STRB     R0,[SP, #+7]
    432              flashXfer.seqIndex      = HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM;
   \       0xA4   0x200A             MOVS     R0,#+10
   \       0xA6   0xF88D 0x0006      STRB     R0,[SP, #+6]
    433              flashXfer.data          = (uint32_t *)src;
   \       0xAA   0xF8CD 0xB008      STR      R11,[SP, #+8]
    434              flashXfer.dataSize      = FLASH_PAGE_SIZE;
   \       0xAE   0xF44F 0x7000      MOV      R0,#+512
   \       0xB2   0x9003             STR      R0,[SP, #+12]
    435              status                  = FLEXSPI_TransferBlocking(base, &flashXfer);
   \       0xB4   0x4669             MOV      R1,SP
   \       0xB6   0x9804             LDR      R0,[SP, #+16]
   \       0xB8   0x....'....        BL       FLEXSPI_TransferBlocking
   \       0xBC   0x0004             MOVS     R4,R0
    436          
    437              if (status != kStatus_Success)
   \       0xBE   0xD103             BNE.N    ??flexspi_nor_flash_page_program_0
    438              {
    439                  goto exit;
    440              }
    441          
    442              status = flexspi_nor_wait_bus_busy(base);
   \       0xC0   0x9804             LDR      R0,[SP, #+16]
   \       0xC2   0x....'....        BL       flexspi_nor_wait_bus_busy
   \       0xC6   0x4604             MOV      R4,R0
    443          
    444          exit:
    445              FLEXSPI_Enable(EXAMPLE_FLEXSPI, false);
   \                     ??flexspi_nor_flash_page_program_0: (+1)
   \       0xC8   0x2100             MOVS     R1,#+0
   \       0xCA   0x4628             MOV      R0,R5
   \       0xCC   0x....'....        BL       FLEXSPI_Enable
    446              CLOCK_DisableClock(kCLOCK_FlexSpi);
   \       0xD0   0xF240 0x6A0A      MOVW     R10,#+1546
   \       0xD4   0x4650             MOV      R0,R10
   \       0xD6   0x....'....        BL       CLOCK_DisableClock
    447             
    448              /* Return back the changes in clocks */
    449              CCM_ANALOG->PFD_480 = pfd480;
   \       0xDA   0x6037             STR      R7,[R6, #+0]
    450              CCM->CSCMR1 = cscmr1;
   \       0xDC   0xF8C8 0x9000      STR      R9,[R8, #+0]
    451              
    452              CLOCK_EnableClock(kCLOCK_FlexSpi);
   \       0xE0   0x4650             MOV      R0,R10
   \       0xE2   0x....'....        BL       CLOCK_EnableClock
    453              FLEXSPI_Enable(EXAMPLE_FLEXSPI, true);
   \       0xE6   0x2101             MOVS     R1,#+1
   \       0xE8   0x4628             MOV      R0,R5
   \       0xEA   0x....'....        BL       FLEXSPI_Enable
    454          
    455              /* Do software reset. */
    456              FLEXSPI_SoftwareReset(EXAMPLE_FLEXSPI); 
   \       0xEE   0x4628             MOV      R0,R5
   \       0xF0   0x....'....        BL       FLEXSPI_SoftwareReset
    457          
    458              return status;
   \       0xF4   0x4620             MOV      R0,R4
   \       0xF6   0xB005             ADD      SP,SP,#+20
   \       0xF8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    459          }
    460          

   \                                 In section .text, align 2, keep-with-next
    461          status_t flexspi_nor_hyperflash_cfi(FLEXSPI_Type *base)
    462          {
   \                     flexspi_nor_hyperflash_cfi: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    463              /*
    464               * Read ID-CFI Parameters
    465               */
    466              // CFI Entry
    467              status_t status;
    468              uint32_t buffer[2];
    469              uint8_t data[2] = {0x00, 0x98};
   \        0x4   0x....             LDR.N    R0,??DataTable8_14
   \        0x6   0x8800             LDRH     R0,[R0, #+0]
   \        0x8   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    470              status          = flexspi_nor_hyperbus_write(base, 0x555, (uint32_t *)data, 2);
   \        0xC   0x2302             MOVS     R3,#+2
   \        0xE   0x466A             MOV      R2,SP
   \       0x10   0xF240 0x5155      MOVW     R1,#+1365
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       flexspi_nor_hyperbus_write
    471              if (status != kStatus_Success)
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD124             BNE.N    ??flexspi_nor_hyperflash_cfi_0
    472              {
    473                  return status;
    474              }
    475          
    476              // ID-CFI Read
    477              // Read Query Unique ASCII String
    478              status = flexspi_nor_hyperbus_read(base, 0x10, &buffer[0], sizeof(buffer));
   \       0x1E   0x2308             MOVS     R3,#+8
   \       0x20   0xAA01             ADD      R2,SP,#+4
   \       0x22   0x2110             MOVS     R1,#+16
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       flexspi_nor_hyperbus_read
    479              if (status != kStatus_Success)
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD11C             BNE.N    ??flexspi_nor_hyperflash_cfi_0
    480              {
    481                  return status;
    482              }
    483              buffer[1] &= 0xFFFF;
   \       0x2E   0xA801             ADD      R0,SP,#+4
   \       0x30   0x6841             LDR      R1,[R0, #+4]
   \       0x32   0xB289             UXTH     R1,R1
   \       0x34   0x6041             STR      R1,[R0, #+4]
    484              // Check that the data read out is  unicode "QRY" in big-endian order
    485              if ((buffer[0] != 0x52005100) || (buffer[1] != 0x5900))
   \       0x36   0x9901             LDR      R1,[SP, #+4]
   \       0x38   0x....             LDR.N    R2,??DataTable8_15  ;; 0x52005100
   \       0x3A   0x4291             CMP      R1,R2
   \       0x3C   0xD103             BNE.N    ??flexspi_nor_hyperflash_cfi_1
   \       0x3E   0x6840             LDR      R0,[R0, #+4]
   \       0x40   0xF5B0 0x4FB2      CMP      R0,#+22784
   \       0x44   0xD001             BEQ.N    ??flexspi_nor_hyperflash_cfi_2
    486              {
    487                  status = kStatus_Fail;
    488                  return status;
   \                     ??flexspi_nor_hyperflash_cfi_1: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xE00E             B.N      ??flexspi_nor_hyperflash_cfi_0
    489              }
    490              // ASO Exit 0xF000
    491              data[1] = 0xF0;
   \                     ??flexspi_nor_hyperflash_cfi_2: (+1)
   \       0x4A   0x20F0             MOVS     R0,#+240
   \       0x4C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    492              status  = flexspi_nor_hyperbus_write(base, 0x0, (uint32_t *)data, 2);
   \       0x50   0x2302             MOVS     R3,#+2
   \       0x52   0x466A             MOV      R2,SP
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x4620             MOV      R0,R4
   \       0x58   0x....'....        BL       flexspi_nor_hyperbus_write
    493              if (status != kStatus_Success)
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD103             BNE.N    ??flexspi_nor_hyperflash_cfi_0
    494              {
    495                  return status;
    496              }
    497          
    498              /* Do software reset. */
    499              FLEXSPI_SoftwareReset(EXAMPLE_FLEXSPI);
   \       0x60   0x....             LDR.N    R0,??DataTable8_9  ;; 0x402a8000
   \       0x62   0x....'....        BL       FLEXSPI_SoftwareReset
    500          
    501              return status;
   \       0x66   0x2000             MOVS     R0,#+0
   \                     ??flexspi_nor_hyperflash_cfi_0: (+1)
   \       0x68   0xB004             ADD      SP,SP,#+16
   \       0x6A   0xBD10             POP      {R4,PC}          ;; return
    502          }
    503          

   \                                 In section .text, align 2, keep-with-next
    504          status_t flexspi_nor_flash_erase_chip(FLEXSPI_Type *base)
    505          {
   \                     flexspi_nor_flash_erase_chip: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    506              status_t status;
    507              flexspi_transfer_t flashXfer;
    508          
    509              /* Write enable */
    510              status = flexspi_nor_write_enable(base, 0);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x....'....        BL       flexspi_nor_write_enable
    511          
    512              if (status != kStatus_Success)
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD112             BNE.N    ??flexspi_nor_flash_erase_chip_0
    513              {
    514                  return status;
    515              }
    516          
    517              flashXfer.deviceAddress = 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9000             STR      R0,[SP, #+0]
    518              flashXfer.port          = kFLEXSPI_PortA1;
   \       0x12   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    519              flashXfer.cmdType       = kFLEXSPI_Command;
    520              flashXfer.SeqNumber     = 4;
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0xF88D 0x0007      STRB     R0,[SP, #+7]
    521              flashXfer.seqIndex      = HYPERFLASH_CMD_LUT_SEQ_IDX_ERASECHIP;
   \       0x1C   0x200C             MOVS     R0,#+12
   \       0x1E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    522              status                  = FLEXSPI_TransferBlocking(base, &flashXfer);
   \       0x22   0x4669             MOV      R1,SP
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       FLEXSPI_TransferBlocking
    523          
    524              if (status != kStatus_Success)
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD102             BNE.N    ??flexspi_nor_flash_erase_chip_0
    525              {
    526                  return status;
    527              }
    528          
    529              status = flexspi_nor_wait_bus_busy(base);
    530          
    531              return status;
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       flexspi_nor_wait_bus_busy
   \                     ??flexspi_nor_flash_erase_chip_0: (+1)
   \       0x34   0xB004             ADD      SP,SP,#+16
   \       0x36   0xBD10             POP      {R4,PC}          ;; return
    532          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x400F'C000        DC32     0x400fc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x400F'C048        DC32     0x400fc048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x400F'C068        DC32     0x400fc068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x8000'7D1C        DC32     0x80007d1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x8000'F71C        DC32     0x8000f71c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x402A'8000        DC32     0x402a8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x....'....        DC32     deviceconfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \        0x0   0x....'....        DC32     customLUT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \        0x0   0x400D'80F0        DC32     0x400d80f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \        0x0   0x400F'C01C        DC32     0x400fc01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \        0x0   0x5200'5100        DC32     0x52005100

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x62 0x75          DC8 "busyShift <= (0x20U)"
   \              0x73 0x79    
   \              0x53 0x68    
   \              0x69 0x66    
   \              0x74 0x20    
   \              0x3C 0x3D    
   \              0x20 0x28    
   \              0x30 0x78    
   \              0x32 0x30    
   \              0x55 0x29    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
   \              0x5C 0x44    
   \              0x65 0x76    
   \              0x65 0x6C    
   \        0x8   0x6F 0x70          DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73    
   \       0x10   0x6D 0x61          DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
   \              0x72 0x74    
   \              0x5F 0x77    
   \              0x61 0x73    
   \       0x18   0x68 0x69          DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
   \              0x6E 0x67    
   \              0x5F 0x6D    
   \              0x61 0x63    
   \       0x20   0x68 0x69          DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
   \              0x6E 0x65    
   \              0x5F 0x33    
   \              0x30 0x38    
   \       0x28   0x30 0x5C          DC8 30H, 5CH, 64H, 72H, 69H, 76H, 65H, 72H
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \       0x30   0x73 0x5C          DC8 73H, 5CH, 66H, 73H, 6CH, 5FH, 63H, 6CH
   \              0x66 0x73    
   \              0x6C 0x5F    
   \              0x63 0x6C    
   \       0x38   0x6F 0x63          DC8 6FH, 63H, 6BH, 2EH, 68H, 0
   \              0x6B 0x2E    
   \              0x68 0x00    
   \       0x3E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x69 0x6E          DC8 "index <= 6"
   \              0x64 0x65    
   \              0x78 0x20    
   \              0x3C 0x3D    
   \              0x20 0x36    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 2
   \                     ?_3:
   \        0x0   0x00 0x98          DC8 0, 152

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CLOCK_ControlGate
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   CLOCK_DisableClock
         0   -> CLOCK_ControlGate
       0   CLOCK_EnableClock
         0   -> CLOCK_ControlGate
      16   CLOCK_SetDiv
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   CLOCK_SetMux
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   FLEXSPI_Enable
       0   FLEXSPI_SoftwareReset
       8   flexspi_clock_init
         8   -> CLOCK_InitUsb1Pfd
         8   -> CLOCK_InitUsb1Pll
         8   -> CLOCK_SetDiv
         8   -> CLOCK_SetMux
      16   flexspi_clock_update
        16   -> CLOCK_DisableClock
        16   -> CLOCK_EnableClock
        16   -> CLOCK_SetDiv
         0   -> FLEXSPI_Enable
        16   -> FLEXSPI_Enable
      64   flexspi_hyper_flash_init
        64   -> FLEXSPI_GetDefaultConfig
        64   -> FLEXSPI_Init
        64   -> FLEXSPI_SetFlashConfig
        64   -> FLEXSPI_SoftwareReset
        64   -> FLEXSPI_UpdateLUT
      24   flexspi_nor_flash_erase_chip
        24   -> FLEXSPI_TransferBlocking
        24   -> flexspi_nor_wait_bus_busy
        24   -> flexspi_nor_write_enable
      32   flexspi_nor_flash_erase_sector
        32   -> FLEXSPI_SoftwareReset
        32   -> FLEXSPI_TransferBlocking
        32   -> flexspi_nor_wait_bus_busy
        32   -> flexspi_nor_write_enable
      56   flexspi_nor_flash_page_program
        56   -> CLOCK_DisableClock
        56   -> CLOCK_EnableClock
        56   -> FLEXSPI_Enable
        56   -> FLEXSPI_SoftwareReset
        56   -> FLEXSPI_TransferBlocking
        56   -> flexspi_nor_wait_bus_busy
        56   -> flexspi_nor_write_enable
      24   flexspi_nor_hyperbus_read
        24   -> FLEXSPI_TransferBlocking
      24   flexspi_nor_hyperbus_write
        24   -> FLEXSPI_TransferBlocking
      24   flexspi_nor_hyperflash_cfi
        24   -> FLEXSPI_SoftwareReset
        24   -> flexspi_nor_hyperbus_read
        24   -> flexspi_nor_hyperbus_write
      32   flexspi_nor_wait_bus_busy
        32   -> FLEXSPI_TransferBlocking
      24   flexspi_nor_write_enable
        24   -> FLEXSPI_TransferBlocking


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      24  ?_0
      64  ?_1
      12  ?_2
       2  ?_3
       2  ?_4
      60  CLOCK_ControlGate
       4  CLOCK_DisableClock
       4  CLOCK_EnableClock
     104  CLOCK_SetDiv
     104  CLOCK_SetMux
      22  FLEXSPI_Enable
      16  FLEXSPI_SoftwareReset
     256  customLUT
      32  deviceconfig
      42  flexspi_clock_init
      46  flexspi_clock_update
      86  flexspi_hyper_flash_init
      56  flexspi_nor_flash_erase_chip
      68  flexspi_nor_flash_erase_sector
     252  flexspi_nor_flash_page_program
      50  flexspi_nor_hyperbus_read
      48  flexspi_nor_hyperbus_write
     108  flexspi_nor_hyperflash_cfi
      68  flexspi_nor_wait_bus_busy
      32  flexspi_nor_write_enable

 
   288 bytes in section .data
   104 bytes in section .rodata
 1 234 bytes in section .text
 
 1 234 bytes of CODE  memory
   104 bytes of CONST memory
   288 bytes of DATA  memory

Errors: none
Warnings: none
