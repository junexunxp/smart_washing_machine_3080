###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:23
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\utilities\fsl_str.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWE95E.tmp
#        (C:\Development\smart_washing_machine_3080\utilities\fsl_str.c -D
#        DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1
#        -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE
#        -D "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\fsl_str.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\fsl_str.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\utilities\fsl_str.c
      1          /*
      2           * Copyright 2017 NXP
      3           * All rights reserved.
      4           *
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           *
      8           */
      9          #include <math.h>
     10          #include <stdarg.h>
     11          #include <stdlib.h>
     12          #include "fsl_str.h"
     13          #include "fsl_debug_console_conf.h"
     14          
     15          /*******************************************************************************
     16           * Definitions
     17           ******************************************************************************/
     18          
     19          /*! @brief The overflow value.*/
     20          #ifndef HUGE_VAL
     21          #define HUGE_VAL (99.e99)
     22          #endif /* HUGE_VAL */
     23          
     24          #if PRINTF_ADVANCED_ENABLE
     25          /*! @brief Specification modifier flags for printf. */
     26          enum _debugconsole_printf_flag
     27          {
     28              kPRINTF_Minus             = 0x01U,  /*!< Minus FLag. */
     29              kPRINTF_Plus              = 0x02U,  /*!< Plus Flag. */
     30              kPRINTF_Space             = 0x04U,  /*!< Space Flag. */
     31              kPRINTF_Zero              = 0x08U,  /*!< Zero Flag. */
     32              kPRINTF_Pound             = 0x10U,  /*!< Pound Flag. */
     33              kPRINTF_LengthChar        = 0x20U,  /*!< Length: Char Flag. */
     34              kPRINTF_LengthShortInt    = 0x40U,  /*!< Length: Short Int Flag. */
     35              kPRINTF_LengthLongInt     = 0x80U,  /*!< Length: Long Int Flag. */
     36              kPRINTF_LengthLongLongInt = 0x100U, /*!< Length: Long Long Int Flag. */
     37          };
     38          #endif /* PRINTF_ADVANCED_ENABLE */
     39          
     40          /*! @brief Specification modifier flags for scanf. */
     41          enum _debugconsole_scanf_flag
     42          {
     43              kSCANF_Suppress   = 0x2U,    /*!< Suppress Flag. */
     44              kSCANF_DestMask   = 0x7cU,   /*!< Destination Mask. */
     45              kSCANF_DestChar   = 0x4U,    /*!< Destination Char Flag. */
     46              kSCANF_DestString = 0x8U,    /*!< Destination String FLag. */
     47              kSCANF_DestSet    = 0x10U,   /*!< Destination Set Flag. */
     48              kSCANF_DestInt    = 0x20U,   /*!< Destination Int Flag. */
     49              kSCANF_DestFloat  = 0x30U,   /*!< Destination Float Flag. */
     50              kSCANF_LengthMask = 0x1f00U, /*!< Length Mask Flag. */
     51          #if SCANF_ADVANCED_ENABLE
     52              kSCANF_LengthChar        = 0x100U, /*!< Length Char Flag. */
     53              kSCANF_LengthShortInt    = 0x200U, /*!< Length ShortInt Flag. */
     54              kSCANF_LengthLongInt     = 0x400U, /*!< Length LongInt Flag. */
     55              kSCANF_LengthLongLongInt = 0x800U, /*!< Length LongLongInt Flag. */
     56          #endif                                 /* SCANF_ADVANCED_ENABLE */
     57          #if SCANF_FLOAT_ENABLE
     58              kSCANF_LengthLongLongDouble = 0x1000U, /*!< Length LongLongDuoble Flag. */
     59          #endif                                     /*PRINTF_FLOAT_ENABLE */
     60              kSCANF_TypeSinged = 0x2000U,           /*!< TypeSinged Flag. */
     61          };
     62          
     63          /*! @brief Keil: suppress ellipsis warning in va_arg usage below. */
     64          #if defined(__CC_ARM)
     65          #pragma diag_suppress 1256
     66          #endif /* __CC_ARM */
     67          
     68          /*******************************************************************************
     69           * Prototypes
     70           ******************************************************************************/
     71          /*!
     72           * @brief Scanline function which ignores white spaces.
     73           *
     74           * @param[in]   s The address of the string pointer to update.
     75           * @return      String without white spaces.
     76           */
     77          static uint32_t ScanIgnoreWhiteSpace(const char **s);
     78          
     79          /*!
     80           * @brief Converts a radix number to a string and return its length.
     81           *
     82           * @param[in] numstr    Converted string of the number.
     83           * @param[in] nump      Pointer to the number.
     84           * @param[in] neg       Polarity of the number.
     85           * @param[in] radix     The radix to be converted to.
     86           * @param[in] use_caps  Used to identify %x/X output format.
     87          
     88           * @return Length of the converted string.
     89           */
     90          static int32_t ConvertRadixNumToString(char *numstr, void *nump, int32_t neg, int32_t radix, bool use_caps);
     91          
     92          #if PRINTF_FLOAT_ENABLE
     93          /*!
     94           * @brief Converts a floating radix number to a string and return its length.
     95           *
     96           * @param[in] numstr            Converted string of the number.
     97           * @param[in] nump              Pointer to the number.
     98           * @param[in] radix             The radix to be converted to.
     99           * @param[in] precision_width   Specify the precision width.
    100          
    101           * @return Length of the converted string.
    102           */
    103          static int32_t ConvertFloatRadixNumToString(char *numstr, void *nump, int32_t radix, uint32_t precision_width);
    104          #endif /* PRINTF_FLOAT_ENABLE */
    105          
    106          /*!
    107           *
    108           */
    109          double modf(double input_dbl, double *intpart_ptr);
    110          
    111          /*************Code for process formatted data*******************************/
    112          

   \                                 In section .text, align 2, keep-with-next
    113          static uint32_t ScanIgnoreWhiteSpace(const char **s)
    114          {
   \                     ScanIgnoreWhiteSpace: (+1)
   \        0x0   0x4601             MOV      R1,R0
    115              uint8_t count = 0;
   \        0x2   0x2000             MOVS     R0,#+0
    116              uint8_t c;
    117          
    118              c = **s;
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x7812             LDRB     R2,[R2, #+0]
   \        0x8   0xE004             B.N      ??ScanIgnoreWhiteSpace_0
    119              while ((c == ' ') || (c == '\t') || (c == '\n') || (c == '\r') || (c == '\v') || (c == '\f'))
    120              {
    121                  count++;
   \                     ??ScanIgnoreWhiteSpace_1: (+1)
   \        0xA   0x1C40             ADDS     R0,R0,#+1
    122                  (*s)++;
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0x1C52             ADDS     R2,R2,#+1
   \       0x10   0x600A             STR      R2,[R1, #+0]
    123                  c = **s;
   \       0x12   0x7812             LDRB     R2,[R2, #+0]
    124              }
   \                     ??ScanIgnoreWhiteSpace_0: (+1)
   \       0x14   0x2A20             CMP      R2,#+32
   \       0x16   0xD0F8             BEQ.N    ??ScanIgnoreWhiteSpace_1
   \       0x18   0x2A09             CMP      R2,#+9
   \       0x1A   0xD0F6             BEQ.N    ??ScanIgnoreWhiteSpace_1
   \       0x1C   0x2A0A             CMP      R2,#+10
   \       0x1E   0xD0F4             BEQ.N    ??ScanIgnoreWhiteSpace_1
   \       0x20   0x2A0D             CMP      R2,#+13
   \       0x22   0xD0F2             BEQ.N    ??ScanIgnoreWhiteSpace_1
   \       0x24   0x2A0B             CMP      R2,#+11
   \       0x26   0xD0F0             BEQ.N    ??ScanIgnoreWhiteSpace_1
   \       0x28   0x2A0C             CMP      R2,#+12
   \       0x2A   0xD0EE             BEQ.N    ??ScanIgnoreWhiteSpace_1
    125              return count;
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x4770             BX       LR               ;; return
    126          }
    127          

   \                                 In section .text, align 2, keep-with-next
    128          static int32_t ConvertRadixNumToString(char *numstr, void *nump, int32_t neg, int32_t radix, bool use_caps)
    129          {
   \                     ConvertRadixNumToString: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x4698             MOV      R8,R3
    130          #if PRINTF_ADVANCED_ENABLE
    131              int64_t a;
    132              int64_t b;
    133              int64_t c;
    134          
    135              uint64_t ua;
    136              uint64_t ub;
    137              uint64_t uc;
    138          #else
    139              int32_t a;
    140              int32_t b;
    141              int32_t c;
    142          
    143              uint32_t ua;
    144              uint32_t ub;
    145              uint32_t uc;
    146          #endif /* PRINTF_ADVANCED_ENABLE */
    147          
    148              int32_t nlen;
    149              char *nstrp;
    150          
    151              nlen     = 0;
   \        0x8   0x2700             MOVS     R7,#+0
    152              nstrp    = numstr;
    153              *nstrp++ = '\0';
   \        0xA   0x4638             MOV      R0,R7
   \        0xC   0xF806 0x0B01      STRB     R0,[R6], #+1
    154          
    155              if (neg)
   \       0x10   0x2A00             CMP      R2,#+0
   \       0x12   0xE9D1 0x4500      LDRD     R4,R5,[R1, #+0]
   \       0x16   0xD024             BEQ.N    ??ConvertRadixNumToString_0
    156              {
    157          #if PRINTF_ADVANCED_ENABLE
    158                  a = *(int64_t *)nump;
    159          #else
    160                  a = *(int32_t *)nump;
    161          #endif /* PRINTF_ADVANCED_ENABLE */
    162                  if (a == 0)
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD101             BNE.N    ??ConvertRadixNumToString_1
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD026             BEQ.N    ??ConvertRadixNumToString_2
    163                  {
    164                      *nstrp = '0';
    165                      ++nlen;
    166                      return nlen;
    167                  }
    168                  while (a != 0)
   \                     ??ConvertRadixNumToString_1: (+1)
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD101             BNE.N    ??ConvertRadixNumToString_3
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD050             BEQ.N    ??ConvertRadixNumToString_4
    169                  {
    170          #if PRINTF_ADVANCED_ENABLE
    171                      b = (int64_t)a / (int64_t)radix;
   \                     ??ConvertRadixNumToString_3: (+1)
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x4629             MOV      R1,R5
   \       0x2C   0x4642             MOV      R2,R8
   \       0x2E   0xEA4F 0x73E8      ASR      R3,R8,#+31
   \       0x32   0x....'....        BL       __aeabi_ldivmod
    172                      c = (int64_t)a - ((int64_t)b * (int64_t)radix);
   \       0x36   0xEA4F 0x79E8      ASR      R9,R8,#+31
   \       0x3A   0xFBA8 0x2300      UMULL    R2,R3,R8,R0
   \       0x3E   0xFB08 0x3301      MLA      R3,R8,R1,R3
   \       0x42   0xFB09 0x3300      MLA      R3,R9,R0,R3
   \       0x46   0x1AA2             SUBS     R2,R4,R2
   \       0x48   0xEB75 0x0303      SBCS     R3,R5,R3
    173                      if (c < 0)
   \       0x4C   0xD401             BMI.N    ??ConvertRadixNumToString_5
    174                      {
    175                          uc = (uint64_t)c;
    176                          c  = (int64_t)(~uc) + 1 + '0';
    177                      }
    178          #else
    179                      b = a / radix;
    180                      c = a - (b * radix);
    181                      if (c < 0)
    182                      {
    183                          uc = (uint32_t)c;
    184                          c  = (uint32_t)(~uc) + 1 + '0';
    185                      }
    186          #endif /* PRINTF_ADVANCED_ENABLE */
    187                      else
    188                      {
    189                          c = c + '0';
   \       0x4E   0x3230             ADDS     R2,R2,#+48
   \       0x50   0xE001             B.N      ??ConvertRadixNumToString_6
    190                      }
   \                     ??ConvertRadixNumToString_5: (+1)
   \       0x52   0x43D2             MVNS     R2,R2
   \       0x54   0x3231             ADDS     R2,R2,#+49
    191                      a        = b;
   \                     ??ConvertRadixNumToString_6: (+1)
   \       0x56   0x4604             MOV      R4,R0
   \       0x58   0x460D             MOV      R5,R1
    192                      *nstrp++ = (char)c;
   \       0x5A   0xF806 0x2B01      STRB     R2,[R6], #+1
    193                      ++nlen;
   \       0x5E   0x1C7F             ADDS     R7,R7,#+1
   \       0x60   0xE7DE             B.N      ??ConvertRadixNumToString_1
    194                  }
    195              }
    196              else
    197              {
    198          #if PRINTF_ADVANCED_ENABLE
    199                  ua = *(uint64_t *)nump;
   \                     ??ConvertRadixNumToString_0: (+1)
   \       0x62   0xF8DD 0xA020      LDR      R10,[SP, #+32]
    200          #else
    201                  ua = *(uint32_t *)nump;
    202          #endif /* PRINTF_ADVANCED_ENABLE */
    203                  if (ua == 0)
   \       0x66   0x2D00             CMP      R5,#+0
   \       0x68   0xD112             BNE.N    ??ConvertRadixNumToString_7
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD110             BNE.N    ??ConvertRadixNumToString_7
    204                  {
    205                      *nstrp = '0';
   \                     ??ConvertRadixNumToString_2: (+1)
   \       0x6E   0x2030             MOVS     R0,#+48
   \       0x70   0x7030             STRB     R0,[R6, #+0]
    206                      ++nlen;
    207                      return nlen;
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0xE02A             B.N      ??ConvertRadixNumToString_8
    208                  }
    209                  while (ua != 0)
    210                  {
    211          #if PRINTF_ADVANCED_ENABLE
    212                      ub = (uint64_t)ua / (uint64_t)radix;
    213                      uc = (uint64_t)ua - ((uint64_t)ub * (uint64_t)radix);
    214          #else
    215                      ub = ua / (uint32_t)radix;
    216                      uc = ua - (ub * (uint32_t)radix);
    217          #endif /* PRINTF_ADVANCED_ENABLE */
    218          
    219                      if (uc < 10)
    220                      {
    221                          uc = uc + '0';
    222                      }
    223                      else
    224                      {
    225                          uc = uc - 10 + (use_caps ? 'A' : 'a');
   \                     ??ConvertRadixNumToString_9: (+1)
   \       0x76   0x2261             MOVS     R2,#+97
   \       0x78   0xE003             B.N      ??ConvertRadixNumToString_10
   \                     ??ConvertRadixNumToString_11: (+1)
   \       0x7A   0x4652             MOV      R2,R10
   \       0x7C   0x2A00             CMP      R2,#+0
   \       0x7E   0xD0FA             BEQ.N    ??ConvertRadixNumToString_9
   \       0x80   0x2241             MOVS     R2,#+65
   \                     ??ConvertRadixNumToString_10: (+1)
   \       0x82   0x3A0A             SUBS     R2,R2,#+10
   \       0x84   0x18A2             ADDS     R2,R4,R2
    226                      }
    227                      ua       = ub;
   \                     ??ConvertRadixNumToString_12: (+1)
   \       0x86   0x4604             MOV      R4,R0
   \       0x88   0x460D             MOV      R5,R1
    228                      *nstrp++ = (char)uc;
   \       0x8A   0xF806 0x2B01      STRB     R2,[R6], #+1
    229                      ++nlen;
   \       0x8E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??ConvertRadixNumToString_7: (+1)
   \       0x90   0x2D00             CMP      R5,#+0
   \       0x92   0xD101             BNE.N    ??ConvertRadixNumToString_13
   \       0x94   0x2C00             CMP      R4,#+0
   \       0x96   0xD018             BEQ.N    ??ConvertRadixNumToString_4
   \                     ??ConvertRadixNumToString_13: (+1)
   \       0x98   0x4620             MOV      R0,R4
   \       0x9A   0x4629             MOV      R1,R5
   \       0x9C   0x4642             MOV      R2,R8
   \       0x9E   0xEA4F 0x73E8      ASR      R3,R8,#+31
   \       0xA2   0x....'....        BL       __aeabi_uldivmod
   \       0xA6   0xEA4F 0x79E8      ASR      R9,R8,#+31
   \       0xAA   0xFBA8 0x2300      UMULL    R2,R3,R8,R0
   \       0xAE   0xFB08 0x3301      MLA      R3,R8,R1,R3
   \       0xB2   0xFB09 0x3300      MLA      R3,R9,R0,R3
   \       0xB6   0x1AA4             SUBS     R4,R4,R2
   \       0xB8   0x419D             SBCS     R5,R5,R3
   \       0xBA   0x2D00             CMP      R5,#+0
   \       0xBC   0xD8DD             BHI.N    ??ConvertRadixNumToString_11
   \       0xBE   0xD301             BCC.N    ??ConvertRadixNumToString_14
   \       0xC0   0x2C0A             CMP      R4,#+10
   \       0xC2   0xD2DA             BCS.N    ??ConvertRadixNumToString_11
   \                     ??ConvertRadixNumToString_14: (+1)
   \       0xC4   0xF104 0x0230      ADD      R2,R4,#+48
   \       0xC8   0xE7DD             B.N      ??ConvertRadixNumToString_12
    230                  }
    231              }
   \                     ??ConvertRadixNumToString_4: (+1)
   \       0xCA   0x4638             MOV      R0,R7
    232              return nlen;
   \                     ??ConvertRadixNumToString_8: (+1)
   \       0xCC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    233          }
    234          
    235          #if PRINTF_FLOAT_ENABLE
    236          static int32_t ConvertFloatRadixNumToString(char *numstr, void *nump, int32_t radix, uint32_t precision_width)
    237          {
    238              int32_t a;
    239              int32_t b;
    240              int32_t c;
    241              int32_t i;
    242              uint32_t uc;
    243              double fa;
    244              double dc;
    245              double fb;
    246              double r;
    247              double fractpart;
    248              double intpart;
    249          
    250              int32_t nlen;
    251              char *nstrp;
    252              nlen     = 0;
    253              nstrp    = numstr;
    254              *nstrp++ = '\0';
    255              r        = *(double *)nump;
    256              if (!r)
    257              {
    258                  *nstrp = '0';
    259                  ++nlen;
    260                  return nlen;
    261              }
    262              fractpart = modf((double)r, (double *)&intpart);
    263              /* Process fractional part. */
    264              for (i = 0; i < precision_width; i++)
    265              {
    266                  fractpart *= radix;
    267              }
    268              if (r >= 0)
    269              {
    270                  fa = fractpart + (double)0.5;
    271                  if (fa >= pow(10, precision_width))
    272                  {
    273                      intpart++;
    274                  }
    275              }
    276              else
    277              {
    278                  fa = fractpart - (double)0.5;
    279                  if (fa <= -pow(10, precision_width))
    280                  {
    281                      intpart--;
    282                  }
    283              }
    284              for (i = 0; i < precision_width; i++)
    285              {
    286                  fb = fa / (int32_t)radix;
    287                  dc = (fa - (int64_t)fb * (int32_t)radix);
    288                  c  = (int32_t)dc;
    289                  if (c < 0)
    290                  {
    291                      uc = (uint32_t)c;
    292                      c  = (int32_t)(~uc) + 1 + '0';
    293                  }
    294                  else
    295                  {
    296                      c = c + '0';
    297                  }
    298                  fa       = fb;
    299                  *nstrp++ = (char)c;
    300                  ++nlen;
    301              }
    302              *nstrp++ = (char)'.';
    303              ++nlen;
    304              a = (int32_t)intpart;
    305              if (a == 0)
    306              {
    307                  *nstrp++ = '0';
    308                  ++nlen;
    309              }
    310              else
    311              {
    312                  while (a != 0)
    313                  {
    314                      b = (int32_t)a / (int32_t)radix;
    315                      c = (int32_t)a - ((int32_t)b * (int32_t)radix);
    316                      if (c < 0)
    317                      {
    318                          uc = (uint32_t)c;
    319                          c  = (int32_t)(~uc) + 1 + '0';
    320                      }
    321                      else
    322                      {
    323                          c = c + '0';
    324                      }
    325                      a        = b;
    326                      *nstrp++ = (char)c;
    327                      ++nlen;
    328                  }
    329              }
    330              return nlen;
    331          }
    332          #endif /* PRINTF_FLOAT_ENABLE */
    333          
    334          /*!
    335           * brief This function outputs its parameters according to a formatted string.
    336           *
    337           * note I/O is performed by calling given function pointer using following
    338           * (*func_ptr)(c);
    339           *
    340           * param[in] fmt_ptr   Format string for printf.
    341           * param[in] args_ptr  Arguments to printf.
    342           * param[in] buf  pointer to the buffer
    343           * param cb print callback function pointer
    344           *
    345           * return Number of characters to be print
    346           */

   \                                 In section .text, align 2, keep-with-next
    347          int StrFormatPrintf(const char *fmt, va_list ap, char *buf, printfCb cb)
    348          {
   \                     StrFormatPrintf: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x460E             MOV      R6,R1
    349              /* va_list ap; */
    350              char *p;
    351              int32_t c;
    352          
    353              char vstr[33];
    354              char *vstrp  = NULL;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x9100             STR      R1,[SP, #+0]
    355              int32_t vlen = 0;
   \        0xC   0x460C             MOV      R4,R1
    356          
    357              int32_t done;
    358              int32_t count = 0;
   \        0xE   0x9101             STR      R1,[SP, #+4]
    359          
    360              uint32_t field_width;
    361              uint32_t precision_width;
    362              char *sval;
    363              int32_t cval;
    364              bool use_caps;
    365              uint8_t radix = 0;
    366          
    367          #if PRINTF_ADVANCED_ENABLE
    368              uint32_t flags_used;
    369              int32_t schar, dschar;
    370              int64_t ival;
    371              uint64_t uval = 0;
   \       0x10   0x460A             MOV      R2,R1
   \       0x12   0x460B             MOV      R3,R1
   \       0x14   0xE9CD 0x2304      STRD     R2,R3,[SP, #+16]
    372              bool valid_precision_width;
    373          #else
    374              int32_t ival;
    375              uint32_t uval = 0;
    376          #endif /* PRINTF_ADVANCED_ENABLE */
    377          
    378          #if PRINTF_FLOAT_ENABLE
    379              double fval;
    380          #endif /* PRINTF_FLOAT_ENABLE */
    381          
    382              /* Start parsing apart the format string and display appropriate formats and data. */
    383              for (p = (char *)fmt; (c = *p) != 0; p++)
   \       0x18   0x9002             STR      R0,[SP, #+8]
   \       0x1A   0xE27B             B.N      ??StrFormatPrintf_0
    384              {
    385                  /*
    386                   * All formats begin with a '%' marker.  Special chars like
    387                   * '\n' or '\t' are normally converted to the appropriate
    388                   * character by the __compiler__.  Thus, no need for this
    389                   * routine to account for the '\' character.
    390                   */
    391                  if (c != '%')
    392                  {
    393                      cb(buf, &count, c, 1);
    394                      /* By using 'continue', the next iteration of the loop is used, skipping the code that follows. */
    395                      continue;
    396                  }
    397          
    398                  use_caps = true;
    399          
    400          #if PRINTF_ADVANCED_ENABLE
    401                  /* First check for specification modifier flags. */
    402                  flags_used = 0;
    403                  done       = false;
    404                  while (!done)
    405                  {
    406                      switch (*++p)
    407                      {
    408                          case '-':
    409                              flags_used |= kPRINTF_Minus;
    410                              break;
    411                          case '+':
    412                              flags_used |= kPRINTF_Plus;
    413                              break;
    414                          case ' ':
    415                              flags_used |= kPRINTF_Space;
    416                              break;
    417                          case '0':
    418                              flags_used |= kPRINTF_Zero;
    419                              break;
    420                          case '#':
    421                              flags_used |= kPRINTF_Pound;
    422                              break;
    423                          default:
    424                              /* We've gone one char too far. */
    425                              --p;
    426                              done = true;
    427                              break;
    428                      }
    429                  }
    430          #endif /* PRINTF_ADVANCED_ENABLE */
    431          
    432                  /* Next check for minimum field width. */
    433                  field_width = 0;
    434                  done        = false;
    435                  while (!done)
    436                  {
    437                      c = *++p;
    438                      if ((c >= '0') && (c <= '9'))
    439                      {
    440                          field_width = (field_width * 10) + (c - '0');
    441                      }
    442          #if PRINTF_ADVANCED_ENABLE
    443                      else if (c == '*')
    444                      {
    445                          field_width = (uint32_t)va_arg(ap, uint32_t);
    446                      }
    447          #endif /* PRINTF_ADVANCED_ENABLE */
    448                      else
    449                      {
    450                          /* We've gone one char too far. */
    451                          --p;
    452                          done = true;
    453                      }
    454                  }
    455                  /* Next check for the width and precision field separator. */
    456                  precision_width = 6;
    457          #if PRINTF_ADVANCED_ENABLE
    458                  valid_precision_width = false;
    459          #endif /* PRINTF_ADVANCED_ENABLE */
    460                  if (*++p == '.')
    461                  {
    462                      /* Must get precision field width, if present. */
    463                      precision_width = 0;
    464                      done            = false;
    465                      while (!done)
    466                      {
    467                          c = *++p;
    468                          if ((c >= '0') && (c <= '9'))
    469                          {
    470                              precision_width = (precision_width * 10) + (c - '0');
    471          #if PRINTF_ADVANCED_ENABLE
    472                              valid_precision_width = true;
    473          #endif /* PRINTF_ADVANCED_ENABLE */
    474                          }
    475          #if PRINTF_ADVANCED_ENABLE
    476                          else if (c == '*')
    477                          {
    478                              precision_width       = (uint32_t)va_arg(ap, uint32_t);
    479                              valid_precision_width = true;
    480                          }
    481          #endif /* PRINTF_ADVANCED_ENABLE */
    482                          else
    483                          {
    484                              /* We've gone one char too far. */
    485                              --p;
    486                              done = true;
    487                          }
    488                      }
    489                  }
    490                  else
    491                  {
    492                      /* We've gone one char too far. */
    493                      --p;
    494                  }
    495          #if PRINTF_ADVANCED_ENABLE
    496                  /*
    497                   * Check for the length modifier.
    498                   */
    499                  switch (/* c = */ *++p)
    500                  {
    501                      case 'h':
    502                          if (*++p != 'h')
    503                          {
    504                              flags_used |= kPRINTF_LengthShortInt;
    505                              --p;
    506                          }
    507                          else
    508                          {
    509                              flags_used |= kPRINTF_LengthChar;
    510                          }
    511                          break;
    512                      case 'l':
    513                          if (*++p != 'l')
    514                          {
    515                              flags_used |= kPRINTF_LengthLongInt;
    516                              --p;
    517                          }
    518                          else
    519                          {
    520                              flags_used |= kPRINTF_LengthLongLongInt;
    521                          }
    522                          break;
    523                      default:
    524                          /* we've gone one char too far */
    525                          --p;
    526                          break;
    527                  }
    528          #endif /* PRINTF_ADVANCED_ENABLE */
    529                  /* Now we're ready to examine the format. */
    530                  c = *++p;
    531                  {
    532                      if ((c == 'd') || (c == 'i') || (c == 'f') || (c == 'F') || (c == 'x') || (c == 'X') || (c == 'o') ||
    533                          (c == 'b') || (c == 'p') || (c == 'u'))
    534                      {
    535                          if ((c == 'd') || (c == 'i'))
    536                          {
    537          #if PRINTF_ADVANCED_ENABLE
    538                              if (flags_used & kPRINTF_LengthLongLongInt)
    539                              {
    540                                  ival = (int64_t)va_arg(ap, int64_t);
    541                              }
    542                              else
    543          #endif /* PRINTF_ADVANCED_ENABLE */
    544                              {
    545                                  ival = (int32_t)va_arg(ap, int32_t);
    546                              }
    547                              vlen  = ConvertRadixNumToString(vstr, &ival, true, 10, use_caps);
    548                              vstrp = &vstr[vlen];
    549          #if PRINTF_ADVANCED_ENABLE
    550                              if (ival < 0)
    551                              {
    552                                  schar = '-';
    553                                  ++vlen;
    554                              }
    555                              else
    556                              {
    557                                  if (flags_used & kPRINTF_Plus)
    558                                  {
    559                                      schar = '+';
    560                                      ++vlen;
    561                                  }
    562                                  else
    563                                  {
    564                                      if (flags_used & kPRINTF_Space)
    565                                      {
    566                                          schar = ' ';
    567                                          ++vlen;
    568                                      }
    569                                      else
    570                                      {
    571                                          schar = 0;
    572                                      }
    573                                  }
    574                              }
    575                              dschar = false;
    576                              /* Do the ZERO pad. */
    577                              if (flags_used & kPRINTF_Zero)
    578                              {
    579                                  if (schar)
    580                                  {
    581                                      cb(buf, &count, schar, 1);
    582                                  }
    583                                  dschar = true;
    584          
    585                                  cb(buf, &count, '0', field_width - vlen);
    586                                  vlen = field_width;
    587                              }
    588                              else
    589                              {
    590                                  if (!(flags_used & kPRINTF_Minus))
    591                                  {
    592                                      cb(buf, &count, ' ', field_width - vlen);
    593                                      if (schar)
    594                                      {
    595                                          cb(buf, &count, schar, 1);
    596                                      }
    597                                      dschar = true;
    598                                  }
    599                              }
    600                              /* The string was built in reverse order, now display in correct order. */
    601                              if ((!dschar) && schar)
    602                              {
    603                                  cb(buf, &count, schar, 1);
    604                              }
    605          #endif /* PRINTF_ADVANCED_ENABLE */
    606                          }
    607          
    608          #if PRINTF_FLOAT_ENABLE
    609                          if ((c == 'f') || (c == 'F'))
    610                          {
    611                              fval  = (double)va_arg(ap, double);
    612                              vlen  = ConvertFloatRadixNumToString(vstr, &fval, 10, precision_width);
    613                              vstrp = &vstr[vlen];
    614          
    615          #if PRINTF_ADVANCED_ENABLE
    616                              if (fval < 0)
    617                              {
    618                                  schar = '-';
    619                                  ++vlen;
    620                              }
    621                              else
    622                              {
    623                                  if (flags_used & kPRINTF_Plus)
    624                                  {
    625                                      schar = '+';
    626                                      ++vlen;
    627                                  }
    628                                  else
    629                                  {
    630                                      if (flags_used & kPRINTF_Space)
    631                                      {
    632                                          schar = ' ';
    633                                          ++vlen;
    634                                      }
    635                                      else
    636                                      {
    637                                          schar = 0;
    638                                      }
    639                                  }
    640                              }
    641                              dschar = false;
    642                              if (flags_used & kPRINTF_Zero)
    643                              {
    644                                  if (schar)
    645                                  {
    646                                      cb(buf, &count, schar, 1);
    647                                  }
    648                                  dschar = true;
    649                                  cb(buf, &count, '0', field_width - vlen);
    650                                  vlen = field_width;
    651                              }
    652                              else
    653                              {
    654                                  if (!(flags_used & kPRINTF_Minus))
    655                                  {
    656                                      cb(buf, &count, ' ', field_width - vlen);
    657                                      if (schar)
    658                                      {
    659                                          cb(buf, &count, schar, 1);
    660                                      }
    661                                      dschar = true;
    662                                  }
    663                              }
    664                              if ((!dschar) && schar)
    665                              {
    666                                  cb(buf, &count, schar, 1);
    667                              }
    668          #endif /* PRINTF_ADVANCED_ENABLE */
    669                          }
    670          #endif /* PRINTF_FLOAT_ENABLE */
    671                          if ((c == 'X') || (c == 'x'))
    672                          {
    673                              if (c == 'x')
    674                              {
    675                                  use_caps = false;
    676                              }
    677          #if PRINTF_ADVANCED_ENABLE
    678                              if (flags_used & kPRINTF_LengthLongLongInt)
    679                              {
    680                                  uval = (uint64_t)va_arg(ap, uint64_t);
    681                              }
    682                              else
    683          #endif /* PRINTF_ADVANCED_ENABLE */
    684                              {
    685                                  uval = (uint32_t)va_arg(ap, uint32_t);
    686                              }
    687                              vlen  = ConvertRadixNumToString(vstr, &uval, false, 16, use_caps);
    688                              vstrp = &vstr[vlen];
    689          
    690          #if PRINTF_ADVANCED_ENABLE
    691                              dschar = false;
    692                              if (flags_used & kPRINTF_Zero)
    693                              {
    694                                  if (flags_used & kPRINTF_Pound)
    695                                  {
    696                                      cb(buf, &count, '0', 1);
    697                                      cb(buf, &count, (use_caps ? 'X' : 'x'), 1);
    698                                      dschar = true;
    699                                  }
    700                                  cb(buf, &count, '0', field_width - vlen);
    701                                  vlen = field_width;
    702                              }
    703                              else
    704                              {
    705                                  if (!(flags_used & kPRINTF_Minus))
    706                                  {
    707                                      if (flags_used & kPRINTF_Pound)
    708                                      {
    709                                          vlen += 2;
    710                                      }
    711                                      cb(buf, &count, ' ', field_width - vlen);
    712                                      if (flags_used & kPRINTF_Pound)
    713                                      {
    714                                          cb(buf, &count, '0', 1);
    715                                          cb(buf, &count, (use_caps ? 'X' : 'x'), 1);
    716                                          dschar = true;
    717                                      }
    718                                  }
    719                              }
    720          
    721                              if ((flags_used & kPRINTF_Pound) && (!dschar))
    722                              {
    723                                  cb(buf, &count, '0', 1);
    724                                  cb(buf, &count, (use_caps ? 'X' : 'x'), 1);
    725                                  vlen += 2;
    726                              }
    727          #endif /* PRINTF_ADVANCED_ENABLE */
    728                          }
    729                          if ((c == 'o') || (c == 'b') || (c == 'p') || (c == 'u'))
    730                          {
    731          #if PRINTF_ADVANCED_ENABLE
    732                              if (flags_used & kPRINTF_LengthLongLongInt)
    733                              {
    734                                  uval = (uint64_t)va_arg(ap, uint64_t);
    735                              }
    736                              else
    737          #endif /* PRINTF_ADVANCED_ENABLE */
    738                              {
    739                                  uval = (uint32_t)va_arg(ap, uint32_t);
    740                              }
    741          
    742                              if (c == 'o')
    743                              {
    744                                  radix = 8;
    745                              }
    746                              else if (c == 'b')
    747                              {
    748                                  radix = 2;
    749                              }
    750                              else if (c == 'p')
    751                              {
    752                                  radix = 16;
    753                              }
    754                              else
    755                              {
    756                                  radix = 10;
    757                              }
    758          
    759                              vlen  = ConvertRadixNumToString(vstr, &uval, false, radix, use_caps);
    760                              vstrp = &vstr[vlen];
    761          #if PRINTF_ADVANCED_ENABLE
    762                              if (flags_used & kPRINTF_Zero)
    763                              {
    764                                  cb(buf, &count, '0', field_width - vlen);
    765                                  vlen = field_width;
    766                              }
    767                              else
    768                              {
    769                                  if (!(flags_used & kPRINTF_Minus))
    770                                  {
    771                                      cb(buf, &count, ' ', field_width - vlen);
    772                                  }
    773                              }
    774          #endif /* PRINTF_ADVANCED_ENABLE */
    775                          }
    776          #if !PRINTF_ADVANCED_ENABLE
    777                          cb(buf, &count, ' ', field_width - vlen);
    778          #endif /* !PRINTF_ADVANCED_ENABLE */
    779                          if (vstrp != NULL)
    780                          {
    781                              while (*vstrp)
    782                              {
    783                                  cb(buf, &count, *vstrp--, 1);
    784                              }
    785                          }
    786          #if PRINTF_ADVANCED_ENABLE
    787                          if (flags_used & kPRINTF_Minus)
    788                          {
    789                              cb(buf, &count, ' ', field_width - vlen);
    790                          }
    791          #endif /* PRINTF_ADVANCED_ENABLE */
    792                      }
    793                      else if (c == 'c')
    794                      {
    795                          cval = (char)va_arg(ap, uint32_t);
    796                          cb(buf, &count, cval, 1);
    797                      }
    798                      else if (c == 's')
    799                      {
    800                          sval = (char *)va_arg(ap, char *);
    801                          if (sval)
    802                          {
    803          #if PRINTF_ADVANCED_ENABLE
    804                              if (valid_precision_width)
    805                              {
    806                                  vlen = precision_width;
    807                              }
    808                              else
    809                              {
    810                                  vlen = strlen(sval);
    811                              }
    812          #else
    813                              vlen = strlen(sval);
    814          #endif /* PRINTF_ADVANCED_ENABLE */
    815          #if PRINTF_ADVANCED_ENABLE
    816                              if (!(flags_used & kPRINTF_Minus))
    817          #endif /* PRINTF_ADVANCED_ENABLE */
    818                              {
    819                                  cb(buf, &count, ' ', field_width - vlen);
    820                              }
    821          
    822          #if PRINTF_ADVANCED_ENABLE
    823                              if (valid_precision_width)
    824                              {
    825                                  while ((*sval) && (vlen > 0))
    826                                  {
    827                                      cb(buf, &count, *sval++, 1);
    828                                      vlen--;
    829                                  }
    830                                  /* In case that vlen sval is shorter than vlen */
    831                                  vlen = precision_width - vlen;
    832                              }
    833                              else
    834                              {
    835          #endif /* PRINTF_ADVANCED_ENABLE */
    836                                  while (*sval)
    837                                  {
    838                                      cb(buf, &count, *sval++, 1);
    839                                  }
    840          #if PRINTF_ADVANCED_ENABLE
    841                              }
    842          #endif /* PRINTF_ADVANCED_ENABLE */
    843          
    844          #if PRINTF_ADVANCED_ENABLE
    845                              if (flags_used & kPRINTF_Minus)
    846                              {
    847                                  cb(buf, &count, ' ', field_width - vlen);
    848                              }
    849          #endif /* PRINTF_ADVANCED_ENABLE */
    850                          }
    851                      }
    852                      else
    853                      {
    854                          cb(buf, &count, c, 1);
   \                     ??StrFormatPrintf_1: (+1)
   \       0x1C   0x2301             MOVS     R3,#+1
   \       0x1E   0x464A             MOV      R2,R9
   \       0x20   0xA901             ADD      R1,SP,#+4
   \       0x22   0x9813             LDR      R0,[SP, #+76]
   \       0x24   0x9D14             LDR      R5,[SP, #+80]
   \       0x26   0x47A8             BLX      R5
   \       0x28   0xE271             B.N      ??StrFormatPrintf_2
    855                      }
   \                     ??StrFormatPrintf_3: (+1)
   \       0x2A   0xF047 0x0701      ORR      R7,R7,#0x1
   \                     ??StrFormatPrintf_4: (+1)
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xF040 0x823C      BNE.W    ??StrFormatPrintf_5
   \       0x34   0xF812 0x1F01      LDRB     R1,[R2, #+1]!
   \       0x38   0x2920             CMP      R1,#+32
   \       0x3A   0xD00B             BEQ.N    ??StrFormatPrintf_6
   \       0x3C   0x2923             CMP      R1,#+35
   \       0x3E   0xD00F             BEQ.N    ??StrFormatPrintf_7
   \       0x40   0x292B             CMP      R1,#+43
   \       0x42   0xD004             BEQ.N    ??StrFormatPrintf_8
   \       0x44   0x292D             CMP      R1,#+45
   \       0x46   0xD0F0             BEQ.N    ??StrFormatPrintf_3
   \       0x48   0x2930             CMP      R1,#+48
   \       0x4A   0xD006             BEQ.N    ??StrFormatPrintf_9
   \       0x4C   0xE00B             B.N      ??StrFormatPrintf_10
   \                     ??StrFormatPrintf_8: (+1)
   \       0x4E   0xF047 0x0702      ORR      R7,R7,#0x2
   \       0x52   0xE7EC             B.N      ??StrFormatPrintf_4
   \                     ??StrFormatPrintf_6: (+1)
   \       0x54   0xF047 0x0704      ORR      R7,R7,#0x4
   \       0x58   0xE7E9             B.N      ??StrFormatPrintf_4
   \                     ??StrFormatPrintf_9: (+1)
   \       0x5A   0xF047 0x0708      ORR      R7,R7,#0x8
   \       0x5E   0xE7E6             B.N      ??StrFormatPrintf_4
   \                     ??StrFormatPrintf_7: (+1)
   \       0x60   0xF047 0x0710      ORR      R7,R7,#0x10
   \       0x64   0xE7E3             B.N      ??StrFormatPrintf_4
   \                     ??StrFormatPrintf_10: (+1)
   \       0x66   0x1E52             SUBS     R2,R2,#+1
   \       0x68   0x4640             MOV      R0,R8
   \       0x6A   0xE7E0             B.N      ??StrFormatPrintf_4
   \                     ??StrFormatPrintf_11: (+1)
   \       0x6C   0xEB03 0x0583      ADD      R5,R3,R3, LSL #+2
   \       0x70   0x3930             SUBS     R1,R1,#+48
   \       0x72   0xEB01 0x0145      ADD      R1,R1,R5, LSL #+1
   \       0x76   0x460B             MOV      R3,R1
   \                     ??StrFormatPrintf_12: (+1)
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xF040 0x821A      BNE.W    ??StrFormatPrintf_13
   \       0x7E   0xF812 0x1F01      LDRB     R1,[R2, #+1]!
   \       0x82   0xF1A1 0x0530      SUB      R5,R1,#+48
   \       0x86   0x2D0A             CMP      R5,#+10
   \       0x88   0xD3F0             BCC.N    ??StrFormatPrintf_11
   \       0x8A   0x292A             CMP      R1,#+42
   \       0x8C   0xD102             BNE.N    ??StrFormatPrintf_14
   \       0x8E   0xF856 0x3B04      LDR      R3,[R6], #+4
   \       0x92   0xE7F1             B.N      ??StrFormatPrintf_12
   \                     ??StrFormatPrintf_14: (+1)
   \       0x94   0x1E52             SUBS     R2,R2,#+1
   \       0x96   0x4640             MOV      R0,R8
   \       0x98   0xE7EE             B.N      ??StrFormatPrintf_12
   \                     ??StrFormatPrintf_15: (+1)
   \       0x9A   0xEB03 0x0183      ADD      R1,R3,R3, LSL #+2
   \       0x9E   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \       0xA2   0xEB0C 0x0C41      ADD      R12,R12,R1, LSL #+1
   \       0xA6   0x4663             MOV      R3,R12
   \       0xA8   0x4641             MOV      R1,R8
   \                     ??StrFormatPrintf_16: (+1)
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xF040 0x820F      BNE.W    ??StrFormatPrintf_17
   \       0xB0   0xF812 0xCF01      LDRB     R12,[R2, #+1]!
   \       0xB4   0xF1AC 0x0E30      SUB      LR,R12,#+48
   \       0xB8   0xF1BE 0x0F0A      CMP      LR,#+10
   \       0xBC   0xD3ED             BCC.N    ??StrFormatPrintf_15
   \       0xBE   0xF1BC 0x0F2A      CMP      R12,#+42
   \       0xC2   0xD103             BNE.N    ??StrFormatPrintf_18
   \       0xC4   0xF856 0x3B04      LDR      R3,[R6], #+4
   \       0xC8   0x4641             MOV      R1,R8
   \       0xCA   0xE7EE             B.N      ??StrFormatPrintf_16
   \                     ??StrFormatPrintf_18: (+1)
   \       0xCC   0x1E52             SUBS     R2,R2,#+1
   \       0xCE   0x4640             MOV      R0,R8
   \       0xD0   0xE7EB             B.N      ??StrFormatPrintf_16
   \                     ??StrFormatPrintf_19: (+1)
   \       0xD2   0x1E50             SUBS     R0,R2,#+1
   \       0xD4   0x9002             STR      R0,[SP, #+8]
   \                     ??StrFormatPrintf_20: (+1)
   \       0xD6   0x9802             LDR      R0,[SP, #+8]
   \       0xD8   0x7840             LDRB     R0,[R0, #+1]
   \       0xDA   0x2868             CMP      R0,#+104
   \       0xDC   0xD002             BEQ.N    ??StrFormatPrintf_21
   \       0xDE   0x286C             CMP      R0,#+108
   \       0xE0   0xD00F             BEQ.N    ??StrFormatPrintf_22
   \       0xE2   0xE01C             B.N      ??StrFormatPrintf_23
   \                     ??StrFormatPrintf_21: (+1)
   \       0xE4   0x9802             LDR      R0,[SP, #+8]
   \       0xE6   0x1C80             ADDS     R0,R0,#+2
   \       0xE8   0x9002             STR      R0,[SP, #+8]
   \       0xEA   0x7800             LDRB     R0,[R0, #+0]
   \       0xEC   0x2868             CMP      R0,#+104
   \       0xEE   0xD005             BEQ.N    ??StrFormatPrintf_24
   \       0xF0   0xF047 0x0740      ORR      R7,R7,#0x40
   \       0xF4   0x9802             LDR      R0,[SP, #+8]
   \       0xF6   0x1E40             SUBS     R0,R0,#+1
   \       0xF8   0x9002             STR      R0,[SP, #+8]
   \       0xFA   0xE010             B.N      ??StrFormatPrintf_23
   \                     ??StrFormatPrintf_24: (+1)
   \       0xFC   0xF047 0x0720      ORR      R7,R7,#0x20
   \      0x100   0xE00D             B.N      ??StrFormatPrintf_23
   \                     ??StrFormatPrintf_22: (+1)
   \      0x102   0x9802             LDR      R0,[SP, #+8]
   \      0x104   0x1C80             ADDS     R0,R0,#+2
   \      0x106   0x9002             STR      R0,[SP, #+8]
   \      0x108   0x7800             LDRB     R0,[R0, #+0]
   \      0x10A   0x286C             CMP      R0,#+108
   \      0x10C   0xD005             BEQ.N    ??StrFormatPrintf_25
   \      0x10E   0xF047 0x0780      ORR      R7,R7,#0x80
   \      0x112   0x9802             LDR      R0,[SP, #+8]
   \      0x114   0x1E40             SUBS     R0,R0,#+1
   \      0x116   0x9002             STR      R0,[SP, #+8]
   \      0x118   0xE001             B.N      ??StrFormatPrintf_23
   \                     ??StrFormatPrintf_25: (+1)
   \      0x11A   0xF447 0x7780      ORR      R7,R7,#0x100
   \                     ??StrFormatPrintf_23: (+1)
   \      0x11E   0x9802             LDR      R0,[SP, #+8]
   \      0x120   0x1C40             ADDS     R0,R0,#+1
   \      0x122   0x9002             STR      R0,[SP, #+8]
   \      0x124   0xF890 0x9000      LDRB     R9,[R0, #+0]
   \      0x128   0xF1B9 0x0F64      CMP      R9,#+100
   \      0x12C   0xD01B             BEQ.N    ??StrFormatPrintf_26
   \      0x12E   0xF1B9 0x0F69      CMP      R9,#+105
   \      0x132   0xD018             BEQ.N    ??StrFormatPrintf_26
   \      0x134   0xF1B9 0x0F66      CMP      R9,#+102
   \      0x138   0xD015             BEQ.N    ??StrFormatPrintf_26
   \      0x13A   0xF1B9 0x0F46      CMP      R9,#+70
   \      0x13E   0xD012             BEQ.N    ??StrFormatPrintf_26
   \      0x140   0xF1B9 0x0F78      CMP      R9,#+120
   \      0x144   0xD00F             BEQ.N    ??StrFormatPrintf_26
   \      0x146   0xF1B9 0x0F58      CMP      R9,#+88
   \      0x14A   0xD00C             BEQ.N    ??StrFormatPrintf_26
   \      0x14C   0xF1B9 0x0F6F      CMP      R9,#+111
   \      0x150   0xD009             BEQ.N    ??StrFormatPrintf_26
   \      0x152   0xF1B9 0x0F62      CMP      R9,#+98
   \      0x156   0xD006             BEQ.N    ??StrFormatPrintf_26
   \      0x158   0xF1B9 0x0F70      CMP      R9,#+112
   \      0x15C   0xD003             BEQ.N    ??StrFormatPrintf_26
   \      0x15E   0xF1B9 0x0F75      CMP      R9,#+117
   \      0x162   0xF040 0x8157      BNE.W    ??StrFormatPrintf_27
   \                     ??StrFormatPrintf_26: (+1)
   \      0x166   0xF1B9 0x0F64      CMP      R9,#+100
   \      0x16A   0xD002             BEQ.N    ??StrFormatPrintf_28
   \      0x16C   0xF1B9 0x0F69      CMP      R9,#+105
   \      0x170   0xD16B             BNE.N    ??StrFormatPrintf_29
   \                     ??StrFormatPrintf_28: (+1)
   \      0x172   0x05F8             LSLS     R0,R7,#+23
   \      0x174   0xD507             BPL.N    ??StrFormatPrintf_30
   \      0x176   0x1DF6             ADDS     R6,R6,#+7
   \      0x178   0xF026 0x0607      BIC      R6,R6,#0x7
   \      0x17C   0xE8F6 0x0102      LDRD     R0,R1,[R6], #+8
   \      0x180   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
   \      0x184   0xE004             B.N      ??StrFormatPrintf_31
   \                     ??StrFormatPrintf_30: (+1)
   \      0x186   0xF856 0x0B04      LDR      R0,[R6], #+4
   \      0x18A   0x17C1             ASRS     R1,R0,#+31
   \      0x18C   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
   \                     ??StrFormatPrintf_31: (+1)
   \      0x190   0x4640             MOV      R0,R8
   \      0x192   0x9000             STR      R0,[SP, #+0]
   \      0x194   0x230A             MOVS     R3,#+10
   \      0x196   0x4602             MOV      R2,R0
   \      0x198   0xA906             ADD      R1,SP,#+24
   \      0x19A   0xA809             ADD      R0,SP,#+36
   \      0x19C   0x....'....        BL       ConvertRadixNumToString
   \      0x1A0   0x4604             MOV      R4,R0
   \      0x1A2   0xA809             ADD      R0,SP,#+36
   \      0x1A4   0x4420             ADD      R0,R0,R4
   \      0x1A6   0x9000             STR      R0,[SP, #+0]
   \      0x1A8   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \      0x1AC   0x2900             CMP      R1,#+0
   \      0x1AE   0xD503             BPL.N    ??StrFormatPrintf_32
   \      0x1B0   0xF04F 0x0A2D      MOV      R10,#+45
   \      0x1B4   0x1C64             ADDS     R4,R4,#+1
   \      0x1B6   0xE00D             B.N      ??StrFormatPrintf_33
   \                     ??StrFormatPrintf_32: (+1)
   \      0x1B8   0x07B8             LSLS     R0,R7,#+30
   \      0x1BA   0xD503             BPL.N    ??StrFormatPrintf_34
   \      0x1BC   0xF04F 0x0A2B      MOV      R10,#+43
   \      0x1C0   0x1C64             ADDS     R4,R4,#+1
   \      0x1C2   0xE007             B.N      ??StrFormatPrintf_33
   \                     ??StrFormatPrintf_34: (+1)
   \      0x1C4   0x0778             LSLS     R0,R7,#+29
   \      0x1C6   0xD503             BPL.N    ??StrFormatPrintf_35
   \      0x1C8   0xF04F 0x0A20      MOV      R10,#+32
   \      0x1CC   0x1C64             ADDS     R4,R4,#+1
   \      0x1CE   0xE001             B.N      ??StrFormatPrintf_33
   \                     ??StrFormatPrintf_35: (+1)
   \      0x1D0   0xF04F 0x0A00      MOV      R10,#+0
   \                     ??StrFormatPrintf_33: (+1)
   \      0x1D4   0xF04F 0x0B00      MOV      R11,#+0
   \      0x1D8   0x0738             LSLS     R0,R7,#+28
   \      0x1DA   0xD514             BPL.N    ??StrFormatPrintf_36
   \      0x1DC   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x1E0   0xD007             BEQ.N    ??StrFormatPrintf_37
   \      0x1E2   0x4643             MOV      R3,R8
   \      0x1E4   0x4650             MOV      R0,R10
   \      0x1E6   0x4602             MOV      R2,R0
   \      0x1E8   0xA901             ADD      R1,SP,#+4
   \      0x1EA   0x9813             LDR      R0,[SP, #+76]
   \      0x1EC   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x1F0   0x47E0             BLX      R12
   \                     ??StrFormatPrintf_37: (+1)
   \      0x1F2   0x46C3             MOV      R11,R8
   \      0x1F4   0x1B2C             SUBS     R4,R5,R4
   \      0x1F6   0x4623             MOV      R3,R4
   \      0x1F8   0x2230             MOVS     R2,#+48
   \      0x1FA   0xA901             ADD      R1,SP,#+4
   \      0x1FC   0x9813             LDR      R0,[SP, #+76]
   \      0x1FE   0x9C14             LDR      R4,[SP, #+80]
   \      0x200   0x47A0             BLX      R4
   \      0x202   0x462C             MOV      R4,R5
   \      0x204   0xE014             B.N      ??StrFormatPrintf_38
   \                     ??StrFormatPrintf_36: (+1)
   \      0x206   0x07F8             LSLS     R0,R7,#+31
   \      0x208   0xD412             BMI.N    ??StrFormatPrintf_38
   \      0x20A   0x1B2B             SUBS     R3,R5,R4
   \      0x20C   0x2220             MOVS     R2,#+32
   \      0x20E   0xA901             ADD      R1,SP,#+4
   \      0x210   0x9813             LDR      R0,[SP, #+76]
   \      0x212   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x216   0x47E0             BLX      R12
   \      0x218   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x21C   0xD007             BEQ.N    ??StrFormatPrintf_39
   \      0x21E   0x4643             MOV      R3,R8
   \      0x220   0x4650             MOV      R0,R10
   \      0x222   0x4602             MOV      R2,R0
   \      0x224   0xA901             ADD      R1,SP,#+4
   \      0x226   0x9813             LDR      R0,[SP, #+76]
   \      0x228   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x22C   0x47E0             BLX      R12
   \                     ??StrFormatPrintf_39: (+1)
   \      0x22E   0x46C3             MOV      R11,R8
   \                     ??StrFormatPrintf_38: (+1)
   \      0x230   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x234   0xD109             BNE.N    ??StrFormatPrintf_29
   \      0x236   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x23A   0xD006             BEQ.N    ??StrFormatPrintf_29
   \      0x23C   0x4643             MOV      R3,R8
   \      0x23E   0x4652             MOV      R2,R10
   \      0x240   0xA901             ADD      R1,SP,#+4
   \      0x242   0x9813             LDR      R0,[SP, #+76]
   \      0x244   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x248   0x47E0             BLX      R12
   \                     ??StrFormatPrintf_29: (+1)
   \      0x24A   0xF1B9 0x0F58      CMP      R9,#+88
   \      0x24E   0xD003             BEQ.N    ??StrFormatPrintf_40
   \      0x250   0xF1B9 0x0F78      CMP      R9,#+120
   \      0x254   0xF040 0x8080      BNE.W    ??StrFormatPrintf_41
   \                     ??StrFormatPrintf_40: (+1)
   \      0x258   0xF1B9 0x0F78      CMP      R9,#+120
   \      0x25C   0xD101             BNE.N    ??StrFormatPrintf_42
   \      0x25E   0x2000             MOVS     R0,#+0
   \      0x260   0x4680             MOV      R8,R0
   \                     ??StrFormatPrintf_42: (+1)
   \      0x262   0x05F8             LSLS     R0,R7,#+23
   \      0x264   0xD507             BPL.N    ??StrFormatPrintf_43
   \      0x266   0x1DF6             ADDS     R6,R6,#+7
   \      0x268   0xF026 0x0607      BIC      R6,R6,#0x7
   \      0x26C   0xE8F6 0x0102      LDRD     R0,R1,[R6], #+8
   \      0x270   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
   \      0x274   0xE004             B.N      ??StrFormatPrintf_44
   \                     ??StrFormatPrintf_43: (+1)
   \      0x276   0xF856 0x0B04      LDR      R0,[R6], #+4
   \      0x27A   0x2100             MOVS     R1,#+0
   \      0x27C   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
   \                     ??StrFormatPrintf_44: (+1)
   \      0x280   0x4640             MOV      R0,R8
   \      0x282   0x9000             STR      R0,[SP, #+0]
   \      0x284   0x2310             MOVS     R3,#+16
   \      0x286   0x2200             MOVS     R2,#+0
   \      0x288   0xA904             ADD      R1,SP,#+16
   \      0x28A   0xA809             ADD      R0,SP,#+36
   \      0x28C   0x....'....        BL       ConvertRadixNumToString
   \      0x290   0x4604             MOV      R4,R0
   \      0x292   0xA809             ADD      R0,SP,#+36
   \      0x294   0x4420             ADD      R0,R0,R4
   \      0x296   0x9000             STR      R0,[SP, #+0]
   \      0x298   0xF04F 0x0A00      MOV      R10,#+0
   \      0x29C   0x0738             LSLS     R0,R7,#+28
   \      0x29E   0xD51F             BPL.N    ??StrFormatPrintf_45
   \      0x2A0   0x06F8             LSLS     R0,R7,#+27
   \      0x2A2   0xD514             BPL.N    ??StrFormatPrintf_46
   \      0x2A4   0x2301             MOVS     R3,#+1
   \      0x2A6   0x2230             MOVS     R2,#+48
   \      0x2A8   0xA901             ADD      R1,SP,#+4
   \      0x2AA   0x9813             LDR      R0,[SP, #+76]
   \      0x2AC   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x2B0   0x47E0             BLX      R12
   \      0x2B2   0x4640             MOV      R0,R8
   \      0x2B4   0x2800             CMP      R0,#+0
   \      0x2B6   0xD001             BEQ.N    ??StrFormatPrintf_47
   \      0x2B8   0x2258             MOVS     R2,#+88
   \      0x2BA   0xE000             B.N      ??StrFormatPrintf_48
   \                     ??StrFormatPrintf_47: (+1)
   \      0x2BC   0x2278             MOVS     R2,#+120
   \                     ??StrFormatPrintf_48: (+1)
   \      0x2BE   0x2301             MOVS     R3,#+1
   \      0x2C0   0xA901             ADD      R1,SP,#+4
   \      0x2C2   0x9813             LDR      R0,[SP, #+76]
   \      0x2C4   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x2C8   0x47E0             BLX      R12
   \      0x2CA   0xF04F 0x0A01      MOV      R10,#+1
   \                     ??StrFormatPrintf_46: (+1)
   \      0x2CE   0x1B2C             SUBS     R4,R5,R4
   \      0x2D0   0x4623             MOV      R3,R4
   \      0x2D2   0x2230             MOVS     R2,#+48
   \      0x2D4   0xA901             ADD      R1,SP,#+4
   \      0x2D6   0x9813             LDR      R0,[SP, #+76]
   \      0x2D8   0x9C14             LDR      R4,[SP, #+80]
   \      0x2DA   0x47A0             BLX      R4
   \      0x2DC   0x462C             MOV      R4,R5
   \      0x2DE   0xE022             B.N      ??StrFormatPrintf_49
   \                     ??StrFormatPrintf_45: (+1)
   \      0x2E0   0x07F8             LSLS     R0,R7,#+31
   \      0x2E2   0xD420             BMI.N    ??StrFormatPrintf_49
   \      0x2E4   0x06F8             LSLS     R0,R7,#+27
   \      0x2E6   0xD500             BPL.N    ??StrFormatPrintf_50
   \      0x2E8   0x1CA4             ADDS     R4,R4,#+2
   \                     ??StrFormatPrintf_50: (+1)
   \      0x2EA   0x1B2B             SUBS     R3,R5,R4
   \      0x2EC   0x2220             MOVS     R2,#+32
   \      0x2EE   0xA901             ADD      R1,SP,#+4
   \      0x2F0   0x9813             LDR      R0,[SP, #+76]
   \      0x2F2   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x2F6   0x47E0             BLX      R12
   \      0x2F8   0x06F8             LSLS     R0,R7,#+27
   \      0x2FA   0xD514             BPL.N    ??StrFormatPrintf_49
   \      0x2FC   0x2301             MOVS     R3,#+1
   \      0x2FE   0x2230             MOVS     R2,#+48
   \      0x300   0xA901             ADD      R1,SP,#+4
   \      0x302   0x9813             LDR      R0,[SP, #+76]
   \      0x304   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x308   0x47E0             BLX      R12
   \      0x30A   0x4640             MOV      R0,R8
   \      0x30C   0x2800             CMP      R0,#+0
   \      0x30E   0xD001             BEQ.N    ??StrFormatPrintf_51
   \      0x310   0x2258             MOVS     R2,#+88
   \      0x312   0xE000             B.N      ??StrFormatPrintf_52
   \                     ??StrFormatPrintf_51: (+1)
   \      0x314   0x2278             MOVS     R2,#+120
   \                     ??StrFormatPrintf_52: (+1)
   \      0x316   0x2301             MOVS     R3,#+1
   \      0x318   0xA901             ADD      R1,SP,#+4
   \      0x31A   0x9813             LDR      R0,[SP, #+76]
   \      0x31C   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x320   0x47E0             BLX      R12
   \      0x322   0xF04F 0x0A01      MOV      R10,#+1
   \                     ??StrFormatPrintf_49: (+1)
   \      0x326   0x06F8             LSLS     R0,R7,#+27
   \      0x328   0xD516             BPL.N    ??StrFormatPrintf_41
   \      0x32A   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x32E   0xD113             BNE.N    ??StrFormatPrintf_41
   \      0x330   0x2301             MOVS     R3,#+1
   \      0x332   0x2230             MOVS     R2,#+48
   \      0x334   0xA901             ADD      R1,SP,#+4
   \      0x336   0x9813             LDR      R0,[SP, #+76]
   \      0x338   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x33C   0x47E0             BLX      R12
   \      0x33E   0x4640             MOV      R0,R8
   \      0x340   0x2800             CMP      R0,#+0
   \      0x342   0xD001             BEQ.N    ??StrFormatPrintf_53
   \      0x344   0x2258             MOVS     R2,#+88
   \      0x346   0xE000             B.N      ??StrFormatPrintf_54
   \                     ??StrFormatPrintf_53: (+1)
   \      0x348   0x2278             MOVS     R2,#+120
   \                     ??StrFormatPrintf_54: (+1)
   \      0x34A   0x2301             MOVS     R3,#+1
   \      0x34C   0xA901             ADD      R1,SP,#+4
   \      0x34E   0x9813             LDR      R0,[SP, #+76]
   \      0x350   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x354   0x47E0             BLX      R12
   \      0x356   0x1CA4             ADDS     R4,R4,#+2
   \                     ??StrFormatPrintf_41: (+1)
   \      0x358   0xF1B9 0x0F6F      CMP      R9,#+111
   \      0x35C   0xD008             BEQ.N    ??StrFormatPrintf_55
   \      0x35E   0xF1B9 0x0F62      CMP      R9,#+98
   \      0x362   0xD005             BEQ.N    ??StrFormatPrintf_55
   \      0x364   0xF1B9 0x0F70      CMP      R9,#+112
   \      0x368   0xD002             BEQ.N    ??StrFormatPrintf_55
   \      0x36A   0xF1B9 0x0F75      CMP      R9,#+117
   \      0x36E   0xD13D             BNE.N    ??StrFormatPrintf_56
   \                     ??StrFormatPrintf_55: (+1)
   \      0x370   0x05F8             LSLS     R0,R7,#+23
   \      0x372   0xD507             BPL.N    ??StrFormatPrintf_57
   \      0x374   0x1DF6             ADDS     R6,R6,#+7
   \      0x376   0xF026 0x0607      BIC      R6,R6,#0x7
   \      0x37A   0xE8F6 0x0102      LDRD     R0,R1,[R6], #+8
   \      0x37E   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
   \      0x382   0xE004             B.N      ??StrFormatPrintf_58
   \                     ??StrFormatPrintf_57: (+1)
   \      0x384   0xF856 0x0B04      LDR      R0,[R6], #+4
   \      0x388   0x2100             MOVS     R1,#+0
   \      0x38A   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
   \                     ??StrFormatPrintf_58: (+1)
   \      0x38E   0xF1B9 0x0F6F      CMP      R9,#+111
   \      0x392   0xD101             BNE.N    ??StrFormatPrintf_59
   \      0x394   0x2308             MOVS     R3,#+8
   \      0x396   0xE00A             B.N      ??StrFormatPrintf_60
   \                     ??StrFormatPrintf_59: (+1)
   \      0x398   0xF1B9 0x0F62      CMP      R9,#+98
   \      0x39C   0xD101             BNE.N    ??StrFormatPrintf_61
   \      0x39E   0x2302             MOVS     R3,#+2
   \      0x3A0   0xE005             B.N      ??StrFormatPrintf_60
   \                     ??StrFormatPrintf_61: (+1)
   \      0x3A2   0xF1B9 0x0F70      CMP      R9,#+112
   \      0x3A6   0xD101             BNE.N    ??StrFormatPrintf_62
   \      0x3A8   0x2310             MOVS     R3,#+16
   \      0x3AA   0xE000             B.N      ??StrFormatPrintf_60
   \                     ??StrFormatPrintf_62: (+1)
   \      0x3AC   0x230A             MOVS     R3,#+10
   \                     ??StrFormatPrintf_60: (+1)
   \      0x3AE   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x3B2   0x2200             MOVS     R2,#+0
   \      0x3B4   0xA904             ADD      R1,SP,#+16
   \      0x3B6   0xA809             ADD      R0,SP,#+36
   \      0x3B8   0x....'....        BL       ConvertRadixNumToString
   \      0x3BC   0x4604             MOV      R4,R0
   \      0x3BE   0xA809             ADD      R0,SP,#+36
   \      0x3C0   0x4420             ADD      R0,R0,R4
   \      0x3C2   0x9000             STR      R0,[SP, #+0]
   \      0x3C4   0x0738             LSLS     R0,R7,#+28
   \      0x3C6   0xD508             BPL.N    ??StrFormatPrintf_63
   \      0x3C8   0x1B2C             SUBS     R4,R5,R4
   \      0x3CA   0x4623             MOV      R3,R4
   \      0x3CC   0x2230             MOVS     R2,#+48
   \      0x3CE   0xA901             ADD      R1,SP,#+4
   \      0x3D0   0x9813             LDR      R0,[SP, #+76]
   \      0x3D2   0x9C14             LDR      R4,[SP, #+80]
   \      0x3D4   0x47A0             BLX      R4
   \      0x3D6   0x462C             MOV      R4,R5
   \      0x3D8   0xE008             B.N      ??StrFormatPrintf_56
   \                     ??StrFormatPrintf_63: (+1)
   \      0x3DA   0x07F8             LSLS     R0,R7,#+31
   \      0x3DC   0xD406             BMI.N    ??StrFormatPrintf_56
   \      0x3DE   0x1B2B             SUBS     R3,R5,R4
   \      0x3E0   0x2220             MOVS     R2,#+32
   \      0x3E2   0xA901             ADD      R1,SP,#+4
   \      0x3E4   0x9813             LDR      R0,[SP, #+76]
   \      0x3E6   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x3EA   0x47E0             BLX      R12
   \                     ??StrFormatPrintf_56: (+1)
   \      0x3EC   0x9800             LDR      R0,[SP, #+0]
   \      0x3EE   0x2800             CMP      R0,#+0
   \      0x3F0   0xF000 0x8084      BEQ.W    ??StrFormatPrintf_64
   \      0x3F4   0xF8DD 0x904C      LDR      R9,[SP, #+76]
   \      0x3F8   0xF8DD 0xA050      LDR      R10,[SP, #+80]
   \      0x3FC   0x4683             MOV      R11,R0
   \                     ??StrFormatPrintf_65: (+1)
   \      0x3FE   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \      0x402   0x2800             CMP      R0,#+0
   \      0x404   0xD067             BEQ.N    ??StrFormatPrintf_66
   \      0x406   0x2301             MOVS     R3,#+1
   \      0x408   0xF81B 0x2901      LDRB     R2,[R11], #-1
   \      0x40C   0xA901             ADD      R1,SP,#+4
   \      0x40E   0x4648             MOV      R0,R9
   \      0x410   0x47D0             BLX      R10
   \      0x412   0xE7F4             B.N      ??StrFormatPrintf_65
   \                     ??StrFormatPrintf_27: (+1)
   \      0x414   0xF1B9 0x0F63      CMP      R9,#+99
   \      0x418   0xD109             BNE.N    ??StrFormatPrintf_67
   \      0x41A   0xF856 0x0B04      LDR      R0,[R6], #+4
   \      0x41E   0xB2C0             UXTB     R0,R0
   \      0x420   0x4643             MOV      R3,R8
   \      0x422   0x4602             MOV      R2,R0
   \      0x424   0xA901             ADD      R1,SP,#+4
   \      0x426   0x9813             LDR      R0,[SP, #+76]
   \      0x428   0x9F14             LDR      R7,[SP, #+80]
   \      0x42A   0x47B8             BLX      R7
   \      0x42C   0xE06F             B.N      ??StrFormatPrintf_2
   \                     ??StrFormatPrintf_67: (+1)
   \      0x42E   0xF1B9 0x0F73      CMP      R9,#+115
   \      0x432   0xF47F 0xADF3      BNE.W    ??StrFormatPrintf_1
   \      0x436   0xF856 0x0B04      LDR      R0,[R6], #+4
   \      0x43A   0x9003             STR      R0,[SP, #+12]
   \      0x43C   0x2800             CMP      R0,#+0
   \      0x43E   0xD066             BEQ.N    ??StrFormatPrintf_2
   \      0x440   0x4650             MOV      R0,R10
   \      0x442   0x2800             CMP      R0,#+0
   \      0x444   0xD001             BEQ.N    ??StrFormatPrintf_68
   \      0x446   0x9C08             LDR      R4,[SP, #+32]
   \      0x448   0xE003             B.N      ??StrFormatPrintf_69
   \                     ??StrFormatPrintf_68: (+1)
   \      0x44A   0x9803             LDR      R0,[SP, #+12]
   \      0x44C   0x....'....        BL       strlen
   \      0x450   0x4604             MOV      R4,R0
   \                     ??StrFormatPrintf_69: (+1)
   \      0x452   0x07F8             LSLS     R0,R7,#+31
   \      0x454   0xD406             BMI.N    ??StrFormatPrintf_70
   \      0x456   0x1B2B             SUBS     R3,R5,R4
   \      0x458   0x2220             MOVS     R2,#+32
   \      0x45A   0xA901             ADD      R1,SP,#+4
   \      0x45C   0x9813             LDR      R0,[SP, #+76]
   \      0x45E   0xF8DD 0xC050      LDR      R12,[SP, #+80]
   \      0x462   0x47E0             BLX      R12
   \                     ??StrFormatPrintf_70: (+1)
   \      0x464   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x468   0xF8DD 0x904C      LDR      R9,[SP, #+76]
   \      0x46C   0xF8DD 0xA050      LDR      R10,[SP, #+80]
   \      0x470   0xD138             BNE.N    ??StrFormatPrintf_71
   \      0x472   0xF8DD 0x800C      LDR      R8,[SP, #+12]
   \      0x476   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \                     ??StrFormatPrintf_72: (+1)
   \      0x47A   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x47E   0x2800             CMP      R0,#+0
   \      0x480   0xD029             BEQ.N    ??StrFormatPrintf_66
   \      0x482   0x2301             MOVS     R3,#+1
   \      0x484   0xF818 0x2B01      LDRB     R2,[R8], #+1
   \      0x488   0xA901             ADD      R1,SP,#+4
   \      0x48A   0x4648             MOV      R0,R9
   \      0x48C   0x47D0             BLX      R10
   \      0x48E   0xE7F4             B.N      ??StrFormatPrintf_72
   \                     ??StrFormatPrintf_73: (+1)
   \      0x490   0x2C01             CMP      R4,#+1
   \      0x492   0xDB2D             BLT.N    ??StrFormatPrintf_74
   \      0x494   0x4643             MOV      R3,R8
   \      0x496   0xF81B 0x2B01      LDRB     R2,[R11], #+1
   \      0x49A   0xA901             ADD      R1,SP,#+4
   \      0x49C   0x4648             MOV      R0,R9
   \      0x49E   0x47D0             BLX      R10
   \      0x4A0   0x1E64             SUBS     R4,R4,#+1
   \      0x4A2   0xE021             B.N      ??StrFormatPrintf_75
    856                  }
    857              }
    858          
    859              return count;
   \                     ??StrFormatPrintf_76: (+1)
   \      0x4A4   0x9801             LDR      R0,[SP, #+4]
   \      0x4A6   0xB015             ADD      SP,SP,#+84
   \      0x4A8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??StrFormatPrintf_5: (+1)
   \      0x4AC   0x2300             MOVS     R3,#+0
   \      0x4AE   0x4618             MOV      R0,R3
   \      0x4B0   0xE5E2             B.N      ??StrFormatPrintf_12
   \                     ??StrFormatPrintf_13: (+1)
   \      0x4B2   0x461D             MOV      R5,R3
   \      0x4B4   0x2006             MOVS     R0,#+6
   \      0x4B6   0x9008             STR      R0,[SP, #+32]
   \      0x4B8   0xF04F 0x0A00      MOV      R10,#+0
   \      0x4BC   0xF812 0x0F01      LDRB     R0,[R2, #+1]!
   \      0x4C0   0x282E             CMP      R0,#+46
   \      0x4C2   0xF47F 0xAE06      BNE.W    ??StrFormatPrintf_19
   \      0x4C6   0x4653             MOV      R3,R10
   \      0x4C8   0x4618             MOV      R0,R3
   \      0x4CA   0x4651             MOV      R1,R10
   \      0x4CC   0xE5ED             B.N      ??StrFormatPrintf_16
   \                     ??StrFormatPrintf_17: (+1)
   \      0x4CE   0x9202             STR      R2,[SP, #+8]
   \      0x4D0   0x9308             STR      R3,[SP, #+32]
   \      0x4D2   0x468A             MOV      R10,R1
   \      0x4D4   0xE5FF             B.N      ??StrFormatPrintf_20
   \                     ??StrFormatPrintf_66: (+1)
   \      0x4D6   0xF8CD 0x904C      STR      R9,[SP, #+76]
   \      0x4DA   0xF8CD 0xA050      STR      R10,[SP, #+80]
   \      0x4DE   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \      0x4E2   0xE00B             B.N      ??StrFormatPrintf_64
   \                     ??StrFormatPrintf_71: (+1)
   \      0x4E4   0xF8DD 0xB00C      LDR      R11,[SP, #+12]
   \                     ??StrFormatPrintf_75: (+1)
   \      0x4E8   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \      0x4EC   0x2800             CMP      R0,#+0
   \      0x4EE   0xD1CF             BNE.N    ??StrFormatPrintf_73
   \                     ??StrFormatPrintf_74: (+1)
   \      0x4F0   0xF8CD 0x904C      STR      R9,[SP, #+76]
   \      0x4F4   0xF8CD 0xA050      STR      R10,[SP, #+80]
   \      0x4F8   0x9808             LDR      R0,[SP, #+32]
   \      0x4FA   0x1B04             SUBS     R4,R0,R4
   \                     ??StrFormatPrintf_64: (+1)
   \      0x4FC   0x07F8             LSLS     R0,R7,#+31
   \      0x4FE   0xD506             BPL.N    ??StrFormatPrintf_2
   \      0x500   0x1B2D             SUBS     R5,R5,R4
   \      0x502   0x462B             MOV      R3,R5
   \      0x504   0x2220             MOVS     R2,#+32
   \      0x506   0xA901             ADD      R1,SP,#+4
   \      0x508   0x9813             LDR      R0,[SP, #+76]
   \      0x50A   0x9D14             LDR      R5,[SP, #+80]
   \      0x50C   0x47A8             BLX      R5
   \                     ??StrFormatPrintf_2: (+1)
   \      0x50E   0x9802             LDR      R0,[SP, #+8]
   \      0x510   0x1C40             ADDS     R0,R0,#+1
   \      0x512   0x9002             STR      R0,[SP, #+8]
   \                     ??StrFormatPrintf_0: (+1)
   \      0x514   0x9802             LDR      R0,[SP, #+8]
   \      0x516   0xF890 0x9000      LDRB     R9,[R0, #+0]
   \      0x51A   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x51E   0xD0C1             BEQ.N    ??StrFormatPrintf_76
   \      0x520   0xF1B9 0x0F25      CMP      R9,#+37
   \      0x524   0xF47F 0xAD7A      BNE.W    ??StrFormatPrintf_1
   \      0x528   0x2001             MOVS     R0,#+1
   \      0x52A   0x4680             MOV      R8,R0
   \      0x52C   0x2700             MOVS     R7,#+0
   \      0x52E   0x4638             MOV      R0,R7
   \      0x530   0x9A02             LDR      R2,[SP, #+8]
   \      0x532   0xE57C             B.N      ??StrFormatPrintf_4
    860          }
    861          
    862          /*!
    863           * brief Converts an input line of ASCII characters based upon a provided
    864           * string format.
    865           *
    866           * param[in] line_ptr The input line of ASCII data.
    867           * param[in] format   Format first points to the format string.
    868           * param[in] args_ptr The list of parameters.
    869           *
    870           * return Number of input items converted and assigned.
    871           * retval IO_EOF When line_ptr is empty string "".
    872           */

   \                                 In section .text, align 2, keep-with-next
    873          int StrFormatScanf(const char *line_ptr, char *format, va_list args_ptr)
    874          {
   \                     StrFormatScanf: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4615             MOV      R5,R2
    875              uint8_t base;
    876              int8_t neg;
    877              /* Identifier for the format string. */
    878              char *c = format;
   \        0x6   0x9101             STR      R1,[SP, #+4]
    879              char temp;
    880              char *buf;
    881              /* Flag telling the conversion specification. */
    882              uint32_t flag = 0;
    883              /* Filed width for the matching input streams. */
    884              uint32_t field_width;
    885              /* How many arguments are assigned except the suppress. */
    886              uint32_t nassigned = 0;
   \        0x8   0x2600             MOVS     R6,#+0
    887              /* How many characters are read from the input streams. */
    888              uint32_t n_decode = 0;
    889          
    890              int32_t val;
    891          
    892              const char *s;
    893              /* Identifier for the input string. */
    894              const char *p = line_ptr;
   \        0xA   0x9000             STR      R0,[SP, #+0]
    895          
    896          #if SCANF_FLOAT_ENABLE
    897              double fnum = 0.0;
    898          #endif /* SCANF_FLOAT_ENABLE */
    899              /* Return EOF error before any conversion. */
    900              if (*p == '\0')
   \        0xC   0x7800             LDRB     R0,[R0, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD105             BNE.N    ??StrFormatScanf_0
    901              {
    902                  return -1;
   \       0x12   0xF04F 0x30FF      MOV      R0,#-1
   \       0x16   0xE164             B.N      ??StrFormatScanf_1
    903              }
    904          
    905              /* Decode directives. */
    906              while ((*c) && (*p))
    907              {
    908                  /* Ignore all white-spaces in the format strings. */
    909                  if (ScanIgnoreWhiteSpace((const char **)&c))
    910                  {
    911                      n_decode += ScanIgnoreWhiteSpace(&p);
   \                     ??StrFormatScanf_2: (+1)
   \       0x18   0x4668             MOV      R0,SP
   \       0x1A   0x....'....        BL       ScanIgnoreWhiteSpace
    912                  }
   \                     ??StrFormatScanf_0: (+1)
   \       0x1E   0x9801             LDR      R0,[SP, #+4]
   \       0x20   0x7800             LDRB     R0,[R0, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xF000 0x815C      BEQ.W    ??StrFormatScanf_3
   \       0x28   0x9800             LDR      R0,[SP, #+0]
   \       0x2A   0x7800             LDRB     R0,[R0, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xF000 0x8157      BEQ.W    ??StrFormatScanf_3
   \       0x32   0xA801             ADD      R0,SP,#+4
   \       0x34   0x....'....        BL       ScanIgnoreWhiteSpace
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD1ED             BNE.N    ??StrFormatScanf_2
    913                  else if ((*c != '%') || ((*c == '%') && (*(c + 1) == '%')))
   \       0x3C   0x9801             LDR      R0,[SP, #+4]
   \       0x3E   0x7800             LDRB     R0,[R0, #+0]
   \       0x40   0x2825             CMP      R0,#+37
   \       0x42   0xD104             BNE.N    ??StrFormatScanf_4
   \       0x44   0xD114             BNE.N    ??StrFormatScanf_5
   \       0x46   0x9801             LDR      R0,[SP, #+4]
   \       0x48   0x7840             LDRB     R0,[R0, #+1]
   \       0x4A   0x2825             CMP      R0,#+37
   \       0x4C   0xD110             BNE.N    ??StrFormatScanf_5
    914                  {
    915                      /* Ordinary characters. */
    916                      c++;
   \                     ??StrFormatScanf_4: (+1)
   \       0x4E   0x9801             LDR      R0,[SP, #+4]
   \       0x50   0x1C40             ADDS     R0,R0,#+1
   \       0x52   0x9001             STR      R0,[SP, #+4]
    917                      if (*p == *c)
   \       0x54   0x9800             LDR      R0,[SP, #+0]
   \       0x56   0x7800             LDRB     R0,[R0, #+0]
   \       0x58   0x9901             LDR      R1,[SP, #+4]
   \       0x5A   0x7809             LDRB     R1,[R1, #+0]
   \       0x5C   0x4288             CMP      R0,R1
   \       0x5E   0xF040 0x813F      BNE.W    ??StrFormatScanf_3
    918                      {
    919                          n_decode++;
    920                          p++;
   \       0x62   0x9800             LDR      R0,[SP, #+0]
   \       0x64   0x1C40             ADDS     R0,R0,#+1
   \       0x66   0x9000             STR      R0,[SP, #+0]
    921                          c++;
   \       0x68   0x9801             LDR      R0,[SP, #+4]
   \       0x6A   0x1C40             ADDS     R0,R0,#+1
   \       0x6C   0x9001             STR      R0,[SP, #+4]
   \       0x6E   0xE7D6             B.N      ??StrFormatScanf_0
    922                      }
    923                      else
    924                      {
    925                          /* Match failure. Misalignment with C99, the unmatched characters need to be pushed back to stream.
    926                           * However, it is deserted now. */
    927                          break;
    928                      }
    929                  }
    930                  else
    931                  {
    932                      /* convernsion specification */
    933                      c++;
   \                     ??StrFormatScanf_5: (+1)
   \       0x70   0x9801             LDR      R0,[SP, #+4]
   \       0x72   0x1C40             ADDS     R0,R0,#+1
   \       0x74   0x9001             STR      R0,[SP, #+4]
    934                      /* Reset. */
    935                      flag        = 0;
   \       0x76   0x2700             MOVS     R7,#+0
    936                      field_width = 0;
   \       0x78   0x463C             MOV      R4,R7
    937                      base        = 0;
   \       0x7A   0x46A0             MOV      R8,R4
   \       0x7C   0xE008             B.N      ??StrFormatScanf_6
    938          
    939                      /* Loop to get full conversion specification. */
    940                      while ((*c) && (!(flag & kSCANF_DestMask)))
    941                      {
    942                          switch (*c)
    943                          {
    944          #if SCANF_ADVANCED_ENABLE
    945                              case '*':
    946                                  if (flag & kSCANF_Suppress)
    947                                  {
    948                                      /* Match failure. */
    949                                      return nassigned;
    950                                  }
    951                                  flag |= kSCANF_Suppress;
    952                                  c++;
    953                                  break;
    954                              case 'h':
    955                                  if (flag & kSCANF_LengthMask)
    956                                  {
    957                                      /* Match failure. */
    958                                      return nassigned;
    959                                  }
    960          
    961                                  if (c[1] == 'h')
    962                                  {
    963                                      flag |= kSCANF_LengthChar;
    964                                      c++;
    965                                  }
    966                                  else
    967                                  {
    968                                      flag |= kSCANF_LengthShortInt;
    969                                  }
    970                                  c++;
    971                                  break;
    972                              case 'l':
    973                                  if (flag & kSCANF_LengthMask)
    974                                  {
    975                                      /* Match failure. */
    976                                      return nassigned;
    977                                  }
    978          
    979                                  if (c[1] == 'l')
    980                                  {
    981                                      flag |= kSCANF_LengthLongLongInt;
    982                                      c++;
    983                                  }
    984                                  else
    985                                  {
    986                                      flag |= kSCANF_LengthLongInt;
    987                                  }
    988                                  c++;
    989                                  break;
    990          #endif /* SCANF_ADVANCED_ENABLE */
    991          #if SCANF_FLOAT_ENABLE
    992                              case 'L':
    993                                  if (flag & kSCANF_LengthMask)
    994                                  {
    995                                      /* Match failure. */
    996                                      return nassigned;
    997                                  }
    998                                  flag |= kSCANF_LengthLongLongDouble;
    999                                  c++;
   1000                                  break;
   1001          #endif /* SCANF_FLOAT_ENABLE */
   1002                              case '0':
   1003                              case '1':
   1004                              case '2':
   1005                              case '3':
   1006                              case '4':
   1007                              case '5':
   1008                              case '6':
   1009                              case '7':
   1010                              case '8':
   1011                              case '9':
   1012                                  if (field_width)
   1013                                  {
   1014                                      /* Match failure. */
   1015                                      return nassigned;
   1016                                  }
   1017                                  do
   1018                                  {
   1019                                      field_width = field_width * 10 + *c - '0';
   1020                                      c++;
   1021                                  } while ((*c >= '0') && (*c <= '9'));
   1022                                  break;
   1023                              case 'd':
   1024                                  base = 10;
   \                     ??StrFormatScanf_7: (+1)
   \       0x7E   0xF04F 0x080A      MOV      R8,#+10
   1025                                  flag |= kSCANF_TypeSinged;
   1026                                  flag |= kSCANF_DestInt;
   \       0x82   0xF447 0x5700      ORR      R7,R7,#0x2000
   \       0x86   0xF047 0x0720      ORR      R7,R7,#0x20
   1027                                  c++;
   \       0x8A   0x9801             LDR      R0,[SP, #+4]
   \       0x8C   0x1C40             ADDS     R0,R0,#+1
   \       0x8E   0x9001             STR      R0,[SP, #+4]
   1028                                  break;
   \                     ??StrFormatScanf_6: (+1)
   \       0x90   0x9801             LDR      R0,[SP, #+4]
   \       0x92   0x7800             LDRB     R0,[R0, #+0]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD059             BEQ.N    ??StrFormatScanf_8
   \       0x98   0xF017 0x0F7C      TST      R7,#0x7C
   \       0x9C   0xD156             BNE.N    ??StrFormatScanf_8
   \       0x9E   0x9801             LDR      R0,[SP, #+4]
   \       0xA0   0x7800             LDRB     R0,[R0, #+0]
   \       0xA2   0x3830             SUBS     R0,R0,#+48
   \       0xA4   0x2809             CMP      R0,#+9
   \       0xA6   0xD910             BLS.N    ??StrFormatScanf_9
   \       0xA8   0x3828             SUBS     R0,R0,#+40
   \       0xAA   0xD030             BEQ.N    ??StrFormatScanf_10
   \       0xAC   0x380B             SUBS     R0,R0,#+11
   \       0xAE   0xD03E             BEQ.N    ??StrFormatScanf_11
   \       0xB0   0x1E40             SUBS     R0,R0,#+1
   \       0xB2   0xD0E4             BEQ.N    ??StrFormatScanf_7
   \       0xB4   0x1F40             SUBS     R0,R0,#+5
   \       0xB6   0xD032             BEQ.N    ??StrFormatScanf_12
   \       0xB8   0x1F80             SUBS     R0,R0,#+6
   \       0xBA   0xD020             BEQ.N    ??StrFormatScanf_13
   \       0xBC   0x1F00             SUBS     R0,R0,#+4
   \       0xBE   0xD03F             BEQ.N    ??StrFormatScanf_14
   \       0xC0   0x1E80             SUBS     R0,R0,#+2
   \       0xC2   0xD014             BEQ.N    ??StrFormatScanf_15
   \       0xC4   0x1EC0             SUBS     R0,R0,#+3
   \       0xC6   0xD022             BEQ.N    ??StrFormatScanf_10
   \       0xC8   0xE10A             B.N      ??StrFormatScanf_3
   \                     ??StrFormatScanf_9: (+1)
   \       0xCA   0x2C00             CMP      R4,#+0
   \       0xCC   0xF040 0x8108      BNE.W    ??StrFormatScanf_3
   \                     ??StrFormatScanf_16: (+1)
   \       0xD0   0xEB04 0x0084      ADD      R0,R4,R4, LSL #+2
   \       0xD4   0x9901             LDR      R1,[SP, #+4]
   \       0xD6   0x780C             LDRB     R4,[R1, #+0]
   \       0xD8   0xEB04 0x0440      ADD      R4,R4,R0, LSL #+1
   \       0xDC   0x3C30             SUBS     R4,R4,#+48
   \       0xDE   0x4608             MOV      R0,R1
   \       0xE0   0x1C40             ADDS     R0,R0,#+1
   \       0xE2   0x9001             STR      R0,[SP, #+4]
   \       0xE4   0x7800             LDRB     R0,[R0, #+0]
   \       0xE6   0x3830             SUBS     R0,R0,#+48
   \       0xE8   0x280A             CMP      R0,#+10
   \       0xEA   0xD3F1             BCC.N    ??StrFormatScanf_16
   \       0xEC   0xE7D0             B.N      ??StrFormatScanf_6
   1029                              case 'u':
   1030                                  base = 10;
   \                     ??StrFormatScanf_15: (+1)
   \       0xEE   0xF04F 0x080A      MOV      R8,#+10
   1031                                  flag |= kSCANF_DestInt;
   \       0xF2   0xF047 0x0720      ORR      R7,R7,#0x20
   1032                                  c++;
   \       0xF6   0x9801             LDR      R0,[SP, #+4]
   \       0xF8   0x1C40             ADDS     R0,R0,#+1
   \       0xFA   0x9001             STR      R0,[SP, #+4]
   1033                                  break;
   \       0xFC   0xE7C8             B.N      ??StrFormatScanf_6
   1034                              case 'o':
   1035                                  base = 8;
   \                     ??StrFormatScanf_13: (+1)
   \       0xFE   0xF04F 0x0808      MOV      R8,#+8
   1036                                  flag |= kSCANF_DestInt;
   \      0x102   0xF047 0x0720      ORR      R7,R7,#0x20
   1037                                  c++;
   \      0x106   0x9801             LDR      R0,[SP, #+4]
   \      0x108   0x1C40             ADDS     R0,R0,#+1
   \      0x10A   0x9001             STR      R0,[SP, #+4]
   1038                                  break;
   \      0x10C   0xE7C0             B.N      ??StrFormatScanf_6
   1039                              case 'x':
   1040                              case 'X':
   1041                                  base = 16;
   \                     ??StrFormatScanf_10: (+1)
   \      0x10E   0xF04F 0x0810      MOV      R8,#+16
   1042                                  flag |= kSCANF_DestInt;
   \      0x112   0xF047 0x0720      ORR      R7,R7,#0x20
   1043                                  c++;
   \      0x116   0x9801             LDR      R0,[SP, #+4]
   \      0x118   0x1C40             ADDS     R0,R0,#+1
   \      0x11A   0x9001             STR      R0,[SP, #+4]
   1044                                  break;
   \      0x11C   0xE7B8             B.N      ??StrFormatScanf_6
   1045                              case 'i':
   1046                                  base = 0;
   \                     ??StrFormatScanf_12: (+1)
   \      0x11E   0xF04F 0x0800      MOV      R8,#+0
   1047                                  flag |= kSCANF_DestInt;
   \      0x122   0xF047 0x0720      ORR      R7,R7,#0x20
   1048                                  c++;
   \      0x126   0x9801             LDR      R0,[SP, #+4]
   \      0x128   0x1C40             ADDS     R0,R0,#+1
   \      0x12A   0x9001             STR      R0,[SP, #+4]
   1049                                  break;
   \      0x12C   0xE7B0             B.N      ??StrFormatScanf_6
   1050          #if SCANF_FLOAT_ENABLE
   1051                              case 'a':
   1052                              case 'A':
   1053                              case 'e':
   1054                              case 'E':
   1055                              case 'f':
   1056                              case 'F':
   1057                              case 'g':
   1058                              case 'G':
   1059                                  flag |= kSCANF_DestFloat;
   1060                                  c++;
   1061                                  break;
   1062          #endif /* SCANF_FLOAT_ENABLE */
   1063                              case 'c':
   1064                                  flag |= kSCANF_DestChar;
   \                     ??StrFormatScanf_11: (+1)
   \      0x12E   0xF047 0x0704      ORR      R7,R7,#0x4
   1065                                  if (!field_width)
   \      0x132   0x2C00             CMP      R4,#+0
   \      0x134   0xD100             BNE.N    ??StrFormatScanf_17
   1066                                  {
   1067                                      field_width = 1;
   \      0x136   0x2401             MOVS     R4,#+1
   1068                                  }
   1069                                  c++;
   \                     ??StrFormatScanf_17: (+1)
   \      0x138   0x9801             LDR      R0,[SP, #+4]
   \      0x13A   0x1C40             ADDS     R0,R0,#+1
   \      0x13C   0x9001             STR      R0,[SP, #+4]
   1070                                  break;
   \      0x13E   0xE7A7             B.N      ??StrFormatScanf_6
   1071                              case 's':
   1072                                  flag |= kSCANF_DestString;
   \                     ??StrFormatScanf_14: (+1)
   \      0x140   0xF047 0x0708      ORR      R7,R7,#0x8
   1073                                  c++;
   \      0x144   0x9801             LDR      R0,[SP, #+4]
   \      0x146   0x1C40             ADDS     R0,R0,#+1
   \      0x148   0x9001             STR      R0,[SP, #+4]
   1074                                  break;
   \      0x14A   0xE7A1             B.N      ??StrFormatScanf_6
   1075                              default:
   1076                                  return nassigned;
   1077                          }
   1078                      }
   1079          
   1080                      if (!(flag & kSCANF_DestMask))
   \                     ??StrFormatScanf_8: (+1)
   \      0x14C   0xF017 0x0F7C      TST      R7,#0x7C
   \      0x150   0xF000 0x80C6      BEQ.W    ??StrFormatScanf_3
   1081                      {
   1082                          /* Format strings are exhausted. */
   1083                          return nassigned;
   1084                      }
   1085          
   1086                      if (!field_width)
   \      0x154   0x2C00             CMP      R4,#+0
   \      0x156   0xD100             BNE.N    ??StrFormatScanf_18
   1087                      {
   1088                          /* Large than length of a line. */
   1089                          field_width = 99;
   \      0x158   0x2463             MOVS     R4,#+99
   1090                      }
   1091          
   1092                      /* Matching strings in input streams and assign to argument. */
   1093                      switch (flag & kSCANF_DestMask)
   \                     ??StrFormatScanf_18: (+1)
   \      0x15A   0xF007 0x007C      AND      R0,R7,#0x7C
   \      0x15E   0x2804             CMP      R0,#+4
   \      0x160   0xD004             BEQ.N    ??StrFormatScanf_19
   \      0x162   0x2808             CMP      R0,#+8
   \      0x164   0xD01C             BEQ.N    ??StrFormatScanf_20
   \      0x166   0x2820             CMP      R0,#+32
   \      0x168   0xD054             BEQ.N    ??StrFormatScanf_21
   \      0x16A   0xE0B9             B.N      ??StrFormatScanf_3
   1094                      {
   1095                          case kSCANF_DestChar:
   1096                              s   = (const char *)p;
   \                     ??StrFormatScanf_19: (+1)
   \      0x16C   0x9900             LDR      R1,[SP, #+0]
   1097                              buf = va_arg(args_ptr, char *);
   \      0x16E   0xF855 0x2B04      LDR      R2,[R5], #+4
   \      0x172   0xE005             B.N      ??StrFormatScanf_22
   1098                              while ((field_width--) && (*p))
   1099                              {
   1100                                  if (!(flag & kSCANF_Suppress))
   1101                                  {
   1102                                      *buf++ = *p++;
   \                     ??StrFormatScanf_23: (+1)
   \      0x174   0x7800             LDRB     R0,[R0, #+0]
   \      0x176   0xF802 0x0B01      STRB     R0,[R2], #+1
   \      0x17A   0x9800             LDR      R0,[SP, #+0]
   \      0x17C   0x1C40             ADDS     R0,R0,#+1
   \      0x17E   0x9000             STR      R0,[SP, #+0]
   1103                                  }
   \                     ??StrFormatScanf_22: (+1)
   \      0x180   0x4620             MOV      R0,R4
   \      0x182   0x1E44             SUBS     R4,R0,#+1
   \      0x184   0x2800             CMP      R0,#+0
   \      0x186   0xF000 0x80AE      BEQ.W    ??StrFormatScanf_24
   \      0x18A   0x9800             LDR      R0,[SP, #+0]
   \      0x18C   0x7800             LDRB     R0,[R0, #+0]
   \      0x18E   0x2800             CMP      R0,#+0
   \      0x190   0xF000 0x80A9      BEQ.W    ??StrFormatScanf_24
   \      0x194   0x07B8             LSLS     R0,R7,#+30
   \      0x196   0x9800             LDR      R0,[SP, #+0]
   \      0x198   0xD5EC             BPL.N    ??StrFormatScanf_23
   1104                                  else
   1105                                  {
   1106                                      p++;
   \      0x19A   0x1C40             ADDS     R0,R0,#+1
   \      0x19C   0x9000             STR      R0,[SP, #+0]
   \      0x19E   0xE7EF             B.N      ??StrFormatScanf_22
   1107                                  }
   1108                                  n_decode++;
   1109                              }
   1110          
   1111                              if ((!(flag & kSCANF_Suppress)) && (s != p))
   1112                              {
   1113                                  nassigned++;
   1114                              }
   1115                              break;
   1116                          case kSCANF_DestString:
   1117                              n_decode += ScanIgnoreWhiteSpace(&p);
   \                     ??StrFormatScanf_20: (+1)
   \      0x1A0   0x4668             MOV      R0,SP
   \      0x1A2   0x....'....        BL       ScanIgnoreWhiteSpace
   1118                              s   = p;
   \      0x1A6   0x9900             LDR      R1,[SP, #+0]
   1119                              buf = va_arg(args_ptr, char *);
   \      0x1A8   0xF855 0x2B04      LDR      R2,[R5], #+4
   \      0x1AC   0xE001             B.N      ??StrFormatScanf_25
   1120                              while ((field_width--) && (*p != '\0') && (*p != ' ') && (*p != '\t') && (*p != '\n') &&
   1121                                     (*p != '\r') && (*p != '\v') && (*p != '\f'))
   1122                              {
   1123                                  if (flag & kSCANF_Suppress)
   1124                                  {
   1125                                      p++;
   \                     ??StrFormatScanf_26: (+1)
   \      0x1AE   0x1C40             ADDS     R0,R0,#+1
   \      0x1B0   0x9000             STR      R0,[SP, #+0]
   1126                                  }
   \                     ??StrFormatScanf_25: (+1)
   \      0x1B2   0x4620             MOV      R0,R4
   \      0x1B4   0x1E44             SUBS     R4,R0,#+1
   \      0x1B6   0x2800             CMP      R0,#+0
   \      0x1B8   0xF000 0x809E      BEQ.W    ??StrFormatScanf_27
   \      0x1BC   0x9800             LDR      R0,[SP, #+0]
   \      0x1BE   0x7800             LDRB     R0,[R0, #+0]
   \      0x1C0   0x2800             CMP      R0,#+0
   \      0x1C2   0xF000 0x8099      BEQ.W    ??StrFormatScanf_27
   \      0x1C6   0x9800             LDR      R0,[SP, #+0]
   \      0x1C8   0x7800             LDRB     R0,[R0, #+0]
   \      0x1CA   0x2820             CMP      R0,#+32
   \      0x1CC   0xF000 0x8094      BEQ.W    ??StrFormatScanf_27
   \      0x1D0   0x9800             LDR      R0,[SP, #+0]
   \      0x1D2   0x7800             LDRB     R0,[R0, #+0]
   \      0x1D4   0x2809             CMP      R0,#+9
   \      0x1D6   0xF000 0x808F      BEQ.W    ??StrFormatScanf_27
   \      0x1DA   0x9800             LDR      R0,[SP, #+0]
   \      0x1DC   0x7800             LDRB     R0,[R0, #+0]
   \      0x1DE   0x280A             CMP      R0,#+10
   \      0x1E0   0xF000 0x808A      BEQ.W    ??StrFormatScanf_27
   \      0x1E4   0x9800             LDR      R0,[SP, #+0]
   \      0x1E6   0x7800             LDRB     R0,[R0, #+0]
   \      0x1E8   0x280D             CMP      R0,#+13
   \      0x1EA   0xF000 0x8085      BEQ.W    ??StrFormatScanf_27
   \      0x1EE   0x9800             LDR      R0,[SP, #+0]
   \      0x1F0   0x7800             LDRB     R0,[R0, #+0]
   \      0x1F2   0x280B             CMP      R0,#+11
   \      0x1F4   0xF000 0x8080      BEQ.W    ??StrFormatScanf_27
   \      0x1F8   0x9800             LDR      R0,[SP, #+0]
   \      0x1FA   0x7800             LDRB     R0,[R0, #+0]
   \      0x1FC   0x280C             CMP      R0,#+12
   \      0x1FE   0xD07B             BEQ.N    ??StrFormatScanf_27
   \      0x200   0x07B8             LSLS     R0,R7,#+30
   \      0x202   0x9800             LDR      R0,[SP, #+0]
   \      0x204   0xD4D3             BMI.N    ??StrFormatScanf_26
   1127                                  else
   1128                                  {
   1129                                      *buf++ = *p++;
   \      0x206   0x7800             LDRB     R0,[R0, #+0]
   \      0x208   0xF802 0x0B01      STRB     R0,[R2], #+1
   \      0x20C   0x9800             LDR      R0,[SP, #+0]
   \      0x20E   0x1C40             ADDS     R0,R0,#+1
   \      0x210   0x9000             STR      R0,[SP, #+0]
   \      0x212   0xE7CE             B.N      ??StrFormatScanf_25
   1130                                  }
   1131                                  n_decode++;
   1132                              }
   1133          
   1134                              if ((!(flag & kSCANF_Suppress)) && (s != p))
   1135                              {
   1136                                  /* Add NULL to end of string. */
   1137                                  *buf = '\0';
   1138                                  nassigned++;
   1139                              }
   1140                              break;
   1141                          case kSCANF_DestInt:
   1142                              n_decode += ScanIgnoreWhiteSpace(&p);
   \                     ??StrFormatScanf_21: (+1)
   \      0x214   0x4668             MOV      R0,SP
   \      0x216   0x....'....        BL       ScanIgnoreWhiteSpace
   1143                              s   = p;
   \      0x21A   0x9800             LDR      R0,[SP, #+0]
   1144                              val = 0;
   \      0x21C   0x2100             MOVS     R1,#+0
   1145                              if ((base == 0) || (base == 16))
   \      0x21E   0x4642             MOV      R2,R8
   \      0x220   0x2A00             CMP      R2,#+0
   \      0x222   0xD001             BEQ.N    ??StrFormatScanf_28
   \      0x224   0x2A10             CMP      R2,#+16
   \      0x226   0xD10F             BNE.N    ??StrFormatScanf_29
   1146                              {
   1147                                  if ((s[0] == '0') && ((s[1] == 'x') || (s[1] == 'X')))
   \                     ??StrFormatScanf_28: (+1)
   \      0x228   0x7802             LDRB     R2,[R0, #+0]
   \      0x22A   0x2A30             CMP      R2,#+48
   \      0x22C   0xD10C             BNE.N    ??StrFormatScanf_29
   \      0x22E   0x7842             LDRB     R2,[R0, #+1]
   \      0x230   0x2A78             CMP      R2,#+120
   \      0x232   0xD001             BEQ.N    ??StrFormatScanf_30
   \      0x234   0x2A58             CMP      R2,#+88
   \      0x236   0xD107             BNE.N    ??StrFormatScanf_29
   1148                                  {
   1149                                      base = 16;
   \                     ??StrFormatScanf_30: (+1)
   \      0x238   0xF04F 0x0810      MOV      R8,#+16
   1150                                      if (field_width >= 1)
   \      0x23C   0x2C00             CMP      R4,#+0
   \      0x23E   0xD003             BEQ.N    ??StrFormatScanf_29
   1151                                      {
   1152                                          p += 2;
   \      0x240   0x4602             MOV      R2,R0
   \      0x242   0x1C92             ADDS     R2,R2,#+2
   \      0x244   0x9200             STR      R2,[SP, #+0]
   1153                                          n_decode += 2;
   1154                                          field_width -= 2;
   \      0x246   0x1EA4             SUBS     R4,R4,#+2
   1155                                      }
   1156                                  }
   1157                              }
   1158          
   1159                              if (base == 0)
   \                     ??StrFormatScanf_29: (+1)
   \      0x248   0x4642             MOV      R2,R8
   \      0x24A   0x2A00             CMP      R2,#+0
   \      0x24C   0xD107             BNE.N    ??StrFormatScanf_31
   1160                              {
   1161                                  if (s[0] == '0')
   \      0x24E   0x7800             LDRB     R0,[R0, #+0]
   \      0x250   0x2830             CMP      R0,#+48
   \      0x252   0xD102             BNE.N    ??StrFormatScanf_32
   1162                                  {
   1163                                      base = 8;
   \      0x254   0xF04F 0x0808      MOV      R8,#+8
   \      0x258   0xE001             B.N      ??StrFormatScanf_31
   1164                                  }
   1165                                  else
   1166                                  {
   1167                                      base = 10;
   \                     ??StrFormatScanf_32: (+1)
   \      0x25A   0xF04F 0x080A      MOV      R8,#+10
   1168                                  }
   1169                              }
   1170          
   1171                              neg = 1;
   \                     ??StrFormatScanf_31: (+1)
   \      0x25E   0x2201             MOVS     R2,#+1
   1172                              switch (*p)
   \      0x260   0x9800             LDR      R0,[SP, #+0]
   \      0x262   0x7800             LDRB     R0,[R0, #+0]
   \      0x264   0x282B             CMP      R0,#+43
   \      0x266   0xD008             BEQ.N    ??StrFormatScanf_33
   \      0x268   0x282D             CMP      R0,#+45
   \      0x26A   0xD118             BNE.N    ??StrFormatScanf_34
   1173                              {
   1174                                  case '-':
   1175                                      neg = -1;
   \      0x26C   0xF04F 0x32FF      MOV      R2,#-1
   1176                                      n_decode++;
   1177                                      p++;
   \      0x270   0x9800             LDR      R0,[SP, #+0]
   \      0x272   0x1C40             ADDS     R0,R0,#+1
   \      0x274   0x9000             STR      R0,[SP, #+0]
   1178                                      field_width--;
   \      0x276   0x1E64             SUBS     R4,R4,#+1
   1179                                      break;
   \      0x278   0xE011             B.N      ??StrFormatScanf_34
   1180                                  case '+':
   1181                                      neg = 1;
   1182                                      n_decode++;
   1183                                      p++;
   \                     ??StrFormatScanf_33: (+1)
   \      0x27A   0x9800             LDR      R0,[SP, #+0]
   \      0x27C   0x1C40             ADDS     R0,R0,#+1
   \      0x27E   0x9000             STR      R0,[SP, #+0]
   1184                                      field_width--;
   \      0x280   0x1E64             SUBS     R4,R4,#+1
   1185                                      break;
   \      0x282   0xE00C             B.N      ??StrFormatScanf_34
   1186                                  default:
   1187                                      break;
   1188                              }
   1189          
   1190                              while ((*p) && (field_width--))
   1191                              {
   1192                                  if ((*p <= '9') && (*p >= '0'))
   1193                                  {
   1194                                      temp = *p - '0';
   1195                                  }
   1196                                  else if ((*p <= 'f') && (*p >= 'a'))
   1197                                  {
   1198                                      temp = *p - 'a' + 10;
   1199                                  }
   1200                                  else if ((*p <= 'F') && (*p >= 'A'))
   1201                                  {
   1202                                      temp = *p - 'A' + 10;
   1203                                  }
   1204                                  else
   1205                                  {
   1206                                      temp = base;
   \                     ??StrFormatScanf_35: (+1)
   \      0x284   0x4640             MOV      R0,R8
   1207                                  }
   1208          
   1209                                  if (temp >= base)
   \                     ??StrFormatScanf_36: (+1)
   \      0x286   0x4603             MOV      R3,R0
   \      0x288   0x46C4             MOV      R12,R8
   \      0x28A   0xB2DB             UXTB     R3,R3
   \      0x28C   0x4563             CMP      R3,R12
   \      0x28E   0xD23E             BCS.N    ??StrFormatScanf_37
   1210                                  {
   1211                                      break;
   1212                                  }
   1213                                  else
   1214                                  {
   1215                                      val = base * val + temp;
   \      0x290   0x4643             MOV      R3,R8
   \      0x292   0xB2C0             UXTB     R0,R0
   \      0x294   0xFB03 0x0101      MLA      R1,R3,R1,R0
   1216                                  }
   1217                                  p++;
   \      0x298   0x9800             LDR      R0,[SP, #+0]
   \      0x29A   0x1C40             ADDS     R0,R0,#+1
   \      0x29C   0x9000             STR      R0,[SP, #+0]
   1218                                  n_decode++;
   \                     ??StrFormatScanf_34: (+1)
   \      0x29E   0x9800             LDR      R0,[SP, #+0]
   \      0x2A0   0x7800             LDRB     R0,[R0, #+0]
   \      0x2A2   0x2800             CMP      R0,#+0
   \      0x2A4   0xD033             BEQ.N    ??StrFormatScanf_37
   \      0x2A6   0x4620             MOV      R0,R4
   \      0x2A8   0x1E44             SUBS     R4,R0,#+1
   \      0x2AA   0x2800             CMP      R0,#+0
   \      0x2AC   0xD02F             BEQ.N    ??StrFormatScanf_37
   \      0x2AE   0x9800             LDR      R0,[SP, #+0]
   \      0x2B0   0x7800             LDRB     R0,[R0, #+0]
   \      0x2B2   0x3830             SUBS     R0,R0,#+48
   \      0x2B4   0x280A             CMP      R0,#+10
   \      0x2B6   0x9800             LDR      R0,[SP, #+0]
   \      0x2B8   0x7800             LDRB     R0,[R0, #+0]
   \      0x2BA   0xD201             BCS.N    ??StrFormatScanf_38
   \      0x2BC   0x3830             SUBS     R0,R0,#+48
   \      0x2BE   0xE7E2             B.N      ??StrFormatScanf_36
   \                     ??StrFormatScanf_38: (+1)
   \      0x2C0   0x3861             SUBS     R0,R0,#+97
   \      0x2C2   0x2806             CMP      R0,#+6
   \      0x2C4   0x9800             LDR      R0,[SP, #+0]
   \      0x2C6   0x7800             LDRB     R0,[R0, #+0]
   \      0x2C8   0xD201             BCS.N    ??StrFormatScanf_39
   \      0x2CA   0x3857             SUBS     R0,R0,#+87
   \      0x2CC   0xE7DB             B.N      ??StrFormatScanf_36
   \                     ??StrFormatScanf_39: (+1)
   \      0x2CE   0x3841             SUBS     R0,R0,#+65
   \      0x2D0   0x2806             CMP      R0,#+6
   \      0x2D2   0xD2D7             BCS.N    ??StrFormatScanf_35
   \      0x2D4   0x9800             LDR      R0,[SP, #+0]
   \      0x2D6   0x7800             LDRB     R0,[R0, #+0]
   \      0x2D8   0x3837             SUBS     R0,R0,#+55
   \      0x2DA   0xE7D4             B.N      ??StrFormatScanf_36
   1219                              }
   1220                              val *= neg;
   1221                              if (!(flag & kSCANF_Suppress))
   1222                              {
   1223          #if SCANF_ADVANCED_ENABLE
   1224                                  switch (flag & kSCANF_LengthMask)
   1225                                  {
   1226                                      case kSCANF_LengthChar:
   1227                                          if (flag & kSCANF_TypeSinged)
   1228                                          {
   1229                                              *va_arg(args_ptr, signed char *) = (signed char)val;
   1230                                          }
   1231                                          else
   1232                                          {
   1233                                              *va_arg(args_ptr, unsigned char *) = (unsigned char)val;
   1234                                          }
   1235                                          break;
   1236                                      case kSCANF_LengthShortInt:
   1237                                          if (flag & kSCANF_TypeSinged)
   1238                                          {
   1239                                              *va_arg(args_ptr, signed short *) = (signed short)val;
   1240                                          }
   1241                                          else
   1242                                          {
   1243                                              *va_arg(args_ptr, unsigned short *) = (unsigned short)val;
   1244                                          }
   1245                                          break;
   1246                                      case kSCANF_LengthLongInt:
   1247                                          if (flag & kSCANF_TypeSinged)
   1248                                          {
   1249                                              *va_arg(args_ptr, signed long int *) = (signed long int)val;
   1250                                          }
   1251                                          else
   1252                                          {
   1253                                              *va_arg(args_ptr, unsigned long int *) = (unsigned long int)val;
   1254                                          }
   1255                                          break;
   1256                                      case kSCANF_LengthLongLongInt:
   1257                                          if (flag & kSCANF_TypeSinged)
   1258                                          {
   1259                                              *va_arg(args_ptr, signed long long int *) = (signed long long int)val;
   1260                                          }
   1261                                          else
   1262                                          {
   1263                                              *va_arg(args_ptr, unsigned long long int *) = (unsigned long long int)val;
   1264                                          }
   1265                                          break;
   1266                                      default:
   1267                                          /* The default type is the type int. */
   1268                                          if (flag & kSCANF_TypeSinged)
   1269                                          {
   1270                                              *va_arg(args_ptr, signed int *) = (signed int)val;
   1271                                          }
   1272                                          else
   1273                                          {
   1274                                              *va_arg(args_ptr, unsigned int *) = (unsigned int)val;
   1275                                          }
   1276                                          break;
   1277                                  }
   1278          #else
   1279                                  /* The default type is the type int. */
   1280                                  if (flag & kSCANF_TypeSinged)
   1281                                  {
   1282                                      *va_arg(args_ptr, signed int *) = (signed int)val;
   1283                                  }
   1284                                  else
   1285                                  {
   1286                                      *va_arg(args_ptr, unsigned int *) = (unsigned int)val;
   1287                                  }
   1288          #endif /* SCANF_ADVANCED_ENABLE */
   1289                                  nassigned++;
   \                     ??StrFormatScanf_40: (+1)
   \      0x2DC   0x1C76             ADDS     R6,R6,#+1
   \      0x2DE   0xE69E             B.N      ??StrFormatScanf_0
   1290                              }
   1291                              break;
   1292          #if SCANF_FLOAT_ENABLE
   1293                          case kSCANF_DestFloat:
   1294                              n_decode += ScanIgnoreWhiteSpace(&p);
   1295                              fnum = strtod(p, (char **)&s);
   1296          
   1297                              if ((fnum >= HUGE_VAL) || (fnum <= -HUGE_VAL))
   1298                              {
   1299                                  break;
   1300                              }
   1301          
   1302                              n_decode += (int)(s) - (int)(p);
   1303                              p = s;
   1304                              if (!(flag & kSCANF_Suppress))
   1305                              {
   1306                                  if (flag & kSCANF_LengthLongLongDouble)
   1307                                  {
   1308                                      *va_arg(args_ptr, double *) = fnum;
   1309                                  }
   1310                                  else
   1311                                  {
   1312                                      *va_arg(args_ptr, float *) = (float)fnum;
   1313                                  }
   1314                                  nassigned++;
   1315                              }
   1316                              break;
   1317          #endif /* SCANF_FLOAT_ENABLE */
   1318                          default:
   1319                              return nassigned;
   1320                      }
   1321                  }
   1322              }
   1323              return nassigned;
   \                     ??StrFormatScanf_3: (+1)
   \      0x2E0   0x4630             MOV      R0,R6
   \                     ??StrFormatScanf_1: (+1)
   \      0x2E2   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   \                     ??StrFormatScanf_24: (+1)
   \      0x2E6   0x07B8             LSLS     R0,R7,#+30
   \      0x2E8   0xF53F 0xAE99      BMI.W    ??StrFormatScanf_0
   \      0x2EC   0x9800             LDR      R0,[SP, #+0]
   \      0x2EE   0x4281             CMP      R1,R0
   \      0x2F0   0xF43F 0xAE95      BEQ.W    ??StrFormatScanf_0
   \      0x2F4   0x1C76             ADDS     R6,R6,#+1
   \      0x2F6   0xE692             B.N      ??StrFormatScanf_0
   \                     ??StrFormatScanf_27: (+1)
   \      0x2F8   0x07B8             LSLS     R0,R7,#+30
   \      0x2FA   0xF53F 0xAE90      BMI.W    ??StrFormatScanf_0
   \      0x2FE   0x9800             LDR      R0,[SP, #+0]
   \      0x300   0x4281             CMP      R1,R0
   \      0x302   0xF43F 0xAE8C      BEQ.W    ??StrFormatScanf_0
   \      0x306   0x2000             MOVS     R0,#+0
   \      0x308   0x7010             STRB     R0,[R2, #+0]
   \      0x30A   0x1C76             ADDS     R6,R6,#+1
   \      0x30C   0xE687             B.N      ??StrFormatScanf_0
   \                     ??StrFormatScanf_37: (+1)
   \      0x30E   0x4351             MULS     R1,R2,R1
   \      0x310   0x07B8             LSLS     R0,R7,#+30
   \      0x312   0xF53F 0xAE84      BMI.W    ??StrFormatScanf_0
   \      0x316   0xF855 0x0B04      LDR      R0,[R5], #+4
   \      0x31A   0x6001             STR      R1,[R0, #+0]
   \      0x31C   0xE7DE             B.N      ??StrFormatScanf_40
   1324          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ConvertRadixNumToString
        32 __aeabi_ldivmod
        32 __aeabi_uldivmod
       0   ScanIgnoreWhiteSpace
     120   StrFormatPrintf
       120   -- Indirect call
       120   -> ConvertRadixNumToString
       120   -> strlen
      32   StrFormatScanf
        32   -> ScanIgnoreWhiteSpace


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     208  ConvertRadixNumToString
      48  ScanIgnoreWhiteSpace
    1332  StrFormatPrintf
     798  StrFormatScanf

 
 2 386 bytes in section .text
 
 2 386 bytes of CODE memory

Errors: none
Warnings: none
