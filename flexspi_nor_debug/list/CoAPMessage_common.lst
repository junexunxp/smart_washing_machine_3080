###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:08
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\CoAPMessage_common.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWAC88.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\CoAPMessage_common.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\CoAPMessage_common.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\CoAPMessage_common.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\CoAPMessage_common.c
      1          /*
      2           * Copyright (C) 2015-2018 Alibaba Group Holding Limited
      3           */
      4          
      5          
      6          
      7          
      8          
      9          #include <stdio.h>
     10          #include "iotx_coap_internal.h"
     11          #include "CoAPSerialize.h"
     12          #include "CoAPDeserialize.h"
     13          #if 0
     14          #include "CoAPResource.h"
     15          #include "CoAPObserve.h"
     16          #include "CoAPInternal.h"
     17          #endif
     18          #include "CoAPPlatform.h"
     19          
     20          #define COAPAckMsg(header) \
     21              ((header.code == COAP_MSG_CODE_EMPTY_MESSAGE) \
     22               &&(header.type == COAP_MESSAGE_TYPE_ACK))
     23          
     24          #define CoAPRespMsg(header)\
     25              ((header.code >= 0x40) && (header.code < 0xc0))
     26          
     27          #define CoAPPingMsg(header)\
     28              ((header.code == COAP_MSG_CODE_EMPTY_MESSAGE)\
     29               && (header.type == COAP_MESSAGE_TYPE_CON))
     30          
     31          #define CoAPResetMsg(header)\
     32              (header.type == COAP_MESSAGE_TYPE_RST)
     33          
     34          #define CoAPCONRespMsg(header)\
     35              ((header.code == COAP_MSG_CODE_205_CONTENT) \
     36               && (header.type == COAP_MESSAGE_TYPE_CON))
     37          
     38          #define CoAPReqMsg(header)\
     39              ((1 <= header.code) && (32 > header.code))
     40          
     41          
     42          #define COAP_CUR_VERSION        1
     43          #define COAP_WAIT_TIME_MS       2000
     44          #define COAP_MAX_MESSAGE_ID     65535
     45          #define COAP_MAX_RETRY_COUNT    4
     46          #define COAP_ACK_TIMEOUT        2
     47          #define COAP_ACK_RANDOM_FACTOR  1
     48          #define COAP_MAX_TRANSMISSION_SPAN   10
     49          

   \                                 In section .text, align 2, keep-with-next
     50          int CoAPStrOption_add(CoAPMessage *message, unsigned short optnum, unsigned char *data, unsigned short datalen)
     51          {
   \                     CoAPStrOption_add: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x4698             MOV      R8,R3
     52              unsigned char *ptr = NULL;
     53              if (COAP_MSG_MAX_OPTION_NUM <= message->optcount) {
   \        0xC   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \       0x10   0x280C             CMP      R0,#+12
   \       0x12   0xDB02             BLT.N    ??CoAPStrOption_add_0
     54                  return COAP_ERROR_INVALID_PARAM;
   \       0x14   0xF240 0x1001      MOVW     R0,#+257
   \       0x18   0xE029             B.N      ??CoAPStrOption_add_1
     55              }
     56          
     57              message->options[message->optcount].num = optnum - message->optdelta;
   \                     ??CoAPStrOption_add_0: (+1)
   \       0x1A   0xEB05 0x00C0      ADD      R0,R5,R0, LSL #+3
   \       0x1E   0xF895 0x106D      LDRB     R1,[R5, #+109]
   \       0x22   0x1A79             SUBS     R1,R7,R1
   \       0x24   0x8181             STRH     R1,[R0, #+12]
     58              message->options[message->optcount].len = datalen;
   \       0x26   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \       0x2A   0xEB05 0x00C0      ADD      R0,R5,R0, LSL #+3
   \       0x2E   0xF8A0 0x800E      STRH     R8,[R0, #+14]
     59              ptr = (unsigned char *)coap_malloc(datalen);
   \       0x32   0x4640             MOV      R0,R8
   \       0x34   0x....'....        BL       HAL_Malloc
   \       0x38   0x0004             MOVS     R4,R0
     60              if (NULL == ptr) {
   \       0x3A   0xD102             BNE.N    ??CoAPStrOption_add_2
     61                  return COAP_ERROR_MALLOC;
   \       0x3C   0xF240 0x1003      MOVW     R0,#+259
   \       0x40   0xE015             B.N      ??CoAPStrOption_add_1
     62              }
     63              memset(ptr, 0x00, datalen);
   \                     ??CoAPStrOption_add_2: (+1)
   \       0x42   0x2200             MOVS     R2,#+0
   \       0x44   0x4641             MOV      R1,R8
   \       0x46   0x....'....        BL       __aeabi_memset
     64              memcpy(ptr, data, datalen);
   \       0x4A   0x4642             MOV      R2,R8
   \       0x4C   0x4631             MOV      R1,R6
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x....'....        BL       __aeabi_memcpy
     65              message->options[message->optcount].val = ptr;
   \       0x54   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \       0x58   0xEB05 0x00C0      ADD      R0,R5,R0, LSL #+3
   \       0x5C   0x6104             STR      R4,[R0, #+16]
     66              message->optdelta = optnum;
   \       0x5E   0xF885 0x706D      STRB     R7,[R5, #+109]
     67              message->optcount ++;
   \       0x62   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \       0x66   0x1C40             ADDS     R0,R0,#+1
   \       0x68   0xF885 0x006C      STRB     R0,[R5, #+108]
     68          
     69              return COAP_SUCCESS;
   \       0x6C   0x2000             MOVS     R0,#+0
   \                     ??CoAPStrOption_add_1: (+1)
   \       0x6E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     70          
     71          }
     72          

   \                                 In section .text, align 2, keep-with-next
     73          int CoAPStrOption_get(CoAPMessage *message, unsigned short optnum, unsigned char *data, unsigned short *datalen)
     74          {
   \                     CoAPStrOption_get: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x4610             MOV      R0,R2
   \        0x6   0x461C             MOV      R4,R3
     75              unsigned char index = 0;
     76          
     77              for (index = 0; index < message->optcount; index++) {
   \        0x8   0x2600             MOVS     R6,#+0
   \        0xA   0x460B             MOV      R3,R1
   \        0xC   0xE001             B.N      ??CoAPStrOption_get_0
   \                     ??CoAPStrOption_get_1: (+1)
   \        0xE   0x1C76             ADDS     R6,R6,#+1
   \       0x10   0xB2F6             UXTB     R6,R6
   \                     ??CoAPStrOption_get_0: (+1)
   \       0x12   0xF895 0x206C      LDRB     R2,[R5, #+108]
   \       0x16   0x4296             CMP      R6,R2
   \       0x18   0xDA18             BGE.N    ??CoAPStrOption_get_2
     78                  if (message->options[index].num == optnum) {
   \       0x1A   0xEB05 0x02C6      ADD      R2,R5,R6, LSL #+3
   \       0x1E   0x8992             LDRH     R2,[R2, #+12]
   \       0x20   0x429A             CMP      R2,R3
   \       0x22   0xD1F4             BNE.N    ??CoAPStrOption_get_1
     79                      if (*datalen >= message->options[index].len) {
   \       0x24   0x8821             LDRH     R1,[R4, #+0]
   \       0x26   0xEB05 0x02C6      ADD      R2,R5,R6, LSL #+3
   \       0x2A   0x89D2             LDRH     R2,[R2, #+14]
   \       0x2C   0x4291             CMP      R1,R2
   \       0x2E   0xD30A             BCC.N    ??CoAPStrOption_get_3
     80                          memcpy(data, message->options[index].val, message->options[index].len);
   \       0x30   0xEB05 0x01C6      ADD      R1,R5,R6, LSL #+3
   \       0x34   0x6909             LDR      R1,[R1, #+16]
   \       0x36   0x....'....        BL       __aeabi_memcpy
     81                          *datalen = message->options[index].len;
   \       0x3A   0xEB05 0x00C6      ADD      R0,R5,R6, LSL #+3
   \       0x3E   0x89C0             LDRH     R0,[R0, #+14]
   \       0x40   0x8020             STRH     R0,[R4, #+0]
     82                          return COAP_SUCCESS;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBD70             POP      {R4-R6,PC}
     83                      } else {
     84                          return COAP_ERROR_INVALID_LENGTH;
   \                     ??CoAPStrOption_get_3: (+1)
   \       0x46   0xF44F 0x7082      MOV      R0,#+260
   \       0x4A   0xBD70             POP      {R4-R6,PC}
     85                      }
     86                  }
     87              }
     88          
     89              return COAP_ERROR_NOT_FOUND;
   \                     ??CoAPStrOption_get_2: (+1)
   \       0x4C   0xF240 0x1007      MOVW     R0,#+263
   \       0x50   0xBD70             POP      {R4-R6,PC}       ;; return
     90          
     91          }
     92          
     93          

   \                                 In section .text, align 2, keep-with-next
     94          int CoAPUintOption_add(CoAPMessage *message, unsigned short  optnum, unsigned int data)
     95          {
   \                     CoAPUintOption_add: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4614             MOV      R4,R2
     96              unsigned char *ptr = NULL;
   \        0x8   0x2000             MOVS     R0,#+0
     97              if (COAP_MSG_MAX_OPTION_NUM <= message->optcount) {
   \        0xA   0xF895 0x106C      LDRB     R1,[R5, #+108]
   \        0xE   0x290C             CMP      R1,#+12
   \       0x10   0xDB02             BLT.N    ??CoAPUintOption_add_0
     98                  return COAP_ERROR_INVALID_PARAM;
   \       0x12   0xF240 0x1001      MOVW     R0,#+257
   \       0x16   0xBD70             POP      {R4-R6,PC}
     99              }
    100              message->options[message->optcount].num = optnum - message->optdelta;
   \                     ??CoAPUintOption_add_0: (+1)
   \       0x18   0xEB05 0x01C1      ADD      R1,R5,R1, LSL #+3
   \       0x1C   0xF895 0x206D      LDRB     R2,[R5, #+109]
   \       0x20   0x1AB2             SUBS     R2,R6,R2
   \       0x22   0x818A             STRH     R2,[R1, #+12]
    101          
    102              if (0 == data) {
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD106             BNE.N    ??CoAPUintOption_add_1
    103                  message->options[message->optcount].len = 0;
   \       0x28   0xF895 0x106C      LDRB     R1,[R5, #+108]
   \       0x2C   0xEB05 0x01C1      ADD      R1,R5,R1, LSL #+3
   \       0x30   0x4602             MOV      R2,R0
   \       0x32   0x81CA             STRH     R2,[R1, #+14]
   \       0x34   0xE033             B.N      ??CoAPUintOption_add_2
    104              } else if (255 >= data) {
   \                     ??CoAPUintOption_add_1: (+1)
   \       0x36   0xF5B4 0x7F80      CMP      R4,#+256
   \       0x3A   0xD20C             BCS.N    ??CoAPUintOption_add_3
    105                  message->options[message->optcount].len = 1;
   \       0x3C   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \       0x40   0xEB05 0x00C0      ADD      R0,R5,R0, LSL #+3
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0x81C1             STRH     R1,[R0, #+14]
    106                  ptr = (unsigned char *)coap_malloc(1);
   \       0x48   0x4608             MOV      R0,R1
   \       0x4A   0x....'....        BL       HAL_Malloc
    107                  if (NULL != ptr) {
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD025             BEQ.N    ??CoAPUintOption_add_2
    108                      *ptr = (unsigned char)data;
   \       0x52   0x7004             STRB     R4,[R0, #+0]
   \       0x54   0xE023             B.N      ??CoAPUintOption_add_2
    109                  }
    110              } else if (65535 >= data) {
   \                     ??CoAPUintOption_add_3: (+1)
   \       0x56   0xF5B4 0x3F80      CMP      R4,#+65536
   \       0x5A   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \       0x5E   0xEB05 0x00C0      ADD      R0,R5,R0, LSL #+3
   \       0x62   0xD20B             BCS.N    ??CoAPUintOption_add_4
    111                  message->options[message->optcount].len = 2;
   \       0x64   0x2102             MOVS     R1,#+2
   \       0x66   0x81C1             STRH     R1,[R0, #+14]
    112                  ptr  = (unsigned char *)coap_malloc(2);
   \       0x68   0x4608             MOV      R0,R1
   \       0x6A   0x....'....        BL       HAL_Malloc
    113                  if (NULL != ptr) {
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD015             BEQ.N    ??CoAPUintOption_add_2
    114                      *ptr     = (unsigned char)((data & 0xFF00) >> 8);
   \       0x72   0x4621             MOV      R1,R4
   \       0x74   0x0A09             LSRS     R1,R1,#+8
   \       0x76   0x7001             STRB     R1,[R0, #+0]
    115                      *(ptr + 1) = (unsigned char)(data & 0x00FF);
   \       0x78   0x7044             STRB     R4,[R0, #+1]
   \       0x7A   0xE010             B.N      ??CoAPUintOption_add_2
    116                  }
    117              } else {
    118                  message->options[message->optcount].len = 4;
   \                     ??CoAPUintOption_add_4: (+1)
   \       0x7C   0x2104             MOVS     R1,#+4
   \       0x7E   0x81C1             STRH     R1,[R0, #+14]
    119                  ptr   = (unsigned char *)coap_malloc(4);
   \       0x80   0x4608             MOV      R0,R1
   \       0x82   0x....'....        BL       HAL_Malloc
    120                  if (NULL != ptr) {
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD009             BEQ.N    ??CoAPUintOption_add_2
    121                      *ptr     = (unsigned char)((data & 0xFF000000) >> 24);
   \       0x8A   0x4621             MOV      R1,R4
   \       0x8C   0x0E09             LSRS     R1,R1,#+24
   \       0x8E   0x7001             STRB     R1,[R0, #+0]
    122                      *(ptr + 1) = (unsigned char)((data & 0x00FF0000) >> 16);
   \       0x90   0x4621             MOV      R1,R4
   \       0x92   0x0C09             LSRS     R1,R1,#+16
   \       0x94   0x7041             STRB     R1,[R0, #+1]
    123                      *(ptr + 2) = (unsigned char)((data & 0x0000FF00) >> 8);
   \       0x96   0x4621             MOV      R1,R4
   \       0x98   0x0A09             LSRS     R1,R1,#+8
   \       0x9A   0x7081             STRB     R1,[R0, #+2]
    124                      *(ptr + 3) = (unsigned char)(data & 0x000000FF);
   \       0x9C   0x70C4             STRB     R4,[R0, #+3]
    125                  }
    126              }
    127              message->options[message->optcount].val = ptr;
   \                     ??CoAPUintOption_add_2: (+1)
   \       0x9E   0xF895 0x106C      LDRB     R1,[R5, #+108]
   \       0xA2   0xEB05 0x01C1      ADD      R1,R5,R1, LSL #+3
   \       0xA6   0x6108             STR      R0,[R1, #+16]
    128              message->optdelta = optnum;
   \       0xA8   0xF885 0x606D      STRB     R6,[R5, #+109]
    129              message->optcount   += 1;
   \       0xAC   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \       0xB0   0x1C40             ADDS     R0,R0,#+1
   \       0xB2   0xF885 0x006C      STRB     R0,[R5, #+108]
    130          
    131              return COAP_SUCCESS;
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0xBD70             POP      {R4-R6,PC}       ;; return
    132          }
    133          

   \                                 In section .text, align 4, keep-with-next
    134          int CoAPUintOption_get(CoAPMessage *message,
    135                                 unsigned short  optnum,
    136                                 unsigned int *data)
    137          {
   \                     CoAPUintOption_get: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    138          
    139              unsigned char index = 0;
    140          
    141              for (index = 0; index < message->optcount; index++) {
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0xE001             B.N      ??CoAPUintOption_get_1
   \                     ??CoAPUintOption_get_2: (+1)
   \        0x8   0x1C5B             ADDS     R3,R3,#+1
   \        0xA   0xB2DB             UXTB     R3,R3
   \                     ??CoAPUintOption_get_1: (+1)
   \        0xC   0xF890 0x406C      LDRB     R4,[R0, #+108]
   \       0x10   0x42A3             CMP      R3,R4
   \       0x12   0xDA62             BGE.N    ??CoAPUintOption_get_3
    142                  if (message->options[index].num == optnum) {
   \       0x14   0xEB00 0x04C3      ADD      R4,R0,R3, LSL #+3
   \       0x18   0x89A4             LDRH     R4,[R4, #+12]
   \       0x1A   0x42AC             CMP      R4,R5
   \       0x1C   0xD1F4             BNE.N    ??CoAPUintOption_get_2
    143                      int byte = 0;
    144                      switch (message->options[index].len) {
   \       0x1E   0xEB00 0x01C3      ADD      R1,R0,R3, LSL #+3
   \       0x22   0x89C9             LDRH     R1,[R1, #+14]
   \       0x24   0x1E49             SUBS     R1,R1,#+1
   \       0x26   0x2903             CMP      R1,#+3
   \       0x28   0xD853             BHI.N    ??CoAPUintOption_get_4
   \       0x2A   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??CoAPUintOption_get_0:
   \       0x2E   0x02 0x0A          DC8      0x2,0xA,0x1A,0x32
   \              0x1A 0x32    
    145                          case 1:
    146                              *data |= message->options[index].val[byte++];
   \                     ??CoAPUintOption_get_5: (+1)
   \       0x32   0x6811             LDR      R1,[R2, #+0]
   \       0x34   0xEB00 0x00C3      ADD      R0,R0,R3, LSL #+3
   \       0x38   0x6900             LDR      R0,[R0, #+16]
   \       0x3A   0x7800             LDRB     R0,[R0, #+0]
   \       0x3C   0x4301             ORRS     R1,R0,R1
   \       0x3E   0x6011             STR      R1,[R2, #+0]
    147                              break;
   \       0x40   0xE049             B.N      ??CoAPUintOption_get_6
    148                          case 2:
    149                              *data |= (message->options[index].val[byte++] << 8);
   \                     ??CoAPUintOption_get_7: (+1)
   \       0x42   0x6811             LDR      R1,[R2, #+0]
   \       0x44   0xEB00 0x04C3      ADD      R4,R0,R3, LSL #+3
   \       0x48   0x6924             LDR      R4,[R4, #+16]
   \       0x4A   0x7824             LDRB     R4,[R4, #+0]
   \       0x4C   0xEA41 0x2104      ORR      R1,R1,R4, LSL #+8
   \       0x50   0x6011             STR      R1,[R2, #+0]
    150                              *data |= message->options[index].val[byte++];
   \       0x52   0x6811             LDR      R1,[R2, #+0]
   \       0x54   0xEB00 0x00C3      ADD      R0,R0,R3, LSL #+3
   \       0x58   0x6900             LDR      R0,[R0, #+16]
   \       0x5A   0x7840             LDRB     R0,[R0, #+1]
   \       0x5C   0x4301             ORRS     R1,R0,R1
   \       0x5E   0x6011             STR      R1,[R2, #+0]
    151                              break;
   \       0x60   0xE039             B.N      ??CoAPUintOption_get_6
    152                          case 3:
    153                              *data |= (message->options[index].val[byte++] << 16);
   \                     ??CoAPUintOption_get_8: (+1)
   \       0x62   0x6811             LDR      R1,[R2, #+0]
   \       0x64   0xEB00 0x04C3      ADD      R4,R0,R3, LSL #+3
   \       0x68   0x6924             LDR      R4,[R4, #+16]
   \       0x6A   0x7824             LDRB     R4,[R4, #+0]
   \       0x6C   0xEA41 0x4104      ORR      R1,R1,R4, LSL #+16
   \       0x70   0x6011             STR      R1,[R2, #+0]
    154                              *data |= (message->options[index].val[byte++] << 8);
   \       0x72   0x6811             LDR      R1,[R2, #+0]
   \       0x74   0xEB00 0x04C3      ADD      R4,R0,R3, LSL #+3
   \       0x78   0x6924             LDR      R4,[R4, #+16]
   \       0x7A   0x7864             LDRB     R4,[R4, #+1]
   \       0x7C   0xEA41 0x2104      ORR      R1,R1,R4, LSL #+8
   \       0x80   0x6011             STR      R1,[R2, #+0]
    155                              *data |= message->options[index].val[byte++];
   \       0x82   0x6811             LDR      R1,[R2, #+0]
   \       0x84   0xEB00 0x00C3      ADD      R0,R0,R3, LSL #+3
   \       0x88   0x6900             LDR      R0,[R0, #+16]
   \       0x8A   0x7880             LDRB     R0,[R0, #+2]
   \       0x8C   0x4301             ORRS     R1,R0,R1
   \       0x8E   0x6011             STR      R1,[R2, #+0]
    156                              break;
   \       0x90   0xE021             B.N      ??CoAPUintOption_get_6
    157                          case 4:
    158                              *data |= (message->options[index].val[byte++] << 24);
   \                     ??CoAPUintOption_get_9: (+1)
   \       0x92   0x6811             LDR      R1,[R2, #+0]
   \       0x94   0xEB00 0x04C3      ADD      R4,R0,R3, LSL #+3
   \       0x98   0x6924             LDR      R4,[R4, #+16]
   \       0x9A   0x7824             LDRB     R4,[R4, #+0]
   \       0x9C   0xEA41 0x6104      ORR      R1,R1,R4, LSL #+24
   \       0xA0   0x6011             STR      R1,[R2, #+0]
    159                              *data |= (message->options[index].val[byte++] << 16);
   \       0xA2   0x6811             LDR      R1,[R2, #+0]
   \       0xA4   0xEB00 0x04C3      ADD      R4,R0,R3, LSL #+3
   \       0xA8   0x6924             LDR      R4,[R4, #+16]
   \       0xAA   0x7864             LDRB     R4,[R4, #+1]
   \       0xAC   0xEA41 0x4104      ORR      R1,R1,R4, LSL #+16
   \       0xB0   0x6011             STR      R1,[R2, #+0]
    160                              *data |= (message->options[index].val[byte++] << 8);
   \       0xB2   0x6811             LDR      R1,[R2, #+0]
   \       0xB4   0xEB00 0x04C3      ADD      R4,R0,R3, LSL #+3
   \       0xB8   0x6924             LDR      R4,[R4, #+16]
   \       0xBA   0x78A4             LDRB     R4,[R4, #+2]
   \       0xBC   0xEA41 0x2104      ORR      R1,R1,R4, LSL #+8
   \       0xC0   0x6011             STR      R1,[R2, #+0]
    161                              *data |= message->options[index].val[byte++];
   \       0xC2   0x6811             LDR      R1,[R2, #+0]
   \       0xC4   0xEB00 0x00C3      ADD      R0,R0,R3, LSL #+3
   \       0xC8   0x6900             LDR      R0,[R0, #+16]
   \       0xCA   0x78C0             LDRB     R0,[R0, #+3]
   \       0xCC   0x4301             ORRS     R1,R0,R1
   \       0xCE   0x6011             STR      R1,[R2, #+0]
    162                              break;
   \       0xD0   0xE001             B.N      ??CoAPUintOption_get_6
    163                          default:
    164                              *data = 0;
   \                     ??CoAPUintOption_get_4: (+1)
   \       0xD2   0x2000             MOVS     R0,#+0
   \       0xD4   0x6010             STR      R0,[R2, #+0]
    165                              break;
    166                      }
    167                      return COAP_SUCCESS;
   \                     ??CoAPUintOption_get_6: (+1)
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xE001             B.N      ??CoAPUintOption_get_10
    168                  }
    169              }
    170          
    171              return COAP_ERROR_NOT_FOUND;
   \                     ??CoAPUintOption_get_3: (+1)
   \       0xDA   0xF240 0x1007      MOVW     R0,#+263
   \                     ??CoAPUintOption_get_10: (+1)
   \       0xDE   0xBC30             POP      {R4,R5}
   \       0xE0   0x4770             BX       LR               ;; return
    172          }
    173          
    174          

   \                                 In section .text, align 2, keep-with-next
    175          int CoAPOption_present(CoAPMessage *message, unsigned short option)
    176          {
   \                     CoAPOption_present: (+1)
   \        0x0   0xB410             PUSH     {R4}
    177              unsigned char index = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    178          
    179          
    180              for (index = 0; index < message->optcount; index++) {
   \        0x4   0xE000             B.N      ??CoAPOption_present_0
   \                     ??CoAPOption_present_1: (+1)
   \        0x6   0x1C52             ADDS     R2,R2,#+1
   \                     ??CoAPOption_present_0: (+1)
   \        0x8   0x4613             MOV      R3,R2
   \        0xA   0xF890 0x406C      LDRB     R4,[R0, #+108]
   \        0xE   0xB2DB             UXTB     R3,R3
   \       0x10   0x42A3             CMP      R3,R4
   \       0x12   0xD209             BCS.N    ??CoAPOption_present_2
    181                  if (message->options[index].num == option) {
   \       0x14   0x4613             MOV      R3,R2
   \       0x16   0xB2DB             UXTB     R3,R3
   \       0x18   0xEB00 0x03C3      ADD      R3,R0,R3, LSL #+3
   \       0x1C   0x899B             LDRH     R3,[R3, #+12]
   \       0x1E   0x460C             MOV      R4,R1
   \       0x20   0x42A3             CMP      R3,R4
   \       0x22   0xD1F0             BNE.N    ??CoAPOption_present_1
    182                      return COAP_SUCCESS;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE001             B.N      ??CoAPOption_present_3
    183                  }
    184              }
    185              return COAP_ERROR_NOT_FOUND;
   \                     ??CoAPOption_present_2: (+1)
   \       0x28   0xF240 0x1007      MOVW     R0,#+263
   \                     ??CoAPOption_present_3: (+1)
   \       0x2C   0xBC10             POP      {R4}
   \       0x2E   0x4770             BX       LR               ;; return
    186          }
    187          

   \                                 In section .text, align 2, keep-with-next
    188          int CoAPMessageId_set(CoAPMessage *message, unsigned short msgid)
    189          {
    190              if (NULL == message) {
   \                     CoAPMessageId_set: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD102             BNE.N    ??CoAPMessageId_set_0
    191                  return COAP_ERROR_NULL;
   \        0x4   0xF44F 0x7081      MOV      R0,#+258
   \        0x8   0x4770             BX       LR
    192              }
    193              message->header.msgid = msgid;
   \                     ??CoAPMessageId_set_0: (+1)
   \        0xA   0x8041             STRH     R1,[R0, #+2]
    194              return COAP_SUCCESS;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
    195          }
    196          

   \                                 In section .text, align 2, keep-with-next
    197          int CoAPMessageType_set(CoAPMessage *message, unsigned char type)
    198          {
    199              if (NULL == message) {
   \                     CoAPMessageType_set: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD102             BNE.N    ??CoAPMessageType_set_0
    200                  return COAP_ERROR_NULL;
   \        0x4   0xF44F 0x7081      MOV      R0,#+258
   \        0x8   0x4770             BX       LR
    201              }
    202              if (COAP_MESSAGE_TYPE_CON != type && COAP_MESSAGE_TYPE_NON != type
    203                  && COAP_MESSAGE_TYPE_ACK != type && COAP_MESSAGE_TYPE_RST != type) {
   \                     ??CoAPMessageType_set_0: (+1)
   \        0xA   0x000A             MOVS     R2,R1
   \        0xC   0xD008             BEQ.N    ??CoAPMessageType_set_1
   \        0xE   0x2A01             CMP      R2,#+1
   \       0x10   0xD006             BEQ.N    ??CoAPMessageType_set_1
   \       0x12   0x2A02             CMP      R2,#+2
   \       0x14   0xD004             BEQ.N    ??CoAPMessageType_set_1
   \       0x16   0x2A03             CMP      R2,#+3
   \       0x18   0xD002             BEQ.N    ??CoAPMessageType_set_1
    204                  return COAP_ERROR_INVALID_PARAM;
   \       0x1A   0xF240 0x1001      MOVW     R0,#+257
   \       0x1E   0x4770             BX       LR
    205              }
    206          
    207              message->header.type = type;
   \                     ??CoAPMessageType_set_1: (+1)
   \       0x20   0x7802             LDRB     R2,[R0, #+0]
   \       0x22   0xF361 0x0283      BFI      R2,R1,#+2,#+2
   \       0x26   0x7002             STRB     R2,[R0, #+0]
    208              return COAP_SUCCESS;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x4770             BX       LR               ;; return
    209          }
    210          

   \                                 In section .text, align 2, keep-with-next
    211          int CoAPMessageCode_set(CoAPMessage *message, CoAPMessageCode code)
    212          {
    213              if (NULL == message) {
   \                     CoAPMessageCode_set: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD102             BNE.N    ??CoAPMessageCode_set_0
    214                  return COAP_ERROR_NULL;
   \        0x4   0xF44F 0x7081      MOV      R0,#+258
   \        0x8   0x4770             BX       LR
    215              }
    216              message->header.code  = code;
   \                     ??CoAPMessageCode_set_0: (+1)
   \        0xA   0x7041             STRB     R1,[R0, #+1]
    217              return COAP_SUCCESS;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
    218          }
    219          

   \                                 In section .text, align 2, keep-with-next
    220          int CoAPMessageCode_get(CoAPMessage *message, CoAPMessageCode *code)
    221          {
    222              if (NULL == message || NULL == code) {
   \                     CoAPMessageCode_get: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??CoAPMessageCode_get_0
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD102             BNE.N    ??CoAPMessageCode_get_1
    223                  return COAP_ERROR_NULL;
   \                     ??CoAPMessageCode_get_0: (+1)
   \        0x8   0xF44F 0x7081      MOV      R0,#+258
   \        0xC   0x4770             BX       LR
    224              }
    225              *code = message->header.code;
                           ^
Warning[Pe188]: enumerated type mixed with another type
   \                     ??CoAPMessageCode_get_1: (+1)
   \        0xE   0x7840             LDRB     R0,[R0, #+1]
   \       0x10   0x7008             STRB     R0,[R1, #+0]
    226              return COAP_SUCCESS;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
    227          }
    228          

   \                                 In section .text, align 2, keep-with-next
    229          int CoAPMessageToken_set(CoAPMessage *message, unsigned char *token,
    230                                   unsigned char tokenlen)
    231          {
   \                     CoAPMessageToken_set: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4615             MOV      R5,R2
    232              if (NULL == message || NULL == token) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??CoAPMessageToken_set_0
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD102             BNE.N    ??CoAPMessageToken_set_1
    233                  return COAP_ERROR_NULL;
   \                     ??CoAPMessageToken_set_0: (+1)
   \        0xE   0xF44F 0x7081      MOV      R0,#+258
   \       0x12   0xBD32             POP      {R1,R4,R5,PC}
    234              }
    235              if (COAP_MSG_MAX_TOKEN_LEN < tokenlen) {
   \                     ??CoAPMessageToken_set_1: (+1)
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x2809             CMP      R0,#+9
   \       0x18   0xDB02             BLT.N    ??CoAPMessageToken_set_2
    236                  return COAP_ERROR_INVALID_LENGTH;
   \       0x1A   0xF44F 0x7082      MOV      R0,#+260
   \       0x1E   0xBD32             POP      {R1,R4,R5,PC}
    237              }
    238              memcpy(message->token, token, tokenlen);
   \                     ??CoAPMessageToken_set_2: (+1)
   \       0x20   0x1D20             ADDS     R0,R4,#+4
   \       0x22   0x....'....        BL       __aeabi_memcpy
    239              message->header.tokenlen = tokenlen;
   \       0x26   0x7820             LDRB     R0,[R4, #+0]
   \       0x28   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x2C   0xEA40 0x1005      ORR      R0,R0,R5, LSL #+4
   \       0x30   0x7020             STRB     R0,[R4, #+0]
    240          
    241              return COAP_SUCCESS;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    242          }
    243          

   \                                 In section .text, align 2, keep-with-next
    244          int CoAPMessageUserData_set(CoAPMessage *message, void *userdata)
    245          {
    246              if (NULL == message || NULL == userdata) {
   \                     CoAPMessageUserData_set: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??CoAPMessageUserData_set_0
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD102             BNE.N    ??CoAPMessageUserData_set_1
    247                  return COAP_ERROR_NULL;
   \                     ??CoAPMessageUserData_set_0: (+1)
   \        0x8   0xF44F 0x7081      MOV      R0,#+258
   \        0xC   0x4770             BX       LR
    248              }
    249              message->user = userdata;
   \                     ??CoAPMessageUserData_set_1: (+1)
   \        0xE   0x67C1             STR      R1,[R0, #+124]
    250              return COAP_SUCCESS;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x4770             BX       LR               ;; return
    251          }
    252          

   \                                 In section .text, align 2, keep-with-next
    253          int CoAPMessageKeep_Set(CoAPMessage *message, int keep)
    254          {
    255              if (NULL == message || keep < 0) {
   \                     CoAPMessageKeep_Set: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??CoAPMessageKeep_Set_0
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD502             BPL.N    ??CoAPMessageKeep_Set_1
    256                  return COAP_ERROR_NULL;
   \                     ??CoAPMessageKeep_Set_0: (+1)
   \        0x8   0xF44F 0x7081      MOV      R0,#+258
   \        0xC   0x4770             BX       LR
    257              }
    258              message->keep = keep;
   \                     ??CoAPMessageKeep_Set_1: (+1)
   \        0xE   0xF8C0 0x1080      STR      R1,[R0, #+128]
    259              return COAP_SUCCESS;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
    260          }
    261          

   \                                 In section .text, align 2, keep-with-next
    262          int CoAPMessagePayload_set(CoAPMessage *message, unsigned char *payload,
    263                                     unsigned short payloadlen)
    264          {
    265              if (NULL == message || (0 < payloadlen && NULL == payload)) {
   \                     CoAPMessagePayload_set: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD003             BEQ.N    ??CoAPMessagePayload_set_0
   \        0x4   0x0013             MOVS     R3,R2
   \        0x6   0xD004             BEQ.N    ??CoAPMessagePayload_set_1
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD102             BNE.N    ??CoAPMessagePayload_set_1
    266                  return COAP_ERROR_NULL;
   \                     ??CoAPMessagePayload_set_0: (+1)
   \        0xC   0xF44F 0x7081      MOV      R0,#+258
   \       0x10   0x4770             BX       LR
    267              }
    268              message->payload = payload;
   \                     ??CoAPMessagePayload_set_1: (+1)
   \       0x12   0x6701             STR      R1,[R0, #+112]
    269              message->payloadlen = payloadlen;
   \       0x14   0xF8A0 0x206E      STRH     R2,[R0, #+110]
    270          
    271              return COAP_SUCCESS;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x4770             BX       LR               ;; return
    272          }
    273          

   \                                 In section .text, align 2, keep-with-next
    274          int CoAPMessage_init(CoAPMessage *message)
    275          {
   \                     CoAPMessage_init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    276              int count = 0;
   \        0x4   0x2500             MOVS     R5,#+0
    277          
    278              if (NULL == message) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??CoAPMessage_init_0
    279                  return COAP_ERROR_NULL;
   \        0xA   0xF44F 0x7081      MOV      R0,#+258
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
    280              }
    281              memset(message, 0x00, sizeof(CoAPMessage));
   \                     ??CoAPMessage_init_0: (+1)
   \       0x10   0x462A             MOV      R2,R5
   \       0x12   0x2184             MOVS     R1,#+132
   \       0x14   0x....'....        BL       __aeabi_memset4
    282              message->header.version    = COAP_CUR_VERSION;
   \       0x18   0x7820             LDRB     R0,[R4, #+0]
   \       0x1A   0xF000 0x00FC      AND      R0,R0,#0xFC
   \       0x1E   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x22   0x7020             STRB     R0,[R4, #+0]
    283              message->header.type       = COAP_MESSAGE_TYPE_ACK;
   \       0x24   0xF000 0x00F3      AND      R0,R0,#0xF3
   \       0x28   0xF040 0x0008      ORR      R0,R0,#0x8
   \       0x2C   0x7020             STRB     R0,[R4, #+0]
    284              message->header.tokenlen   = 0;
   \       0x2E   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x32   0x7020             STRB     R0,[R4, #+0]
    285              message->header.code       = COAP_MSG_CODE_EMPTY_MESSAGE;
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x7060             STRB     R0,[R4, #+1]
    286              message->header.msgid      = 0;
   \       0x38   0x8060             STRH     R0,[R4, #+2]
    287              message->payload           = NULL;
   \       0x3A   0x6720             STR      R0,[R4, #+112]
    288              message->payloadlen        = 0;
   \       0x3C   0xF8A4 0x006E      STRH     R0,[R4, #+110]
    289              message->optcount          = 0;
   \       0x40   0xF884 0x006C      STRB     R0,[R4, #+108]
    290              message->optdelta          = 0;
   \       0x44   0xF884 0x006D      STRB     R0,[R4, #+109]
    291              message->handler           = NULL;
   \       0x48   0x6760             STR      R0,[R4, #+116]
    292              message->keep              = 0;
   \       0x4A   0xF8C4 0x0080      STR      R0,[R4, #+128]
    293              for (count = 0; count < COAP_MSG_MAX_OPTION_NUM; count++) {
   \       0x4E   0xE005             B.N      ??CoAPMessage_init_1
    294                  message->options[count].len = 0;
   \                     ??CoAPMessage_init_2: (+1)
   \       0x50   0xEB04 0x01C5      ADD      R1,R4,R5, LSL #+3
   \       0x54   0x81C8             STRH     R0,[R1, #+14]
    295                  message->options[count].num = 0;
   \       0x56   0x8188             STRH     R0,[R1, #+12]
    296                  message->options[count].val = NULL;
   \       0x58   0x6108             STR      R0,[R1, #+16]
    297              }
   \       0x5A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??CoAPMessage_init_1: (+1)
   \       0x5C   0x2D0C             CMP      R5,#+12
   \       0x5E   0xDBF7             BLT.N    ??CoAPMessage_init_2
   \       0x60   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    298          
    299              return COAP_SUCCESS;
    300          }
    301          

   \                                 In section .text, align 2, keep-with-next
    302          int CoAPMessage_destory(CoAPMessage *message)
    303          {
   \                     CoAPMessage_destory: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    304              int count = 0;
   \        0x4   0x2500             MOVS     R5,#+0
    305              if (NULL == message) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD111             BNE.N    ??CoAPMessage_destory_0
    306                  return COAP_ERROR_NULL;
   \        0xA   0xF44F 0x7081      MOV      R0,#+258
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
    307              }
    308          
    309              for (count = 0; count < COAP_MSG_MAX_OPTION_NUM; count++) {
    310                  if (NULL != message->options[count].val) {
   \                     ??CoAPMessage_destory_1: (+1)
   \       0x10   0xEB04 0x00C5      ADD      R0,R4,R5, LSL #+3
   \       0x14   0x6900             LDR      R0,[R0, #+16]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD008             BEQ.N    ??CoAPMessage_destory_2
    311                      coap_free(message->options[count].val);
   \       0x1A   0xEB04 0x00C5      ADD      R0,R4,R5, LSL #+3
   \       0x1E   0x6900             LDR      R0,[R0, #+16]
   \       0x20   0x....'....        BL       HAL_Free
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xEB04 0x01C5      ADD      R1,R4,R5, LSL #+3
   \       0x2A   0x6108             STR      R0,[R1, #+16]
    312                      message->options[count].val = NULL;
    313                  }
    314              }
   \                     ??CoAPMessage_destory_2: (+1)
   \       0x2C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??CoAPMessage_destory_0: (+1)
   \       0x2E   0x2D0C             CMP      R5,#+12
   \       0x30   0xDBEE             BLT.N    ??CoAPMessage_destory_1
    315          
    316              return COAP_SUCCESS;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    317          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CoAPMessageCode_get
       0   CoAPMessageCode_set
       0   CoAPMessageId_set
       0   CoAPMessageKeep_Set
       0   CoAPMessagePayload_set
      16   CoAPMessageToken_set
        16   -> __aeabi_memcpy
       0   CoAPMessageType_set
       0   CoAPMessageUserData_set
      16   CoAPMessage_destory
        16   -> HAL_Free
      16   CoAPMessage_init
        16   -> __aeabi_memset4
       4   CoAPOption_present
      24   CoAPStrOption_add
        24   -> HAL_Malloc
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      16   CoAPStrOption_get
        16   -> __aeabi_memcpy
      16   CoAPUintOption_add
        16   -> HAL_Malloc
       8   CoAPUintOption_get


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      22  CoAPMessageCode_get
      16  CoAPMessageCode_set
      16  CoAPMessageId_set
      22  CoAPMessageKeep_Set
      28  CoAPMessagePayload_set
      54  CoAPMessageToken_set
      44  CoAPMessageType_set
      20  CoAPMessageUserData_set
      54  CoAPMessage_destory
      98  CoAPMessage_init
      48  CoAPOption_present
     114  CoAPStrOption_add
      82  CoAPStrOption_get
     186  CoAPUintOption_add
     226  CoAPUintOption_get

 
 1 030 bytes in section .text
 
 1 030 bytes of CODE memory

Errors: none
Warnings: 1
