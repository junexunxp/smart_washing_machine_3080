###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:40
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\mbedtls\library\pk.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW2D4F.tmp
#        (C:\Development\smart_washing_machine_3080\mbedtls\library\pk.c -D
#        DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1
#        -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE
#        -D "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\pk.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\pk.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\mbedtls\library\pk.c
      1          /*
      2           *  Public Key abstraction layer
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_PK_C)
     29          #include "mbedtls/pk.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp mbedtls_rsa_context *mbedtls_pk_rsa(mbedtls_pk_context const)
   \                     mbedtls_pk_rsa: (+1)
   \        0x0   0x4608             MOV      R0,R1
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp size_t mbedtls_pk_get_len(mbedtls_pk_context const *)
   \                     mbedtls_pk_get_len: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x....'....        BL       mbedtls_pk_get_bitlen
   \        0x6   0x1DC0             ADDS     R0,R0,#+7
   \        0x8   0x08C0             LSRS     R0,R0,#+3
   \        0xA   0xBD02             POP      {R1,PC}          ;; return
     30          #include "mbedtls/pk_internal.h"
     31          
     32          #include "mbedtls/platform_util.h"
     33          
     34          #if defined(MBEDTLS_RSA_C)
     35          #include "mbedtls/rsa.h"
     36          #endif
     37          #if defined(MBEDTLS_ECP_C)
     38          #include "mbedtls/ecp.h"
     39          #endif
     40          #if defined(MBEDTLS_ECDSA_C)
     41          #include "mbedtls/ecdsa.h"
     42          #endif
     43          
     44          #include <limits.h>
     45          #include <stdint.h>
     46          
     47          /*
     48           * Initialise a mbedtls_pk_context
     49           */

   \                                 In section .text, align 2, keep-with-next
     50          void mbedtls_pk_init( mbedtls_pk_context *ctx )
     51          {
     52              if( ctx == NULL )
   \                     mbedtls_pk_init: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD002             BEQ.N    ??mbedtls_pk_init_0
     53                  return;
     54          
     55              ctx->pk_info = NULL;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6001             STR      R1,[R0, #+0]
     56              ctx->pk_ctx = NULL;
   \        0x8   0x6041             STR      R1,[R0, #+4]
     57          }
   \                     ??mbedtls_pk_init_0: (+1)
   \        0xA   0x4770             BX       LR               ;; return
     58          
     59          /*
     60           * Free (the components of) a mbedtls_pk_context
     61           */

   \                                 In section .text, align 2, keep-with-next
     62          void mbedtls_pk_free( mbedtls_pk_context *ctx )
     63          {
   \                     mbedtls_pk_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     64              if( ctx == NULL || ctx->pk_info == NULL )
   \        0x4   0xD00C             BEQ.N    ??mbedtls_pk_free_0
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD009             BEQ.N    ??mbedtls_pk_free_0
     65                  return;
     66          
     67              ctx->pk_info->ctx_free_func( ctx->pk_ctx );
   \        0xC   0x6860             LDR      R0,[R4, #+4]
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x6A89             LDR      R1,[R1, #+40]
   \       0x12   0x4788             BLX      R1
     68          
     69              mbedtls_platform_zeroize( ctx, sizeof( mbedtls_pk_context ) );
   \       0x14   0x2108             MOVS     R1,#+8
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1C   0x....'....        B.W      mbedtls_platform_zeroize
   \                     ??mbedtls_pk_free_0: (+1)
   \       0x20   0xBD10             POP      {R4,PC}          ;; return
     70          }
     71          
     72          /*
     73           * Get pk_info structure from type
     74           */

   \                                 In section .text, align 4, keep-with-next
     75          const mbedtls_pk_info_t * mbedtls_pk_info_from_type( mbedtls_pk_type_t pk_type )
     76          {
     77              switch( pk_type ) {
   \                     mbedtls_pk_info_from_type: (+1)
   \        0x0   0x1E40             SUBS     R0,R0,#+1
   \        0x2   0x2803             CMP      R0,#+3
   \        0x4   0xD80F             BHI.N    ??mbedtls_pk_info_from_type_1
   \        0x6   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??mbedtls_pk_info_from_type_0:
   \        0xA   0x02 0x05          DC8      0x2,0x5,0x8,0xB
   \              0x08 0x0B    
     78          #if defined(MBEDTLS_RSA_C)
     79                  case MBEDTLS_PK_RSA:
     80                      return( &mbedtls_rsa_info );
   \                     ??mbedtls_pk_info_from_type_2: (+1)
   \        0xE   0x....'....        LDR.W    R0,??DataTable11
   \       0x12   0x4770             BX       LR
     81          #endif
     82          #if defined(MBEDTLS_ECP_C)
     83                  case MBEDTLS_PK_ECKEY:
     84                      return( &mbedtls_eckey_info );
   \                     ??mbedtls_pk_info_from_type_3: (+1)
   \       0x14   0x....'....        LDR.W    R0,??DataTable11_1
   \       0x18   0x4770             BX       LR
     85                  case MBEDTLS_PK_ECKEY_DH:
     86                      return( &mbedtls_eckeydh_info );
   \                     ??mbedtls_pk_info_from_type_4: (+1)
   \       0x1A   0x....'....        LDR.W    R0,??DataTable11_2
   \       0x1E   0x4770             BX       LR
     87          #endif
     88          #if defined(MBEDTLS_ECDSA_C)
     89                  case MBEDTLS_PK_ECDSA:
     90                      return( &mbedtls_ecdsa_info );
   \                     ??mbedtls_pk_info_from_type_5: (+1)
   \       0x20   0x....'....        LDR.W    R0,??DataTable11_3
   \       0x24   0x4770             BX       LR
     91          #endif
     92                  /* MBEDTLS_PK_RSA_ALT omitted on purpose */
     93                  default:
     94                      return( NULL );
   \                     ??mbedtls_pk_info_from_type_1: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x4770             BX       LR               ;; return
     95              }
     96          }
     97          
     98          /*
     99           * Initialise context
    100           */

   \                                 In section .text, align 2, keep-with-next
    101          int mbedtls_pk_setup( mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info )
    102          {
   \                     mbedtls_pk_setup: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    103              if( ctx == NULL || info == NULL || ctx->pk_info != NULL )
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD004             BEQ.N    ??mbedtls_pk_setup_0
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD002             BEQ.N    ??mbedtls_pk_setup_0
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD002             BEQ.N    ??mbedtls_pk_setup_1
    104                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_setup_0: (+1)
   \       0x14   0x....'....        LDR.W    R0,??DataTable11_4  ;; 0xffffc180
   \       0x18   0xBD32             POP      {R1,R4,R5,PC}
    105          
    106              if( ( ctx->pk_ctx = info->ctx_alloc_func() ) == NULL )
   \                     ??mbedtls_pk_setup_1: (+1)
   \       0x1A   0x6A60             LDR      R0,[R4, #+36]
   \       0x1C   0x4780             BLX      R0
   \       0x1E   0x6068             STR      R0,[R5, #+4]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD102             BNE.N    ??mbedtls_pk_setup_2
    107                  return( MBEDTLS_ERR_PK_ALLOC_FAILED );
   \       0x24   0x....'....        LDR.W    R0,??DataTable11_5  ;; 0xffffc080
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}
    108          
    109              ctx->pk_info = info;
   \                     ??mbedtls_pk_setup_2: (+1)
   \       0x2A   0x602C             STR      R4,[R5, #+0]
    110          
    111              return( 0 );
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    112          }
    113          
    114          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
    115          /*
    116           * Initialize an RSA-alt context
    117           */

   \                                 In section .text, align 2, keep-with-next
    118          int mbedtls_pk_setup_rsa_alt( mbedtls_pk_context *ctx, void * key,
    119                                   mbedtls_pk_rsa_alt_decrypt_func decrypt_func,
    120                                   mbedtls_pk_rsa_alt_sign_func sign_func,
    121                                   mbedtls_pk_rsa_alt_key_len_func key_len_func )
    122          {
   \                     mbedtls_pk_setup_rsa_alt: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    123              mbedtls_rsa_alt_context *rsa_alt;
    124              const mbedtls_pk_info_t *info = &mbedtls_rsa_alt_info;
   \        0xC   0x....'....        LDR.W    R8,??DataTable11_6
    125          
    126              if( ctx == NULL || ctx->pk_info != NULL )
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD002             BEQ.N    ??mbedtls_pk_setup_rsa_alt_0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??mbedtls_pk_setup_rsa_alt_1
    127                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_setup_rsa_alt_0: (+1)
   \       0x1A   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \       0x1C   0xE010             B.N      ??mbedtls_pk_setup_rsa_alt_2
    128          
    129              if( ( ctx->pk_ctx = info->ctx_alloc_func() ) == NULL )
   \                     ??mbedtls_pk_setup_rsa_alt_1: (+1)
   \       0x1E   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \       0x22   0x4780             BLX      R0
   \       0x24   0x6060             STR      R0,[R4, #+4]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD101             BNE.N    ??mbedtls_pk_setup_rsa_alt_3
    130                  return( MBEDTLS_ERR_PK_ALLOC_FAILED );
   \       0x2A   0x....             LDR.N    R0,??DataTable11_5  ;; 0xffffc080
   \       0x2C   0xE008             B.N      ??mbedtls_pk_setup_rsa_alt_2
   \                     ??mbedtls_pk_setup_rsa_alt_3: (+1)
   \       0x2E   0x9806             LDR      R0,[SP, #+24]
    131          
    132              ctx->pk_info = info;
   \       0x30   0xF8C4 0x8000      STR      R8,[R4, #+0]
    133          
    134              rsa_alt = (mbedtls_rsa_alt_context *) ctx->pk_ctx;
   \       0x34   0x6861             LDR      R1,[R4, #+4]
    135          
    136              rsa_alt->key = key;
   \       0x36   0x600D             STR      R5,[R1, #+0]
    137              rsa_alt->decrypt_func = decrypt_func;
   \       0x38   0x604E             STR      R6,[R1, #+4]
    138              rsa_alt->sign_func = sign_func;
   \       0x3A   0x608F             STR      R7,[R1, #+8]
    139              rsa_alt->key_len_func = key_len_func;
   \       0x3C   0x60C8             STR      R0,[R1, #+12]
    140          
    141              return( 0 );
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_pk_setup_rsa_alt_2: (+1)
   \       0x40   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    142          }
    143          #endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
    144          
    145          /*
    146           * Tell if a PK can do the operations of the given type
    147           */

   \                                 In section .text, align 2, keep-with-next
    148          int mbedtls_pk_can_do( const mbedtls_pk_context *ctx, mbedtls_pk_type_t type )
    149          {
   \                     mbedtls_pk_can_do: (+1)
   \        0x0   0x4602             MOV      R2,R0
   \        0x2   0x4608             MOV      R0,R1
    150              /* null or NONE context can't do anything */
    151              if( ctx == NULL || ctx->pk_info == NULL )
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD002             BEQ.N    ??mbedtls_pk_can_do_0
   \        0x8   0x6811             LDR      R1,[R2, #+0]
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD101             BNE.N    ??mbedtls_pk_can_do_1
    152                  return( 0 );
   \                     ??mbedtls_pk_can_do_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR
    153          
    154              return( ctx->pk_info->can_do( type ) );
   \                     ??mbedtls_pk_can_do_1: (+1)
   \       0x12   0x68C9             LDR      R1,[R1, #+12]
   \       0x14   0x4708             BX       R1
    155          }
    156          
    157          /*
    158           * Helper for mbedtls_pk_sign and mbedtls_pk_verify
    159           */

   \                                 In section .text, align 2, keep-with-next
    160          static inline int pk_hashlen_helper( mbedtls_md_type_t md_alg, size_t *hash_len )
    161          {
   \                     pk_hashlen_helper: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    162              const mbedtls_md_info_t *md_info;
    163          
    164              if( *hash_len != 0 )
   \        0x4   0x6821             LDR      R1,[R4, #+0]
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD001             BEQ.N    ??pk_hashlen_helper_0
    165                  return( 0 );
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD10             POP      {R4,PC}
    166          
    167              if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
   \                     ??pk_hashlen_helper_0: (+1)
   \        0xE   0x....'....        BL       mbedtls_md_info_from_type
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??pk_hashlen_helper_1
    168                  return( -1 );
   \       0x16   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1A   0xBD10             POP      {R4,PC}
    169          
    170              *hash_len = mbedtls_md_get_size( md_info );
   \                     ??pk_hashlen_helper_1: (+1)
   \       0x1C   0x....'....        BL       mbedtls_md_get_size
   \       0x20   0x6020             STR      R0,[R4, #+0]
    171              return( 0 );
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    172          }
    173          
    174          /*
    175           * Verify a signature
    176           */

   \                                 In section .text, align 2, keep-with-next
    177          int mbedtls_pk_verify( mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
    178                         const unsigned char *hash, size_t hash_len,
    179                         const unsigned char *sig, size_t sig_len )
    180          {
   \                     mbedtls_pk_verify: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    181              if( ctx == NULL || ctx->pk_info == NULL ||
    182                  pk_hashlen_helper( md_alg, &hash_len ) != 0 )
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD008             BEQ.N    ??mbedtls_pk_verify_0
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD005             BEQ.N    ??mbedtls_pk_verify_0
   \       0x12   0xA903             ADD      R1,SP,#+12
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x....'....        BL       pk_hashlen_helper
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??mbedtls_pk_verify_1
    183                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_verify_0: (+1)
   \       0x1E   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \       0x20   0xE010             B.N      ??mbedtls_pk_verify_2
    184          
    185              if( ctx->pk_info->verify_func == NULL )
   \                     ??mbedtls_pk_verify_1: (+1)
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6900             LDR      R0,[R0, #+16]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD101             BNE.N    ??mbedtls_pk_verify_3
    186                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \       0x2A   0x....             LDR.N    R0,??DataTable11_7  ;; 0xffffc100
   \       0x2C   0xE00A             B.N      ??mbedtls_pk_verify_2
   \                     ??mbedtls_pk_verify_3: (+1)
   \       0x2E   0x9909             LDR      R1,[SP, #+36]
   \       0x30   0x9808             LDR      R0,[SP, #+32]
    187          
    188              return( ctx->pk_info->verify_func( ctx->pk_ctx, md_alg, hash, hash_len,
    189                                                 sig, sig_len ) );
   \       0x32   0x9101             STR      R1,[SP, #+4]
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x9B03             LDR      R3,[SP, #+12]
   \       0x38   0x4632             MOV      R2,R6
   \       0x3A   0x4629             MOV      R1,R5
   \       0x3C   0x6860             LDR      R0,[R4, #+4]
   \       0x3E   0x6824             LDR      R4,[R4, #+0]
   \       0x40   0x6924             LDR      R4,[R4, #+16]
   \       0x42   0x47A0             BLX      R4
   \                     ??mbedtls_pk_verify_2: (+1)
   \       0x44   0xB004             ADD      SP,SP,#+16
   \       0x46   0xBD70             POP      {R4-R6,PC}       ;; return
    190          }
    191          
    192          /*
    193           * Verify a signature with options
    194           */

   \                                 In section .text, align 2, keep-with-next
    195          int mbedtls_pk_verify_ext( mbedtls_pk_type_t type, const void *options,
    196                             mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
    197                             const unsigned char *hash, size_t hash_len,
    198                             const unsigned char *sig, size_t sig_len )
    199          {
   \                     mbedtls_pk_verify_ext: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x469A             MOV      R10,R3
    200              if( ctx == NULL || ctx->pk_info == NULL )
   \        0xC   0xD002             BEQ.N    ??mbedtls_pk_verify_ext_0
   \        0xE   0x6829             LDR      R1,[R5, #+0]
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD101             BNE.N    ??mbedtls_pk_verify_ext_1
    201                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_verify_ext_0: (+1)
   \       0x14   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \       0x16   0xE048             B.N      ??mbedtls_pk_verify_ext_2
   \                     ??mbedtls_pk_verify_ext_1: (+1)
   \       0x18   0x4683             MOV      R11,R0
    202          
    203              if( ! mbedtls_pk_can_do( ctx, type ) )
   \       0x1A   0x4659             MOV      R1,R11
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x....'....        BL       mbedtls_pk_can_do
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD101             BNE.N    ??mbedtls_pk_verify_ext_3
    204                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \       0x26   0x....             LDR.N    R0,??DataTable11_7  ;; 0xffffc100
   \       0x28   0xE03F             B.N      ??mbedtls_pk_verify_ext_2
   \                     ??mbedtls_pk_verify_ext_3: (+1)
   \       0x2A   0x9E10             LDR      R6,[SP, #+64]
   \       0x2C   0x9F11             LDR      R7,[SP, #+68]
   \       0x2E   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \       0x32   0xF8DD 0x904C      LDR      R9,[SP, #+76]
    205          
    206              if( type == MBEDTLS_PK_RSASSA_PSS )
   \       0x36   0xF1BB 0x0F06      CMP      R11,#+6
   \       0x3A   0xD128             BNE.N    ??mbedtls_pk_verify_ext_4
    207              {
    208          #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_PKCS1_V21)
    209                  int ret;
    210                  const mbedtls_pk_rsassa_pss_options *pss_opts;
    211          
    212          #if SIZE_MAX > UINT_MAX
    213                  if( md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len )
    214                      return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    215          #endif /* SIZE_MAX > UINT_MAX */
    216          
    217                  if( options == NULL )
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD101             BNE.N    ??mbedtls_pk_verify_ext_5
    218                      return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \       0x40   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \       0x42   0xE032             B.N      ??mbedtls_pk_verify_ext_2
    219          
    220                  pss_opts = (const mbedtls_pk_rsassa_pss_options *) options;
    221          
    222                  if( sig_len < mbedtls_pk_get_len( ctx ) )
   \                     ??mbedtls_pk_verify_ext_5: (+1)
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x....'....        BL       mbedtls_pk_get_len
   \       0x4A   0x4581             CMP      R9,R0
   \       0x4C   0xD201             BCS.N    ??mbedtls_pk_verify_ext_6
    223                      return( MBEDTLS_ERR_RSA_VERIFY_FAILED );
   \       0x4E   0x....             LDR.N    R0,??DataTable11_8  ;; 0xffffbc80
   \       0x50   0xE02B             B.N      ??mbedtls_pk_verify_ext_2
    224          
    225                  ret = mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_pk_rsa( *ctx ),
    226                          NULL, NULL, MBEDTLS_RSA_PUBLIC,
    227                          md_alg, (unsigned int) hash_len, hash,
    228                          pss_opts->mgf1_hash_id,
    229                          pss_opts->expected_salt_len,
    230                          sig );
   \                     ??mbedtls_pk_verify_ext_6: (+1)
   \       0x52   0xE9D5 0x0100      LDRD     R0,R1,[R5, #+0]
   \       0x56   0x....'....        BL       mbedtls_pk_rsa
   \       0x5A   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \       0x5E   0x6861             LDR      R1,[R4, #+4]
   \       0x60   0x9104             STR      R1,[SP, #+16]
   \       0x62   0x7821             LDRB     R1,[R4, #+0]
   \       0x64   0x9103             STR      R1,[SP, #+12]
   \       0x66   0x9602             STR      R6,[SP, #+8]
   \       0x68   0x9701             STR      R7,[SP, #+4]
   \       0x6A   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \       0x6E   0x2300             MOVS     R3,#+0
   \       0x70   0x461A             MOV      R2,R3
   \       0x72   0x4611             MOV      R1,R2
   \       0x74   0x....'....        BL       mbedtls_rsa_rsassa_pss_verify_ext
    231                  if( ret != 0 )
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD116             BNE.N    ??mbedtls_pk_verify_ext_2
    232                      return( ret );
    233          
    234                  if( sig_len > mbedtls_pk_get_len( ctx ) )
   \       0x7C   0x4628             MOV      R0,R5
   \       0x7E   0x....'....        BL       mbedtls_pk_get_len
   \       0x82   0x4548             CMP      R0,R9
   \       0x84   0xD201             BCS.N    ??mbedtls_pk_verify_ext_7
    235                      return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
   \       0x86   0x....             LDR.N    R0,??DataTable11_9  ;; 0xffffc700
   \       0x88   0xE00F             B.N      ??mbedtls_pk_verify_ext_2
    236          
    237                  return( 0 );
   \                     ??mbedtls_pk_verify_ext_7: (+1)
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xE00D             B.N      ??mbedtls_pk_verify_ext_2
    238          #else
    239                  return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
    240          #endif /* MBEDTLS_RSA_C && MBEDTLS_PKCS1_V21 */
    241              }
    242          
    243              /* General case: no options */
    244              if( options != NULL )
   \                     ??mbedtls_pk_verify_ext_4: (+1)
   \       0x8E   0x2C00             CMP      R4,#+0
   \       0x90   0xD001             BEQ.N    ??mbedtls_pk_verify_ext_8
    245                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \       0x92   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \       0x94   0xE009             B.N      ??mbedtls_pk_verify_ext_2
    246          
    247              return( mbedtls_pk_verify( ctx, md_alg, hash, hash_len, sig, sig_len ) );
   \                     ??mbedtls_pk_verify_ext_8: (+1)
   \       0x96   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x9A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x9E   0x463B             MOV      R3,R7
   \       0xA0   0x4632             MOV      R2,R6
   \       0xA2   0x4651             MOV      R1,R10
   \       0xA4   0x4628             MOV      R0,R5
   \       0xA6   0x....'....        BL       mbedtls_pk_verify
   \                     ??mbedtls_pk_verify_ext_2: (+1)
   \       0xAA   0xB007             ADD      SP,SP,#+28
   \       0xAC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    248          }
    249          
    250          /*
    251           * Make a signature
    252           */

   \                                 In section .text, align 2, keep-with-next
    253          int mbedtls_pk_sign( mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
    254                       const unsigned char *hash, size_t hash_len,
    255                       unsigned char *sig, size_t *sig_len,
    256                       int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    257          {
   \                     mbedtls_pk_sign: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
    258              if( ctx == NULL || ctx->pk_info == NULL ||
    259                  pk_hashlen_helper( md_alg, &hash_len ) != 0 )
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD008             BEQ.N    ??mbedtls_pk_sign_0
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD005             BEQ.N    ??mbedtls_pk_sign_0
   \       0x14   0xA905             ADD      R1,SP,#+20
   \       0x16   0x4630             MOV      R0,R6
   \       0x18   0x....'....        BL       pk_hashlen_helper
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD001             BEQ.N    ??mbedtls_pk_sign_1
    260                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_sign_0: (+1)
   \       0x20   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \       0x22   0xE014             B.N      ??mbedtls_pk_sign_2
    261          
    262              if( ctx->pk_info->sign_func == NULL )
   \                     ??mbedtls_pk_sign_1: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6940             LDR      R0,[R0, #+20]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD101             BNE.N    ??mbedtls_pk_sign_3
    263                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \       0x2C   0x....             LDR.N    R0,??DataTable11_7  ;; 0xffffc100
   \       0x2E   0xE00E             B.N      ??mbedtls_pk_sign_2
   \                     ??mbedtls_pk_sign_3: (+1)
   \       0x30   0x9B0D             LDR      R3,[SP, #+52]
   \       0x32   0x9A0C             LDR      R2,[SP, #+48]
   \       0x34   0x990B             LDR      R1,[SP, #+44]
   \       0x36   0x980A             LDR      R0,[SP, #+40]
    264          
    265              return( ctx->pk_info->sign_func( ctx->pk_ctx, md_alg, hash, hash_len,
    266                                               sig, sig_len, f_rng, p_rng ) );
   \       0x38   0x9303             STR      R3,[SP, #+12]
   \       0x3A   0x9202             STR      R2,[SP, #+8]
   \       0x3C   0x9101             STR      R1,[SP, #+4]
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0x9B05             LDR      R3,[SP, #+20]
   \       0x42   0x462A             MOV      R2,R5
   \       0x44   0x4631             MOV      R1,R6
   \       0x46   0x6860             LDR      R0,[R4, #+4]
   \       0x48   0x6824             LDR      R4,[R4, #+0]
   \       0x4A   0x6964             LDR      R4,[R4, #+20]
   \       0x4C   0x47A0             BLX      R4
   \                     ??mbedtls_pk_sign_2: (+1)
   \       0x4E   0xB006             ADD      SP,SP,#+24
   \       0x50   0xBD70             POP      {R4-R6,PC}       ;; return
    267          }
    268          
    269          /*
    270           * Decrypt message
    271           */

   \                                 In section .text, align 2, keep-with-next
    272          int mbedtls_pk_decrypt( mbedtls_pk_context *ctx,
    273                          const unsigned char *input, size_t ilen,
    274                          unsigned char *output, size_t *olen, size_t osize,
    275                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    276          {
   \                     mbedtls_pk_decrypt: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
    277              if( ctx == NULL || ctx->pk_info == NULL )
   \        0x6   0xD002             BEQ.N    ??mbedtls_pk_decrypt_0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??mbedtls_pk_decrypt_1
    278                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_decrypt_0: (+1)
   \        0xE   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \       0x10   0xE010             B.N      ??mbedtls_pk_decrypt_2
    279          
    280              if( ctx->pk_info->decrypt_func == NULL )
   \                     ??mbedtls_pk_decrypt_1: (+1)
   \       0x12   0x6980             LDR      R0,[R0, #+24]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??mbedtls_pk_decrypt_3
    281                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \       0x18   0x....             LDR.N    R0,??DataTable11_7  ;; 0xffffc100
   \       0x1A   0xE00B             B.N      ??mbedtls_pk_decrypt_2
   \                     ??mbedtls_pk_decrypt_3: (+1)
   \       0x1C   0x9F0D             LDR      R7,[SP, #+52]
   \       0x1E   0x9E0C             LDR      R6,[SP, #+48]
   \       0x20   0x9D0B             LDR      R5,[SP, #+44]
   \       0x22   0x980A             LDR      R0,[SP, #+40]
    282          
    283              return( ctx->pk_info->decrypt_func( ctx->pk_ctx, input, ilen,
    284                          output, olen, osize, f_rng, p_rng ) );
   \       0x24   0x9703             STR      R7,[SP, #+12]
   \       0x26   0x9602             STR      R6,[SP, #+8]
   \       0x28   0x9501             STR      R5,[SP, #+4]
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x6860             LDR      R0,[R4, #+4]
   \       0x2E   0x6824             LDR      R4,[R4, #+0]
   \       0x30   0x69A4             LDR      R4,[R4, #+24]
   \       0x32   0x47A0             BLX      R4
   \                     ??mbedtls_pk_decrypt_2: (+1)
   \       0x34   0xB005             ADD      SP,SP,#+20
   \       0x36   0xBDF0             POP      {R4-R7,PC}       ;; return
    285          }
    286          
    287          /*
    288           * Encrypt message
    289           */

   \                                 In section .text, align 2, keep-with-next
    290          int mbedtls_pk_encrypt( mbedtls_pk_context *ctx,
    291                          const unsigned char *input, size_t ilen,
    292                          unsigned char *output, size_t *olen, size_t osize,
    293                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    294          {
   \                     mbedtls_pk_encrypt: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
    295              if( ctx == NULL || ctx->pk_info == NULL )
   \        0x6   0xD002             BEQ.N    ??mbedtls_pk_encrypt_0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??mbedtls_pk_encrypt_1
    296                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_encrypt_0: (+1)
   \        0xE   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \       0x10   0xE010             B.N      ??mbedtls_pk_encrypt_2
    297          
    298              if( ctx->pk_info->encrypt_func == NULL )
   \                     ??mbedtls_pk_encrypt_1: (+1)
   \       0x12   0x69C0             LDR      R0,[R0, #+28]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??mbedtls_pk_encrypt_3
    299                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \       0x18   0x....             LDR.N    R0,??DataTable11_7  ;; 0xffffc100
   \       0x1A   0xE00B             B.N      ??mbedtls_pk_encrypt_2
   \                     ??mbedtls_pk_encrypt_3: (+1)
   \       0x1C   0x9F0D             LDR      R7,[SP, #+52]
   \       0x1E   0x9E0C             LDR      R6,[SP, #+48]
   \       0x20   0x9D0B             LDR      R5,[SP, #+44]
   \       0x22   0x980A             LDR      R0,[SP, #+40]
    300          
    301              return( ctx->pk_info->encrypt_func( ctx->pk_ctx, input, ilen,
    302                          output, olen, osize, f_rng, p_rng ) );
   \       0x24   0x9703             STR      R7,[SP, #+12]
   \       0x26   0x9602             STR      R6,[SP, #+8]
   \       0x28   0x9501             STR      R5,[SP, #+4]
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x6860             LDR      R0,[R4, #+4]
   \       0x2E   0x6824             LDR      R4,[R4, #+0]
   \       0x30   0x69E4             LDR      R4,[R4, #+28]
   \       0x32   0x47A0             BLX      R4
   \                     ??mbedtls_pk_encrypt_2: (+1)
   \       0x34   0xB005             ADD      SP,SP,#+20
   \       0x36   0xBDF0             POP      {R4-R7,PC}       ;; return
    303          }
    304          
    305          /*
    306           * Check public-private key pair
    307           */

   \                                 In section .text, align 2, keep-with-next
    308          int mbedtls_pk_check_pair( const mbedtls_pk_context *pub, const mbedtls_pk_context *prv )
    309          {
   \                     mbedtls_pk_check_pair: (+1)
   \        0x0   0x460A             MOV      R2,R1
    310              if( pub == NULL || pub->pk_info == NULL ||
    311                  prv == NULL || prv->pk_info == NULL ||
    312                  prv->pk_info->check_pair_func == NULL )
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD00A             BEQ.N    ??mbedtls_pk_check_pair_0
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD007             BEQ.N    ??mbedtls_pk_check_pair_0
   \        0xC   0x2A00             CMP      R2,#+0
   \        0xE   0xD005             BEQ.N    ??mbedtls_pk_check_pair_0
   \       0x10   0x6811             LDR      R1,[R2, #+0]
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD002             BEQ.N    ??mbedtls_pk_check_pair_0
   \       0x16   0x6A09             LDR      R1,[R1, #+32]
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD101             BNE.N    ??mbedtls_pk_check_pair_1
    313              {
    314                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_check_pair_0: (+1)
   \       0x1C   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \       0x1E   0x4770             BX       LR
    315              }
    316          
    317              if( prv->pk_info->type == MBEDTLS_PK_RSA_ALT )
   \                     ??mbedtls_pk_check_pair_1: (+1)
   \       0x20   0x6811             LDR      R1,[R2, #+0]
   \       0x22   0x7809             LDRB     R1,[R1, #+0]
   \       0x24   0x2905             CMP      R1,#+5
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0xD107             BNE.N    ??mbedtls_pk_check_pair_2
    318              {
    319                  if( pub->pk_info->type != MBEDTLS_PK_RSA )
   \       0x2A   0x7809             LDRB     R1,[R1, #+0]
   \       0x2C   0x2901             CMP      R1,#+1
   \       0x2E   0xD107             BNE.N    ??mbedtls_pk_check_pair_3
    320                      return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
    321              }
    322              else
    323              {
    324                  if( pub->pk_info != prv->pk_info )
    325                      return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
    326              }
    327          
    328              return( prv->pk_info->check_pair_func( pub->pk_ctx, prv->pk_ctx ) );
   \                     ??mbedtls_pk_check_pair_4: (+1)
   \       0x30   0x6851             LDR      R1,[R2, #+4]
   \       0x32   0x6840             LDR      R0,[R0, #+4]
   \       0x34   0x6812             LDR      R2,[R2, #+0]
   \       0x36   0x6A12             LDR      R2,[R2, #+32]
   \       0x38   0x4710             BX       R2
   \                     ??mbedtls_pk_check_pair_2: (+1)
   \       0x3A   0x6813             LDR      R3,[R2, #+0]
   \       0x3C   0x4299             CMP      R1,R3
   \       0x3E   0xD0F7             BEQ.N    ??mbedtls_pk_check_pair_4
   \                     ??mbedtls_pk_check_pair_3: (+1)
   \       0x40   0x....             LDR.N    R0,??DataTable11_7  ;; 0xffffc100
   \       0x42   0x4770             BX       LR
    329          }
    330          
    331          /*
    332           * Get key size in bits
    333           */

   \                                 In section .text, align 2, keep-with-next
    334          size_t mbedtls_pk_get_bitlen( const mbedtls_pk_context *ctx )
    335          {
   \                     mbedtls_pk_get_bitlen: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    336              if( ctx == NULL || ctx->pk_info == NULL )
   \        0x2   0xD002             BEQ.N    ??mbedtls_pk_get_bitlen_0
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD101             BNE.N    ??mbedtls_pk_get_bitlen_1
    337                  return( 0 );
   \                     ??mbedtls_pk_get_bitlen_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    338          
    339              return( ctx->pk_info->get_bitlen( ctx->pk_ctx ) );
   \                     ??mbedtls_pk_get_bitlen_1: (+1)
   \        0xE   0x6848             LDR      R0,[R1, #+4]
   \       0x10   0x6809             LDR      R1,[R1, #+0]
   \       0x12   0x6889             LDR      R1,[R1, #+8]
   \       0x14   0x4708             BX       R1
    340          }
    341          
    342          /*
    343           * Export debug information
    344           */

   \                                 In section .text, align 2, keep-with-next
    345          int mbedtls_pk_debug( const mbedtls_pk_context *ctx, mbedtls_pk_debug_item *items )
    346          {
   \                     mbedtls_pk_debug: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x0002             MOVS     R2,R0
    347              if( ctx == NULL || ctx->pk_info == NULL )
   \        0x4   0xD002             BEQ.N    ??mbedtls_pk_debug_0
   \        0x6   0x6810             LDR      R0,[R2, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??mbedtls_pk_debug_1
    348                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_debug_0: (+1)
   \        0xC   0x....             LDR.N    R0,??DataTable11_4  ;; 0xffffc180
   \        0xE   0xBD02             POP      {R1,PC}
    349          
    350              if( ctx->pk_info->debug_func == NULL )
   \                     ??mbedtls_pk_debug_1: (+1)
   \       0x10   0x6AC0             LDR      R0,[R0, #+44]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??mbedtls_pk_debug_2
    351                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \       0x16   0x....             LDR.N    R0,??DataTable11_7  ;; 0xffffc100
   \       0x18   0xBD02             POP      {R1,PC}
    352          
    353              ctx->pk_info->debug_func( ctx->pk_ctx, items );
   \                     ??mbedtls_pk_debug_2: (+1)
   \       0x1A   0x6850             LDR      R0,[R2, #+4]
   \       0x1C   0x6812             LDR      R2,[R2, #+0]
   \       0x1E   0x6AD2             LDR      R2,[R2, #+44]
   \       0x20   0x4790             BLX      R2
    354              return( 0 );
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD02             POP      {R1,PC}          ;; return
    355          }
    356          
    357          /*
    358           * Access the PK type name
    359           */

   \                                 In section .text, align 2, keep-with-next
    360          const char *mbedtls_pk_get_name( const mbedtls_pk_context *ctx )
    361          {
    362              if( ctx == NULL || ctx->pk_info == NULL )
   \                     mbedtls_pk_get_name: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD002             BEQ.N    ??mbedtls_pk_get_name_0
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??mbedtls_pk_get_name_1
    363                  return( "invalid PK" );
   \                     ??mbedtls_pk_get_name_0: (+1)
   \        0xA   0x....             LDR.N    R0,??DataTable11_10
   \        0xC   0x4770             BX       LR
    364          
    365              return( ctx->pk_info->name );
   \                     ??mbedtls_pk_get_name_1: (+1)
   \        0xE   0x4608             MOV      R0,R1
   \       0x10   0x6840             LDR      R0,[R0, #+4]
   \       0x12   0x4770             BX       LR               ;; return
    366          }
    367          
    368          /*
    369           * Access the PK type
    370           */

   \                                 In section .text, align 2, keep-with-next
    371          mbedtls_pk_type_t mbedtls_pk_get_type( const mbedtls_pk_context *ctx )
    372          {
    373              if( ctx == NULL || ctx->pk_info == NULL )
   \                     mbedtls_pk_get_type: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD002             BEQ.N    ??mbedtls_pk_get_type_0
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??mbedtls_pk_get_type_1
    374                  return( MBEDTLS_PK_NONE );
   \                     ??mbedtls_pk_get_type_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    375          
    376              return( ctx->pk_info->type );
   \                     ??mbedtls_pk_get_type_1: (+1)
   \        0xE   0x4608             MOV      R0,R1
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   \       0x12   0x4770             BX       LR               ;; return
    377          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     mbedtls_rsa_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     mbedtls_eckey_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x....'....        DC32     mbedtls_eckeydh_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x....'....        DC32     mbedtls_ecdsa_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0xFFFF'C180        DC32     0xffffc180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0xFFFF'C080        DC32     0xffffc080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x....'....        DC32     mbedtls_rsa_alt_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0xFFFF'C100        DC32     0xffffc100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0xFFFF'BC80        DC32     0xffffbc80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \        0x0   0xFFFF'C700        DC32     0xffffc700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x6E          DC8 "invalid PK"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x50 0x4B    
   \              0x00         
   \        0xB   0x00               DC8 0
    378          
    379          #endif /* MBEDTLS_PK_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_pk_can_do
         0   -- Indirect call
       0   mbedtls_pk_check_pair
         0   -- Indirect call
       8   mbedtls_pk_debug
         8   -- Indirect call
      40   mbedtls_pk_decrypt
        40   -- Indirect call
      40   mbedtls_pk_encrypt
        40   -- Indirect call
       8   mbedtls_pk_free
         8   -- Indirect call
         0   -> mbedtls_platform_zeroize
       0   mbedtls_pk_get_bitlen
         0   -- Indirect call
       8   mbedtls_pk_get_len
         8   -> mbedtls_pk_get_bitlen
       0   mbedtls_pk_get_name
       0   mbedtls_pk_get_type
       0   mbedtls_pk_info_from_type
       0   mbedtls_pk_init
       0   mbedtls_pk_rsa
      16   mbedtls_pk_setup
        16   -- Indirect call
      24   mbedtls_pk_setup_rsa_alt
        24   -- Indirect call
      40   mbedtls_pk_sign
        40   -- Indirect call
        40   -> pk_hashlen_helper
      32   mbedtls_pk_verify
        32   -- Indirect call
        32   -> pk_hashlen_helper
      64   mbedtls_pk_verify_ext
        64   -> mbedtls_pk_can_do
        64   -> mbedtls_pk_get_len
        64   -> mbedtls_pk_rsa
        64   -> mbedtls_pk_verify
        64   -> mbedtls_rsa_rsassa_pss_verify_ext
       8   pk_hashlen_helper
         8   -> mbedtls_md_get_size
         8   -> mbedtls_md_info_from_type


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      12  ?_0
      22  mbedtls_pk_can_do
      68  mbedtls_pk_check_pair
      38  mbedtls_pk_debug
      56  mbedtls_pk_decrypt
      56  mbedtls_pk_encrypt
      34  mbedtls_pk_free
      22  mbedtls_pk_get_bitlen
      12  mbedtls_pk_get_len
      20  mbedtls_pk_get_name
      20  mbedtls_pk_get_type
      42  mbedtls_pk_info_from_type
      12  mbedtls_pk_init
       4  mbedtls_pk_rsa
      48  mbedtls_pk_setup
      68  mbedtls_pk_setup_rsa_alt
      82  mbedtls_pk_sign
      72  mbedtls_pk_verify
     176  mbedtls_pk_verify_ext
      38  pk_hashlen_helper

 
  12 bytes in section .rodata
 934 bytes in section .text
 
 934 bytes of CODE  memory
  12 bytes of CONST memory

Errors: none
Warnings: none
