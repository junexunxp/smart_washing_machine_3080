###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:29
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\infra_sha256.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW1A2.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\infra\infra_sha256.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\infra_sha256.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\infra_sha256.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\infra\infra_sha256.c
      1          /*
      2           * Copyright (C) 2015-2018 Alibaba Group Holding Limited
      3           */
      4          #include "infra_config.h"
      5          
      6          #ifdef INFRA_SHA256
      7          
      8          #define INFRA_SHA256_SMALLER
      9          
     10          #include <stdlib.h>
     11          #include <string.h>
     12          #include "infra_sha256.h"
     13          
     14          #define SHA256_KEY_IOPAD_SIZE   (64)
     15          #define SHA256_DIGEST_SIZE      (32)
     16          
     17          /*
     18           * 32-bit integer manipulation macros (big endian)
     19           */
     20          #ifndef GET_UINT32_BE
     21          #define GET_UINT32_BE(n,b,i)                            \
     22              do {                                                    \
     23                  (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \
     24                        | ( (uint32_t) (b)[(i) + 1] << 16 )             \
     25                        | ( (uint32_t) (b)[(i) + 2] <<  8 )             \
     26                        | ( (uint32_t) (b)[(i) + 3]       );            \
     27              } while( 0 )
     28          #endif
     29          
     30          #ifndef PUT_UINT32_BE
     31          #define PUT_UINT32_BE(n,b,i)                            \
     32              do {                                                    \
     33                  (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
     34                  (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
     35                  (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
     36                  (b)[(i) + 3] = (unsigned char) ( (n)       );       \
     37              } while( 0 )
     38          #endif
     39          
     40          

   \                                 In section .text, align 2, keep-with-next
     41          static void utils_sha256_zeroize(void *v, uint32_t n)
     42          {
     43              volatile unsigned char *p = v;
   \                     utils_sha256_zeroize: (+1)
   \        0x0   0xE002             B.N      ??utils_sha256_zeroize_0
     44              while (n--) {
     45                  *p++ = 0;
   \                     ??utils_sha256_zeroize_1: (+1)
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0xF800 0x2B01      STRB     R2,[R0], #+1
     46              }
   \                     ??utils_sha256_zeroize_0: (+1)
   \        0x8   0x460A             MOV      R2,R1
   \        0xA   0x1E51             SUBS     R1,R2,#+1
   \        0xC   0x2A00             CMP      R2,#+0
   \        0xE   0xD1F8             BNE.N    ??utils_sha256_zeroize_1
     47          }
   \       0x10   0x4770             BX       LR               ;; return
     48          

   \                                 In section .text, align 2, keep-with-next
     49          void utils_sha256_init(iot_sha256_context *ctx)
     50          {
     51              memset(ctx, 0, sizeof(iot_sha256_context));
   \                     utils_sha256_init: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x216C             MOVS     R1,#+108
   \        0x4   0x....'....        B.W      __aeabi_memset4
     52          }
     53          

   \                                 In section .text, align 2, keep-with-next
     54          void utils_sha256_free(iot_sha256_context *ctx)
     55          {
     56              if (NULL == ctx) {
   \                     utils_sha256_free: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??utils_sha256_free_0
     57                  return;
     58              }
     59          
     60              utils_sha256_zeroize(ctx, sizeof(iot_sha256_context));
   \        0x4   0x216C             MOVS     R1,#+108
   \        0x6   0x....             B.N      utils_sha256_zeroize
   \                     ??utils_sha256_free_0: (+1)
   \        0x8   0x4770             BX       LR               ;; return
     61          }
     62          

   \                                 In section .text, align 2, keep-with-next
     63          void utils_sha256_starts(iot_sha256_context *ctx)
     64          {
     65              int is224 = 0;
     66              ctx->total[0] = 0;
   \                     utils_sha256_starts: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
     67              ctx->total[1] = 0;
   \        0x4   0x6041             STR      R1,[R0, #+4]
     68          
     69              if (is224 == 0) {
     70                  /* SHA-256 */
     71                  ctx->state[0] = 0x6A09E667;
   \        0x6   0x....             LDR.N    R1,??DataTable3  ;; 0x6a09e667
   \        0x8   0x6081             STR      R1,[R0, #+8]
     72                  ctx->state[1] = 0xBB67AE85;
   \        0xA   0x....             LDR.N    R1,??DataTable3_1  ;; 0xbb67ae85
   \        0xC   0x60C1             STR      R1,[R0, #+12]
     73                  ctx->state[2] = 0x3C6EF372;
   \        0xE   0x....             LDR.N    R1,??DataTable3_2  ;; 0x3c6ef372
   \       0x10   0x6101             STR      R1,[R0, #+16]
     74                  ctx->state[3] = 0xA54FF53A;
   \       0x12   0x....             LDR.N    R1,??DataTable3_3  ;; 0xa54ff53a
   \       0x14   0x6141             STR      R1,[R0, #+20]
     75                  ctx->state[4] = 0x510E527F;
   \       0x16   0x....             LDR.N    R1,??DataTable3_4  ;; 0x510e527f
   \       0x18   0x6181             STR      R1,[R0, #+24]
     76                  ctx->state[5] = 0x9B05688C;
   \       0x1A   0x....             LDR.N    R1,??DataTable3_5  ;; 0x9b05688c
   \       0x1C   0x61C1             STR      R1,[R0, #+28]
     77                  ctx->state[6] = 0x1F83D9AB;
   \       0x1E   0x....             LDR.N    R1,??DataTable3_6  ;; 0x1f83d9ab
   \       0x20   0x6201             STR      R1,[R0, #+32]
     78                  ctx->state[7] = 0x5BE0CD19;
   \       0x22   0x....             LDR.N    R1,??DataTable3_7  ;; 0x5be0cd19
   \       0x24   0x6241             STR      R1,[R0, #+36]
     79              }
     80          
     81              ctx->is224 = is224;
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x6681             STR      R1,[R0, #+104]
     82          }
   \       0x2A   0x4770             BX       LR               ;; return
     83          

   \                                 In section .rodata, align 4
     84          static const uint32_t K[] = {
   \                     K:
   \        0x0   0x428A'2F98        DC32 1116352408, 1899447441, 3049323471, 3921009573, 961987163
   \              0x7137'4491  
   \              0xB5C0'FBCF  
   \              0xE9B5'DBA5  
   \              0x3956'C25B  
   \       0x14   0x59F1'11F1        DC32 1508970993, 2453635748, 2870763221, 3624381080, 310598401
   \              0x923F'82A4  
   \              0xAB1C'5ED5  
   \              0xD807'AA98  
   \              0x1283'5B01  
   \       0x28   0x2431'85BE        DC32 607225278, 1426881987, 1925078388, 2162078206, 2614888103
   \              0x550C'7DC3  
   \              0x72BE'5D74  
   \              0x80DE'B1FE  
   \              0x9BDC'06A7  
   \       0x3C   0xC19B'F174        DC32 3248222580, 3835390401, 4022224774, 264347078, 604807628
   \              0xE49B'69C1  
   \              0xEFBE'4786  
   \              0x0FC1'9DC6  
   \              0x240C'A1CC  
   \       0x50   0x2DE9'2C6F        DC32 770255983, 1249150122, 1555081692, 1996064986, 2554220882
   \              0x4A74'84AA  
   \              0x5CB0'A9DC  
   \              0x76F9'88DA  
   \              0x983E'5152  
   \       0x64   0xA831'C66D        DC32 2821834349, 2952996808, 3210313671, 3336571891, 3584528711
   \              0xB003'27C8  
   \              0xBF59'7FC7  
   \              0xC6E0'0BF3  
   \              0xD5A7'9147  
   \       0x78   0x06CA'6351        DC32 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291
   \              0x1429'2967  
   \              0x27B7'0A85  
   \              0x2E1B'2138  
   \              0x4D2C'6DFC  
   \              0x5338'0D13  
   \       0x90   0x650A'7354        DC32 1695183700, 1986661051, 2177026350, 2456956037, 2730485921
   \              0x766A'0ABB  
   \              0x81C2'C92E  
   \              0x9272'2C85  
   \              0xA2BF'E8A1  
   \       0xA4   0xA81A'664B        DC32 2820302411, 3259730800, 3345764771, 3516065817, 3600352804
   \              0xC24B'8B70  
   \              0xC76C'51A3  
   \              0xD192'E819  
   \              0xD699'0624  
   \       0xB8   0xF40E'3585        DC32 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877
   \              0x106A'A070  
   \              0x19A4'C116  
   \              0x1E37'6C08  
   \              0x2748'774C  
   \              0x34B0'BCB5  
   \       0xD0   0x391C'0CB3        DC32 958139571, 1322822218, 1537002063, 1747873779, 1955562222
   \              0x4ED8'AA4A  
   \              0x5B9C'CA4F  
   \              0x682E'6FF3  
   \              0x748F'82EE  
   \       0xE4   0x78A5'636F        DC32 2024104815, 2227730452, 2361852424, 2428436474, 2756734187
   \              0x84C8'7814  
   \              0x8CC7'0208  
   \              0x90BE'FFFA  
   \              0xA450'6CEB  
   \       0xF8   0xBEF9'A3F7        DC32 3204031479, 3329325298
   \              0xC671'78F2  
     85              0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
     86              0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
     87              0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
     88              0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
     89              0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
     90              0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
     91              0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
     92              0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
     93              0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
     94              0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
     95              0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
     96              0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
     97              0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
     98              0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
     99              0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
    100              0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2,
    101          };
    102          
    103          #define  SHR(x,n) ((x & 0xFFFFFFFF) >> n)
    104          #define ROTR(x,n) (SHR(x,n) | (x << (32 - n)))
    105          
    106          #define S0(x) (ROTR(x, 7) ^ ROTR(x,18) ^  SHR(x, 3))
    107          #define S1(x) (ROTR(x,17) ^ ROTR(x,19) ^  SHR(x,10))
    108          
    109          #define S2(x) (ROTR(x, 2) ^ ROTR(x,13) ^ ROTR(x,22))
    110          #define S3(x) (ROTR(x, 6) ^ ROTR(x,11) ^ ROTR(x,25))
    111          
    112          #define F0(x,y,z) ((x & y) | (z & (x | y)))
    113          #define F1(x,y,z) (z ^ (x & (y ^ z)))
    114          
    115          #define R(t)                                    \
    116              (                                               \
    117                      W[t] = S1(W[t -  2]) + W[t -  7] +          \
    118                             S0(W[t - 15]) + W[t - 16]            \
    119              )
    120          
    121          #define P(a,b,c,d,e,f,g,h,x,K)                  \
    122              {                                               \
    123                  temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    124                  temp2 = S2(a) + F0(a,b,c);                  \
    125                  d += temp1; h = temp1 + temp2;              \
    126              }
    127          

   \                                 In section .text, align 2, keep-with-next
    128          void utils_sha256_process(iot_sha256_context *ctx, const unsigned char data[64])
    129          {
   \                     utils_sha256_process: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB0C8             SUB      SP,SP,#+288
    130              uint32_t temp1, temp2, W[64];
    131              uint32_t A[8];
    132              unsigned int i;
    133          
    134              for (i = 0; i < 8; i++) {
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x466C             MOV      R4,SP
   \        0x8   0xE005             B.N      ??utils_sha256_process_0
    135                  A[i] = ctx->state[i];
   \                     ??utils_sha256_process_1: (+1)
   \        0xA   0xEB00 0x0382      ADD      R3,R0,R2, LSL #+2
   \        0xE   0x689B             LDR      R3,[R3, #+8]
   \       0x10   0xF844 0x3022      STR      R3,[R4, R2, LSL #+2]
    136              }
   \       0x14   0x1C52             ADDS     R2,R2,#+1
   \                     ??utils_sha256_process_0: (+1)
   \       0x16   0x2A08             CMP      R2,#+8
   \       0x18   0xD3F7             BCC.N    ??utils_sha256_process_1
    137          
    138          #if defined(INFRA_SHA256_SMALLER)
    139              for (i = 0; i < 64; i++) {
   \       0x1A   0x2200             MOVS     R2,#+0
   \                     ??utils_sha256_process_2: (+1)
   \       0x1C   0x2A40             CMP      R2,#+64
   \       0x1E   0xF080 0x809F      BCS.W    ??utils_sha256_process_3
    140                  if (i < 16) {
   \       0x22   0x2A10             CMP      R2,#+16
   \       0x24   0xD332             BCC.N    ??utils_sha256_process_4
    141                      GET_UINT32_BE(W[i], data, 4 * i);
    142                  } else {
    143                      R(i);
   \       0x26   0xAB08             ADD      R3,SP,#+32
   \       0x28   0xEB03 0x0382      ADD      R3,R3,R2, LSL #+2
   \       0x2C   0xF853 0x4C08      LDR      R4,[R3, #-8]
   \       0x30   0x4623             MOV      R3,R4
   \       0x32   0xEA4F 0x43F3      ROR      R3,R3,#+19
   \       0x36   0xEA83 0x4374      EOR      R3,R3,R4, ROR #+17
   \       0x3A   0xAC08             ADD      R4,SP,#+32
   \       0x3C   0xEB04 0x0482      ADD      R4,R4,R2, LSL #+2
   \       0x40   0xF854 0x4C08      LDR      R4,[R4, #-8]
   \       0x44   0xEA83 0x2394      EOR      R3,R3,R4, LSR #+10
   \       0x48   0xAC08             ADD      R4,SP,#+32
   \       0x4A   0xEB04 0x0482      ADD      R4,R4,R2, LSL #+2
   \       0x4E   0xF854 0x4C1C      LDR      R4,[R4, #-28]
   \       0x52   0x18E3             ADDS     R3,R4,R3
   \       0x54   0xAC08             ADD      R4,SP,#+32
   \       0x56   0xEB04 0x0482      ADD      R4,R4,R2, LSL #+2
   \       0x5A   0xF854 0x4C3C      LDR      R4,[R4, #-60]
   \       0x5E   0x4625             MOV      R5,R4
   \       0x60   0xEA4F 0x45B5      ROR      R5,R5,#+18
   \       0x64   0xEA85 0x15F4      EOR      R5,R5,R4, ROR #+7
   \       0x68   0xAC08             ADD      R4,SP,#+32
   \       0x6A   0xEB04 0x0482      ADD      R4,R4,R2, LSL #+2
   \       0x6E   0xF854 0x4C3C      LDR      R4,[R4, #-60]
   \       0x72   0xEA85 0x05D4      EOR      R5,R5,R4, LSR #+3
   \       0x76   0x18EB             ADDS     R3,R5,R3
   \       0x78   0xAC08             ADD      R4,SP,#+32
   \       0x7A   0xEB04 0x0482      ADD      R4,R4,R2, LSL #+2
   \       0x7E   0xF854 0x4C40      LDR      R4,[R4, #-64]
   \       0x82   0x18E3             ADDS     R3,R4,R3
   \       0x84   0xAC08             ADD      R4,SP,#+32
   \       0x86   0xF844 0x3022      STR      R3,[R4, R2, LSL #+2]
   \       0x8A   0xE013             B.N      ??utils_sha256_process_5
    144                  }
   \                     ??utils_sha256_process_4: (+1)
   \       0x8C   0xF811 0x3022      LDRB     R3,[R1, R2, LSL #+2]
   \       0x90   0xEB01 0x0482      ADD      R4,R1,R2, LSL #+2
   \       0x94   0x7864             LDRB     R4,[R4, #+1]
   \       0x96   0x0424             LSLS     R4,R4,#+16
   \       0x98   0xEA44 0x6403      ORR      R4,R4,R3, LSL #+24
   \       0x9C   0xEB01 0x0382      ADD      R3,R1,R2, LSL #+2
   \       0xA0   0x789B             LDRB     R3,[R3, #+2]
   \       0xA2   0xEA44 0x2403      ORR      R4,R4,R3, LSL #+8
   \       0xA6   0xEB01 0x0382      ADD      R3,R1,R2, LSL #+2
   \       0xAA   0x78DB             LDRB     R3,[R3, #+3]
   \       0xAC   0x431C             ORRS     R4,R3,R4
   \       0xAE   0xAB08             ADD      R3,SP,#+32
   \       0xB0   0xF843 0x4022      STR      R4,[R3, R2, LSL #+2]
    145          
    146                  P(A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i], K[i]);
   \                     ??utils_sha256_process_5: (+1)
   \       0xB4   0x466B             MOV      R3,SP
   \       0xB6   0x69DC             LDR      R4,[R3, #+28]
   \       0xB8   0x691D             LDR      R5,[R3, #+16]
   \       0xBA   0x462E             MOV      R6,R5
   \       0xBC   0xEA4F 0x26F6      ROR      R6,R6,#+11
   \       0xC0   0xEA86 0x16B5      EOR      R6,R6,R5, ROR #+6
   \       0xC4   0xEA86 0x6675      EOR      R6,R6,R5, ROR #+25
   \       0xC8   0x1934             ADDS     R4,R6,R4
   \       0xCA   0x699D             LDR      R5,[R3, #+24]
   \       0xCC   0x691E             LDR      R6,[R3, #+16]
   \       0xCE   0x695F             LDR      R7,[R3, #+20]
   \       0xD0   0x46AC             MOV      R12,R5
   \       0xD2   0xEA8C 0x0707      EOR      R7,R12,R7
   \       0xD6   0x403E             ANDS     R6,R7,R6
   \       0xD8   0x4075             EORS     R5,R6,R5
   \       0xDA   0x192C             ADDS     R4,R5,R4
   \       0xDC   0x....             LDR.N    R5,??DataTable3_8
   \       0xDE   0xF855 0x5022      LDR      R5,[R5, R2, LSL #+2]
   \       0xE2   0x192C             ADDS     R4,R5,R4
   \       0xE4   0xAD08             ADD      R5,SP,#+32
   \       0xE6   0xF855 0x5022      LDR      R5,[R5, R2, LSL #+2]
   \       0xEA   0x192C             ADDS     R4,R5,R4
   \       0xEC   0x9E00             LDR      R6,[SP, #+0]
   \       0xEE   0x4635             MOV      R5,R6
   \       0xF0   0xEA4F 0x3575      ROR      R5,R5,#+13
   \       0xF4   0xEA85 0x05B6      EOR      R5,R5,R6, ROR #+2
   \       0xF8   0xEA85 0x55B6      EOR      R5,R5,R6, ROR #+22
   \       0xFC   0x685F             LDR      R7,[R3, #+4]
   \       0xFE   0x403E             ANDS     R6,R7,R6
   \      0x100   0x689F             LDR      R7,[R3, #+8]
   \      0x102   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \      0x106   0xF8D3 0xE004      LDR      LR,[R3, #+4]
   \      0x10A   0xEA4E 0x0C0C      ORR      R12,LR,R12
   \      0x10E   0xEA0C 0x0707      AND      R7,R12,R7
   \      0x112   0x433E             ORRS     R6,R7,R6
   \      0x114   0x1975             ADDS     R5,R6,R5
   \      0x116   0x68DE             LDR      R6,[R3, #+12]
   \      0x118   0x19A6             ADDS     R6,R4,R6
   \      0x11A   0x60DE             STR      R6,[R3, #+12]
   \      0x11C   0x192C             ADDS     R4,R5,R4
   \      0x11E   0x61DC             STR      R4,[R3, #+28]
    147          
    148                  temp1 = A[7];
    149                  A[7] = A[6];
   \      0x120   0x699D             LDR      R5,[R3, #+24]
   \      0x122   0x61DD             STR      R5,[R3, #+28]
    150                  A[6] = A[5];
   \      0x124   0x695D             LDR      R5,[R3, #+20]
   \      0x126   0x619D             STR      R5,[R3, #+24]
    151                  A[5] = A[4];
   \      0x128   0x691D             LDR      R5,[R3, #+16]
   \      0x12A   0x615D             STR      R5,[R3, #+20]
    152                  A[4] = A[3];
   \      0x12C   0x68DD             LDR      R5,[R3, #+12]
   \      0x12E   0x611D             STR      R5,[R3, #+16]
    153                  A[3] = A[2];
   \      0x130   0x689D             LDR      R5,[R3, #+8]
   \      0x132   0x60DD             STR      R5,[R3, #+12]
    154                  A[2] = A[1];
   \      0x134   0x685D             LDR      R5,[R3, #+4]
   \      0x136   0x609D             STR      R5,[R3, #+8]
    155                  A[1] = A[0];
   \      0x138   0x9D00             LDR      R5,[SP, #+0]
   \      0x13A   0x605D             STR      R5,[R3, #+4]
    156                  A[0] = temp1;
   \      0x13C   0x9400             STR      R4,[SP, #+0]
    157              }
   \      0x13E   0x1C52             ADDS     R2,R2,#+1
   \      0x140   0xE76C             B.N      ??utils_sha256_process_2
    158          #else /* INFRA_SHA256_SMALLER */
    159              for (i = 0; i < 16; i++) {
    160                  GET_UINT32_BE(W[i], data, 4 * i);
    161              }
    162          
    163              for (i = 0; i < 16; i += 8) {
    164                  P(A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i + 0], K[i + 0]);
    165                  P(A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i + 1], K[i + 1]);
    166                  P(A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i + 2], K[i + 2]);
    167                  P(A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], W[i + 3], K[i + 3]);
    168                  P(A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], W[i + 4], K[i + 4]);
    169                  P(A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], W[i + 5], K[i + 5]);
    170                  P(A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i + 6], K[i + 6]);
    171                  P(A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i + 7], K[i + 7]);
    172              }
    173          
    174              for (i = 16; i < 64; i += 8) {
    175                  P(A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i + 0), K[i + 0]);
    176                  P(A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i + 1), K[i + 1]);
    177                  P(A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i + 2), K[i + 2]);
    178                  P(A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], R(i + 3), K[i + 3]);
    179                  P(A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], R(i + 4), K[i + 4]);
    180                  P(A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], R(i + 5), K[i + 5]);
    181                  P(A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i + 6), K[i + 6]);
    182                  P(A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i + 7), K[i + 7]);
    183              }
    184          #endif /* INFRA_SHA256_SMALLER */
    185          
    186              for (i = 0; i < 8; i++) {
    187                  ctx->state[i] += A[i];
   \                     ??utils_sha256_process_6: (+1)
   \      0x142   0xEB00 0x0281      ADD      R2,R0,R1, LSL #+2
   \      0x146   0x6892             LDR      R2,[R2, #+8]
   \      0x148   0x466B             MOV      R3,SP
   \      0x14A   0xF853 0x3021      LDR      R3,[R3, R1, LSL #+2]
   \      0x14E   0x189A             ADDS     R2,R3,R2
   \      0x150   0xEB00 0x0381      ADD      R3,R0,R1, LSL #+2
   \      0x154   0x609A             STR      R2,[R3, #+8]
    188              }
   \      0x156   0x1C49             ADDS     R1,R1,#+1
   \                     ??utils_sha256_process_7: (+1)
   \      0x158   0x2908             CMP      R1,#+8
   \      0x15A   0xD3F2             BCC.N    ??utils_sha256_process_6
    189          }
   \      0x15C   0xB048             ADD      SP,SP,#+288
   \      0x15E   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??utils_sha256_process_3: (+1)
   \      0x160   0x2100             MOVS     R1,#+0
   \      0x162   0xE7F9             B.N      ??utils_sha256_process_7

   \                                 In section .text, align 2, keep-with-next
    190          void utils_sha256_update(iot_sha256_context *ctx, const unsigned char *input, uint32_t ilen)
    191          {
   \                     utils_sha256_update: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x0014             MOVS     R4,R2
    192              size_t fill;
    193              uint32_t left;
    194          
    195              if (ilen == 0) {
   \        0xA   0xD039             BEQ.N    ??utils_sha256_update_0
    196                  return;
    197              }
    198          
    199              left = ctx->total[0] & 0x3F;
   \        0xC   0xF898 0x5000      LDRB     R5,[R8, #+0]
   \       0x10   0xF005 0x053F      AND      R5,R5,#0x3F
    200              fill = 64 - left;
   \       0x14   0xF1C5 0x0740      RSB      R7,R5,#+64
    201          
    202              ctx->total[0] += (uint32_t) ilen;
   \       0x18   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x1C   0x1820             ADDS     R0,R4,R0
   \       0x1E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    203              ctx->total[0] &= 0xFFFFFFFF;
   \       0x22   0xF8C8 0x0000      STR      R0,[R8, #+0]
    204          
    205              if (ctx->total[0] < (uint32_t) ilen) {
   \       0x26   0x42A0             CMP      R0,R4
   \       0x28   0xD204             BCS.N    ??utils_sha256_update_1
    206                  ctx->total[1]++;
   \       0x2A   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x2E   0x1C40             ADDS     R0,R0,#+1
   \       0x30   0xF8C8 0x0004      STR      R0,[R8, #+4]
    207              }
    208          
    209              if (left && ilen >= fill) {
   \                     ??utils_sha256_update_1: (+1)
   \       0x34   0x2D00             CMP      R5,#+0
   \       0x36   0xD016             BEQ.N    ??utils_sha256_update_2
   \       0x38   0x42BC             CMP      R4,R7
   \       0x3A   0xD314             BCC.N    ??utils_sha256_update_2
    210                  memcpy((void *)(ctx->buffer + left), input, fill);
   \       0x3C   0x463A             MOV      R2,R7
   \       0x3E   0xEB08 0x0005      ADD      R0,R8,R5
   \       0x42   0x3028             ADDS     R0,R0,#+40
   \       0x44   0x....'....        BL       __aeabi_memcpy
    211                  utils_sha256_process(ctx, ctx->buffer);
   \       0x48   0xF108 0x0128      ADD      R1,R8,#+40
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0x....'....        BL       utils_sha256_process
    212                  input += fill;
   \       0x52   0x443E             ADD      R6,R6,R7
    213                  ilen  -= fill;
   \       0x54   0x1BE4             SUBS     R4,R4,R7
    214                  left = 0;
   \       0x56   0x2500             MOVS     R5,#+0
   \       0x58   0xE005             B.N      ??utils_sha256_update_2
    215              }
    216          
    217              while (ilen >= 64) {
    218                  utils_sha256_process(ctx, input);
   \                     ??utils_sha256_update_3: (+1)
   \       0x5A   0x4631             MOV      R1,R6
   \       0x5C   0x4640             MOV      R0,R8
   \       0x5E   0x....'....        BL       utils_sha256_process
    219                  input += 64;
   \       0x62   0x3640             ADDS     R6,R6,#+64
    220                  ilen  -= 64;
   \       0x64   0x3C40             SUBS     R4,R4,#+64
    221              }
   \                     ??utils_sha256_update_2: (+1)
   \       0x66   0x2C40             CMP      R4,#+64
   \       0x68   0xD2F7             BCS.N    ??utils_sha256_update_3
    222          
    223              if (ilen > 0) {
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD008             BEQ.N    ??utils_sha256_update_0
    224                  memcpy((void *)(ctx->buffer + left), input, ilen);
   \       0x6E   0x4622             MOV      R2,R4
   \       0x70   0x4631             MOV      R1,R6
   \       0x72   0xEB08 0x0005      ADD      R0,R8,R5
   \       0x76   0x3028             ADDS     R0,R0,#+40
   \       0x78   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x7C   0x....'....        B.W      __aeabi_memcpy
    225              }
    226          }
   \                     ??utils_sha256_update_0: (+1)
   \       0x80   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    227          

   \                                 In section .rodata, align 4
    228          static const unsigned char sha256_padding[64] = {
   \                     sha256_padding:
   \        0x0   0x80 0x00          DC8 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x16   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x2D   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
    229              0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    230              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    231              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    232              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    233          };
    234          

   \                                 In section .text, align 2, keep-with-next
    235          void utils_sha256_finish(iot_sha256_context *ctx, uint8_t output[32])
    236          {
   \                     utils_sha256_finish: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    237              uint32_t last, padn;
    238              uint32_t high, low;
    239              unsigned char msglen[8];
    240          
    241              high = (ctx->total[0] >> 29)
    242                     | (ctx->total[1] <<  3);
   \        0x6   0x6821             LDR      R1,[R4, #+0]
   \        0x8   0x6860             LDR      R0,[R4, #+4]
   \        0xA   0x00C0             LSLS     R0,R0,#+3
   \        0xC   0xEA40 0x7051      ORR      R0,R0,R1, LSR #+29
    243              low  = (ctx->total[0] <<  3);
   \       0x10   0x00C9             LSLS     R1,R1,#+3
    244          
    245              PUT_UINT32_BE(high, msglen, 0);
   \       0x12   0x4602             MOV      R2,R0
   \       0x14   0x0E12             LSRS     R2,R2,#+24
   \       0x16   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \       0x1A   0x466A             MOV      R2,SP
   \       0x1C   0x4603             MOV      R3,R0
   \       0x1E   0x0C1B             LSRS     R3,R3,#+16
   \       0x20   0x7053             STRB     R3,[R2, #+1]
   \       0x22   0x4603             MOV      R3,R0
   \       0x24   0x0A1B             LSRS     R3,R3,#+8
   \       0x26   0x7093             STRB     R3,[R2, #+2]
   \       0x28   0x70D0             STRB     R0,[R2, #+3]
    246              PUT_UINT32_BE(low,  msglen, 4);
   \       0x2A   0x4608             MOV      R0,R1
   \       0x2C   0x0E00             LSRS     R0,R0,#+24
   \       0x2E   0x7110             STRB     R0,[R2, #+4]
   \       0x30   0x4608             MOV      R0,R1
   \       0x32   0x0C00             LSRS     R0,R0,#+16
   \       0x34   0x7150             STRB     R0,[R2, #+5]
   \       0x36   0x4608             MOV      R0,R1
   \       0x38   0x0A00             LSRS     R0,R0,#+8
   \       0x3A   0x7190             STRB     R0,[R2, #+6]
   \       0x3C   0x71D1             STRB     R1,[R2, #+7]
    247          
    248              last = ctx->total[0] & 0x3F;
   \       0x3E   0x7822             LDRB     R2,[R4, #+0]
   \       0x40   0xF002 0x023F      AND      R2,R2,#0x3F
    249              padn = (last < 56) ? (56 - last) : (120 - last);
   \       0x44   0x2A38             CMP      R2,#+56
   \       0x46   0xD202             BCS.N    ??utils_sha256_finish_0
   \       0x48   0xF1C2 0x0238      RSB      R2,R2,#+56
   \       0x4C   0xE001             B.N      ??utils_sha256_finish_1
   \                     ??utils_sha256_finish_0: (+1)
   \       0x4E   0xF1C2 0x0278      RSB      R2,R2,#+120
    250          
    251              utils_sha256_update(ctx, sha256_padding, padn);
   \                     ??utils_sha256_finish_1: (+1)
   \       0x52   0x....             LDR.N    R1,??DataTable3_9
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0x....'....        BL       utils_sha256_update
    252              utils_sha256_update(ctx, msglen, 8);
   \       0x5A   0x2208             MOVS     R2,#+8
   \       0x5C   0x4669             MOV      R1,SP
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x....'....        BL       utils_sha256_update
    253          
    254              PUT_UINT32_BE(ctx->state[0], output,  0);
   \       0x64   0x68A0             LDR      R0,[R4, #+8]
   \       0x66   0x0E00             LSRS     R0,R0,#+24
   \       0x68   0x7028             STRB     R0,[R5, #+0]
   \       0x6A   0x68A0             LDR      R0,[R4, #+8]
   \       0x6C   0x0C00             LSRS     R0,R0,#+16
   \       0x6E   0x7068             STRB     R0,[R5, #+1]
   \       0x70   0x68A0             LDR      R0,[R4, #+8]
   \       0x72   0x0A00             LSRS     R0,R0,#+8
   \       0x74   0x70A8             STRB     R0,[R5, #+2]
   \       0x76   0x68A0             LDR      R0,[R4, #+8]
   \       0x78   0x70E8             STRB     R0,[R5, #+3]
    255              PUT_UINT32_BE(ctx->state[1], output,  4);
   \       0x7A   0x68E0             LDR      R0,[R4, #+12]
   \       0x7C   0x0E00             LSRS     R0,R0,#+24
   \       0x7E   0x7128             STRB     R0,[R5, #+4]
   \       0x80   0x68E0             LDR      R0,[R4, #+12]
   \       0x82   0x0C00             LSRS     R0,R0,#+16
   \       0x84   0x7168             STRB     R0,[R5, #+5]
   \       0x86   0x68E0             LDR      R0,[R4, #+12]
   \       0x88   0x0A00             LSRS     R0,R0,#+8
   \       0x8A   0x71A8             STRB     R0,[R5, #+6]
   \       0x8C   0x68E0             LDR      R0,[R4, #+12]
   \       0x8E   0x71E8             STRB     R0,[R5, #+7]
    256              PUT_UINT32_BE(ctx->state[2], output,  8);
   \       0x90   0x6920             LDR      R0,[R4, #+16]
   \       0x92   0x0E00             LSRS     R0,R0,#+24
   \       0x94   0x7228             STRB     R0,[R5, #+8]
   \       0x96   0x6920             LDR      R0,[R4, #+16]
   \       0x98   0x0C00             LSRS     R0,R0,#+16
   \       0x9A   0x7268             STRB     R0,[R5, #+9]
   \       0x9C   0x6920             LDR      R0,[R4, #+16]
   \       0x9E   0x0A00             LSRS     R0,R0,#+8
   \       0xA0   0x72A8             STRB     R0,[R5, #+10]
   \       0xA2   0x6920             LDR      R0,[R4, #+16]
   \       0xA4   0x72E8             STRB     R0,[R5, #+11]
    257              PUT_UINT32_BE(ctx->state[3], output, 12);
   \       0xA6   0x6960             LDR      R0,[R4, #+20]
   \       0xA8   0x0E00             LSRS     R0,R0,#+24
   \       0xAA   0x7328             STRB     R0,[R5, #+12]
   \       0xAC   0x6960             LDR      R0,[R4, #+20]
   \       0xAE   0x0C00             LSRS     R0,R0,#+16
   \       0xB0   0x7368             STRB     R0,[R5, #+13]
   \       0xB2   0x6960             LDR      R0,[R4, #+20]
   \       0xB4   0x0A00             LSRS     R0,R0,#+8
   \       0xB6   0x73A8             STRB     R0,[R5, #+14]
   \       0xB8   0x6960             LDR      R0,[R4, #+20]
   \       0xBA   0x73E8             STRB     R0,[R5, #+15]
    258              PUT_UINT32_BE(ctx->state[4], output, 16);
   \       0xBC   0x69A0             LDR      R0,[R4, #+24]
   \       0xBE   0x0E00             LSRS     R0,R0,#+24
   \       0xC0   0x7428             STRB     R0,[R5, #+16]
   \       0xC2   0x69A0             LDR      R0,[R4, #+24]
   \       0xC4   0x0C00             LSRS     R0,R0,#+16
   \       0xC6   0x7468             STRB     R0,[R5, #+17]
   \       0xC8   0x69A0             LDR      R0,[R4, #+24]
   \       0xCA   0x0A00             LSRS     R0,R0,#+8
   \       0xCC   0x74A8             STRB     R0,[R5, #+18]
   \       0xCE   0x69A0             LDR      R0,[R4, #+24]
   \       0xD0   0x74E8             STRB     R0,[R5, #+19]
    259              PUT_UINT32_BE(ctx->state[5], output, 20);
   \       0xD2   0x69E0             LDR      R0,[R4, #+28]
   \       0xD4   0x0E00             LSRS     R0,R0,#+24
   \       0xD6   0x7528             STRB     R0,[R5, #+20]
   \       0xD8   0x69E0             LDR      R0,[R4, #+28]
   \       0xDA   0x0C00             LSRS     R0,R0,#+16
   \       0xDC   0x7568             STRB     R0,[R5, #+21]
   \       0xDE   0x69E0             LDR      R0,[R4, #+28]
   \       0xE0   0x0A00             LSRS     R0,R0,#+8
   \       0xE2   0x75A8             STRB     R0,[R5, #+22]
   \       0xE4   0x69E0             LDR      R0,[R4, #+28]
   \       0xE6   0x75E8             STRB     R0,[R5, #+23]
    260              PUT_UINT32_BE(ctx->state[6], output, 24);
   \       0xE8   0x6A20             LDR      R0,[R4, #+32]
   \       0xEA   0x0E00             LSRS     R0,R0,#+24
   \       0xEC   0x7628             STRB     R0,[R5, #+24]
   \       0xEE   0x6A20             LDR      R0,[R4, #+32]
   \       0xF0   0x0C00             LSRS     R0,R0,#+16
   \       0xF2   0x7668             STRB     R0,[R5, #+25]
   \       0xF4   0x6A20             LDR      R0,[R4, #+32]
   \       0xF6   0x0A00             LSRS     R0,R0,#+8
   \       0xF8   0x76A8             STRB     R0,[R5, #+26]
   \       0xFA   0x6A20             LDR      R0,[R4, #+32]
   \       0xFC   0x76E8             STRB     R0,[R5, #+27]
    261          
    262              if (ctx->is224 == 0) {
   \       0xFE   0x6EA0             LDR      R0,[R4, #+104]
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD10A             BNE.N    ??utils_sha256_finish_2
    263                  PUT_UINT32_BE(ctx->state[7], output, 28);
   \      0x104   0x6A60             LDR      R0,[R4, #+36]
   \      0x106   0x0E00             LSRS     R0,R0,#+24
   \      0x108   0x7728             STRB     R0,[R5, #+28]
   \      0x10A   0x6A60             LDR      R0,[R4, #+36]
   \      0x10C   0x0C00             LSRS     R0,R0,#+16
   \      0x10E   0x7768             STRB     R0,[R5, #+29]
   \      0x110   0x6A60             LDR      R0,[R4, #+36]
   \      0x112   0x0A00             LSRS     R0,R0,#+8
   \      0x114   0x77A8             STRB     R0,[R5, #+30]
   \      0x116   0x6A60             LDR      R0,[R4, #+36]
   \      0x118   0x77E8             STRB     R0,[R5, #+31]
    264              }
    265          }
   \                     ??utils_sha256_finish_2: (+1)
   \      0x11A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    266          

   \                                 In section .text, align 2, keep-with-next
    267          void utils_sha256(const uint8_t *input, uint32_t ilen, uint8_t output[32])
    268          {
   \                     utils_sha256: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB09B             SUB      SP,SP,#+108
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    269              iot_sha256_context ctx;
    270          
    271              utils_sha256_init(&ctx);
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x....'....        BL       utils_sha256_init
    272              utils_sha256_starts(&ctx);
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x....'....        BL       utils_sha256_starts
    273              utils_sha256_update(&ctx, input, ilen);
   \       0x16   0x462A             MOV      R2,R5
   \       0x18   0x4621             MOV      R1,R4
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0x....'....        BL       utils_sha256_update
    274              utils_sha256_finish(&ctx, output);
   \       0x20   0x4631             MOV      R1,R6
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x....'....        BL       utils_sha256_finish
    275              utils_sha256_free(&ctx);
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x....'....        BL       utils_sha256_free
    276          }
   \       0x2E   0xB01C             ADD      SP,SP,#+112
   \       0x30   0xBD70             POP      {R4-R6,PC}       ;; return
    277          

   \                                 In section .text, align 2, keep-with-next
    278          void utils_hmac_sha256(const uint8_t *msg, uint32_t msg_len, const uint8_t *key, uint32_t key_len, uint8_t output[32])
    279          {
   \                     utils_hmac_sha256: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB0BB             SUB      SP,SP,#+236
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460F             MOV      R7,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x4698             MOV      R8,R3
    280              iot_sha256_context context;
    281              uint8_t k_ipad[SHA256_KEY_IOPAD_SIZE];    /* inner padding - key XORd with ipad  */
    282              uint8_t k_opad[SHA256_KEY_IOPAD_SIZE];    /* outer padding - key XORd with opad */
    283              int32_t i;
    284          
    285              if ((NULL == msg) || (NULL == key) || (NULL == output)) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD052             BEQ.N    ??utils_hmac_sha256_0
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD050             BEQ.N    ??utils_hmac_sha256_0
   \       0x16   0x9D42             LDR      R5,[SP, #+264]
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD04D             BEQ.N    ??utils_hmac_sha256_0
    286                  return;
    287              }
    288          
    289              if (key_len > SHA256_KEY_IOPAD_SIZE) {
   \       0x1C   0xF1B8 0x0F41      CMP      R8,#+65
   \       0x20   0xD24A             BCS.N    ??utils_hmac_sha256_0
    290                  return;
    291              }
    292          
    293              /* start out by storing key in pads */
    294              memset(k_ipad, 0, sizeof(k_ipad));
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x2140             MOVS     R1,#+64
   \       0x26   0xA810             ADD      R0,SP,#+64
   \       0x28   0x....'....        BL       __aeabi_memset4
    295              memset(k_opad, 0, sizeof(k_opad));
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x2140             MOVS     R1,#+64
   \       0x30   0x4668             MOV      R0,SP
   \       0x32   0x....'....        BL       __aeabi_memset4
    296              memcpy(k_ipad, key, key_len);
   \       0x36   0x4642             MOV      R2,R8
   \       0x38   0x4631             MOV      R1,R6
   \       0x3A   0xA810             ADD      R0,SP,#+64
   \       0x3C   0x....'....        BL       __aeabi_memcpy
    297              memcpy(k_opad, key, key_len);
   \       0x40   0x4642             MOV      R2,R8
   \       0x42   0x4631             MOV      R1,R6
   \       0x44   0x4668             MOV      R0,SP
   \       0x46   0x....'....        BL       __aeabi_memcpy
    298          
    299              /* XOR key with ipad and opad values */
    300              for (i = 0; i < SHA256_KEY_IOPAD_SIZE; i++) {
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xE00A             B.N      ??utils_hmac_sha256_1
    301                  k_ipad[i] ^= 0x36;
   \                     ??utils_hmac_sha256_2: (+1)
   \       0x4E   0xA910             ADD      R1,SP,#+64
   \       0x50   0x5C0A             LDRB     R2,[R1, R0]
   \       0x52   0xF082 0x0236      EOR      R2,R2,#0x36
   \       0x56   0x540A             STRB     R2,[R1, R0]
    302                  k_opad[i] ^= 0x5c;
   \       0x58   0x4669             MOV      R1,SP
   \       0x5A   0x5C0A             LDRB     R2,[R1, R0]
   \       0x5C   0xF082 0x025C      EOR      R2,R2,#0x5C
   \       0x60   0x540A             STRB     R2,[R1, R0]
    303              }
   \       0x62   0x1C40             ADDS     R0,R0,#+1
   \                     ??utils_hmac_sha256_1: (+1)
   \       0x64   0x2840             CMP      R0,#+64
   \       0x66   0xDBF2             BLT.N    ??utils_hmac_sha256_2
    304          
    305              /* perform inner SHA */
    306              utils_sha256_init(&context);                                      /* init context for 1st pass */
   \       0x68   0xA820             ADD      R0,SP,#+128
   \       0x6A   0x....'....        BL       utils_sha256_init
    307              utils_sha256_starts(&context);                                    /* setup context for 1st pass */
   \       0x6E   0xA820             ADD      R0,SP,#+128
   \       0x70   0x....'....        BL       utils_sha256_starts
    308              utils_sha256_update(&context, k_ipad, SHA256_KEY_IOPAD_SIZE);     /* start with inner pad */
   \       0x74   0x2240             MOVS     R2,#+64
   \       0x76   0xA910             ADD      R1,SP,#+64
   \       0x78   0xA820             ADD      R0,SP,#+128
   \       0x7A   0x....'....        BL       utils_sha256_update
    309              utils_sha256_update(&context, msg, msg_len);                      /* then text of datagram */
   \       0x7E   0x463A             MOV      R2,R7
   \       0x80   0x4621             MOV      R1,R4
   \       0x82   0xA820             ADD      R0,SP,#+128
   \       0x84   0x....'....        BL       utils_sha256_update
    310              utils_sha256_finish(&context, output);                            /* finish up 1st pass */
   \       0x88   0x4629             MOV      R1,R5
   \       0x8A   0xA820             ADD      R0,SP,#+128
   \       0x8C   0x....'....        BL       utils_sha256_finish
    311          
    312              /* perform outer SHA */
    313              utils_sha256_init(&context);                              /* init context for 2nd pass */
   \       0x90   0xA820             ADD      R0,SP,#+128
   \       0x92   0x....'....        BL       utils_sha256_init
    314              utils_sha256_starts(&context);                            /* setup context for 2nd pass */
   \       0x96   0xA820             ADD      R0,SP,#+128
   \       0x98   0x....'....        BL       utils_sha256_starts
    315              utils_sha256_update(&context, k_opad, SHA256_KEY_IOPAD_SIZE);    /* start with outer pad */
   \       0x9C   0x2240             MOVS     R2,#+64
   \       0x9E   0x4669             MOV      R1,SP
   \       0xA0   0xA820             ADD      R0,SP,#+128
   \       0xA2   0x....'....        BL       utils_sha256_update
    316              utils_sha256_update(&context, output, SHA256_DIGEST_SIZE);     /* then results of 1st hash */
   \       0xA6   0x2220             MOVS     R2,#+32
   \       0xA8   0x4629             MOV      R1,R5
   \       0xAA   0xA820             ADD      R0,SP,#+128
   \       0xAC   0x....'....        BL       utils_sha256_update
    317              utils_sha256_finish(&context, output);                       /* finish up 2nd pass */
   \       0xB0   0x4629             MOV      R1,R5
   \       0xB2   0xA820             ADD      R0,SP,#+128
   \       0xB4   0x....'....        BL       utils_sha256_finish
    318          }
   \                     ??utils_hmac_sha256_0: (+1)
   \       0xB8   0xB03C             ADD      SP,SP,#+240
   \       0xBA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x6A09'E667        DC32     0x6a09e667

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0xBB67'AE85        DC32     0xbb67ae85

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x3C6E'F372        DC32     0x3c6ef372

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0xA54F'F53A        DC32     0xa54ff53a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x510E'527F        DC32     0x510e527f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x9B05'688C        DC32     0x9b05688c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x1F83'D9AB        DC32     0x1f83d9ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x5BE0'CD19        DC32     0x5be0cd19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0x....'....        DC32     K

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \        0x0   0x....'....        DC32     sha256_padding
    319          
    320          #endif
    321          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     264   utils_hmac_sha256
       264   -> __aeabi_memcpy
       264   -> __aeabi_memset4
       264   -> utils_sha256_finish
       264   -> utils_sha256_init
       264   -> utils_sha256_starts
       264   -> utils_sha256_update
     128   utils_sha256
       128   -> utils_sha256_finish
       128   -> utils_sha256_free
       128   -> utils_sha256_init
       128   -> utils_sha256_starts
       128   -> utils_sha256_update
      24   utils_sha256_finish
        24   -> utils_sha256_update
       0   utils_sha256_free
         0   -> utils_sha256_zeroize
       0   utils_sha256_init
         0   -> __aeabi_memset4
     308   utils_sha256_process
       0   utils_sha256_starts
      24   utils_sha256_update
         0   -> __aeabi_memcpy
        24   -> __aeabi_memcpy
        24   -> utils_sha256_process
       0   utils_sha256_zeroize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
     256  K
      64  sha256_padding
     190  utils_hmac_sha256
      50  utils_sha256
     284  utils_sha256_finish
      10  utils_sha256_free
       8  utils_sha256_init
     356  utils_sha256_process
      44  utils_sha256_starts
     132  utils_sha256_update
      18  utils_sha256_zeroize

 
   320 bytes in section .rodata
 1 132 bytes in section .text
 
 1 132 bytes of CODE  memory
   320 bytes of CONST memory

Errors: none
Warnings: none
