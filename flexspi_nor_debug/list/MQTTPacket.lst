###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:37
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\MQTTPacket.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW213D.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\MQTTPacket.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\MQTTPacket.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\MQTTPacket.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\MQTTPacket.c
      1          /*
      2           * Copyright (C) 2015-2018 Alibaba Group Holding Limited
      3           */
      4          
      5          #include "MQTTPacket.h"
      6          
      7          #include <string.h>
      8          
      9          /**
     10           * Encodes the message length according to the MQTT algorithm
     11           * @param buf the buffer into which the encoded data is written
     12           * @param length the length to be encoded
     13           * @return the number of bytes written to buffer
     14           */

   \                                 In section .text, align 2, keep-with-next
     15          int MQTTPacket_encode(unsigned char *buf, int length)
     16          {
   \                     MQTTPacket_encode: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x4602             MOV      R2,R0
     17              int rc = 0;
   \        0x4   0x2000             MOVS     R0,#+0
     18          
     19              do {
     20                  char d = length % 128;
   \                     ??MQTTPacket_encode_0: (+1)
   \        0x6   0x460B             MOV      R3,R1
   \        0x8   0x119B             ASRS     R3,R3,#+6
   \        0xA   0xEB01 0x6353      ADD      R3,R1,R3, LSR #+25
   \        0xE   0x11DB             ASRS     R3,R3,#+7
   \       0x10   0xEBA1 0x13C3      SUB      R3,R1,R3, LSL #+7
     21                  length /= 128;
   \       0x14   0x460C             MOV      R4,R1
   \       0x16   0x11A4             ASRS     R4,R4,#+6
   \       0x18   0xEB01 0x6154      ADD      R1,R1,R4, LSR #+25
   \       0x1C   0x11C9             ASRS     R1,R1,#+7
     22                  /* if there are more digits to encode, set the top bit of this digit */
     23                  if (length > 0) {
   \       0x1E   0x2901             CMP      R1,#+1
   \       0x20   0xDB01             BLT.N    ??MQTTPacket_encode_1
     24                      d |= 0x80;
   \       0x22   0xF043 0x0380      ORR      R3,R3,#0x80
     25                  }
     26                  buf[rc++] = d;
   \                     ??MQTTPacket_encode_1: (+1)
   \       0x26   0x5413             STRB     R3,[R2, R0]
   \       0x28   0x1C40             ADDS     R0,R0,#+1
     27              } while (length > 0);
   \       0x2A   0x2901             CMP      R1,#+1
   \       0x2C   0xDAEB             BGE.N    ??MQTTPacket_encode_0
     28              return rc;
   \       0x2E   0xBC10             POP      {R4}
   \       0x30   0x4770             BX       LR               ;; return
     29          }
     30          
     31          
     32          /**
     33           * Decodes the message length according to the MQTT algorithm
     34           * @param getcharfn pointer to function to read the next character from the data source
     35           * @param value the decoded length returned
     36           * @return the number of bytes read from the socket
     37           */

   \                                 In section .text, align 2, keep-with-next
     38          int MQTTPacket_decode(int (*getcharfn)(unsigned char *, int), int *value)
     39          {
   \                     MQTTPacket_decode: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
     40              unsigned char c;
     41              int multiplier = 1;
   \        0x6   0x2601             MOVS     R6,#+1
     42              int len = 0;
   \        0x8   0x2700             MOVS     R7,#+0
     43          #define MAX_NO_OF_REMAINING_LENGTH_BYTES 4
     44          
     45              *value = 0;
   \        0xA   0x4638             MOV      R0,R7
   \        0xC   0x6028             STR      R0,[R5, #+0]
     46              do {
     47                  int rc = MQTTPACKET_READ_ERROR;
     48          
     49                  if (++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
   \                     ??MQTTPacket_decode_0: (+1)
   \        0xE   0x1C7F             ADDS     R7,R7,#+1
   \       0x10   0x2F05             CMP      R7,#+5
   \       0x12   0xDA11             BGE.N    ??MQTTPacket_decode_1
     50                      rc = MQTTPACKET_READ_ERROR; /* bad data */
     51                      goto exit;
     52                  }
     53                  rc = (*getcharfn)(&c, 1);
     54                  if (rc != 1) {
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x4668             MOV      R0,SP
   \       0x18   0x47A0             BLX      R4
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10C             BNE.N    ??MQTTPacket_decode_1
     55                      goto exit;
     56                  }
     57                  *value += (c & 127) * multiplier;
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x24   0xF001 0x017F      AND      R1,R1,#0x7F
   \       0x28   0xFB06 0x0001      MLA      R0,R6,R1,R0
   \       0x2C   0x6028             STR      R0,[R5, #+0]
     58                  multiplier *= 128;
   \       0x2E   0x01F6             LSLS     R6,R6,#+7
     59              } while ((c & 128) != 0);
   \       0x30   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x34   0x0600             LSLS     R0,R0,#+24
   \       0x36   0xD4EA             BMI.N    ??MQTTPacket_decode_0
     60          exit:
     61              return len;
   \                     ??MQTTPacket_decode_1: (+1)
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     62          }
     63          
     64          

   \                                 In section .text, align 2, keep-with-next
     65          int MQTTPacket_len(int rem_len)
     66          {
     67              rem_len += 1; /* header byte */
   \                     MQTTPacket_len: (+1)
   \        0x0   0x1C40             ADDS     R0,R0,#+1
     68          
     69              /* now remaining_length field */
     70              if (rem_len < 128) {
   \        0x2   0x2880             CMP      R0,#+128
   \        0x4   0xDA01             BGE.N    ??MQTTPacket_len_0
     71                  rem_len += 1;
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   \        0x8   0x4770             BX       LR
     72              } else if (rem_len < 16384) {
   \                     ??MQTTPacket_len_0: (+1)
   \        0xA   0xF5B0 0x4F80      CMP      R0,#+16384
   \        0xE   0xDA01             BGE.N    ??MQTTPacket_len_1
     73                  rem_len += 2;
   \       0x10   0x1C80             ADDS     R0,R0,#+2
   \       0x12   0x4770             BX       LR
     74              } else if (rem_len < 2097151) {
   \                     ??MQTTPacket_len_1: (+1)
   \       0x14   0x....             LDR.N    R1,??DataTable3  ;; 0x1fffff
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xDA01             BGE.N    ??MQTTPacket_len_2
     75                  rem_len += 3;
   \       0x1A   0x1CC0             ADDS     R0,R0,#+3
   \       0x1C   0x4770             BX       LR
     76              } else {
     77                  rem_len += 4;
   \                     ??MQTTPacket_len_2: (+1)
   \       0x1E   0x1D00             ADDS     R0,R0,#+4
     78              }
     79              return rem_len;
   \       0x20   0x4770             BX       LR               ;; return
     80          }
     81          
     82          

   \                                 In section .bss, align 4
     83          static unsigned char *bufptr;
   \                     bufptr:
   \        0x0                      DS8 4
     84          

   \                                 In section .text, align 2, keep-with-next
     85          int bufchar(unsigned char *c, int count)
     86          {
   \                     bufchar: (+1)
   \        0x0   0xB410             PUSH     {R4}
     87              int i;
     88          
     89              for (i = 0; i < count; ++i) {
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0xE007             B.N      ??bufchar_0
     90                  *c = *bufptr++;
   \                     ??bufchar_1: (+1)
   \        0x6   0x....             LDR.N    R3,??DataTable3_1
   \        0x8   0x681C             LDR      R4,[R3, #+0]
   \        0xA   0x1C64             ADDS     R4,R4,#+1
   \        0xC   0x601C             STR      R4,[R3, #+0]
   \        0xE   0x1E64             SUBS     R4,R4,#+1
   \       0x10   0x7823             LDRB     R3,[R4, #+0]
   \       0x12   0x7003             STRB     R3,[R0, #+0]
     91              }
   \       0x14   0x1C52             ADDS     R2,R2,#+1
   \                     ??bufchar_0: (+1)
   \       0x16   0x428A             CMP      R2,R1
   \       0x18   0xDBF5             BLT.N    ??bufchar_1
     92              return count;
   \       0x1A   0x4608             MOV      R0,R1
   \       0x1C   0xBC10             POP      {R4}
   \       0x1E   0x4770             BX       LR               ;; return
     93          }
     94          
     95          

   \                                 In section .text, align 2, keep-with-next
     96          int MQTTPacket_decodeBuf(unsigned char *buf, int *value)
     97          {
     98              bufptr = buf;
   \                     MQTTPacket_decodeBuf: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable3_1
   \        0x2   0x6010             STR      R0,[R2, #+0]
     99              return MQTTPacket_decode(bufchar, value);
   \        0x4   0x....             LDR.N    R0,??DataTable3_2
   \        0x6   0x....             B.N      MQTTPacket_decode
    100          }
    101          
    102          
    103          /**
    104           * Calculates an integer from two bytes read from the input buffer
    105           * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
    106           * @return the integer value calculated
    107           */

   \                                 In section .text, align 2, keep-with-next
    108          int readInt(unsigned char **pptr)
    109          {
   \                     readInt: (+1)
   \        0x0   0x4601             MOV      R1,R0
    110              unsigned char *ptr = *pptr;
   \        0x2   0x6808             LDR      R0,[R1, #+0]
    111              int len = 256 * (*ptr) + (*(ptr + 1));
   \        0x4   0x7802             LDRB     R2,[R0, #+0]
   \        0x6   0x7840             LDRB     R0,[R0, #+1]
   \        0x8   0xEB10 0x2002      ADDS     R0,R0,R2, LSL #+8
    112              *pptr += 2;
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0x1C92             ADDS     R2,R2,#+2
   \       0x10   0x600A             STR      R2,[R1, #+0]
    113              return len;
   \       0x12   0x4770             BX       LR               ;; return
    114          }
    115          
    116          
    117          /**
    118           * Reads one character from the input buffer.
    119           * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
    120           * @return the character read
    121           */

   \                                 In section .text, align 2, keep-with-next
    122          char readChar(unsigned char **pptr)
    123          {
   \                     readChar: (+1)
   \        0x0   0x4601             MOV      R1,R0
    124              char c = **pptr;
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
    125              (*pptr)++;
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x1C52             ADDS     R2,R2,#+1
   \        0xA   0x600A             STR      R2,[R1, #+0]
    126              return c;
   \        0xC   0x4770             BX       LR               ;; return
    127          }
    128          
    129          
    130          /**
    131           * Writes one character to an output buffer.
    132           * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
    133           * @param c the character to write
    134           */

   \                                 In section .text, align 2, keep-with-next
    135          void writeChar(unsigned char **pptr, char c)
    136          {
    137              **pptr = c;
   \                     writeChar: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0x7011             STRB     R1,[R2, #+0]
    138              (*pptr)++;
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    139          }
   \        0xA   0x4770             BX       LR               ;; return
    140          
    141          
    142          /**
    143           * Writes an integer as 2 bytes to an output buffer.
    144           * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
    145           * @param anInt the integer to write
    146           */

   \                                 In section .text, align 2, keep-with-next
    147          void writeInt(unsigned char **pptr, int anInt)
    148          {
    149              **pptr = (unsigned char)(anInt / 256);
   \                     writeInt: (+1)
   \        0x0   0x460A             MOV      R2,R1
   \        0x2   0x11D2             ASRS     R2,R2,#+7
   \        0x4   0xEB01 0x6212      ADD      R2,R1,R2, LSR #+24
   \        0x8   0x1212             ASRS     R2,R2,#+8
   \        0xA   0x6803             LDR      R3,[R0, #+0]
   \        0xC   0x701A             STRB     R2,[R3, #+0]
    150              (*pptr)++;
   \        0xE   0x6802             LDR      R2,[R0, #+0]
   \       0x10   0x1C52             ADDS     R2,R2,#+1
   \       0x12   0x6002             STR      R2,[R0, #+0]
    151              **pptr = (unsigned char)(anInt % 256);
   \       0x14   0x7011             STRB     R1,[R2, #+0]
    152              (*pptr)++;
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x1C49             ADDS     R1,R1,#+1
   \       0x1A   0x6001             STR      R1,[R0, #+0]
    153          }
   \       0x1C   0x4770             BX       LR               ;; return
    154          
    155          
    156          /**
    157           * Writes a "UTF" string to an output buffer.  Converts C string to length-delimited.
    158           * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
    159           * @param string the C string to write
    160           */

   \                                 In section .text, align 2, keep-with-next
    161          void writeCString(unsigned char **pptr, const char *string)
    162          {
   \                     writeCString: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    163              int len = strlen(string);
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x....'....        BL       strlen
   \        0xC   0x4606             MOV      R6,R0
    164              writeInt(pptr, len);
   \        0xE   0x4631             MOV      R1,R6
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       writeInt
    165              memcpy(*pptr, string, len);
   \       0x16   0x4632             MOV      R2,R6
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x....'....        BL       __aeabi_memcpy
    166              *pptr += len;
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x4430             ADD      R0,R0,R6
   \       0x24   0x6020             STR      R0,[R4, #+0]
    167          }
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
    168          
    169          

   \                                 In section .text, align 2, keep-with-next
    170          int getLenStringLen(char *ptr)
    171          {
    172              int len = 256 * ((unsigned char)(*ptr)) + (unsigned char)(*(ptr + 1));
    173              return len;
   \                     getLenStringLen: (+1)
   \        0x0   0x7801             LDRB     R1,[R0, #+0]
   \        0x2   0x7840             LDRB     R0,[R0, #+1]
   \        0x4   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \        0x8   0x4770             BX       LR               ;; return
    174          }
    175          
    176          

   \                                 In section .text, align 2, keep-with-next
    177          void writeMQTTString(unsigned char **pptr, MQTTString mqttstring)
    178          {
   \                     writeMQTTString: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    179              if (mqttstring.lenstring.len > 0) {
   \        0x4   0x4610             MOV      R0,R2
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xDB0D             BLT.N    ??writeMQTTString_0
    180                  writeInt(pptr, mqttstring.lenstring.len);
   \        0xA   0x4601             MOV      R1,R0
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x....'....        BL       writeInt
    181                  memcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);
   \       0x12   0x9A02             LDR      R2,[SP, #+8]
   \       0x14   0x9903             LDR      R1,[SP, #+12]
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x....'....        BL       __aeabi_memcpy
    182                  *pptr += mqttstring.lenstring.len;
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x9902             LDR      R1,[SP, #+8]
   \       0x20   0x4408             ADD      R0,R0,R1
   \       0x22   0x6020             STR      R0,[R4, #+0]
   \       0x24   0xBD1F             POP      {R0-R4,PC}
    183              } else if (mqttstring.cstring) {
   \                     ??writeMQTTString_0: (+1)
   \       0x26   0x4608             MOV      R0,R1
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD004             BEQ.N    ??writeMQTTString_1
    184                  writeCString(pptr, mqttstring.cstring);
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0xB004             ADD      SP,SP,#+16
   \       0x30   0xE8BD 0x4010      POP      {R4,LR}
   \       0x34   0x....             B.N      writeCString
    185              } else {
    186                  writeInt(pptr, 0);
   \                     ??writeMQTTString_1: (+1)
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0xB004             ADD      SP,SP,#+16
   \       0x3C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x40   0x....             B.N      writeInt
    187              }
    188          }
    189          
    190          
    191          /**
    192           * @param mqttstring the MQTTString structure into which the data is to be read
    193           * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
    194           * @param enddata pointer to the end of the data: do not read beyond
    195           * @return 1 if successful, 0 if not
    196           */

   \                                 In section .text, align 2, keep-with-next
    197          int readMQTTLenString(MQTTString *mqttstring, unsigned char **pptr, unsigned char *enddata)
    198          {
   \                     readMQTTLenString: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4617             MOV      R7,R2
    199              int rc = 0;
   \        0x8   0x2600             MOVS     R6,#+0
    200          
    201              /* the first two bytes are the length of the string */
    202              if (enddata - (*pptr) > 1) { /* enough length to read the integer? */
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x1A38             SUBS     R0,R7,R0
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xDB0F             BLT.N    ??readMQTTLenString_0
    203                  mqttstring->lenstring.len = readInt(pptr); /* increments pptr to point past length */
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x....'....        BL       readInt
   \       0x18   0x6060             STR      R0,[R4, #+4]
    204                  if (&(*pptr)[mqttstring->lenstring.len] <= enddata) {
   \       0x1A   0x6828             LDR      R0,[R5, #+0]
   \       0x1C   0x6861             LDR      R1,[R4, #+4]
   \       0x1E   0x4408             ADD      R0,R0,R1
   \       0x20   0x4287             CMP      R7,R0
   \       0x22   0xD306             BCC.N    ??readMQTTLenString_0
    205                      mqttstring->lenstring.data = (char *)*pptr;
   \       0x24   0x6828             LDR      R0,[R5, #+0]
   \       0x26   0x60A0             STR      R0,[R4, #+8]
    206                      *pptr += mqttstring->lenstring.len;
   \       0x28   0x6828             LDR      R0,[R5, #+0]
   \       0x2A   0x6861             LDR      R1,[R4, #+4]
   \       0x2C   0x4408             ADD      R0,R0,R1
   \       0x2E   0x6028             STR      R0,[R5, #+0]
    207                      rc = 1;
   \       0x30   0x2601             MOVS     R6,#+1
    208                  }
    209              }
    210              mqttstring->cstring = NULL;
   \                     ??readMQTTLenString_0: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6020             STR      R0,[R4, #+0]
    211              return rc;
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    212          }
    213          
    214          
    215          /**
    216           * Return the length of the MQTTstring - C string if there is one, otherwise the length delimited string
    217           * @param mqttstring the string to return the length of
    218           * @return the length of the string
    219           */

   \                                 In section .text, align 2, keep-with-next
    220          int MQTTstrlen(MQTTString mqttstring)
    221          {
   \                     MQTTstrlen: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    222              int rc = 0;
    223          
    224              if (mqttstring.cstring) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD002             BEQ.N    ??MQTTstrlen_0
    225                  rc = strlen(mqttstring.cstring);
   \        0x6   0x....'....        BL       strlen
   \        0xA   0x4601             MOV      R1,R0
    226              } else {
    227                  rc = mqttstring.lenstring.len;
    228              }
    229              return rc;
   \                     ??MQTTstrlen_0: (+1)
   \        0xC   0x4608             MOV      R0,R1
   \        0xE   0xBD02             POP      {R1,PC}          ;; return
    230          }
    231          
    232          
    233          /**
    234           * Compares an MQTTString to a C string
    235           * @param a the MQTTString to compare
    236           * @param bptr the C string to compare
    237           * @return int - equal or not
    238           */

   \                                 In section .text, align 2, keep-with-next
    239          int MQTTPacket_equals(MQTTString *a, char *bptr)
    240          {
   \                     MQTTPacket_equals: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
    241              int alen = 0,
    242                  blen = 0;
    243              char *aptr;
    244          #if !(WITH_MQTT_ZIP_TOPIC)
    245              if (a->cstring) {
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD005             BEQ.N    ??MQTTPacket_equals_0
    246                  aptr = a->cstring;
   \        0xA   0x460D             MOV      R5,R1
    247                  alen = strlen(a->cstring);
   \        0xC   0x4608             MOV      R0,R1
   \        0xE   0x....'....        BL       strlen
   \       0x12   0x4606             MOV      R6,R0
   \       0x14   0xE001             B.N      ??MQTTPacket_equals_1
    248              } else {
    249                  aptr = a->lenstring.data;
   \                     ??MQTTPacket_equals_0: (+1)
   \       0x16   0x6885             LDR      R5,[R0, #+8]
    250                  alen = a->lenstring.len;
   \       0x18   0x6846             LDR      R6,[R0, #+4]
    251              }
    252              blen = strlen(bptr);
   \                     ??MQTTPacket_equals_1: (+1)
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x....'....        BL       strlen
    253          #else
    254              aptr = a->lenstring.data;
    255              alen = a->lenstring.len;
    256              blen = alen;
    257          #endif
    258              return (alen == blen) && (memcmp(aptr, bptr, alen) == 0);
   \       0x20   0x4286             CMP      R6,R0
   \       0x22   0xD108             BNE.N    ??MQTTPacket_equals_2
   \       0x24   0x4632             MOV      R2,R6
   \       0x26   0x4621             MOV      R1,R4
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       memcmp
   \       0x2E   0x1E40             SUBS     R0,R0,#+1
   \       0x30   0x4180             SBCS     R0,R0,R0
   \       0x32   0x0FC0             LSRS     R0,R0,#+31
   \       0x34   0xBD70             POP      {R4-R6,PC}
   \                     ??MQTTPacket_equals_2: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD70             POP      {R4-R6,PC}       ;; return
    259          
    260          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x001F'FFFF        DC32     0x1fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     bufptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     bufchar
    261          
    262          
    263          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   MQTTPacket_decode
        24   -- Indirect call
       0   MQTTPacket_decodeBuf
         0   -> MQTTPacket_decode
       4   MQTTPacket_encode
      16   MQTTPacket_equals
        16   -> memcmp
        16   -> strlen
       0   MQTTPacket_len
       8   MQTTstrlen
         8   -> strlen
       4   bufchar
       0   getLenStringLen
       0   readChar
       0   readInt
      24   readMQTTLenString
        24   -> readInt
      16   writeCString
        16   -> __aeabi_memcpy
        16   -> strlen
        16   -> writeInt
       0   writeChar
       0   writeInt
      24   writeMQTTString
        24   -> __aeabi_memcpy
         0   -> writeCString
         0   -> writeInt
        24   -> writeInt


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
      60  MQTTPacket_decode
       8  MQTTPacket_decodeBuf
      50  MQTTPacket_encode
      58  MQTTPacket_equals
      34  MQTTPacket_len
      16  MQTTstrlen
      32  bufchar
       4  bufptr
      10  getLenStringLen
      14  readChar
      20  readInt
      58  readMQTTLenString
      40  writeCString
      12  writeChar
      30  writeInt
      66  writeMQTTString

 
   4 bytes in section .bss
 520 bytes in section .text
 
 520 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
