###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:23
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\drivers\fsl_lpuart.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWE872.tmp
#        (C:\Development\smart_washing_machine_3080\drivers\fsl_lpuart.c -D
#        DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1
#        -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE
#        -D "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\fsl_lpuart.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\fsl_lpuart.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\drivers\fsl_lpuart.c
      1          /*
      2           * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           * All rights reserved.
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           */
      8          
      9          #include "fsl_lpuart.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xD408             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xF000 0x011F      AND      R1,R0,#0x1F
   \        0xA   0x408A             LSLS     R2,R2,R1
   \        0xC   0x....'....        LDR.W    R1,??DataTable23  ;; 0xe000e100
   \       0x10   0x0940             LSRS     R0,R0,#+5
   \       0x12   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_ControlGate(clock_ip_name_t, clock_gate_value_t)
   \                     CLOCK_ControlGate: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4626             MOV      R6,R4
   \        0x8   0x0A36             LSRS     R6,R6,#+8
   \        0xA   0xF004 0x041F      AND      R4,R4,#0x1F
   \        0xE   0x2E07             CMP      R6,#+7
   \       0x10   0xD309             BCC.N    ??CLOCK_ControlGate_0
   \       0x12   0xF240 0x32C1      MOVW     R2,#+961
   \       0x16   0x....'....        LDR.W    R1,??DataTable23_1
   \       0x1A   0x....'....        LDR.W    R0,??DataTable23_2
   \       0x1E   0x....'....        BL       __aeabi_assert
   \       0x22   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??CLOCK_ControlGate_0: (+1)
   \       0x26   0x....'....        LDR.W    R0,??DataTable23_3  ;; 0x400fc068
   \       0x2A   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0x2203             MOVS     R2,#+3
   \       0x32   0x40A2             LSLS     R2,R2,R4
   \       0x34   0x4391             BICS     R1,R1,R2
   \       0x36   0xFA05 0xF404      LSL      R4,R5,R4
   \       0x3A   0x430C             ORRS     R4,R4,R1
   \       0x3C   0x6004             STR      R4,[R0, #+0]
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \        0x0   0x2103             MOVS     R1,#+3
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int32_t EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0xF06F 0x027F      MVN      R2,#+127
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD101             BNE.N    ??EnableIRQ_0
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xBD02             POP      {R1,PC}
   \                     ??EnableIRQ_0: (+1)
   \       0x10   0x....'....        BL       __NVIC_EnableIRQ
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LPUART_SoftwareReset(LPUART_Type *)
   \                     LPUART_SoftwareReset: (+1)
   \        0x0   0x6881             LDR      R1,[R0, #+8]
   \        0x2   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0x6   0x6081             STR      R1,[R0, #+8]
   \        0x8   0x6881             LDR      R1,[R0, #+8]
   \        0xA   0xF021 0x0102      BIC      R1,R1,#0x2
   \        0xE   0x6081             STR      R1,[R0, #+8]
   \       0x10   0x4770             BX       LR               ;; return
     10          
     11          /*******************************************************************************
     12           * Definitions
     13           ******************************************************************************/
     14          
     15          /* Component ID definition, used by tools. */
     16          #ifndef FSL_COMPONENT_ID
     17          #define FSL_COMPONENT_ID "platform.drivers.lpuart"
     18          #endif
     19          
     20          /* LPUART transfer state. */
     21          enum _lpuart_transfer_states
     22          {
     23              kLPUART_TxIdle, /*!< TX idle. */
     24              kLPUART_TxBusy, /*!< TX busy. */
     25              kLPUART_RxIdle, /*!< RX idle. */
     26              kLPUART_RxBusy  /*!< RX busy. */
     27          };
     28          
     29          /* Typedef for interrupt handler. */
     30          typedef void (*lpuart_isr_t)(LPUART_Type *base, lpuart_handle_t *handle);
     31          
     32          /*******************************************************************************
     33           * Prototypes
     34           ******************************************************************************/
     35          /*!
     36           * @brief Check whether the RX ring buffer is full.
     37           *
     38           * @userData handle LPUART handle pointer.
     39           * @retval true  RX ring buffer is full.
     40           * @retval false RX ring buffer is not full.
     41           */
     42          static bool LPUART_TransferIsRxRingBufferFull(LPUART_Type *base, lpuart_handle_t *handle);
     43          
     44          /*!
     45           * @brief Write to TX register using non-blocking method.
     46           *
     47           * This function writes data to the TX register directly, upper layer must make
     48           * sure the TX register is empty or TX FIFO has empty room before calling this function.
     49           *
     50           * @note This function does not check whether all the data has been sent out to bus,
     51           * so before disable TX, check kLPUART_TransmissionCompleteFlag to ensure the TX is
     52           * finished.
     53           *
     54           * @param base LPUART peripheral base address.
     55           * @param data Start address of the data to write.
     56           * @param length Size of the buffer to be sent.
     57           */
     58          static void LPUART_WriteNonBlocking(LPUART_Type *base, const uint8_t *data, size_t length);
     59          
     60          /*!
     61           * @brief Read RX register using non-blocking method.
     62           *
     63           * This function reads data from the TX register directly, upper layer must make
     64           * sure the RX register is full or TX FIFO has data before calling this function.
     65           *
     66           * @param base LPUART peripheral base address.
     67           * @param data Start address of the buffer to store the received data.
     68           * @param length Size of the buffer.
     69           */
     70          static void LPUART_ReadNonBlocking(LPUART_Type *base, uint8_t *data, size_t length);
     71          
     72          /*******************************************************************************
     73           * Variables
     74           ******************************************************************************/
     75          /* Array of LPUART peripheral base address. */

   \                                 In section .rodata, align 4
     76          static LPUART_Type *const s_lpuartBases[] = LPUART_BASE_PTRS;
   \                     s_lpuartBases:
   \        0x0   0x0000'0000        DC32 0H, 40184000H, 40188000H, 4018C000H, 40190000H, 40194000H
   \              0x4018'4000  
   \              0x4018'8000  
   \              0x4018'C000  
   \              0x4019'0000  
   \              0x4019'4000  
   \       0x18   0x4019'8000        DC32 40198000H, 4019C000H, 401A0000H
   \              0x4019'C000  
   \              0x401A'0000  
     77          /* Array of LPUART handle. */

   \                                 In section .bss, align 4
     78          static lpuart_handle_t *s_lpuartHandle[ARRAY_SIZE(s_lpuartBases)];
   \                     s_lpuartHandle:
   \        0x0                      DS8 36
     79          /* Array of LPUART IRQ number. */
     80          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
     81          static const IRQn_Type s_lpuartRxIRQ[] = LPUART_RX_IRQS;
     82          static const IRQn_Type s_lpuartTxIRQ[] = LPUART_TX_IRQS;
     83          #else

   \                                 In section .rodata, align 4
     84          static const IRQn_Type s_lpuartIRQ[] = LPUART_RX_TX_IRQS;
   \                     s_lpuartIRQ:
   \        0x0   0xFF80 0x0014      DC16 -128, 20, 21, 22, 23, 24, 25, 26, 27
   \               0x0015 0x001
   \              6 0x0017 0x00
   \              18 0x0019 0x0
   \              01A 0x001B   
   \       0x12   0x00 0x00          DC8 0, 0
     85          #endif
     86          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
     87          /* Array of LPUART clock name. */

   \                                 In section .rodata, align 4
     88          static const clock_ip_name_t s_lpuartClock[] = LPUART_CLOCKS;
   \                     s_lpuartClock:
   \        0x0   0xFFFF 0x0518      DC16 -1, 1304, 28, 12, 280, 770, 774, 1306, 1550
   \               0x001C 0x000
   \              C 0x0118 0x03
   \              02 0x0306 0x0
   \              51A 0x060E   
   \       0x12   0x00 0x00          DC8 0, 0
     89          
     90          #if defined(LPUART_PERIPH_CLOCKS)
     91          /* Array of LPUART functional clock name. */
     92          static const clock_ip_name_t s_lpuartPeriphClocks[] = LPUART_PERIPH_CLOCKS;
     93          #endif
     94          
     95          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
     96          
     97          /* LPUART ISR for transactional APIs. */

   \                                 In section .bss, align 4
     98          static lpuart_isr_t s_lpuartIsr;
   \                     s_lpuartIsr:
   \        0x0                      DS8 4
     99          
    100          /*******************************************************************************
    101           * Code
    102           ******************************************************************************/
    103          /*!
    104           * brief Get the LPUART instance from peripheral base address.
    105           *
    106           * param base LPUART peripheral base address.
    107           * return LPUART instance.
    108           */

   \                                 In section .text, align 2, keep-with-next
    109          uint32_t LPUART_GetInstance(LPUART_Type *base)
    110          {
   \                     LPUART_GetInstance: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    111              uint32_t instance;
    112          
    113              /* Find the instance index from base address mappings. */
    114              for (instance = 0; instance < ARRAY_SIZE(s_lpuartBases); instance++)
   \        0x2   0x2400             MOVS     R4,#+0
   \                     ??LPUART_GetInstance_0: (+1)
   \        0x4   0x2C09             CMP      R4,#+9
   \        0x6   0xD207             BCS.N    ??LPUART_GetInstance_1
    115              {
    116                  if (s_lpuartBases[instance] == base)
   \        0x8   0x....'....        LDR.W    R1,??DataTable23_4
   \        0xC   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \       0x10   0x4281             CMP      R1,R0
   \       0x12   0xD001             BEQ.N    ??LPUART_GetInstance_1
    117                  {
    118                      break;
    119                  }
    120              }
   \       0x14   0x1C64             ADDS     R4,R4,#+1
   \       0x16   0xE7F5             B.N      ??LPUART_GetInstance_0
    121          
    122              assert(instance < ARRAY_SIZE(s_lpuartBases));
   \                     ??LPUART_GetInstance_1: (+1)
   \       0x18   0x2C09             CMP      R4,#+9
   \       0x1A   0xD308             BCC.N    ??LPUART_GetInstance_2
   \       0x1C   0x227A             MOVS     R2,#+122
   \       0x1E   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x22   0x....'....        LDR.W    R0,??DataTable23_6
   \       0x26   0x....'....        BL       __aeabi_assert
   \       0x2A   0x....'....        BL       __iar_EmptyStepPoint
    123          
    124              return instance;
   \                     ??LPUART_GetInstance_2: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
    125          }
    126          
    127          /*!
    128           * brief Get the length of received data in RX ring buffer.
    129           *
    130           * userData handle LPUART handle pointer.
    131           * return Length of received data in RX ring buffer.
    132           */

   \                                 In section .text, align 2, keep-with-next
    133          size_t LPUART_TransferGetRxRingBufferLength(LPUART_Type *base, lpuart_handle_t *handle)
    134          {
   \                     LPUART_TransferGetRxRingBufferLength: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
    135              assert(handle);
   \        0x4   0xD108             BNE.N    ??LPUART_TransferGetRxRingBufferLength_0
   \        0x6   0x2287             MOVS     R2,#+135
   \        0x8   0x....'....        LDR.W    R1,??DataTable23_5
   \        0xC   0x....'....        LDR.W    R0,??DataTable23_7
   \       0x10   0x....'....        BL       __aeabi_assert
   \       0x14   0x....'....        BL       __iar_EmptyStepPoint
    136          
    137              size_t size;
    138          
    139              if (handle->rxRingBufferTail > handle->rxRingBufferHead)
   \                     ??LPUART_TransferGetRxRingBufferLength_0: (+1)
   \       0x18   0x8C20             LDRH     R0,[R4, #+32]
   \       0x1A   0x8C61             LDRH     R1,[R4, #+34]
   \       0x1C   0x4288             CMP      R0,R1
   \       0x1E   0xD205             BCS.N    ??LPUART_TransferGetRxRingBufferLength_1
    140              {
    141                  size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferTail);
   \       0x20   0x8C20             LDRH     R0,[R4, #+32]
   \       0x22   0x69E1             LDR      R1,[R4, #+28]
   \       0x24   0x1809             ADDS     R1,R1,R0
   \       0x26   0x8C60             LDRH     R0,[R4, #+34]
   \       0x28   0x1A08             SUBS     R0,R1,R0
   \       0x2A   0xBD10             POP      {R4,PC}
    142              }
    143              else
    144              {
    145                  size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
   \                     ??LPUART_TransferGetRxRingBufferLength_1: (+1)
   \       0x2C   0x8C21             LDRH     R1,[R4, #+32]
   \       0x2E   0x8C60             LDRH     R0,[R4, #+34]
   \       0x30   0x1A08             SUBS     R0,R1,R0
    146              }
    147          
    148              return size;
   \       0x32   0xBD10             POP      {R4,PC}          ;; return
    149          }
    150          

   \                                 In section .text, align 2, keep-with-next
    151          static bool LPUART_TransferIsRxRingBufferFull(LPUART_Type *base, lpuart_handle_t *handle)
    152          {
   \                     LPUART_TransferIsRxRingBufferFull: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    153              assert(handle);
   \        0x6   0xD108             BNE.N    ??LPUART_TransferIsRxRingBufferFull_0
   \        0x8   0x2299             MOVS     R2,#+153
   \        0xA   0x....'....        LDR.W    R1,??DataTable23_5
   \        0xE   0x....'....        LDR.W    R0,??DataTable23_7
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
    154          
    155              bool full;
    156          
    157              if (LPUART_TransferGetRxRingBufferLength(base, handle) == (handle->rxRingBufferSize - 1U))
   \                     ??LPUART_TransferIsRxRingBufferFull_0: (+1)
   \       0x1A   0x4621             MOV      R1,R4
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x....'....        BL       LPUART_TransferGetRxRingBufferLength
   \       0x22   0x69E1             LDR      R1,[R4, #+28]
   \       0x24   0x1E49             SUBS     R1,R1,#+1
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD101             BNE.N    ??LPUART_TransferIsRxRingBufferFull_1
    158              {
    159                  full = true;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
    160              }
    161              else
    162              {
    163                  full = false;
   \                     ??LPUART_TransferIsRxRingBufferFull_1: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
    164              }
    165              return full;
   \       0x30   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    166          }
    167          

   \                                 In section .text, align 2, keep-with-next
    168          static void LPUART_WriteNonBlocking(LPUART_Type *base, const uint8_t *data, size_t length)
    169          {
   \                     LPUART_WriteNonBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
    170              assert(data);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD108             BNE.N    ??LPUART_WriteNonBlocking_0
   \        0xC   0x22AA             MOVS     R2,#+170
   \        0xE   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x12   0x....'....        LDR.W    R0,??DataTable28
   \       0x16   0x....'....        BL       __aeabi_assert
   \       0x1A   0x....'....        BL       __iar_EmptyStepPoint
    171          
    172              size_t i;
    173          
    174              /* The Non Blocking write data API assume user have ensured there is enough space in
    175              peripheral to write. */
    176              for (i = 0; i < length; i++)
   \                     ??LPUART_WriteNonBlocking_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xE002             B.N      ??LPUART_WriteNonBlocking_1
    177              {
    178                  base->DATA = data[i];
   \                     ??LPUART_WriteNonBlocking_2: (+1)
   \       0x22   0x5C21             LDRB     R1,[R4, R0]
   \       0x24   0x61E9             STR      R1,[R5, #+28]
    179              }
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \                     ??LPUART_WriteNonBlocking_1: (+1)
   \       0x28   0x42B0             CMP      R0,R6
   \       0x2A   0xD3FA             BCC.N    ??LPUART_WriteNonBlocking_2
    180          }
   \       0x2C   0xBD70             POP      {R4-R6,PC}       ;; return
    181          

   \                                 In section .text, align 2, keep-with-next
    182          static void LPUART_ReadNonBlocking(LPUART_Type *base, uint8_t *data, size_t length)
    183          {
   \                     LPUART_ReadNonBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
    184              assert(data);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD108             BNE.N    ??LPUART_ReadNonBlocking_0
   \        0xC   0x22B8             MOVS     R2,#+184
   \        0xE   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x12   0x....'....        LDR.W    R0,??DataTable28
   \       0x16   0x....'....        BL       __aeabi_assert
   \       0x1A   0x....'....        BL       __iar_EmptyStepPoint
    185          
    186              size_t i;
    187          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    188              uint32_t ctrl = base->CTRL;
   \                     ??LPUART_ReadNonBlocking_0: (+1)
   \       0x1E   0x69A8             LDR      R0,[R5, #+24]
    189              bool isSevenDataBits =
    190                  ((ctrl & LPUART_CTRL_M7_MASK) || ((!(ctrl & LPUART_CTRL_M_MASK)) && (ctrl & LPUART_CTRL_PE_MASK)));
   \       0x20   0x0501             LSLS     R1,R0,#+20
   \       0x22   0xD403             BMI.N    ??LPUART_ReadNonBlocking_1
   \       0x24   0xF000 0x0012      AND      R0,R0,#0x12
   \       0x28   0x2802             CMP      R0,#+2
   \       0x2A   0xD101             BNE.N    ??LPUART_ReadNonBlocking_2
   \                     ??LPUART_ReadNonBlocking_1: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xE000             B.N      ??LPUART_ReadNonBlocking_3
   \                     ??LPUART_ReadNonBlocking_2: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
    191          #endif
    192          
    193              /* The Non Blocking read data API assume user have ensured there is enough space in
    194              peripheral to write. */
    195              for (i = 0; i < length; i++)
   \                     ??LPUART_ReadNonBlocking_3: (+1)
   \       0x32   0x2100             MOVS     R1,#+0
   \                     ??LPUART_ReadNonBlocking_4: (+1)
   \       0x34   0x42B1             CMP      R1,R6
   \       0x36   0xD209             BCS.N    ??LPUART_ReadNonBlocking_5
    196              {
    197          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    198                  if (isSevenDataBits)
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0x69EA             LDR      R2,[R5, #+28]
   \       0x3C   0xD101             BNE.N    ??LPUART_ReadNonBlocking_6
    199                  {
    200                      data[i] = (base->DATA & 0x7F);
    201                  }
    202                  else
    203                  {
    204                      data[i] = base->DATA;
   \       0x3E   0x5462             STRB     R2,[R4, R1]
   \       0x40   0xE002             B.N      ??LPUART_ReadNonBlocking_7
    205                  }
   \                     ??LPUART_ReadNonBlocking_6: (+1)
   \       0x42   0xF002 0x027F      AND      R2,R2,#0x7F
   \       0x46   0x5462             STRB     R2,[R4, R1]
    206          #else
    207                  data[i] = base->DATA;
    208          #endif
    209              }
   \                     ??LPUART_ReadNonBlocking_7: (+1)
   \       0x48   0x1C49             ADDS     R1,R1,#+1
   \       0x4A   0xE7F3             B.N      ??LPUART_ReadNonBlocking_4
    210          }
   \                     ??LPUART_ReadNonBlocking_5: (+1)
   \       0x4C   0xBD70             POP      {R4-R6,PC}       ;; return
    211          
    212          /*!
    213           * brief Initializes an LPUART instance with the user configuration structure and the peripheral clock.
    214           *
    215           * This function configures the LPUART module with user-defined settings. Call the LPUART_GetDefaultConfig() function
    216           * to configure the configuration structure and get the default configuration.
    217           * The example below shows how to use this API to configure the LPUART.
    218           * code
    219           *  lpuart_config_t lpuartConfig;
    220           *  lpuartConfig.baudRate_Bps = 115200U;
    221           *  lpuartConfig.parityMode = kLPUART_ParityDisabled;
    222           *  lpuartConfig.dataBitsCount = kLPUART_EightDataBits;
    223           *  lpuartConfig.isMsb = false;
    224           *  lpuartConfig.stopBitCount = kLPUART_OneStopBit;
    225           *  lpuartConfig.txFifoWatermark = 0;
    226           *  lpuartConfig.rxFifoWatermark = 1;
    227           *  LPUART_Init(LPUART1, &lpuartConfig, 20000000U);
    228           * endcode
    229           *
    230           * param base LPUART peripheral base address.
    231           * param config Pointer to a user-defined configuration structure.
    232           * param srcClock_Hz LPUART clock source frequency in HZ.
    233           * retval kStatus_LPUART_BaudrateNotSupport Baudrate is not support in current clock source.
    234           * retval kStatus_Success LPUART initialize succeed
    235           */

   \                                 In section .text, align 2, keep-with-next
    236          status_t LPUART_Init(LPUART_Type *base, const lpuart_config_t *config, uint32_t srcClock_Hz)
    237          {
   \                     LPUART_Init: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
    238              assert(config);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD108             BNE.N    ??LPUART_Init_0
   \        0xE   0x22EE             MOVS     R2,#+238
   \       0x10   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x14   0x....'....        LDR.W    R0,??DataTable23_8
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
    239              assert(config->baudRate_Bps);
   \                     ??LPUART_Init_0: (+1)
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD108             BNE.N    ??LPUART_Init_1
   \       0x26   0x22EF             MOVS     R2,#+239
   \       0x28   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x2C   0x....'....        LDR.W    R0,??DataTable23_9
   \       0x30   0x....'....        BL       __aeabi_assert
   \       0x34   0x....'....        BL       __iar_EmptyStepPoint
    240          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    241              assert(FSL_FEATURE_LPUART_FIFO_SIZEn(base) >= config->txFifoWatermark);
   \                     ??LPUART_Init_1: (+1)
   \       0x38   0x7A20             LDRB     R0,[R4, #+8]
   \       0x3A   0x2805             CMP      R0,#+5
   \       0x3C   0xDB08             BLT.N    ??LPUART_Init_2
   \       0x3E   0x22F1             MOVS     R2,#+241
   \       0x40   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x44   0x....'....        LDR.W    R0,??DataTable24
   \       0x48   0x....'....        BL       __aeabi_assert
   \       0x4C   0x....'....        BL       __iar_EmptyStepPoint
    242              assert(FSL_FEATURE_LPUART_FIFO_SIZEn(base) >= config->rxFifoWatermark);
   \                     ??LPUART_Init_2: (+1)
   \       0x50   0x7A60             LDRB     R0,[R4, #+9]
   \       0x52   0x2805             CMP      R0,#+5
   \       0x54   0xDB08             BLT.N    ??LPUART_Init_3
   \       0x56   0x22F2             MOVS     R2,#+242
   \       0x58   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x5C   0x....'....        LDR.W    R0,??DataTable25
   \       0x60   0x....'....        BL       __aeabi_assert
   \       0x64   0x....'....        BL       __iar_EmptyStepPoint
    243          #endif
    244          
    245              uint32_t temp;
    246              uint16_t sbr, sbrTemp;
    247              uint32_t osr, osrTemp, tempDiff, calculatedBaud, baudDiff;
    248          
    249              /* This LPUART instantiation uses a slightly different baud rate calculation
    250               * The idea is to use the best OSR (over-sampling rate) possible
    251               * Note, OSR is typically hard-set to 16 in other LPUART instantiations
    252               * loop to find the best OSR value possible, one that generates minimum baudDiff
    253               * iterate through the rest of the supported values of OSR */
    254          
    255              baudDiff = config->baudRate_Bps;
   \                     ??LPUART_Init_3: (+1)
   \       0x68   0x6821             LDR      R1,[R4, #+0]
    256              osr = 0;
   \       0x6A   0xF04F 0x0800      MOV      R8,#+0
    257              sbr = 0;
   \       0x6E   0x4647             MOV      R7,R8
    258              for (osrTemp = 4; osrTemp <= 32; osrTemp++)
   \       0x70   0x2204             MOVS     R2,#+4
   \       0x72   0xE02F             B.N      ??LPUART_Init_4
    259              {
    260                  /* calculate the temporary sbr value   */
    261                  sbrTemp = (srcClock_Hz / (config->baudRate_Bps * osrTemp));
   \                     ??LPUART_Init_5: (+1)
   \       0x74   0x4350             MULS     R0,R2,R0
   \       0x76   0xFBB5 0xF0F0      UDIV     R0,R5,R0
    262                  /*set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate*/
    263                  if (sbrTemp == 0)
   \       0x7A   0x4603             MOV      R3,R0
   \       0x7C   0xB29B             UXTH     R3,R3
   \       0x7E   0x2B00             CMP      R3,#+0
   \       0x80   0xD100             BNE.N    ??LPUART_Init_6
    264                  {
    265                      sbrTemp = 1;
   \       0x82   0x2001             MOVS     R0,#+1
    266                  }
    267                  /* Calculate the baud rate based on the temporary OSR and SBR values */
    268                  calculatedBaud = (srcClock_Hz / (osrTemp * sbrTemp));
    269          
    270                  tempDiff = calculatedBaud - config->baudRate_Bps;
   \                     ??LPUART_Init_6: (+1)
   \       0x84   0x4603             MOV      R3,R0
   \       0x86   0xB29B             UXTH     R3,R3
   \       0x88   0x4353             MULS     R3,R3,R2
   \       0x8A   0xFBB5 0xFCF3      UDIV     R12,R5,R3
   \       0x8E   0x6823             LDR      R3,[R4, #+0]
   \       0x90   0xEBAC 0x0303      SUB      R3,R12,R3
    271          
    272                  /* Select the better value between srb and (sbr + 1) */
    273                  if (tempDiff > (config->baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)))))
   \       0x94   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \       0x98   0x4686             MOV      LR,R0
   \       0x9A   0xFA1F 0xFE8E      UXTH     LR,LR
   \       0x9E   0xF10E 0x0E01      ADD      LR,LR,#+1
   \       0xA2   0xFB0E 0xFE02      MUL      LR,LR,R2
   \       0xA6   0xFBB5 0xFEFE      UDIV     LR,R5,LR
   \       0xAA   0xEBAC 0x0C0E      SUB      R12,R12,LR
   \       0xAE   0x459C             CMP      R12,R3
   \       0xB0   0xD20A             BCS.N    ??LPUART_Init_7
    274                  {
    275                      tempDiff = config->baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)));
   \       0xB2   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \       0xB6   0x4603             MOV      R3,R0
   \       0xB8   0xB29B             UXTH     R3,R3
   \       0xBA   0x1C5B             ADDS     R3,R3,#+1
   \       0xBC   0x4353             MULS     R3,R3,R2
   \       0xBE   0xFBB5 0xF3F3      UDIV     R3,R5,R3
   \       0xC2   0xEBAC 0x0303      SUB      R3,R12,R3
    276                      sbrTemp++;
   \       0xC6   0x1C40             ADDS     R0,R0,#+1
    277                  }
    278          
    279                  if (tempDiff <= baudDiff)
   \                     ??LPUART_Init_7: (+1)
   \       0xC8   0x4299             CMP      R1,R3
   \       0xCA   0xD302             BCC.N    ??LPUART_Init_8
    280                  {
    281                      baudDiff = tempDiff;
   \       0xCC   0x4619             MOV      R1,R3
    282                      osr = osrTemp; /* update and store the best OSR value calculated */
   \       0xCE   0x4690             MOV      R8,R2
    283                      sbr = sbrTemp; /* update store the best SBR value calculated */
   \       0xD0   0x4607             MOV      R7,R0
    284                  }
    285              }
   \                     ??LPUART_Init_8: (+1)
   \       0xD2   0x1C52             ADDS     R2,R2,#+1
   \                     ??LPUART_Init_4: (+1)
   \       0xD4   0x2A21             CMP      R2,#+33
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   \       0xD8   0xD3CC             BCC.N    ??LPUART_Init_5
    286          
    287              /* Check to see if actual baud rate is within 3% of desired baud rate
    288               * based on the best calculate OSR value */
    289              if (baudDiff > ((config->baudRate_Bps / 100) * 3))
   \       0xDA   0x2264             MOVS     R2,#+100
   \       0xDC   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \       0xE0   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \       0xE4   0x4288             CMP      R0,R1
   \       0xE6   0xD202             BCS.N    ??LPUART_Init_9
    290              {
    291                  /* Unacceptable baud rate difference of more than 3%*/
    292                  return kStatus_LPUART_BaudrateNotSupport;
   \       0xE8   0xF240 0x5021      MOVW     R0,#+1313
   \       0xEC   0xE091             B.N      ??LPUART_Init_10
    293              }
   \                     ??LPUART_Init_9: (+1)
   \       0xEE   0x4635             MOV      R5,R6
    294          
    295          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    296          
    297              uint32_t instance = LPUART_GetInstance(base);
   \       0xF0   0x4628             MOV      R0,R5
   \       0xF2   0x....'....        BL       LPUART_GetInstance
    298          
    299              /* Enable lpuart clock */
    300              CLOCK_EnableClock(s_lpuartClock[instance]);
   \       0xF6   0x....'....        LDR.W    R1,??DataTable29
   \       0xFA   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0xFE   0x....'....        BL       CLOCK_EnableClock
    301          #if defined(LPUART_PERIPH_CLOCKS)
    302              CLOCK_EnableClock(s_lpuartPeriphClocks[instance]);
    303          #endif
    304          
    305          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    306          
    307          #if defined(FSL_FEATURE_LPUART_HAS_GLOBAL) && FSL_FEATURE_LPUART_HAS_GLOBAL
    308              /*Reset all internal logic and registers, except the Global Register */
    309              LPUART_SoftwareReset(base);
   \      0x102   0x4628             MOV      R0,R5
   \      0x104   0x....'....        BL       LPUART_SoftwareReset
    310          #else
    311              /* Disable LPUART TX RX before setting. */
    312              base->CTRL &= ~(LPUART_CTRL_TE_MASK | LPUART_CTRL_RE_MASK);
    313          #endif
    314          
    315              temp = base->BAUD;
   \      0x108   0x6929             LDR      R1,[R5, #+16]
    316          
    317              /* Acceptable baud rate, check if OSR is between 4x and 7x oversampling.
    318               * If so, then "BOTHEDGE" sampling must be turned on */
    319              if ((osr > 3) && (osr < 8))
   \      0x10A   0xF1A8 0x0004      SUB      R0,R8,#+4
   \      0x10E   0x2804             CMP      R0,#+4
   \      0x110   0xD201             BCS.N    ??LPUART_Init_11
    320              {
    321                  temp |= LPUART_BAUD_BOTHEDGE_MASK;
   \      0x112   0xF441 0x3100      ORR      R1,R1,#0x20000
    322              }
    323          
    324              /* program the osr value (bit value is one less than actual value) */
    325              temp &= ~LPUART_BAUD_OSR_MASK;
    326              temp |= LPUART_BAUD_OSR(osr - 1);
    327          
    328              /* write the sbr value to the BAUD registers */
    329              temp &= ~LPUART_BAUD_SBR_MASK;
    330              base->BAUD = temp | LPUART_BAUD_SBR(sbr);
   \                     ??LPUART_Init_11: (+1)
   \      0x116   0x....'....        LDR.W    R0,??DataTable30  ;; 0xe0ffe000
   \      0x11A   0x4001             ANDS     R1,R0,R1
   \      0x11C   0xF1A8 0x0801      SUB      R8,R8,#+1
   \      0x120   0xEA4F 0x6808      LSL      R8,R8,#+24
   \      0x124   0xF008 0x58F8      AND      R8,R8,#0x1F000000
   \      0x128   0xEA48 0x0801      ORR      R8,R8,R1
   \      0x12C   0xB2BF             UXTH     R7,R7
   \      0x12E   0xF3C7 0x070C      UBFX     R7,R7,#+0,#+13
   \      0x132   0xEA47 0x0808      ORR      R8,R7,R8
   \      0x136   0xF8C5 0x8010      STR      R8,[R5, #+16]
    331          
    332              /* Set bit count and parity mode. */
    333              base->BAUD &= ~LPUART_BAUD_M10_MASK;
   \      0x13A   0x6928             LDR      R0,[R5, #+16]
   \      0x13C   0xF020 0x5000      BIC      R0,R0,#0x20000000
   \      0x140   0x6128             STR      R0,[R5, #+16]
    334          
    335              temp = base->CTRL &
    336                     ~(LPUART_CTRL_PE_MASK | LPUART_CTRL_PT_MASK | LPUART_CTRL_M_MASK | LPUART_CTRL_ILT_MASK |
    337                       LPUART_CTRL_IDLECFG_MASK);
   \      0x142   0x69A9             LDR      R1,[R5, #+24]
   \      0x144   0x....'....        LDR.W    R0,??DataTable31  ;; 0xfffff8e8
   \      0x148   0x4001             ANDS     R1,R0,R1
    338          
    339              temp |=
    340                  (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) | LPUART_CTRL_ILT(config->rxIdleType);
   \      0x14A   0x7920             LDRB     R0,[R4, #+4]
   \      0x14C   0x7BE2             LDRB     R2,[R4, #+15]
   \      0x14E   0x0212             LSLS     R2,R2,#+8
   \      0x150   0xF402 0x62E0      AND      R2,R2,#0x700
   \      0x154   0x4310             ORRS     R0,R2,R0
   \      0x156   0x7BA2             LDRB     R2,[R4, #+14]
   \      0x158   0x0092             LSLS     R2,R2,#+2
   \      0x15A   0xF002 0x0204      AND      R2,R2,#0x4
   \      0x15E   0x4310             ORRS     R0,R2,R0
   \      0x160   0x4301             ORRS     R1,R0,R1
    341          
    342          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    343              if (kLPUART_SevenDataBits == config->dataBitsCount)
   \      0x162   0x7960             LDRB     R0,[R4, #+5]
   \      0x164   0x2801             CMP      R0,#+1
   \      0x166   0x7920             LDRB     R0,[R4, #+4]
   \      0x168   0xD107             BNE.N    ??LPUART_Init_12
    344              {
    345                  if (kLPUART_ParityDisabled != config->parityMode)
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD002             BEQ.N    ??LPUART_Init_13
    346                  {
    347                      temp &= ~LPUART_CTRL_M7_MASK; /* Seven data bits and one parity bit */
   \      0x16E   0xF421 0x6100      BIC      R1,R1,#0x800
   \      0x172   0xE006             B.N      ??LPUART_Init_14
    348                  }
    349                  else
    350                  {
    351                      temp |= LPUART_CTRL_M7_MASK;
   \                     ??LPUART_Init_13: (+1)
   \      0x174   0xF441 0x6100      ORR      R1,R1,#0x800
   \      0x178   0xE003             B.N      ??LPUART_Init_14
    352                  }
    353              }
    354              else
    355          #endif
    356              {
    357                  if (kLPUART_ParityDisabled != config->parityMode)
   \                     ??LPUART_Init_12: (+1)
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xD001             BEQ.N    ??LPUART_Init_14
    358                  {
    359                      temp |= LPUART_CTRL_M_MASK; /* Eight data bits and one parity bit */
   \      0x17E   0xF041 0x0110      ORR      R1,R1,#0x10
    360                  }
    361              }
    362          
    363              base->CTRL = temp;
   \                     ??LPUART_Init_14: (+1)
   \      0x182   0x61A9             STR      R1,[R5, #+24]
    364          
    365          #if defined(FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT
    366              /* set stop bit per char */
    367              temp = base->BAUD & ~LPUART_BAUD_SBNS_MASK;
   \      0x184   0x6928             LDR      R0,[R5, #+16]
   \      0x186   0xF420 0x5000      BIC      R0,R0,#0x2000
    368              base->BAUD = temp | LPUART_BAUD_SBNS((uint8_t)config->stopBitCount);
   \      0x18A   0x79E1             LDRB     R1,[R4, #+7]
   \      0x18C   0x0349             LSLS     R1,R1,#+13
   \      0x18E   0xF401 0x5100      AND      R1,R1,#0x2000
   \      0x192   0x4308             ORRS     R0,R1,R0
   \      0x194   0x6128             STR      R0,[R5, #+16]
    369          #endif
    370          
    371          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    372              /* Set tx/rx WATER watermark
    373                 Note:
    374                 Take care of the RX FIFO, RX interrupt request only assert when received bytes
    375                 equal or more than RX water mark, there is potential issue if RX water
    376                 mark larger than 1.
    377                 For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
    378                 5 bytes are received. the last byte will be saved in FIFO but not trigger
    379                 RX interrupt because the water mark is 2.
    380               */
    381              base->WATER = (((uint32_t)(config->rxFifoWatermark) << 16) | config->txFifoWatermark);
   \      0x196   0x7A60             LDRB     R0,[R4, #+9]
   \      0x198   0x7A21             LDRB     R1,[R4, #+8]
   \      0x19A   0xEA41 0x4100      ORR      R1,R1,R0, LSL #+16
   \      0x19E   0x62E9             STR      R1,[R5, #+44]
    382          
    383              /* Enable tx/rx FIFO */
    384              base->FIFO |= (LPUART_FIFO_TXFE_MASK | LPUART_FIFO_RXFE_MASK);
   \      0x1A0   0x6AA8             LDR      R0,[R5, #+40]
   \      0x1A2   0xF040 0x0088      ORR      R0,R0,#0x88
   \      0x1A6   0x62A8             STR      R0,[R5, #+40]
    385          
    386              /* Flush FIFO */
    387              base->FIFO |= (LPUART_FIFO_TXFLUSH_MASK | LPUART_FIFO_RXFLUSH_MASK);
   \      0x1A8   0x6AA8             LDR      R0,[R5, #+40]
   \      0x1AA   0xF440 0x4040      ORR      R0,R0,#0xC000
   \      0x1AE   0x62A8             STR      R0,[R5, #+40]
    388          #endif
    389          
    390              /* Clear all status flags */
    391              temp = (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_NF_MASK |
    392                      LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK);
    393          
    394          #if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
    395              temp |= LPUART_STAT_LBKDIF_MASK;
    396          #endif
    397          
    398          #if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
    399              temp |= (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK);
   \      0x1B0   0x....'....        LDR.W    R1,??DataTable32  ;; 0xc01fc000
    400          #endif
    401          
    402          #if defined(FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT) && FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT
    403              /* Set the CTS configuration/TX CTS source. */
    404              base->MODIR |= LPUART_MODIR_TXCTSC(config->txCtsConfig) | LPUART_MODIR_TXCTSSRC(config->txCtsSource);
   \      0x1B4   0x6A68             LDR      R0,[R5, #+36]
   \      0x1B6   0x7B62             LDRB     R2,[R4, #+13]
   \      0x1B8   0x0112             LSLS     R2,R2,#+4
   \      0x1BA   0xF002 0x0210      AND      R2,R2,#0x10
   \      0x1BE   0x7B23             LDRB     R3,[R4, #+12]
   \      0x1C0   0x015B             LSLS     R3,R3,#+5
   \      0x1C2   0xF003 0x0320      AND      R3,R3,#0x20
   \      0x1C6   0x431A             ORRS     R2,R3,R2
   \      0x1C8   0x4310             ORRS     R0,R2,R0
   \      0x1CA   0x6268             STR      R0,[R5, #+36]
    405              if (config->enableRxRTS)
   \      0x1CC   0x7AA0             LDRB     R0,[R4, #+10]
   \      0x1CE   0x2800             CMP      R0,#+0
   \      0x1D0   0xD003             BEQ.N    ??LPUART_Init_15
    406              {
    407                  /* Enable the receiver RTS(request-to-send) function. */
    408                  base->MODIR |= LPUART_MODIR_RXRTSE_MASK;
   \      0x1D2   0x6A68             LDR      R0,[R5, #+36]
   \      0x1D4   0xF040 0x0008      ORR      R0,R0,#0x8
   \      0x1D8   0x6268             STR      R0,[R5, #+36]
    409              }
    410              if (config->enableTxCTS)
   \                     ??LPUART_Init_15: (+1)
   \      0x1DA   0x7AE0             LDRB     R0,[R4, #+11]
   \      0x1DC   0x2800             CMP      R0,#+0
   \      0x1DE   0xD003             BEQ.N    ??LPUART_Init_16
    411              {
    412                  /* Enable the CTS(clear-to-send) function. */
    413                  base->MODIR |= LPUART_MODIR_TXCTSE_MASK;
   \      0x1E0   0x6A68             LDR      R0,[R5, #+36]
   \      0x1E2   0xF040 0x0001      ORR      R0,R0,#0x1
   \      0x1E6   0x6268             STR      R0,[R5, #+36]
    414              }
    415          #endif
    416          
    417              /* Set data bits order. */
    418              if (config->isMsb)
   \                     ??LPUART_Init_16: (+1)
   \      0x1E8   0x79A0             LDRB     R0,[R4, #+6]
   \      0x1EA   0x2800             CMP      R0,#+0
   \      0x1EC   0xD001             BEQ.N    ??LPUART_Init_17
    419              {
    420                  temp |= LPUART_STAT_MSBF_MASK;
   \      0x1EE   0x....'....        LDR.W    R1,??DataTable32_1  ;; 0xe01fc000
    421              }
    422              else
    423              {
    424                  temp &= ~LPUART_STAT_MSBF_MASK;
    425              }
    426          
    427              base->STAT |= temp;
   \                     ??LPUART_Init_17: (+1)
   \      0x1F2   0x6968             LDR      R0,[R5, #+20]
   \      0x1F4   0x4301             ORRS     R1,R1,R0
   \      0x1F6   0x6169             STR      R1,[R5, #+20]
    428          
    429              /* Enable TX/RX base on configure structure. */
    430              temp = base->CTRL;
   \      0x1F8   0x69A9             LDR      R1,[R5, #+24]
    431              if (config->enableTx)
   \      0x1FA   0x7C20             LDRB     R0,[R4, #+16]
   \      0x1FC   0x2800             CMP      R0,#+0
   \      0x1FE   0xD001             BEQ.N    ??LPUART_Init_18
    432              {
    433                  temp |= LPUART_CTRL_TE_MASK;
   \      0x200   0xF441 0x2100      ORR      R1,R1,#0x80000
    434              }
    435          
    436              if (config->enableRx)
   \                     ??LPUART_Init_18: (+1)
   \      0x204   0x7C60             LDRB     R0,[R4, #+17]
   \      0x206   0x2800             CMP      R0,#+0
   \      0x208   0xD001             BEQ.N    ??LPUART_Init_19
    437              {
    438                  temp |= LPUART_CTRL_RE_MASK;
   \      0x20A   0xF441 0x2180      ORR      R1,R1,#0x40000
    439              }
    440          
    441              base->CTRL = temp;
   \                     ??LPUART_Init_19: (+1)
   \      0x20E   0x61A9             STR      R1,[R5, #+24]
    442          
    443              return kStatus_Success;
   \      0x210   0x2000             MOVS     R0,#+0
   \                     ??LPUART_Init_10: (+1)
   \      0x212   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    444          }
    445          /*!
    446           * brief Deinitializes a LPUART instance.
    447           *
    448           * This function waits for transmit to complete, disables TX and RX, and disables the LPUART clock.
    449           *
    450           * param base LPUART peripheral base address.
    451           */

   \                                 In section .text, align 2, keep-with-next
    452          void LPUART_Deinit(LPUART_Type *base)
    453          {
   \                     LPUART_Deinit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    454              uint32_t temp;
    455          
    456          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    457              /* Wait tx FIFO send out*/
    458              while (0 != ((base->WATER & LPUART_WATER_TXCOUNT_MASK) >> LPUART_WATER_TXWATER_SHIFT))
   \                     ??LPUART_Deinit_0: (+1)
   \        0x2   0x6AC1             LDR      R1,[R0, #+44]
   \        0x4   0xF411 0x6FE0      TST      R1,#0x700
   \        0x8   0xD1FB             BNE.N    ??LPUART_Deinit_0
    459              {
    460              }
    461          #endif
    462              /* Wait last char shift out */
    463              while (0 == (base->STAT & LPUART_STAT_TC_MASK))
   \                     ??LPUART_Deinit_1: (+1)
   \        0xA   0x6941             LDR      R1,[R0, #+20]
   \        0xC   0x0249             LSLS     R1,R1,#+9
   \        0xE   0xD5FC             BPL.N    ??LPUART_Deinit_1
    464              {
    465              }
    466          
    467              /* Clear all status flags */
    468              temp = (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_NF_MASK |
    469                      LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK);
    470          
    471          #if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
    472              temp |= LPUART_STAT_LBKDIF_MASK;
    473          #endif
    474          
    475          #if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
    476              temp |= (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK);
    477          #endif
    478          
    479              base->STAT |= temp;
   \       0x10   0x6941             LDR      R1,[R0, #+20]
   \       0x12   0xF041 0x4140      ORR      R1,R1,#0xC0000000
   \       0x16   0xF441 0x11FE      ORR      R1,R1,#0x1FC000
   \       0x1A   0x6141             STR      R1,[R0, #+20]
    480          
    481              /* Disable the module. */
    482              base->CTRL = 0;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x6181             STR      R1,[R0, #+24]
    483          
    484          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    485              uint32_t instance = LPUART_GetInstance(base);
   \       0x20   0x....'....        BL       LPUART_GetInstance
    486          
    487              /* Disable lpuart clock */
    488              CLOCK_DisableClock(s_lpuartClock[instance]);
   \       0x24   0x....'....        LDR.W    R1,??DataTable29
   \       0x28   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x2C   0xE8BD 0x4002      POP      {R1,LR}
   \       0x30   0x....             B.N      CLOCK_DisableClock
    489          
    490          #if defined(LPUART_PERIPH_CLOCKS)
    491              CLOCK_DisableClock(s_lpuartPeriphClocks[instance]);
    492          #endif
    493          
    494          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    495          }
    496          
    497          /*!
    498           * brief Gets the default configuration structure.
    499           *
    500           * This function initializes the LPUART configuration structure to a default value. The default
    501           * values are:
    502           *   lpuartConfig->baudRate_Bps = 115200U;
    503           *   lpuartConfig->parityMode = kLPUART_ParityDisabled;
    504           *   lpuartConfig->dataBitsCount = kLPUART_EightDataBits;
    505           *   lpuartConfig->isMsb = false;
    506           *   lpuartConfig->stopBitCount = kLPUART_OneStopBit;
    507           *   lpuartConfig->txFifoWatermark = 0;
    508           *   lpuartConfig->rxFifoWatermark = 1;
    509           *   lpuartConfig->rxIdleType = kLPUART_IdleTypeStartBit;
    510           *   lpuartConfig->rxIdleConfig = kLPUART_IdleCharacter1;
    511           *   lpuartConfig->enableTx = false;
    512           *   lpuartConfig->enableRx = false;
    513           *
    514           * param config Pointer to a configuration structure.
    515           */

   \                                 In section .text, align 2, keep-with-next
    516          void LPUART_GetDefaultConfig(lpuart_config_t *config)
    517          {
   \                     LPUART_GetDefaultConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    518              assert(config);
   \        0x4   0xD109             BNE.N    ??LPUART_GetDefaultConfig_0
   \        0x6   0xF240 0x2206      MOVW     R2,#+518
   \        0xA   0x....'....        LDR.W    R1,??DataTable23_5
   \        0xE   0x....'....        LDR.W    R0,??DataTable23_8
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
    519          
    520              /* Initializes the configure structure to zero. */
    521              memset(config, 0, sizeof(*config));
   \                     ??LPUART_GetDefaultConfig_0: (+1)
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x2114             MOVS     R1,#+20
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x....'....        BL       __aeabi_memset4
    522          
    523              config->baudRate_Bps = 115200U;
   \       0x24   0xF44F 0x30E1      MOV      R0,#+115200
   \       0x28   0x6020             STR      R0,[R4, #+0]
    524              config->parityMode = kLPUART_ParityDisabled;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x7120             STRB     R0,[R4, #+4]
    525              config->dataBitsCount = kLPUART_EightDataBits;
   \       0x2E   0x7160             STRB     R0,[R4, #+5]
    526              config->isMsb = false;
   \       0x30   0x71A0             STRB     R0,[R4, #+6]
    527          #if defined(FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT
    528              config->stopBitCount = kLPUART_OneStopBit;
   \       0x32   0x71E0             STRB     R0,[R4, #+7]
    529          #endif
    530          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    531              config->txFifoWatermark = 0;
   \       0x34   0x7220             STRB     R0,[R4, #+8]
    532              config->rxFifoWatermark = 0;
   \       0x36   0x7260             STRB     R0,[R4, #+9]
    533          #endif
    534          #if defined(FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT) && FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT
    535              config->enableRxRTS = false;
   \       0x38   0x72A0             STRB     R0,[R4, #+10]
    536              config->enableTxCTS = false;
   \       0x3A   0x72E0             STRB     R0,[R4, #+11]
    537              config->txCtsConfig = kLPUART_CtsSampleAtStart;
   \       0x3C   0x7360             STRB     R0,[R4, #+13]
    538              config->txCtsSource = kLPUART_CtsSourcePin;
   \       0x3E   0x7320             STRB     R0,[R4, #+12]
    539          #endif
    540              config->rxIdleType = kLPUART_IdleTypeStartBit;
   \       0x40   0x73A0             STRB     R0,[R4, #+14]
    541              config->rxIdleConfig = kLPUART_IdleCharacter1;
   \       0x42   0x73E0             STRB     R0,[R4, #+15]
    542              config->enableTx = false;
   \       0x44   0x7420             STRB     R0,[R4, #+16]
    543              config->enableRx = false;
   \       0x46   0x7460             STRB     R0,[R4, #+17]
    544          }
   \       0x48   0xBD10             POP      {R4,PC}          ;; return
    545          
    546          /*!
    547           * brief Sets the LPUART instance baudrate.
    548           *
    549           * This function configures the LPUART module baudrate. This function is used to update
    550           * the LPUART module baudrate after the LPUART module is initialized by the LPUART_Init.
    551           * code
    552           *  LPUART_SetBaudRate(LPUART1, 115200U, 20000000U);
    553           * endcode
    554           *
    555           * param base LPUART peripheral base address.
    556           * param baudRate_Bps LPUART baudrate to be set.
    557           * param srcClock_Hz LPUART clock source frequency in HZ.
    558           * retval kStatus_LPUART_BaudrateNotSupport Baudrate is not supported in the current clock source.
    559           * retval kStatus_Success Set baudrate succeeded.
    560           */

   \                                 In section .text, align 2, keep-with-next
    561          status_t LPUART_SetBaudRate(LPUART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
    562          {
   \                     LPUART_SetBaudRate: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
    563              assert(baudRate_Bps);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD109             BNE.N    ??LPUART_SetBaudRate_0
   \        0xC   0xF240 0x2233      MOVW     R2,#+563
   \       0x10   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x14   0x....'....        LDR.W    R0,??DataTable32_2
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
    564          
    565              uint32_t temp, oldCtrl;
    566              uint16_t sbr, sbrTemp;
    567              uint32_t osr, osrTemp, tempDiff, calculatedBaud, baudDiff;
    568          
    569              /* This LPUART instantiation uses a slightly different baud rate calculation
    570               * The idea is to use the best OSR (over-sampling rate) possible
    571               * Note, OSR is typically hard-set to 16 in other LPUART instantiations
    572               * loop to find the best OSR value possible, one that generates minimum baudDiff
    573               * iterate through the rest of the supported values of OSR */
    574          
    575              baudDiff = baudRate_Bps;
   \                     ??LPUART_SetBaudRate_0: (+1)
   \       0x20   0x4620             MOV      R0,R4
    576              osr = 0;
   \       0x22   0x2100             MOVS     R1,#+0
    577              sbr = 0;
   \       0x24   0x460A             MOV      R2,R1
    578              for (osrTemp = 4; osrTemp <= 32; osrTemp++)
   \       0x26   0x2304             MOVS     R3,#+4
   \       0x28   0xE032             B.N      ??LPUART_SetBaudRate_1
    579              {
    580                  /* calculate the temporary sbr value   */
    581                  sbrTemp = (srcClock_Hz / (baudRate_Bps * osrTemp));
   \                     ??LPUART_SetBaudRate_2: (+1)
   \       0x2A   0xFB03 0xF704      MUL      R7,R3,R4
   \       0x2E   0xFBB6 0xF7F7      UDIV     R7,R6,R7
    582                  /*set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate*/
    583                  if (sbrTemp == 0)
   \       0x32   0x46BC             MOV      R12,R7
   \       0x34   0xFA1F 0xFC8C      UXTH     R12,R12
   \       0x38   0xF1BC 0x0F00      CMP      R12,#+0
   \       0x3C   0xD100             BNE.N    ??LPUART_SetBaudRate_3
    584                  {
    585                      sbrTemp = 1;
   \       0x3E   0x2701             MOVS     R7,#+1
    586                  }
    587                  /* Calculate the baud rate based on the temporary OSR and SBR values */
    588                  calculatedBaud = (srcClock_Hz / (osrTemp * sbrTemp));
    589          
    590                  tempDiff = calculatedBaud - baudRate_Bps;
   \                     ??LPUART_SetBaudRate_3: (+1)
   \       0x40   0x46BC             MOV      R12,R7
   \       0x42   0xFA1F 0xFC8C      UXTH     R12,R12
   \       0x46   0xFB0C 0xFC03      MUL      R12,R12,R3
   \       0x4A   0xFBB6 0xFCFC      UDIV     R12,R6,R12
   \       0x4E   0xEBAC 0x0C04      SUB      R12,R12,R4
    591          
    592                  /* Select the better value between srb and (sbr + 1) */
    593                  if (tempDiff > (baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)))))
   \       0x52   0x46BE             MOV      LR,R7
   \       0x54   0xFA1F 0xFE8E      UXTH     LR,LR
   \       0x58   0xF10E 0x0E01      ADD      LR,LR,#+1
   \       0x5C   0xFB0E 0xFE03      MUL      LR,LR,R3
   \       0x60   0xFBB6 0xFEFE      UDIV     LR,R6,LR
   \       0x64   0xEBA4 0x0E0E      SUB      LR,R4,LR
   \       0x68   0x45E6             CMP      LR,R12
   \       0x6A   0xD20B             BCS.N    ??LPUART_SetBaudRate_4
    594                  {
    595                      tempDiff = baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)));
   \       0x6C   0x46BC             MOV      R12,R7
   \       0x6E   0xFA1F 0xFC8C      UXTH     R12,R12
   \       0x72   0xF10C 0x0C01      ADD      R12,R12,#+1
   \       0x76   0xFB0C 0xFC03      MUL      R12,R12,R3
   \       0x7A   0xFBB6 0xFCFC      UDIV     R12,R6,R12
   \       0x7E   0xEBA4 0x0C0C      SUB      R12,R4,R12
    596                      sbrTemp++;
   \       0x82   0x1C7F             ADDS     R7,R7,#+1
    597                  }
    598          
    599                  if (tempDiff <= baudDiff)
   \                     ??LPUART_SetBaudRate_4: (+1)
   \       0x84   0x4560             CMP      R0,R12
   \       0x86   0xD302             BCC.N    ??LPUART_SetBaudRate_5
    600                  {
    601                      baudDiff = tempDiff;
   \       0x88   0x4660             MOV      R0,R12
    602                      osr = osrTemp; /* update and store the best OSR value calculated */
   \       0x8A   0x4619             MOV      R1,R3
    603                      sbr = sbrTemp; /* update store the best SBR value calculated */
   \       0x8C   0x463A             MOV      R2,R7
    604                  }
    605              }
   \                     ??LPUART_SetBaudRate_5: (+1)
   \       0x8E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??LPUART_SetBaudRate_1: (+1)
   \       0x90   0x2B21             CMP      R3,#+33
   \       0x92   0xD3CA             BCC.N    ??LPUART_SetBaudRate_2
    606          
    607              /* Check to see if actual baud rate is within 3% of desired baud rate
    608               * based on the best calculate OSR value */
    609              if (baudDiff < ((baudRate_Bps / 100) * 3))
   \       0x94   0x2364             MOVS     R3,#+100
   \       0x96   0xFBB4 0xF3F3      UDIV     R3,R4,R3
   \       0x9A   0xEB03 0x0343      ADD      R3,R3,R3, LSL #+1
   \       0x9E   0x4298             CMP      R0,R3
   \       0xA0   0xD21A             BCS.N    ??LPUART_SetBaudRate_6
    610              {
    611                  /* Store CTRL before disable Tx and Rx */
    612                  oldCtrl = base->CTRL;
   \       0xA2   0x69AB             LDR      R3,[R5, #+24]
    613          
    614                  /* Disable LPUART TX RX before setting. */
    615                  base->CTRL &= ~(LPUART_CTRL_TE_MASK | LPUART_CTRL_RE_MASK);
   \       0xA4   0x69A8             LDR      R0,[R5, #+24]
   \       0xA6   0xF420 0x2040      BIC      R0,R0,#0xC0000
   \       0xAA   0x61A8             STR      R0,[R5, #+24]
    616          
    617                  temp = base->BAUD;
   \       0xAC   0x692C             LDR      R4,[R5, #+16]
    618          
    619                  /* Acceptable baud rate, check if OSR is between 4x and 7x oversampling.
    620                   * If so, then "BOTHEDGE" sampling must be turned on */
    621                  if ((osr > 3) && (osr < 8))
   \       0xAE   0x1F08             SUBS     R0,R1,#+4
   \       0xB0   0x2804             CMP      R0,#+4
   \       0xB2   0xD201             BCS.N    ??LPUART_SetBaudRate_7
    622                  {
    623                      temp |= LPUART_BAUD_BOTHEDGE_MASK;
   \       0xB4   0xF444 0x3400      ORR      R4,R4,#0x20000
    624                  }
    625          
    626                  /* program the osr value (bit value is one less than actual value) */
    627                  temp &= ~LPUART_BAUD_OSR_MASK;
    628                  temp |= LPUART_BAUD_OSR(osr - 1);
    629          
    630                  /* write the sbr value to the BAUD registers */
    631                  temp &= ~LPUART_BAUD_SBR_MASK;
    632                  base->BAUD = temp | LPUART_BAUD_SBR(sbr);
   \                     ??LPUART_SetBaudRate_7: (+1)
   \       0xB8   0x....'....        LDR.W    R0,??DataTable30  ;; 0xe0ffe000
   \       0xBC   0x4004             ANDS     R4,R0,R4
   \       0xBE   0x1E49             SUBS     R1,R1,#+1
   \       0xC0   0x0609             LSLS     R1,R1,#+24
   \       0xC2   0xF001 0x51F8      AND      R1,R1,#0x1F000000
   \       0xC6   0x4321             ORRS     R1,R1,R4
   \       0xC8   0xB292             UXTH     R2,R2
   \       0xCA   0xF3C2 0x020C      UBFX     R2,R2,#+0,#+13
   \       0xCE   0x4311             ORRS     R1,R2,R1
   \       0xD0   0x6129             STR      R1,[R5, #+16]
    633          
    634                  /* Restore CTRL. */
    635                  base->CTRL = oldCtrl;
   \       0xD2   0x61AB             STR      R3,[R5, #+24]
    636          
    637                  return kStatus_Success;
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0xBDF2             POP      {R1,R4-R7,PC}
    638              }
    639              else
    640              {
    641                  /* Unacceptable baud rate difference of more than 3%*/
    642                  return kStatus_LPUART_BaudrateNotSupport;
   \                     ??LPUART_SetBaudRate_6: (+1)
   \       0xD8   0xF240 0x5021      MOVW     R0,#+1313
   \       0xDC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    643              }
    644          }
    645          
    646          /*!
    647           * brief Enables LPUART interrupts according to a provided mask.
    648           *
    649           * This function enables the LPUART interrupts according to a provided mask. The mask
    650           * is a logical OR of enumeration members. See the ref _lpuart_interrupt_enable.
    651           * This examples shows how to enable TX empty interrupt and RX full interrupt:
    652           * code
    653           *     LPUART_EnableInterrupts(LPUART1,kLPUART_TxDataRegEmptyInterruptEnable | kLPUART_RxDataRegFullInterruptEnable);
    654           * endcode
    655           *
    656           * param base LPUART peripheral base address.
    657           * param mask The interrupts to enable. Logical OR of ref _uart_interrupt_enable.
    658           */

   \                                 In section .text, align 2, keep-with-next
    659          void LPUART_EnableInterrupts(LPUART_Type *base, uint32_t mask)
    660          {
    661              base->BAUD |= ((mask << 8) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
   \                     LPUART_EnableInterrupts: (+1)
   \        0x0   0x6902             LDR      R2,[R0, #+16]
   \        0x2   0x020B             LSLS     R3,R1,#+8
   \        0x4   0xF403 0x4340      AND      R3,R3,#0xC000
   \        0x8   0x431A             ORRS     R2,R3,R2
   \        0xA   0x6102             STR      R2,[R0, #+16]
    662          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    663              base->FIFO = (base->FIFO & ~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK)) |
    664                           ((mask << 8) & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK));
   \        0xC   0x6A82             LDR      R2,[R0, #+40]
   \        0xE   0xF422 0x3240      BIC      R2,R2,#0x30000
   \       0x12   0x020B             LSLS     R3,R1,#+8
   \       0x14   0xF403 0x7340      AND      R3,R3,#0x300
   \       0x18   0x431A             ORRS     R2,R3,R2
   \       0x1A   0x6282             STR      R2,[R0, #+40]
    665          #endif
    666              mask &= 0xFFFFFF00U;
    667              base->CTRL |= mask;
   \       0x1C   0x6982             LDR      R2,[R0, #+24]
   \       0x1E   0x0A09             LSRS     R1,R1,#+8
   \       0x20   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \       0x24   0x6181             STR      R1,[R0, #+24]
    668          }
   \       0x26   0x4770             BX       LR               ;; return
    669          
    670          /*!
    671           * brief Disables  LPUART interrupts according to a provided mask.
    672           *
    673           * This function disables the LPUART interrupts according to a provided mask. The mask
    674           * is a logical OR of enumeration members. See ref _lpuart_interrupt_enable.
    675           * This example shows how to disable the TX empty interrupt and RX full interrupt:
    676           * code
    677           *     LPUART_DisableInterrupts(LPUART1,kLPUART_TxDataRegEmptyInterruptEnable | kLPUART_RxDataRegFullInterruptEnable);
    678           * endcode
    679           *
    680           * param base LPUART peripheral base address.
    681           * param mask The interrupts to disable. Logical OR of ref _lpuart_interrupt_enable.
    682           */

   \                                 In section .text, align 2, keep-with-next
    683          void LPUART_DisableInterrupts(LPUART_Type *base, uint32_t mask)
    684          {
    685              base->BAUD &= ~((mask << 8) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
   \                     LPUART_DisableInterrupts: (+1)
   \        0x0   0x6902             LDR      R2,[R0, #+16]
   \        0x2   0x020B             LSLS     R3,R1,#+8
   \        0x4   0xF403 0x4340      AND      R3,R3,#0xC000
   \        0x8   0x439A             BICS     R2,R2,R3
   \        0xA   0x6102             STR      R2,[R0, #+16]
    686          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    687              base->FIFO = (base->FIFO & ~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK)) &
    688                           ~((mask << 8) & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK));
   \        0xC   0x6A82             LDR      R2,[R0, #+40]
   \        0xE   0x020B             LSLS     R3,R1,#+8
   \       0x10   0xF403 0x7340      AND      R3,R3,#0x300
   \       0x14   0x43DB             MVNS     R3,R3
   \       0x16   0xF423 0x3340      BIC      R3,R3,#0x30000
   \       0x1A   0x401A             ANDS     R2,R3,R2
   \       0x1C   0x6282             STR      R2,[R0, #+40]
    689          #endif
    690              mask &= 0xFFFFFF00U;
    691              base->CTRL &= ~mask;
   \       0x1E   0x6982             LDR      R2,[R0, #+24]
   \       0x20   0x0A09             LSRS     R1,R1,#+8
   \       0x22   0xEA22 0x2101      BIC      R1,R2,R1, LSL #+8
   \       0x26   0x6181             STR      R1,[R0, #+24]
    692          }
   \       0x28   0x4770             BX       LR               ;; return
    693          
    694          /*!
    695           * brief Gets enabled LPUART interrupts.
    696           *
    697           * This function gets the enabled LPUART interrupts. The enabled interrupts are returned
    698           * as the logical OR value of the enumerators ref _lpuart_interrupt_enable. To check
    699           * a specific interrupt enable status, compare the return value with enumerators
    700           * in ref _lpuart_interrupt_enable.
    701           * For example, to check whether the TX empty interrupt is enabled:
    702           * code
    703           *     uint32_t enabledInterrupts = LPUART_GetEnabledInterrupts(LPUART1);
    704           *
    705           *     if (kLPUART_TxDataRegEmptyInterruptEnable & enabledInterrupts)
    706           *     {
    707           *         ...
    708           *     }
    709           * endcode
    710           *
    711           * param base LPUART peripheral base address.
    712           * return LPUART interrupt flags which are logical OR of the enumerators in ref _lpuart_interrupt_enable.
    713           */

   \                                 In section .text, align 2, keep-with-next
    714          uint32_t LPUART_GetEnabledInterrupts(LPUART_Type *base)
    715          {
   \                     LPUART_GetEnabledInterrupts: (+1)
   \        0x0   0x4601             MOV      R1,R0
    716              uint32_t temp;
    717              temp = (base->BAUD & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK)) >> 8;
   \        0x2   0x6908             LDR      R0,[R1, #+16]
   \        0x4   0x0A00             LSRS     R0,R0,#+8
   \        0x6   0xF000 0x00C0      AND      R0,R0,#0xC0
    718          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    719              temp |= (base->FIFO & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK)) >> 8;
   \        0xA   0x6A8A             LDR      R2,[R1, #+40]
   \        0xC   0xF3C2 0x2201      UBFX     R2,R2,#+8,#+2
   \       0x10   0x4310             ORRS     R0,R2,R0
    720          #endif
    721              temp |= (base->CTRL & 0xFF0C000);
   \       0x12   0x698A             LDR      R2,[R1, #+24]
   \       0x14   0x....'....        LDR.W    R1,??DataTable32_3  ;; 0xff0c000
   \       0x18   0x400A             ANDS     R2,R1,R2
   \       0x1A   0x4310             ORRS     R0,R2,R0
    722          
    723              return temp;
   \       0x1C   0x4770             BX       LR               ;; return
    724          }
    725          
    726          /*!
    727           * brief Gets LPUART status flags.
    728           *
    729           * This function gets all LPUART status flags. The flags are returned as the logical
    730           * OR value of the enumerators ref _lpuart_flags. To check for a specific status,
    731           * compare the return value with enumerators in the ref _lpuart_flags.
    732           * For example, to check whether the TX is empty:
    733           * code
    734           *     if (kLPUART_TxDataRegEmptyFlag & LPUART_GetStatusFlags(LPUART1))
    735           *     {
    736           *         ...
    737           *     }
    738           * endcode
    739           *
    740           * param base LPUART peripheral base address.
    741           * return LPUART status flags which are ORed by the enumerators in the _lpuart_flags.
    742           */

   \                                 In section .text, align 2, keep-with-next
    743          uint32_t LPUART_GetStatusFlags(LPUART_Type *base)
    744          {
   \                     LPUART_GetStatusFlags: (+1)
   \        0x0   0x4601             MOV      R1,R0
    745              uint32_t temp;
    746              temp = base->STAT;
   \        0x2   0x6948             LDR      R0,[R1, #+20]
    747          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    748              temp |= (base->FIFO &
    749                       (LPUART_FIFO_TXEMPT_MASK | LPUART_FIFO_RXEMPT_MASK | LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK)) >>
    750                      16;
   \        0x4   0x6A89             LDR      R1,[R1, #+40]
   \        0x6   0x0C09             LSRS     R1,R1,#+16
   \        0x8   0xF001 0x01C3      AND      R1,R1,#0xC3
   \        0xC   0x4308             ORRS     R0,R1,R0
    751          #endif
    752              return temp;
   \        0xE   0x4770             BX       LR               ;; return
    753          }
    754          
    755          /*!
    756           * brief Clears status flags with a provided mask.
    757           *
    758           * This function clears LPUART status flags with a provided mask. Automatically cleared flags
    759           * can't be cleared by this function.
    760           * Flags that can only cleared or set by hardware are:
    761           *    kLPUART_TxDataRegEmptyFlag, kLPUART_TransmissionCompleteFlag, kLPUART_RxDataRegFullFlag,
    762           *    kLPUART_RxActiveFlag, kLPUART_NoiseErrorInRxDataRegFlag, kLPUART_ParityErrorInRxDataRegFlag,
    763           *    kLPUART_TxFifoEmptyFlag,kLPUART_RxFifoEmptyFlag
    764           * Note: This API should be called when the Tx/Rx is idle, otherwise it takes no effects.
    765           *
    766           * param base LPUART peripheral base address.
    767           * param mask the status flags to be cleared. The user can use the enumerators in the
    768           *  _lpuart_status_flag_t to do the OR operation and get the mask.
    769           * return 0 succeed, others failed.
    770           * retval kStatus_LPUART_FlagCannotClearManually The flag can't be cleared by this function but
    771           *         it is cleared automatically by hardware.
    772           * retval kStatus_Success Status in the mask are cleared.
    773           */

   \                                 In section .text, align 2, keep-with-next
    774          status_t LPUART_ClearStatusFlags(LPUART_Type *base, uint32_t mask)
    775          {
   \                     LPUART_ClearStatusFlags: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    776              uint32_t temp;
    777              status_t status;
    778          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    779              temp = (uint32_t)base->FIFO;
   \        0x4   0x6A81             LDR      R1,[R0, #+40]
    780              temp &= (uint32_t)(~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK));
    781              temp |= (mask << 16) & (LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK);
    782              base->FIFO = temp;
   \        0x6   0xF364 0x4111      BFI      R1,R4,#+16,#+2
   \        0xA   0x6281             STR      R1,[R0, #+40]
    783          #endif
    784              temp = (uint32_t)base->STAT;
   \        0xC   0x6942             LDR      R2,[R0, #+20]
    785          #if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
    786              temp &= (uint32_t)(~(LPUART_STAT_LBKDIF_MASK));
    787              temp |= mask & LPUART_STAT_LBKDIF_MASK;
    788          #endif
    789              temp &= (uint32_t)(~(LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_NF_MASK |
    790                                   LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK));
    791              temp |= mask & (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_NF_MASK |
    792                              LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK);
    793          #if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
    794              temp &= (uint32_t)(~(LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK));
    795              temp |= mask & (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK);
    796          #endif
    797              base->STAT = temp;
   \        0xE   0x....'....        LDR.W    R1,??DataTable32_4  ;; 0x3fe03fff
   \       0x12   0x400A             ANDS     R2,R1,R2
   \       0x14   0x....'....        LDR.W    R1,??DataTable32  ;; 0xc01fc000
   \       0x18   0x4021             ANDS     R1,R1,R4
   \       0x1A   0x430A             ORRS     R2,R1,R2
   \       0x1C   0x6142             STR      R2,[R0, #+20]
    798              /* If some flags still pending. */
    799              if (mask & LPUART_GetStatusFlags(base))
   \       0x1E   0x....'....        BL       LPUART_GetStatusFlags
   \       0x22   0x4204             TST      R4,R0
   \       0x24   0xD002             BEQ.N    ??LPUART_ClearStatusFlags_0
    800              {
    801                  /* Some flags can only clear or set by the hardware itself, these flags are: kLPUART_TxDataRegEmptyFlag,
    802                  kLPUART_TransmissionCompleteFlag, kLPUART_RxDataRegFullFlag, kLPUART_RxActiveFlag,
    803                  kLPUART_NoiseErrorInRxDataRegFlag, kLPUART_ParityErrorInRxDataRegFlag,
    804                  kLPUART_TxFifoEmptyFlag, kLPUART_RxFifoEmptyFlag. */
    805                  status = kStatus_LPUART_FlagCannotClearManually; /* flags can not clear manually */
   \       0x26   0xF240 0x501A      MOVW     R0,#+1306
   \       0x2A   0xBD10             POP      {R4,PC}
    806              }
    807              else
    808              {
    809                  status = kStatus_Success;
   \                     ??LPUART_ClearStatusFlags_0: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
    810              }
    811          
    812              return status;
   \       0x2E   0xBD10             POP      {R4,PC}          ;; return
    813          }
    814          
    815          /*!
    816           * brief Writes to the transmitter register using a blocking method.
    817           *
    818           * This function polls the transmitter register, waits for the register to be empty or  for TX FIFO to have
    819           * room, and writes data to the transmitter buffer.
    820           *
    821           * note This function does not check whether all data has been sent out to the bus.
    822           * Before disabling the transmitter, check the kLPUART_TransmissionCompleteFlag to ensure that the transmit is
    823           * finished.
    824           *
    825           * param base LPUART peripheral base address.
    826           * param data Start address of the data to write.
    827           * param length Size of the data to write.
    828           */

   \                                 In section .text, align 2, keep-with-next
    829          void LPUART_WriteBlocking(LPUART_Type *base, const uint8_t *data, size_t length)
    830          {
   \                     LPUART_WriteBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
    831              assert(data);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD110             BNE.N    ??LPUART_WriteBlocking_0
   \        0xC   0xF240 0x323F      MOVW     R2,#+831
   \       0x10   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x14   0x....'....        LDR.W    R0,??DataTable28
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
   \       0x20   0xE005             B.N      ??LPUART_WriteBlocking_0
    832          
    833              /* This API can only ensure that the data is written into the data buffer but can't
    834              ensure all data in the data buffer are sent into the transmit shift buffer. */
    835              while (length--)
    836              {
    837                  while (!(base->STAT & LPUART_STAT_TDRE_MASK))
   \                     ??LPUART_WriteBlocking_1: (+1)
   \       0x22   0x6968             LDR      R0,[R5, #+20]
   \       0x24   0x0200             LSLS     R0,R0,#+8
   \       0x26   0xD5FC             BPL.N    ??LPUART_WriteBlocking_1
    838                  {
    839                  }
    840                  base->DATA = *(data++);
   \       0x28   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \       0x2C   0x61E8             STR      R0,[R5, #+28]
    841              }
   \                     ??LPUART_WriteBlocking_0: (+1)
   \       0x2E   0x4630             MOV      R0,R6
   \       0x30   0x1E46             SUBS     R6,R0,#+1
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD1F5             BNE.N    ??LPUART_WriteBlocking_1
    842          }
   \       0x36   0xBD70             POP      {R4-R6,PC}       ;; return
    843          
    844          /*!
    845          * brief Reads the receiver data register using a blocking method.
    846           *
    847           * This function polls the receiver register, waits for the receiver register full or receiver FIFO
    848           * has data, and reads data from the TX register.
    849           *
    850           * param base LPUART peripheral base address.
    851           * param data Start address of the buffer to store the received data.
    852           * param length Size of the buffer.
    853           * retval kStatus_LPUART_RxHardwareOverrun Receiver overrun happened while receiving data.
    854           * retval kStatus_LPUART_NoiseError Noise error happened while receiving data.
    855           * retval kStatus_LPUART_FramingError Framing error happened while receiving data.
    856           * retval kStatus_LPUART_ParityError Parity error happened while receiving data.
    857           * retval kStatus_Success Successfully received all data.
    858           */

   \                                 In section .text, align 2, keep-with-next
    859          status_t LPUART_ReadBlocking(LPUART_Type *base, uint8_t *data, size_t length)
    860          {
   \                     LPUART_ReadBlocking: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4617             MOV      R7,R2
    861              assert(data);
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD109             BNE.N    ??LPUART_ReadBlocking_0
   \        0xC   0xF240 0x325D      MOVW     R2,#+861
   \       0x10   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x14   0x....'....        LDR.W    R0,??DataTable28
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
    862          
    863              uint32_t statusFlag;
    864          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    865              uint32_t ctrl = base->CTRL;
   \                     ??LPUART_ReadBlocking_0: (+1)
   \       0x20   0x69B0             LDR      R0,[R6, #+24]
    866              bool isSevenDataBits =
    867                  ((ctrl & LPUART_CTRL_M7_MASK) || ((!(ctrl & LPUART_CTRL_M_MASK)) && (ctrl & LPUART_CTRL_PE_MASK)));
   \       0x22   0x0501             LSLS     R1,R0,#+20
   \       0x24   0xD403             BMI.N    ??LPUART_ReadBlocking_1
   \       0x26   0xF000 0x0012      AND      R0,R0,#0x12
   \       0x2A   0x2802             CMP      R0,#+2
   \       0x2C   0xD101             BNE.N    ??LPUART_ReadBlocking_2
   \                     ??LPUART_ReadBlocking_1: (+1)
   \       0x2E   0x2401             MOVS     R4,#+1
   \       0x30   0xE005             B.N      ??LPUART_ReadBlocking_3
   \                     ??LPUART_ReadBlocking_2: (+1)
   \       0x32   0x2400             MOVS     R4,#+0
   \       0x34   0xE003             B.N      ??LPUART_ReadBlocking_3
    868          #endif
    869          
    870              while (length--)
    871              {
    872          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    873                  while (0 == ((base->WATER & LPUART_WATER_RXCOUNT_MASK) >> LPUART_WATER_RXCOUNT_SHIFT))
    874          #else
    875                  while (!(base->STAT & LPUART_STAT_RDRF_MASK))
    876          #endif
    877                  {
    878                      statusFlag = LPUART_GetStatusFlags(base);
    879          
    880                      if (statusFlag & kLPUART_RxOverrunFlag)
    881                      {
    882                          LPUART_ClearStatusFlags(base, kLPUART_RxOverrunFlag);
    883                          return kStatus_LPUART_RxHardwareOverrun;
    884                      }
    885          
    886                      if (statusFlag & kLPUART_NoiseErrorFlag)
    887                      {
    888                          LPUART_ClearStatusFlags(base, kLPUART_NoiseErrorFlag);
    889                          return kStatus_LPUART_NoiseError;
    890                      }
    891          
    892                      if (statusFlag & kLPUART_FramingErrorFlag)
    893                      {
    894                          LPUART_ClearStatusFlags(base, kLPUART_FramingErrorFlag);
    895                          return kStatus_LPUART_FramingError;
    896                      }
    897          
    898                      if (statusFlag & kLPUART_ParityErrorFlag)
    899                      {
    900                          LPUART_ClearStatusFlags(base, kLPUART_ParityErrorFlag);
    901                          return kStatus_LPUART_ParityError;
    902                      }
    903                  }
    904          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    905                  if (isSevenDataBits)
    906                  {
    907                      *(data++) = (base->DATA & 0x7F);
   \                     ??LPUART_ReadBlocking_4: (+1)
   \       0x36   0xF000 0x007F      AND      R0,R0,#0x7F
   \       0x3A   0xF805 0x0B01      STRB     R0,[R5], #+1
    908                  }
   \                     ??LPUART_ReadBlocking_3: (+1)
   \       0x3E   0x4638             MOV      R0,R7
   \       0x40   0x1E47             SUBS     R7,R0,#+1
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD02F             BEQ.N    ??LPUART_ReadBlocking_5
   \                     ??LPUART_ReadBlocking_6: (+1)
   \       0x46   0x6AF0             LDR      R0,[R6, #+44]
   \       0x48   0xF3C0 0x6002      UBFX     R0,R0,#+24,#+3
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD12C             BNE.N    ??LPUART_ReadBlocking_7
   \       0x50   0x4630             MOV      R0,R6
   \       0x52   0x....'....        BL       LPUART_GetStatusFlags
   \       0x56   0x0301             LSLS     R1,R0,#+12
   \       0x58   0xD40D             BMI.N    ??LPUART_ReadBlocking_8
   \       0x5A   0x0341             LSLS     R1,R0,#+13
   \       0x5C   0xD413             BMI.N    ??LPUART_ReadBlocking_9
   \       0x5E   0x0381             LSLS     R1,R0,#+14
   \       0x60   0xD419             BMI.N    ??LPUART_ReadBlocking_10
   \       0x62   0x03C0             LSLS     R0,R0,#+15
   \       0x64   0xD5EF             BPL.N    ??LPUART_ReadBlocking_6
   \       0x66   0xF44F 0x3180      MOV      R1,#+65536
   \       0x6A   0x4630             MOV      R0,R6
   \       0x6C   0x....'....        BL       LPUART_ClearStatusFlags
   \       0x70   0xF44F 0x60A4      MOV      R0,#+1312
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??LPUART_ReadBlocking_8: (+1)
   \       0x76   0xF44F 0x2100      MOV      R1,#+524288
   \       0x7A   0x4630             MOV      R0,R6
   \       0x7C   0x....'....        BL       LPUART_ClearStatusFlags
   \       0x80   0xF240 0x501D      MOVW     R0,#+1309
   \       0x84   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??LPUART_ReadBlocking_9: (+1)
   \       0x86   0xF44F 0x2180      MOV      R1,#+262144
   \       0x8A   0x4630             MOV      R0,R6
   \       0x8C   0x....'....        BL       LPUART_ClearStatusFlags
   \       0x90   0xF240 0x501E      MOVW     R0,#+1310
   \       0x94   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??LPUART_ReadBlocking_10: (+1)
   \       0x96   0xF44F 0x3100      MOV      R1,#+131072
   \       0x9A   0x4630             MOV      R0,R6
   \       0x9C   0x....'....        BL       LPUART_ClearStatusFlags
   \       0xA0   0xF240 0x501F      MOVW     R0,#+1311
   \       0xA4   0xBDF2             POP      {R1,R4-R7,PC}
    909                  else
    910                  {
    911                      *(data++) = base->DATA;
    912                  }
    913          #else
    914                  *(data++) = base->DATA;
    915          #endif
    916              }
    917          
    918              return kStatus_Success;
   \                     ??LPUART_ReadBlocking_5: (+1)
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??LPUART_ReadBlocking_7: (+1)
   \       0xAA   0x2C00             CMP      R4,#+0
   \       0xAC   0x69F0             LDR      R0,[R6, #+28]
   \       0xAE   0xD1C2             BNE.N    ??LPUART_ReadBlocking_4
   \       0xB0   0xF805 0x0B01      STRB     R0,[R5], #+1
   \       0xB4   0xE7C3             B.N      ??LPUART_ReadBlocking_3
    919          }
    920          
    921          /*!
    922           * brief Initializes the LPUART handle.
    923           *
    924           * This function initializes the LPUART handle, which can be used for other LPUART
    925           * transactional APIs. Usually, for a specified LPUART instance,
    926           * call this API once to get the initialized handle.
    927           *
    928           * The LPUART driver supports the "background" receiving, which means that user can set up
    929           * an RX ring buffer optionally. Data received is stored into the ring buffer even when the
    930           * user doesn't call the LPUART_TransferReceiveNonBlocking() API. If there is already data received
    931           * in the ring buffer, the user can get the received data from the ring buffer directly.
    932           * The ring buffer is disabled if passing NULL as p ringBuffer.
    933           *
    934           * param base LPUART peripheral base address.
    935           * param handle LPUART handle pointer.
    936           * param callback Callback function.
    937           * param userData User data.
    938           */

   \                                 In section .text, align 2, keep-with-next
    939          void LPUART_TransferCreateHandle(LPUART_Type *base,
    940                                           lpuart_handle_t *handle,
    941                                           lpuart_transfer_callback_t callback,
    942                                           void *userData)
    943          {
   \                     LPUART_TransferCreateHandle: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    944              assert(handle);
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD109             BNE.N    ??LPUART_TransferCreateHandle_0
   \       0x10   0xF44F 0x726C      MOV      R2,#+944
   \       0x14   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x18   0x....'....        LDR.W    R0,??DataTable23_7
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    945          
    946              uint32_t instance;
    947          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    948              uint32_t ctrl = base->CTRL;
   \                     ??LPUART_TransferCreateHandle_0: (+1)
   \       0x24   0x69A8             LDR      R0,[R5, #+24]
    949              bool isSevenDataBits =
    950                  ((ctrl & LPUART_CTRL_M7_MASK) || ((!(ctrl & LPUART_CTRL_M_MASK)) && (ctrl & LPUART_CTRL_PE_MASK)));
   \       0x26   0x0501             LSLS     R1,R0,#+20
   \       0x28   0xD403             BMI.N    ??LPUART_TransferCreateHandle_1
   \       0x2A   0xF000 0x0012      AND      R0,R0,#0x12
   \       0x2E   0x2802             CMP      R0,#+2
   \       0x30   0xD102             BNE.N    ??LPUART_TransferCreateHandle_2
   \                     ??LPUART_TransferCreateHandle_1: (+1)
   \       0x32   0xF04F 0x0801      MOV      R8,#+1
   \       0x36   0xE001             B.N      ??LPUART_TransferCreateHandle_3
   \                     ??LPUART_TransferCreateHandle_2: (+1)
   \       0x38   0xF04F 0x0800      MOV      R8,#+0
    951          #endif
    952          
    953              /* Zero the handle. */
    954              memset(handle, 0, sizeof(lpuart_handle_t));
   \                     ??LPUART_TransferCreateHandle_3: (+1)
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0x2130             MOVS     R1,#+48
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x....'....        BL       __aeabi_memset4
    955          
    956              /* Set the TX/RX state. */
    957              handle->rxState = kLPUART_RxIdle;
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0xF884 0x002D      STRB     R0,[R4, #+45]
    958              handle->txState = kLPUART_TxIdle;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xF884 0x002C      STRB     R0,[R4, #+44]
    959          
    960              /* Set the callback and user data. */
    961              handle->callback = callback;
   \       0x52   0x6266             STR      R6,[R4, #+36]
    962              handle->userData = userData;
   \       0x54   0x62A7             STR      R7,[R4, #+40]
    963          
    964          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    965              /* Initial seven data bits flag */
    966              handle->isSevenDataBits = isSevenDataBits;
   \       0x56   0xF884 0x802E      STRB     R8,[R4, #+46]
    967          #endif
    968          
    969              /* Get instance from peripheral base address. */
    970              instance = LPUART_GetInstance(base);
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0x....'....        BL       LPUART_GetInstance
    971          
    972              /* Save the handle in global variables to support the double weak mechanism. */
    973              s_lpuartHandle[instance] = handle;
   \       0x60   0x....'....        LDR.W    R1,??DataTable32_5
   \       0x64   0xF841 0x4020      STR      R4,[R1, R0, LSL #+2]
    974          
    975              s_lpuartIsr = LPUART_TransferHandleIRQ;
   \       0x68   0x....'....        ADR.W    R1,LPUART_TransferHandleIRQ
   \       0x6C   0x....'....        LDR.W    R2,??DataTable32_6
   \       0x70   0x6011             STR      R1,[R2, #+0]
    976          
    977          /* Enable interrupt in NVIC. */
    978          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
    979              EnableIRQ(s_lpuartRxIRQ[instance]);
    980              EnableIRQ(s_lpuartTxIRQ[instance]);
    981          #else
    982              EnableIRQ(s_lpuartIRQ[instance]);
   \       0x72   0x....'....        LDR.W    R1,??DataTable32_7
   \       0x76   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x7A   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x7E   0x....             B.N      EnableIRQ
    983          #endif
    984          }
    985          
    986          /*!
    987           * brief Sets up the RX ring buffer.
    988           *
    989           * This function sets up the RX ring buffer to a specific UART handle.
    990           *
    991           * When the RX ring buffer is used, data received is stored into the ring buffer even when
    992           * the user doesn't call the UART_TransferReceiveNonBlocking() API. If there is already data received
    993           * in the ring buffer, the user can get the received data from the ring buffer directly.
    994           *
    995           * note When using RX ring buffer, one byte is reserved for internal use. In other
    996           * words, if p ringBufferSize is 32, then only 31 bytes are used for saving data.
    997           *
    998           * param base LPUART peripheral base address.
    999           * param handle LPUART handle pointer.
   1000           * param ringBuffer Start address of ring buffer for background receiving. Pass NULL to disable the ring buffer.
   1001           * param ringBufferSize size of the ring buffer.
   1002           */

   \                                 In section .text, align 2, keep-with-next
   1003          void LPUART_TransferStartRingBuffer(LPUART_Type *base,
   1004                                              lpuart_handle_t *handle,
   1005                                              uint8_t *ringBuffer,
   1006                                              size_t ringBufferSize)
   1007          {
   \                     LPUART_TransferStartRingBuffer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461F             MOV      R7,R3
   1008              assert(handle);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD109             BNE.N    ??LPUART_TransferStartRingBuffer_0
   \        0xE   0xF44F 0x727C      MOV      R2,#+1008
   \       0x12   0x....'....        LDR.W    R1,??DataTable23_5
   \       0x16   0x....'....        LDR.W    R0,??DataTable23_7
   \       0x1A   0x....'....        BL       __aeabi_assert
   \       0x1E   0x....'....        BL       __iar_EmptyStepPoint
   1009              assert(ringBuffer);
   \                     ??LPUART_TransferStartRingBuffer_0: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD108             BNE.N    ??LPUART_TransferStartRingBuffer_1
   \       0x26   0xF240 0x32F1      MOVW     R2,#+1009
   \       0x2A   0x....             LDR.N    R1,??DataTable23_5
   \       0x2C   0x....'....        LDR.W    R0,??DataTable32_8
   \       0x30   0x....'....        BL       __aeabi_assert
   \       0x34   0x....'....        BL       __iar_EmptyStepPoint
   1010          
   1011              /* Setup the ring buffer address */
   1012              handle->rxRingBuffer = ringBuffer;
   \                     ??LPUART_TransferStartRingBuffer_1: (+1)
   \       0x38   0x61AC             STR      R4,[R5, #+24]
   1013              handle->rxRingBufferSize = ringBufferSize;
   \       0x3A   0x61EF             STR      R7,[R5, #+28]
   1014              handle->rxRingBufferHead = 0U;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x8428             STRH     R0,[R5, #+32]
   1015              handle->rxRingBufferTail = 0U;
   \       0x40   0x8468             STRH     R0,[R5, #+34]
   1016          
   1017              /* Enable the interrupt to accept the data when user need the ring buffer. */
   1018              LPUART_EnableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunInterruptEnable);
   \       0x42   0xF04F 0x6102      MOV      R1,#+136314880
   \       0x46   0x4630             MOV      R0,R6
   \       0x48   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x4C   0x....             B.N      LPUART_EnableInterrupts
   1019          }
   1020          
   1021          /*!
   1022           * brief Aborts the background transfer and uninstalls the ring buffer.
   1023           *
   1024           * This function aborts the background transfer and uninstalls the ring buffer.
   1025           *
   1026           * param base LPUART peripheral base address.
   1027           * param handle LPUART handle pointer.
   1028           */

   \                                 In section .text, align 2, keep-with-next
   1029          void LPUART_TransferStopRingBuffer(LPUART_Type *base, lpuart_handle_t *handle)
   1030          {
   \                     LPUART_TransferStopRingBuffer: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1031              assert(handle);
   \        0x6   0xD108             BNE.N    ??LPUART_TransferStopRingBuffer_0
   \        0x8   0xF240 0x4207      MOVW     R2,#+1031
   \        0xC   0x....             LDR.N    R1,??DataTable23_5
   \        0xE   0x....'....        LDR.W    R0,??DataTable32_9
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
   1032          
   1033              if (handle->rxState == kLPUART_RxIdle)
   \                     ??LPUART_TransferStopRingBuffer_0: (+1)
   \       0x1A   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \       0x1E   0x2802             CMP      R0,#+2
   \       0x20   0xD104             BNE.N    ??LPUART_TransferStopRingBuffer_1
   1034              {
   1035                  LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunInterruptEnable);
   \       0x22   0xF04F 0x6102      MOV      R1,#+136314880
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x....'....        BL       LPUART_DisableInterrupts
   1036              }
   1037          
   1038              handle->rxRingBuffer = NULL;
   \                     ??LPUART_TransferStopRingBuffer_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x61A0             STR      R0,[R4, #+24]
   1039              handle->rxRingBufferSize = 0U;
   \       0x30   0x61E0             STR      R0,[R4, #+28]
   1040              handle->rxRingBufferHead = 0U;
   \       0x32   0x8420             STRH     R0,[R4, #+32]
   1041              handle->rxRingBufferTail = 0U;
   \       0x34   0x8460             STRH     R0,[R4, #+34]
   1042          }
   \       0x36   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1043          
   1044          /*!
   1045           * brief Transmits a buffer of data using the interrupt method.
   1046           *
   1047           * This function send data using an interrupt method. This is a non-blocking function, which
   1048           * returns directly without waiting for all data written to the transmitter register. When
   1049           * all data is written to the TX register in the ISR, the LPUART driver calls the callback
   1050           * function and passes the ref kStatus_LPUART_TxIdle as status parameter.
   1051           *
   1052           * note The kStatus_LPUART_TxIdle is passed to the upper layer when all data are written
   1053           * to the TX register. However, there is no check to ensure that all the data sent out. Before disabling the TX,
   1054           * check the kLPUART_TransmissionCompleteFlag to ensure that the transmit is finished.
   1055           *
   1056           * param base LPUART peripheral base address.
   1057           * param handle LPUART handle pointer.
   1058           * param xfer LPUART transfer structure, see #lpuart_transfer_t.
   1059           * retval kStatus_Success Successfully start the data transmission.
   1060           * retval kStatus_LPUART_TxBusy Previous transmission still not finished, data not all written to the TX register.
   1061           * retval kStatus_InvalidArgument Invalid argument.
   1062           */

   \                                 In section .text, align 2, keep-with-next
   1063          status_t LPUART_TransferSendNonBlocking(LPUART_Type *base, lpuart_handle_t *handle, lpuart_transfer_t *xfer)
   1064          {
   \                     LPUART_TransferSendNonBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
   1065              assert(handle);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD107             BNE.N    ??LPUART_TransferSendNonBlocking_0
   \        0xC   0xF240 0x4229      MOVW     R2,#+1065
   \       0x10   0x....             LDR.N    R1,??DataTable23_5
   \       0x12   0x....             LDR.N    R0,??DataTable23_7
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
   1066              assert(xfer);
   \                     ??LPUART_TransferSendNonBlocking_0: (+1)
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD108             BNE.N    ??LPUART_TransferSendNonBlocking_1
   \       0x20   0xF240 0x422A      MOVW     R2,#+1066
   \       0x24   0x....             LDR.N    R1,??DataTable23_5
   \       0x26   0x....'....        LDR.W    R0,??DataTable32_10
   \       0x2A   0x....'....        BL       __aeabi_assert
   \       0x2E   0x....'....        BL       __iar_EmptyStepPoint
   1067              assert(xfer->data);
   \                     ??LPUART_TransferSendNonBlocking_1: (+1)
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD108             BNE.N    ??LPUART_TransferSendNonBlocking_2
   \       0x38   0xF240 0x422B      MOVW     R2,#+1067
   \       0x3C   0x....             LDR.N    R1,??DataTable23_5
   \       0x3E   0x....'....        LDR.W    R0,??DataTable32_11
   \       0x42   0x....'....        BL       __aeabi_assert
   \       0x46   0x....'....        BL       __iar_EmptyStepPoint
   1068              assert(xfer->dataSize);
   \                     ??LPUART_TransferSendNonBlocking_2: (+1)
   \       0x4A   0x6868             LDR      R0,[R5, #+4]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD108             BNE.N    ??LPUART_TransferSendNonBlocking_3
   \       0x50   0xF240 0x422C      MOVW     R2,#+1068
   \       0x54   0x....             LDR.N    R1,??DataTable23_5
   \       0x56   0x....'....        LDR.W    R0,??DataTable32_12
   \       0x5A   0x....'....        BL       __aeabi_assert
   \       0x5E   0x....'....        BL       __iar_EmptyStepPoint
   1069          
   1070              status_t status;
   1071          
   1072              /* Return error if current TX busy. */
   1073              if (kLPUART_TxBusy == handle->txState)
   \                     ??LPUART_TransferSendNonBlocking_3: (+1)
   \       0x62   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \       0x66   0x2801             CMP      R0,#+1
   \       0x68   0xD102             BNE.N    ??LPUART_TransferSendNonBlocking_4
   1074              {
   1075                  status = kStatus_LPUART_TxBusy;
   \       0x6A   0xF240 0x5014      MOVW     R0,#+1300
   \       0x6E   0xBD70             POP      {R4-R6,PC}
   1076              }
   1077              else
   1078              {
   1079                  handle->txData = xfer->data;
   \                     ??LPUART_TransferSendNonBlocking_4: (+1)
   \       0x70   0x6828             LDR      R0,[R5, #+0]
   \       0x72   0x6020             STR      R0,[R4, #+0]
   1080                  handle->txDataSize = xfer->dataSize;
   \       0x74   0x6868             LDR      R0,[R5, #+4]
   \       0x76   0x6060             STR      R0,[R4, #+4]
   1081                  handle->txDataSizeAll = xfer->dataSize;
   \       0x78   0x6868             LDR      R0,[R5, #+4]
   \       0x7A   0x60A0             STR      R0,[R4, #+8]
   1082                  handle->txState = kLPUART_TxBusy;
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xF884 0x002C      STRB     R0,[R4, #+44]
   1083          
   1084                  /* Enable transmitter interrupt. */
   1085                  LPUART_EnableInterrupts(base, kLPUART_TxDataRegEmptyInterruptEnable);
   \       0x82   0xF44F 0x0100      MOV      R1,#+8388608
   \       0x86   0x4630             MOV      R0,R6
   \       0x88   0x....'....        BL       LPUART_EnableInterrupts
   1086          
   1087                  status = kStatus_Success;
   \       0x8C   0x2000             MOVS     R0,#+0
   1088              }
   1089          
   1090              return status;
   \       0x8E   0xBD70             POP      {R4-R6,PC}       ;; return
   1091          }
   1092          
   1093          /*!
   1094           * brief Aborts the interrupt-driven data transmit.
   1095           *
   1096           * This function aborts the interrupt driven data sending. The user can get the remainBtyes to find out
   1097           * how many bytes are not sent out.
   1098           *
   1099           * param base LPUART peripheral base address.
   1100           * param handle LPUART handle pointer.
   1101           */

   \                                 In section .text, align 2, keep-with-next
   1102          void LPUART_TransferAbortSend(LPUART_Type *base, lpuart_handle_t *handle)
   1103          {
   \                     LPUART_TransferAbortSend: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1104              assert(handle);
   \        0x6   0xD108             BNE.N    ??LPUART_TransferAbortSend_0
   \        0x8   0xF44F 0x628A      MOV      R2,#+1104
   \        0xC   0x....             LDR.N    R1,??DataTable23_5
   \        0xE   0x....'....        LDR.W    R0,??DataTable32_9
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
   1105          
   1106              LPUART_DisableInterrupts(base, kLPUART_TxDataRegEmptyInterruptEnable | kLPUART_TransmissionCompleteInterruptEnable);
   \                     ??LPUART_TransferAbortSend_0: (+1)
   \       0x1A   0xF44F 0x0140      MOV      R1,#+12582912
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x....'....        BL       LPUART_DisableInterrupts
   1107          
   1108              handle->txDataSize = 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6060             STR      R0,[R4, #+4]
   1109              handle->txState = kLPUART_TxIdle;
   \       0x28   0xF884 0x002C      STRB     R0,[R4, #+44]
   1110          }
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1111          
   1112          /*!
   1113           * brief Gets the number of bytes that have been written to the LPUART transmitter register.
   1114           *
   1115           * This function gets the number of bytes that have been written to LPUART TX
   1116           * register by an interrupt method.
   1117           *
   1118           * param base LPUART peripheral base address.
   1119           * param handle LPUART handle pointer.
   1120           * param count Send bytes count.
   1121           * retval kStatus_NoTransferInProgress No send in progress.
   1122           * retval kStatus_InvalidArgument Parameter is invalid.
   1123           * retval kStatus_Success Get successfully through the parameter \p count;
   1124           */

   \                                 In section .text, align 2, keep-with-next
   1125          status_t LPUART_TransferGetSendCount(LPUART_Type *base, lpuart_handle_t *handle, uint32_t *count)
   1126          {
   \                     LPUART_TransferGetSendCount: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4614             MOV      R4,R2
   1127              assert(handle);
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD107             BNE.N    ??LPUART_TransferGetSendCount_0
   \        0xA   0xF240 0x4267      MOVW     R2,#+1127
   \        0xE   0x....             LDR.N    R1,??DataTable23_5
   \       0x10   0x....             LDR.N    R0,??DataTable23_7
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
   1128              assert(count);
   \                     ??LPUART_TransferGetSendCount_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD108             BNE.N    ??LPUART_TransferGetSendCount_1
   \       0x1E   0xF44F 0x628D      MOV      R2,#+1128
   \       0x22   0x....             LDR.N    R1,??DataTable23_5
   \       0x24   0x....'....        LDR.W    R0,??DataTable32_13
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1129          
   1130              if (kLPUART_TxIdle == handle->txState)
   \                     ??LPUART_TransferGetSendCount_1: (+1)
   \       0x30   0xF895 0x002C      LDRB     R0,[R5, #+44]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD101             BNE.N    ??LPUART_TransferGetSendCount_2
   1131              {
   1132                  return kStatus_NoTransferInProgress;
   \       0x38   0x2006             MOVS     R0,#+6
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
   1133              }
   1134          
   1135              *count = handle->txDataSizeAll - handle->txDataSize;
   \                     ??LPUART_TransferGetSendCount_2: (+1)
   \       0x3C   0x68A9             LDR      R1,[R5, #+8]
   \       0x3E   0x6868             LDR      R0,[R5, #+4]
   \       0x40   0x1A09             SUBS     R1,R1,R0
   \       0x42   0x6021             STR      R1,[R4, #+0]
   1136          
   1137              return kStatus_Success;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1138          }
   1139          
   1140          /*!
   1141           * brief Receives a buffer of data using the interrupt method.
   1142           *
   1143           * This function receives data using an interrupt method. This is a non-blocking function
   1144           * which returns without waiting to ensure that all data are received.
   1145           * If the RX ring buffer is used and not empty, the data in the ring buffer is copied and
   1146           * the parameter p receivedBytes shows how many bytes are copied from the ring buffer.
   1147           * After copying, if the data in the ring buffer is not enough for read, the receive
   1148           * request is saved by the LPUART driver. When the new data arrives, the receive request
   1149           * is serviced first. When all data is received, the LPUART driver notifies the upper layer
   1150           * through a callback function and passes a status parameter ref kStatus_UART_RxIdle.
   1151           * For example, the upper layer needs 10 bytes but there are only 5 bytes in ring buffer.
   1152           * The 5 bytes are copied to xfer->data, which returns with the
   1153           * parameter p receivedBytes set to 5. For the remaining 5 bytes, the newly arrived data is
   1154           * saved from xfer->data[5]. When 5 bytes are received, the LPUART driver notifies the upper layer.
   1155           * If the RX ring buffer is not enabled, this function enables the RX and RX interrupt
   1156           * to receive data to xfer->data. When all data is received, the upper layer is notified.
   1157           *
   1158           * param base LPUART peripheral base address.
   1159           * param handle LPUART handle pointer.
   1160           * param xfer LPUART transfer structure, see #uart_transfer_t.
   1161           * param receivedBytes Bytes received from the ring buffer directly.
   1162           * retval kStatus_Success Successfully queue the transfer into the transmit queue.
   1163           * retval kStatus_LPUART_RxBusy Previous receive request is not finished.
   1164           * retval kStatus_InvalidArgument Invalid argument.
   1165           */

   \                                 In section .text, align 2, keep-with-next
   1166          status_t LPUART_TransferReceiveNonBlocking(LPUART_Type *base,
   1167                                                     lpuart_handle_t *handle,
   1168                                                     lpuart_transfer_t *xfer,
   1169                                                     size_t *receivedBytes)
   1170          {
   \                     LPUART_TransferReceiveNonBlocking: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
   1171              assert(handle);
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD107             BNE.N    ??LPUART_TransferReceiveNonBlocking_0
   \       0x10   0xF240 0x4293      MOVW     R2,#+1171
   \       0x14   0x....             LDR.N    R1,??DataTable23_5
   \       0x16   0x....             LDR.N    R0,??DataTable23_7
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
   1172              assert(xfer);
   \                     ??LPUART_TransferReceiveNonBlocking_0: (+1)
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xD108             BNE.N    ??LPUART_TransferReceiveNonBlocking_1
   \       0x24   0xF240 0x4294      MOVW     R2,#+1172
   \       0x28   0x....             LDR.N    R1,??DataTable23_5
   \       0x2A   0x....'....        LDR.W    R0,??DataTable32_10
   \       0x2E   0x....'....        BL       __aeabi_assert
   \       0x32   0x....'....        BL       __iar_EmptyStepPoint
   1173              assert(xfer->data);
   \                     ??LPUART_TransferReceiveNonBlocking_1: (+1)
   \       0x36   0x6830             LDR      R0,[R6, #+0]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD108             BNE.N    ??LPUART_TransferReceiveNonBlocking_2
   \       0x3C   0xF240 0x4295      MOVW     R2,#+1173
   \       0x40   0x....             LDR.N    R1,??DataTable23_5
   \       0x42   0x....'....        LDR.W    R0,??DataTable32_11
   \       0x46   0x....'....        BL       __aeabi_assert
   \       0x4A   0x....'....        BL       __iar_EmptyStepPoint
   1174              assert(xfer->dataSize);
   \                     ??LPUART_TransferReceiveNonBlocking_2: (+1)
   \       0x4E   0x6870             LDR      R0,[R6, #+4]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD108             BNE.N    ??LPUART_TransferReceiveNonBlocking_3
   \       0x54   0xF240 0x4296      MOVW     R2,#+1174
   \       0x58   0x....             LDR.N    R1,??DataTable23_5
   \       0x5A   0x....'....        LDR.W    R0,??DataTable32_12
   \       0x5E   0x....'....        BL       __aeabi_assert
   \       0x62   0x....'....        BL       __iar_EmptyStepPoint
   1175          
   1176              uint32_t i;
   1177              status_t status;
   1178              /* How many bytes to copy from ring buffer to user memory. */
   1179              size_t bytesToCopy = 0U;
   1180              /* How many bytes to receive. */
   1181              size_t bytesToReceive;
   1182              /* How many bytes currently have received. */
   1183              size_t bytesCurrentReceived;
   1184          
   1185              /* How to get data:
   1186                 1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
   1187                    to lpuart handle, enable interrupt to store received data to xfer->data. When
   1188                    all data received, trigger callback.
   1189                 2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
   1190                    If there are enough data in ring buffer, copy them to xfer->data and return.
   1191                    If there are not enough data in ring buffer, copy all of them to xfer->data,
   1192                    save the xfer->data remained empty space to lpuart handle, receive data
   1193                    to this empty space and trigger callback when finished. */
   1194          
   1195              if (kLPUART_RxBusy == handle->rxState)
   \                     ??LPUART_TransferReceiveNonBlocking_3: (+1)
   \       0x66   0xF895 0x002D      LDRB     R0,[R5, #+45]
   \       0x6A   0x2803             CMP      R0,#+3
   \       0x6C   0xD102             BNE.N    ??LPUART_TransferReceiveNonBlocking_4
   1196              {
   1197                  status = kStatus_LPUART_RxBusy;
   \       0x6E   0xF240 0x5015      MOVW     R0,#+1301
   \       0x72   0xE03D             B.N      ??LPUART_TransferReceiveNonBlocking_5
   1198              }
   1199              else
   1200              {
   1201                  bytesToReceive = xfer->dataSize;
   \                     ??LPUART_TransferReceiveNonBlocking_4: (+1)
   \       0x74   0x6874             LDR      R4,[R6, #+4]
   1202                  bytesCurrentReceived = 0;
   \       0x76   0xF04F 0x0900      MOV      R9,#+0
   1203          
   1204                  /* If RX ring buffer is used. */
   1205                  if (handle->rxRingBuffer)
   \       0x7A   0x69A8             LDR      R0,[R5, #+24]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD026             BEQ.N    ??LPUART_TransferReceiveNonBlocking_6
   1206                  {
   1207                      /* Disable LPUART RX IRQ, protect ring buffer. */
   1208                      LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable);
   \       0x80   0xF44F 0x1100      MOV      R1,#+2097152
   \       0x84   0x4640             MOV      R0,R8
   \       0x86   0x....'....        BL       LPUART_DisableInterrupts
   1209          
   1210                      /* How many bytes in RX ring buffer currently. */
   1211                      bytesToCopy = LPUART_TransferGetRxRingBufferLength(base, handle);
   \       0x8A   0x4629             MOV      R1,R5
   \       0x8C   0x4640             MOV      R0,R8
   \       0x8E   0x....'....        BL       LPUART_TransferGetRxRingBufferLength
   1212          
   1213                      if (bytesToCopy)
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD02E             BEQ.N    ??LPUART_TransferReceiveNonBlocking_7
   1214                      {
   1215                          bytesToCopy = MIN(bytesToReceive, bytesToCopy);
   \       0x96   0x4284             CMP      R4,R0
   \       0x98   0xD800             BHI.N    ??LPUART_TransferReceiveNonBlocking_8
   \       0x9A   0x4620             MOV      R0,R4
   1216          
   1217                          bytesToReceive -= bytesToCopy;
   \                     ??LPUART_TransferReceiveNonBlocking_8: (+1)
   \       0x9C   0x1A24             SUBS     R4,R4,R0
   1218          
   1219                          /* Copy data from ring buffer to user memory. */
   1220                          for (i = 0U; i < bytesToCopy; i++)
   \       0x9E   0x4649             MOV      R1,R9
   \                     ??LPUART_TransferReceiveNonBlocking_9: (+1)
   \       0xA0   0x4281             CMP      R1,R0
   \       0xA2   0xD227             BCS.N    ??LPUART_TransferReceiveNonBlocking_7
   1221                          {
   1222                              xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferTail];
   \       0xA4   0x69AA             LDR      R2,[R5, #+24]
   \       0xA6   0x8C6B             LDRH     R3,[R5, #+34]
   \       0xA8   0x5CD2             LDRB     R2,[R2, R3]
   \       0xAA   0x6833             LDR      R3,[R6, #+0]
   \       0xAC   0xF803 0x2009      STRB     R2,[R3, R9]
   \       0xB0   0xF109 0x0901      ADD      R9,R9,#+1
   1223          
   1224                              /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
   1225                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
   \       0xB4   0x8C6A             LDRH     R2,[R5, #+34]
   \       0xB6   0x1C52             ADDS     R2,R2,#+1
   \       0xB8   0x69EB             LDR      R3,[R5, #+28]
   \       0xBA   0x429A             CMP      R2,R3
   \       0xBC   0xD003             BEQ.N    ??LPUART_TransferReceiveNonBlocking_10
   1226                              {
   1227                                  handle->rxRingBufferTail = 0U;
   1228                              }
   1229                              else
   1230                              {
   1231                                  handle->rxRingBufferTail++;
   \       0xBE   0x8C6A             LDRH     R2,[R5, #+34]
   \       0xC0   0x1C52             ADDS     R2,R2,#+1
   \       0xC2   0x846A             STRH     R2,[R5, #+34]
   \       0xC4   0xE001             B.N      ??LPUART_TransferReceiveNonBlocking_11
   1232                              }
   \                     ??LPUART_TransferReceiveNonBlocking_10: (+1)
   \       0xC6   0x2200             MOVS     R2,#+0
   \       0xC8   0x846A             STRH     R2,[R5, #+34]
   1233                          }
   \                     ??LPUART_TransferReceiveNonBlocking_11: (+1)
   \       0xCA   0x1C49             ADDS     R1,R1,#+1
   \       0xCC   0xE7E8             B.N      ??LPUART_TransferReceiveNonBlocking_9
   1234                      }
   1235          
   1236                      /* If ring buffer does not have enough data, still need to read more data. */
   1237                      if (bytesToReceive)
   1238                      {
   1239                          /* No data in ring buffer, save the request to LPUART handle. */
   1240                          handle->rxData = xfer->data + bytesCurrentReceived;
   1241                          handle->rxDataSize = bytesToReceive;
   1242                          handle->rxDataSizeAll = bytesToReceive;
   1243                          handle->rxState = kLPUART_RxBusy;
   1244                      }
   1245                      /* Enable LPUART RX IRQ if previously enabled. */
   1246                      LPUART_EnableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable);
   1247          
   1248                      /* Call user callback since all data are received. */
   1249                      if (0 == bytesToReceive)
   1250                      {
   1251                          if (handle->callback)
   1252                          {
   1253                              handle->callback(base, handle, kStatus_LPUART_RxIdle, handle->userData);
   1254                          }
   1255                      }
   1256                  }
   1257                  /* Ring buffer not used. */
   1258                  else
   1259                  {
   1260                      handle->rxData = xfer->data + bytesCurrentReceived;
   \                     ??LPUART_TransferReceiveNonBlocking_6: (+1)
   \       0xCE   0x6830             LDR      R0,[R6, #+0]
   \       0xD0   0x60E8             STR      R0,[R5, #+12]
   1261                      handle->rxDataSize = bytesToReceive;
   \       0xD2   0x612C             STR      R4,[R5, #+16]
   1262                      handle->rxDataSizeAll = bytesToReceive;
   \       0xD4   0x616C             STR      R4,[R5, #+20]
   1263                      handle->rxState = kLPUART_RxBusy;
   \       0xD6   0x2003             MOVS     R0,#+3
   \       0xD8   0xF885 0x002D      STRB     R0,[R5, #+45]
   1264          
   1265                      /* Enable RX interrupt. */
   1266                      LPUART_EnableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunInterruptEnable |
   1267                                                        kLPUART_IdleLineInterruptEnable);
   \       0xDC   0xF04F 0x6103      MOV      R1,#+137363456
   \       0xE0   0x4640             MOV      R0,R8
   \       0xE2   0x....'....        BL       LPUART_EnableInterrupts
   1268                  }
   1269          
   1270                  /* Return the how many bytes have read. */
   1271                  if (receivedBytes)
   \                     ??LPUART_TransferReceiveNonBlocking_12: (+1)
   \       0xE6   0x2F00             CMP      R7,#+0
   \       0xE8   0xD001             BEQ.N    ??LPUART_TransferReceiveNonBlocking_13
   1272                  {
   1273                      *receivedBytes = bytesCurrentReceived;
   \       0xEA   0xF8C7 0x9000      STR      R9,[R7, #+0]
   1274                  }
   1275          
   1276                  status = kStatus_Success;
   \                     ??LPUART_TransferReceiveNonBlocking_13: (+1)
   \       0xEE   0x2000             MOVS     R0,#+0
   1277              }
   1278          
   1279              return status;
   \                     ??LPUART_TransferReceiveNonBlocking_5: (+1)
   \       0xF0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??LPUART_TransferReceiveNonBlocking_7: (+1)
   \       0xF4   0x2C00             CMP      R4,#+0
   \       0xF6   0xD007             BEQ.N    ??LPUART_TransferReceiveNonBlocking_14
   \       0xF8   0x6830             LDR      R0,[R6, #+0]
   \       0xFA   0x4448             ADD      R0,R0,R9
   \       0xFC   0x60E8             STR      R0,[R5, #+12]
   \       0xFE   0x612C             STR      R4,[R5, #+16]
   \      0x100   0x616C             STR      R4,[R5, #+20]
   \      0x102   0x2003             MOVS     R0,#+3
   \      0x104   0xF885 0x002D      STRB     R0,[R5, #+45]
   \                     ??LPUART_TransferReceiveNonBlocking_14: (+1)
   \      0x108   0xF44F 0x1100      MOV      R1,#+2097152
   \      0x10C   0x4640             MOV      R0,R8
   \      0x10E   0x....'....        BL       LPUART_EnableInterrupts
   \      0x112   0x2C00             CMP      R4,#+0
   \      0x114   0xD1E7             BNE.N    ??LPUART_TransferReceiveNonBlocking_12
   \      0x116   0x6A68             LDR      R0,[R5, #+36]
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD0E4             BEQ.N    ??LPUART_TransferReceiveNonBlocking_12
   \      0x11C   0x6AAB             LDR      R3,[R5, #+40]
   \      0x11E   0xF240 0x5217      MOVW     R2,#+1303
   \      0x122   0x4629             MOV      R1,R5
   \      0x124   0x4640             MOV      R0,R8
   \      0x126   0x6A6C             LDR      R4,[R5, #+36]
   \      0x128   0x47A0             BLX      R4
   \      0x12A   0xE7DC             B.N      ??LPUART_TransferReceiveNonBlocking_12
   1280          }
   1281          
   1282          /*!
   1283           * brief Aborts the interrupt-driven data receiving.
   1284           *
   1285           * This function aborts the interrupt-driven data receiving. The user can get the remainBytes to find out
   1286           * how many bytes not received yet.
   1287           *
   1288           * param base LPUART peripheral base address.
   1289           * param handle LPUART handle pointer.
   1290           */

   \                                 In section .text, align 2, keep-with-next
   1291          void LPUART_TransferAbortReceive(LPUART_Type *base, lpuart_handle_t *handle)
   1292          {
   \                     LPUART_TransferAbortReceive: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1293              assert(handle);
   \        0x6   0xD108             BNE.N    ??LPUART_TransferAbortReceive_0
   \        0x8   0xF240 0x520D      MOVW     R2,#+1293
   \        0xC   0x....             LDR.N    R1,??DataTable23_5
   \        0xE   0x....'....        LDR.W    R0,??DataTable32_9
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
   1294          
   1295              /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
   1296              if (!handle->rxRingBuffer)
   \                     ??LPUART_TransferAbortReceive_0: (+1)
   \       0x1A   0x69A0             LDR      R0,[R4, #+24]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD104             BNE.N    ??LPUART_TransferAbortReceive_1
   1297              {
   1298                  /* Disable RX interrupt. */
   1299                  LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunInterruptEnable |
   1300                                                     kLPUART_IdleLineInterruptEnable);
   \       0x20   0xF04F 0x6103      MOV      R1,#+137363456
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x....'....        BL       LPUART_DisableInterrupts
   1301              }
   1302          
   1303              handle->rxDataSize = 0U;
   \                     ??LPUART_TransferAbortReceive_1: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6120             STR      R0,[R4, #+16]
   1304              handle->rxState = kLPUART_RxIdle;
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xF884 0x002D      STRB     R0,[R4, #+45]
   1305          }
   \       0x34   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1306          
   1307          /*!
   1308           * brief Gets the number of bytes that have been received.
   1309           *
   1310           * This function gets the number of bytes that have been received.
   1311           *
   1312           * param base LPUART peripheral base address.
   1313           * param handle LPUART handle pointer.
   1314           * param count Receive bytes count.
   1315           * retval kStatus_NoTransferInProgress No receive in progress.
   1316           * retval kStatus_InvalidArgument Parameter is invalid.
   1317           * retval kStatus_Success Get successfully through the parameter \p count;
   1318           */

   \                                 In section .text, align 2, keep-with-next
   1319          status_t LPUART_TransferGetReceiveCount(LPUART_Type *base, lpuart_handle_t *handle, uint32_t *count)
   1320          {
   \                     LPUART_TransferGetReceiveCount: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4614             MOV      R4,R2
   1321              assert(handle);
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD107             BNE.N    ??LPUART_TransferGetReceiveCount_0
   \        0xA   0xF240 0x5229      MOVW     R2,#+1321
   \        0xE   0x....             LDR.N    R1,??DataTable23_5
   \       0x10   0x....             LDR.N    R0,??DataTable23_7
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
   1322              assert(count);
   \                     ??LPUART_TransferGetReceiveCount_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD108             BNE.N    ??LPUART_TransferGetReceiveCount_1
   \       0x1E   0xF240 0x522A      MOVW     R2,#+1322
   \       0x22   0x....             LDR.N    R1,??DataTable23_5
   \       0x24   0x....'....        LDR.W    R0,??DataTable32_13
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1323          
   1324              if (kLPUART_RxIdle == handle->rxState)
   \                     ??LPUART_TransferGetReceiveCount_1: (+1)
   \       0x30   0xF895 0x002D      LDRB     R0,[R5, #+45]
   \       0x34   0x2802             CMP      R0,#+2
   \       0x36   0xD101             BNE.N    ??LPUART_TransferGetReceiveCount_2
   1325              {
   1326                  return kStatus_NoTransferInProgress;
   \       0x38   0x2006             MOVS     R0,#+6
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
   1327              }
   1328          
   1329              *count = handle->rxDataSizeAll - handle->rxDataSize;
   \                     ??LPUART_TransferGetReceiveCount_2: (+1)
   \       0x3C   0x6969             LDR      R1,[R5, #+20]
   \       0x3E   0x6928             LDR      R0,[R5, #+16]
   \       0x40   0x1A09             SUBS     R1,R1,R0
   \       0x42   0x6021             STR      R1,[R4, #+0]
   1330          
   1331              return kStatus_Success;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1332          }
   1333          
   1334          /*!
   1335           * brief LPUART IRQ handle function.
   1336           *
   1337           * This function handles the LPUART transmit and receive IRQ request.
   1338           *
   1339           * param base LPUART peripheral base address.
   1340           * param handle LPUART handle pointer.
   1341           */

   \                                 In section .text, align 4, keep-with-next
   1342          void LPUART_TransferHandleIRQ(LPUART_Type *base, lpuart_handle_t *handle)
   1343          {
   \                     LPUART_TransferHandleIRQ: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
   1344              assert(handle);
   \        0x8   0xF1B8 0x0F00      CMP      R8,#+0
   \        0xC   0xD109             BNE.N    ??LPUART_TransferHandleIRQ_0
   \        0xE   0xF44F 0x62A8      MOV      R2,#+1344
   \       0x12   0x....'....        LDR.W    R1,??DataTable32_14
   \       0x16   0x....'....        LDR.W    R0,??DataTable32_9
   \       0x1A   0x....'....        BL       __aeabi_assert
   \       0x1E   0x....'....        BL       __iar_EmptyStepPoint
   1345          
   1346              uint8_t count;
   1347              uint8_t tempCount;
   1348              uint32_t status = LPUART_GetStatusFlags(base);
   \                     ??LPUART_TransferHandleIRQ_0: (+1)
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0x....'....        BL       LPUART_GetStatusFlags
   \       0x28   0x4605             MOV      R5,R0
   1349              uint32_t enabledInterrupts = LPUART_GetEnabledInterrupts(base);
   \       0x2A   0x4638             MOV      R0,R7
   \       0x2C   0x....'....        BL       LPUART_GetEnabledInterrupts
   \       0x30   0x4606             MOV      R6,R0
   1350          
   1351              /* If RX overrun. */
   1352              if (kLPUART_RxOverrunFlag & status)
   \       0x32   0x0328             LSLS     R0,R5,#+12
   \       0x34   0xD513             BPL.N    ??LPUART_TransferHandleIRQ_1
   1353              {
   1354                  /* Clear overrun flag, otherwise the RX does not work. */
   1355                  base->STAT = ((base->STAT & 0x3FE00000U) | LPUART_STAT_OR_MASK);
   \       0x36   0x6979             LDR      R1,[R7, #+20]
   \       0x38   0x....'....        LDR.W    R0,??DataTable32_15  ;; 0x3fe00000
   \       0x3C   0x4001             ANDS     R1,R0,R1
   \       0x3E   0xF441 0x2100      ORR      R1,R1,#0x80000
   \       0x42   0x6179             STR      R1,[R7, #+20]
   1356          
   1357                  /* Trigger callback. */
   1358                  if (handle->callback)
   \       0x44   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD008             BEQ.N    ??LPUART_TransferHandleIRQ_1
   1359                  {
   1360                      handle->callback(base, handle, kStatus_LPUART_RxHardwareOverrun, handle->userData);
   \       0x4C   0xF8D8 0x3028      LDR      R3,[R8, #+40]
   \       0x50   0xF240 0x521D      MOVW     R2,#+1309
   \       0x54   0x4641             MOV      R1,R8
   \       0x56   0x4638             MOV      R0,R7
   \       0x58   0xF8D8 0x4024      LDR      R4,[R8, #+36]
   \       0x5C   0x47A0             BLX      R4
   1361                  }
   1362              }
   1363          
   1364              /* If IDLE flag is set and the IDLE interrupt is enabled. */
   1365              if ((kLPUART_IdleLineFlag & status) && (kLPUART_IdleLineInterruptEnable & enabledInterrupts))
   \                     ??LPUART_TransferHandleIRQ_1: (+1)
   \       0x5E   0x02E8             LSLS     R0,R5,#+11
   \       0x60   0xF140 0x8143      BPL.W    ??LPUART_TransferHandleIRQ_2
   \       0x64   0x02F0             LSLS     R0,R6,#+11
   \       0x66   0xF140 0x8140      BPL.W    ??LPUART_TransferHandleIRQ_2
   1366              {
   1367          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
   1368                  count = ((uint8_t)((base->WATER & LPUART_WATER_RXCOUNT_MASK) >> LPUART_WATER_RXCOUNT_SHIFT));
   \       0x6A   0x6AFC             LDR      R4,[R7, #+44]
   \       0x6C   0x0E24             LSRS     R4,R4,#+24
   \       0x6E   0xF004 0x0407      AND      R4,R4,#0x7
   \       0x72   0xE016             B.N      ??LPUART_TransferHandleIRQ_3
   1369          
   1370                  while ((count) && (handle->rxDataSize))
   1371                  {
   1372                      tempCount = MIN(handle->rxDataSize, count);
   \                     ??LPUART_TransferHandleIRQ_4: (+1)
   \       0x74   0x46A1             MOV      R9,R4
   \       0x76   0xE024             B.N      ??LPUART_TransferHandleIRQ_5
   1373          
   1374                      /* Using non block API to read the data from the registers. */
   1375                      LPUART_ReadNonBlocking(base, handle->rxData, tempCount);
   1376                      handle->rxData += tempCount;
   1377                      handle->rxDataSize -= tempCount;
   1378                      count -= tempCount;
   1379          
   1380                      /* If rxDataSize is 0, disable idle line interrupt.*/
   1381                      if (!(handle->rxDataSize))
   1382                      {
   1383                          handle->rxState = kLPUART_RxIdle;
   \                     ??LPUART_TransferHandleIRQ_6: (+1)
   \       0x78   0x2002             MOVS     R0,#+2
   \       0x7A   0xF888 0x002D      STRB     R0,[R8, #+45]
   1384          
   1385                          LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunInterruptEnable);
   \       0x7E   0xF04F 0x6102      MOV      R1,#+136314880
   \       0x82   0x4638             MOV      R0,R7
   \       0x84   0x....'....        BL       LPUART_DisableInterrupts
   1386                          if (handle->callback)
   \       0x88   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD008             BEQ.N    ??LPUART_TransferHandleIRQ_3
   1387                          {
   1388                              handle->callback(base, handle, kStatus_LPUART_RxIdle, handle->userData);
   \       0x90   0xF8D8 0x3028      LDR      R3,[R8, #+40]
   \       0x94   0xF240 0x5217      MOVW     R2,#+1303
   \       0x98   0x4641             MOV      R1,R8
   \       0x9A   0x4638             MOV      R0,R7
   \       0x9C   0xF8D8 0xC024      LDR      R12,[R8, #+36]
   \       0xA0   0x47E0             BLX      R12
   1389                          }
   1390                      }
   \                     ??LPUART_TransferHandleIRQ_3: (+1)
   \       0xA2   0x2C00             CMP      R4,#+0
   \       0xA4   0xF000 0x8103      BEQ.W    ??LPUART_TransferHandleIRQ_7
   \       0xA8   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xF000 0x80FE      BEQ.W    ??LPUART_TransferHandleIRQ_7
   \       0xB2   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0xB6   0x42A0             CMP      R0,R4
   \       0xB8   0xD2DC             BCS.N    ??LPUART_TransferHandleIRQ_4
   \       0xBA   0xF8D8 0x9010      LDR      R9,[R8, #+16]
   \       0xBE   0xFA5F 0xF989      UXTB     R9,R9
   \                     ??LPUART_TransferHandleIRQ_5: (+1)
   \       0xC2   0x464A             MOV      R2,R9
   \       0xC4   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \       0xC8   0x4638             MOV      R0,R7
   \       0xCA   0x....'....        BL       LPUART_ReadNonBlocking
   \       0xCE   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0xD2   0x4448             ADD      R0,R0,R9
   \       0xD4   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \       0xD8   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0xDC   0xEBA0 0x0009      SUB      R0,R0,R9
   \       0xE0   0xF8C8 0x0010      STR      R0,[R8, #+16]
   \       0xE4   0xEBA4 0x0409      SUB      R4,R4,R9
   \       0xE8   0xB2E4             UXTB     R4,R4
   \       0xEA   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD1D7             BNE.N    ??LPUART_TransferHandleIRQ_3
   \       0xF2   0xE7C1             B.N      ??LPUART_TransferHandleIRQ_6
   1391                  }
   1392          #endif
   1393                  /* Clear IDLE flag.*/
   1394                  base->STAT |= LPUART_STAT_IDLE_MASK;
   1395          
   1396                  /* If rxDataSize is 0, disable idle line interrupt.*/
   1397                  if (!(handle->rxDataSize))
   1398                  {
   1399                      LPUART_DisableInterrupts(base, kLPUART_IdleLineInterruptEnable);
   1400                  }
   1401                  /* If callback is not NULL and rxDataSize is not 0. */
   1402                  if ((handle->callback) && (handle->rxDataSize))
   1403                  {
   1404                      handle->callback(base, handle, kStatus_LPUART_IdleLineDetected, handle->userData);
   1405                  }
   1406              }
   1407              /* Receive data register full */
   1408              if ((kLPUART_RxDataRegFullFlag & status) && (kLPUART_RxDataRegFullInterruptEnable & enabledInterrupts))
   1409              {
   1410          /* Get the size that can be stored into buffer for this interrupt. */
   1411          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
   1412                  count = ((uint8_t)((base->WATER & LPUART_WATER_RXCOUNT_MASK) >> LPUART_WATER_RXCOUNT_SHIFT));
   1413          #else
   1414                  count = 1;
   1415          #endif
   1416          
   1417                  /* If handle->rxDataSize is not 0, first save data to handle->rxData. */
   1418                  while ((count) && (handle->rxDataSize))
   1419                  {
   1420          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
   1421                      tempCount = MIN(handle->rxDataSize, count);
   \                     ??LPUART_TransferHandleIRQ_8: (+1)
   \       0xF4   0x46A1             MOV      R9,R4
   \       0xF6   0xE01F             B.N      ??LPUART_TransferHandleIRQ_9
   1422          #else
   1423                      tempCount = 1;
   1424          #endif
   1425          
   1426                      /* Using non block API to read the data from the registers. */
   1427                      LPUART_ReadNonBlocking(base, handle->rxData, tempCount);
   1428                      handle->rxData += tempCount;
   1429                      handle->rxDataSize -= tempCount;
   1430                      count -= tempCount;
   1431          
   1432                      /* If all the data required for upper layer is ready, trigger callback. */
   1433                      if (!handle->rxDataSize)
   1434                      {
   1435                          handle->rxState = kLPUART_RxIdle;
   \                     ??LPUART_TransferHandleIRQ_10: (+1)
   \       0xF8   0x2002             MOVS     R0,#+2
   \       0xFA   0xF888 0x002D      STRB     R0,[R8, #+45]
   1436          
   1437                          if (handle->callback)
   \       0xFE   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD008             BEQ.N    ??LPUART_TransferHandleIRQ_11
   1438                          {
   1439                              handle->callback(base, handle, kStatus_LPUART_RxIdle, handle->userData);
   \      0x106   0xF8D8 0x3028      LDR      R3,[R8, #+40]
   \      0x10A   0xF240 0x5217      MOVW     R2,#+1303
   \      0x10E   0x4641             MOV      R1,R8
   \      0x110   0x4638             MOV      R0,R7
   \      0x112   0xF8D8 0xC024      LDR      R12,[R8, #+36]
   \      0x116   0x47E0             BLX      R12
   1440                          }
   1441                      }
   \                     ??LPUART_TransferHandleIRQ_11: (+1)
   \      0x118   0x2C00             CMP      R4,#+0
   \      0x11A   0xF000 0x80F1      BEQ.W    ??LPUART_TransferHandleIRQ_12
   \      0x11E   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xF000 0x80EC      BEQ.W    ??LPUART_TransferHandleIRQ_12
   \      0x128   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \      0x12C   0x42A0             CMP      R0,R4
   \      0x12E   0xD2E1             BCS.N    ??LPUART_TransferHandleIRQ_8
   \      0x130   0xF8D8 0x9010      LDR      R9,[R8, #+16]
   \      0x134   0xFA5F 0xF989      UXTB     R9,R9
   \                     ??LPUART_TransferHandleIRQ_9: (+1)
   \      0x138   0x464A             MOV      R2,R9
   \      0x13A   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \      0x13E   0x4638             MOV      R0,R7
   \      0x140   0x....'....        BL       LPUART_ReadNonBlocking
   \      0x144   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \      0x148   0x4448             ADD      R0,R0,R9
   \      0x14A   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \      0x14E   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \      0x152   0xEBA0 0x0009      SUB      R0,R0,R9
   \      0x156   0xF8C8 0x0010      STR      R0,[R8, #+16]
   \      0x15A   0xEBA4 0x0409      SUB      R4,R4,R9
   \      0x15E   0xB2E4             UXTB     R4,R4
   \      0x160   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \      0x164   0x2800             CMP      R0,#+0
   \      0x166   0xD1D7             BNE.N    ??LPUART_TransferHandleIRQ_11
   \      0x168   0xE7C6             B.N      ??LPUART_TransferHandleIRQ_10
   1442                  }
   1443          
   1444                  /* If use RX ring buffer, receive data to ring buffer. */
   1445                  if (handle->rxRingBuffer)
   1446                  {
   1447                      while (count--)
   1448                      {
   1449                          /* If RX ring buffer is full, trigger callback to notify over run. */
   1450                          if (LPUART_TransferIsRxRingBufferFull(base, handle))
   1451                          {
   1452                              if (handle->callback)
   1453                              {
   1454                                  handle->callback(base, handle, kStatus_LPUART_RxRingBufferOverrun, handle->userData);
   1455                              }
   1456                          }
   1457          
   1458                          /* If ring buffer is still full after callback function, the oldest data is overrided. */
   1459                          if (LPUART_TransferIsRxRingBufferFull(base, handle))
   1460                          {
   1461                              /* Increase handle->rxRingBufferTail to make room for new data. */
   1462                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
   1463                              {
   1464                                  handle->rxRingBufferTail = 0U;
   1465                              }
   1466                              else
   1467                              {
   1468                                  handle->rxRingBufferTail++;
   1469                              }
   1470                          }
   1471          
   1472          /* Read data. */
   1473          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
   1474                          if (handle->isSevenDataBits)
   1475                          {
   1476                              handle->rxRingBuffer[handle->rxRingBufferHead] = (base->DATA & 0x7F);
   1477                          }
   1478                          else
   1479                          {
   1480                              handle->rxRingBuffer[handle->rxRingBufferHead] = base->DATA;
   1481                          }
   1482          #else
   1483                          handle->rxRingBuffer[handle->rxRingBufferHead] = base->DATA;
   1484          #endif
   1485          
   1486                          /* Increase handle->rxRingBufferHead. */
   1487                          if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
   1488                          {
   1489                              handle->rxRingBufferHead = 0U;
   1490                          }
   1491                          else
   1492                          {
   1493                              handle->rxRingBufferHead++;
   1494                          }
   1495                      }
   1496                  }
   1497                  /* If no receive requst pending, stop RX interrupt. */
   1498                  else if (!handle->rxDataSize)
   \                     ??LPUART_TransferHandleIRQ_13: (+1)
   \      0x16A   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \      0x16E   0x2800             CMP      R0,#+0
   \      0x170   0xD104             BNE.N    ??LPUART_TransferHandleIRQ_14
   1499                  {
   1500                      LPUART_DisableInterrupts(base, kLPUART_RxDataRegFullInterruptEnable | kLPUART_RxOverrunInterruptEnable);
   \      0x172   0xF04F 0x6102      MOV      R1,#+136314880
   \      0x176   0x4638             MOV      R0,R7
   \      0x178   0x....'....        BL       LPUART_DisableInterrupts
   1501                  }
   1502                  else
   1503                  {
   1504                  }
   1505              }
   1506          
   1507              /* Send data register empty and the interrupt is enabled. */
   1508              if ((kLPUART_TxDataRegEmptyFlag & status) && (kLPUART_TxDataRegEmptyInterruptEnable & enabledInterrupts))
   \                     ??LPUART_TransferHandleIRQ_14: (+1)
   \      0x17C   0x0228             LSLS     R0,R5,#+8
   \      0x17E   0xF140 0x80C5      BPL.W    ??LPUART_TransferHandleIRQ_15
   \      0x182   0x0230             LSLS     R0,R6,#+8
   \      0x184   0xF140 0x80C2      BPL.W    ??LPUART_TransferHandleIRQ_15
   1509              {
   1510          /* Get the bytes that available at this moment. */
   1511          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
   1512                  count = FSL_FEATURE_LPUART_FIFO_SIZEn(base) -
   1513                          ((base->WATER & LPUART_WATER_TXCOUNT_MASK) >> LPUART_WATER_TXCOUNT_SHIFT);
   \      0x188   0x6AFC             LDR      R4,[R7, #+44]
   \      0x18A   0x0A24             LSRS     R4,R4,#+8
   \      0x18C   0xF004 0x0407      AND      R4,R4,#0x7
   \      0x190   0xF1C4 0x0404      RSB      R4,R4,#+4
   \      0x194   0xB2E4             UXTB     R4,R4
   \      0x196   0xE063             B.N      ??LPUART_TransferHandleIRQ_16
   \                     ??LPUART_TransferHandleIRQ_17: (+1)
   \      0x198   0x2000             MOVS     R0,#+0
   \      0x19A   0xF8A8 0x0020      STRH     R0,[R8, #+32]
   \                     ??LPUART_TransferHandleIRQ_18: (+1)
   \      0x19E   0x4620             MOV      R0,R4
   \      0x1A0   0x1E44             SUBS     R4,R0,#+1
   \      0x1A2   0xB2E4             UXTB     R4,R4
   \      0x1A4   0x2800             CMP      R0,#+0
   \      0x1A6   0xD0E9             BEQ.N    ??LPUART_TransferHandleIRQ_14
   \      0x1A8   0x4641             MOV      R1,R8
   \      0x1AA   0x4638             MOV      R0,R7
   \      0x1AC   0x....'....        BL       LPUART_TransferIsRxRingBufferFull
   \      0x1B0   0x2800             CMP      R0,#+0
   \      0x1B2   0xD00C             BEQ.N    ??LPUART_TransferHandleIRQ_19
   \      0x1B4   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \      0x1B8   0x2800             CMP      R0,#+0
   \      0x1BA   0xD008             BEQ.N    ??LPUART_TransferHandleIRQ_19
   \      0x1BC   0xF8D8 0x3028      LDR      R3,[R8, #+40]
   \      0x1C0   0xF240 0x521C      MOVW     R2,#+1308
   \      0x1C4   0x4641             MOV      R1,R8
   \      0x1C6   0x4638             MOV      R0,R7
   \      0x1C8   0xF8D8 0xC024      LDR      R12,[R8, #+36]
   \      0x1CC   0x47E0             BLX      R12
   \                     ??LPUART_TransferHandleIRQ_19: (+1)
   \      0x1CE   0x4641             MOV      R1,R8
   \      0x1D0   0x4638             MOV      R0,R7
   \      0x1D2   0x....'....        BL       LPUART_TransferIsRxRingBufferFull
   \      0x1D6   0x2800             CMP      R0,#+0
   \      0x1D8   0xD00F             BEQ.N    ??LPUART_TransferHandleIRQ_20
   \      0x1DA   0xF8B8 0x0022      LDRH     R0,[R8, #+34]
   \      0x1DE   0x1C40             ADDS     R0,R0,#+1
   \      0x1E0   0xF8D8 0x101C      LDR      R1,[R8, #+28]
   \      0x1E4   0x4288             CMP      R0,R1
   \      0x1E6   0xD103             BNE.N    ??LPUART_TransferHandleIRQ_21
   \      0x1E8   0x2000             MOVS     R0,#+0
   \      0x1EA   0xF8A8 0x0022      STRH     R0,[R8, #+34]
   \      0x1EE   0xE004             B.N      ??LPUART_TransferHandleIRQ_20
   \                     ??LPUART_TransferHandleIRQ_21: (+1)
   \      0x1F0   0xF8B8 0x0022      LDRH     R0,[R8, #+34]
   \      0x1F4   0x1C40             ADDS     R0,R0,#+1
   \      0x1F6   0xF8A8 0x0022      STRH     R0,[R8, #+34]
   \                     ??LPUART_TransferHandleIRQ_20: (+1)
   \      0x1FA   0xF898 0x002E      LDRB     R0,[R8, #+46]
   \      0x1FE   0x2800             CMP      R0,#+0
   \      0x200   0xF8B8 0x0020      LDRH     R0,[R8, #+32]
   \      0x204   0x69F9             LDR      R1,[R7, #+28]
   \      0x206   0xD005             BEQ.N    ??LPUART_TransferHandleIRQ_22
   \      0x208   0xF001 0x017F      AND      R1,R1,#0x7F
   \      0x20C   0xF8D8 0x2018      LDR      R2,[R8, #+24]
   \      0x210   0x5411             STRB     R1,[R2, R0]
   \      0x212   0xE002             B.N      ??LPUART_TransferHandleIRQ_23
   \                     ??LPUART_TransferHandleIRQ_22: (+1)
   \      0x214   0xF8D8 0x2018      LDR      R2,[R8, #+24]
   \      0x218   0x5411             STRB     R1,[R2, R0]
   \                     ??LPUART_TransferHandleIRQ_23: (+1)
   \      0x21A   0xF8B8 0x0020      LDRH     R0,[R8, #+32]
   \      0x21E   0x1C40             ADDS     R0,R0,#+1
   \      0x220   0xF8D8 0x101C      LDR      R1,[R8, #+28]
   \      0x224   0x4288             CMP      R0,R1
   \      0x226   0xD0B7             BEQ.N    ??LPUART_TransferHandleIRQ_17
   \      0x228   0xF8B8 0x0020      LDRH     R0,[R8, #+32]
   \      0x22C   0x1C40             ADDS     R0,R0,#+1
   \      0x22E   0xF8A8 0x0020      STRH     R0,[R8, #+32]
   \      0x232   0xE7B4             B.N      ??LPUART_TransferHandleIRQ_18
   1514          #else
   1515                  count = 1;
   1516          #endif
   1517          
   1518                  while ((count) && (handle->txDataSize))
   1519                  {
   1520          #if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
   1521                      tempCount = MIN(handle->txDataSize, count);
   \                     ??LPUART_TransferHandleIRQ_24: (+1)
   \      0x234   0x46A1             MOV      R9,R4
   \      0x236   0xE021             B.N      ??LPUART_TransferHandleIRQ_25
   1522          #else
   1523                      tempCount = 1;
   1524          #endif
   1525          
   1526                      /* Using non block API to write the data to the registers. */
   1527                      LPUART_WriteNonBlocking(base, handle->txData, tempCount);
   1528                      handle->txData += tempCount;
   1529                      handle->txDataSize -= tempCount;
   1530                      count -= tempCount;
   1531          
   1532                      /* If all the data are written to data register, notify user with the callback, then TX finished. */
   1533                      if (!handle->txDataSize)
   1534                      {
   1535                          handle->txState = kLPUART_TxIdle;
   \                     ??LPUART_TransferHandleIRQ_26: (+1)
   \      0x238   0x2000             MOVS     R0,#+0
   \      0x23A   0xF888 0x002C      STRB     R0,[R8, #+44]
   1536          
   1537                          /* Disable TX register empty interrupt. */
   1538                          base->CTRL = (base->CTRL & ~LPUART_CTRL_TIE_MASK);
   \      0x23E   0x69B8             LDR      R0,[R7, #+24]
   \      0x240   0xF420 0x0000      BIC      R0,R0,#0x800000
   \      0x244   0x61B8             STR      R0,[R7, #+24]
   1539          
   1540                          /* Trigger callback. */
   1541                          if (handle->callback)
   \      0x246   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \      0x24A   0x2800             CMP      R0,#+0
   \      0x24C   0xD008             BEQ.N    ??LPUART_TransferHandleIRQ_16
   1542                          {
   1543                              handle->callback(base, handle, kStatus_LPUART_TxIdle, handle->userData);
   \      0x24E   0xF8D8 0x3028      LDR      R3,[R8, #+40]
   \      0x252   0xF240 0x5216      MOVW     R2,#+1302
   \      0x256   0x4641             MOV      R1,R8
   \      0x258   0x4638             MOV      R0,R7
   \      0x25A   0xF8D8 0xC024      LDR      R12,[R8, #+36]
   \      0x25E   0x47E0             BLX      R12
   1544                          }
   1545                      }
   \                     ??LPUART_TransferHandleIRQ_16: (+1)
   \      0x260   0x2C00             CMP      R4,#+0
   \      0x262   0xD053             BEQ.N    ??LPUART_TransferHandleIRQ_15
   \      0x264   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \      0x268   0x2800             CMP      R0,#+0
   \      0x26A   0xD04F             BEQ.N    ??LPUART_TransferHandleIRQ_15
   \      0x26C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \      0x270   0x42A0             CMP      R0,R4
   \      0x272   0xD2DF             BCS.N    ??LPUART_TransferHandleIRQ_24
   \      0x274   0xF8D8 0x9004      LDR      R9,[R8, #+4]
   \      0x278   0xFA5F 0xF989      UXTB     R9,R9
   \                     ??LPUART_TransferHandleIRQ_25: (+1)
   \      0x27C   0x464A             MOV      R2,R9
   \      0x27E   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \      0x282   0x4638             MOV      R0,R7
   \      0x284   0x....'....        BL       LPUART_WriteNonBlocking
   \      0x288   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x28C   0x4448             ADD      R0,R0,R9
   \      0x28E   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \      0x292   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \      0x296   0xEBA0 0x0009      SUB      R0,R0,R9
   \      0x29A   0xF8C8 0x0004      STR      R0,[R8, #+4]
   \      0x29E   0xEBA4 0x0409      SUB      R4,R4,R9
   \      0x2A2   0xB2E4             UXTB     R4,R4
   \      0x2A4   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \      0x2A8   0x2800             CMP      R0,#+0
   \      0x2AA   0xD1D9             BNE.N    ??LPUART_TransferHandleIRQ_16
   \      0x2AC   0xE7C4             B.N      ??LPUART_TransferHandleIRQ_26
   1546                  }
   1547              }
   \                     ??LPUART_TransferHandleIRQ_7: (+1)
   \      0x2AE   0x6978             LDR      R0,[R7, #+20]
   \      0x2B0   0xF440 0x1080      ORR      R0,R0,#0x100000
   \      0x2B4   0x6178             STR      R0,[R7, #+20]
   \      0x2B6   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \      0x2BA   0x2800             CMP      R0,#+0
   \      0x2BC   0xD104             BNE.N    ??LPUART_TransferHandleIRQ_27
   \      0x2BE   0xF44F 0x1180      MOV      R1,#+1048576
   \      0x2C2   0x4638             MOV      R0,R7
   \      0x2C4   0x....'....        BL       LPUART_DisableInterrupts
   \                     ??LPUART_TransferHandleIRQ_27: (+1)
   \      0x2C8   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \      0x2CC   0x2800             CMP      R0,#+0
   \      0x2CE   0xD00C             BEQ.N    ??LPUART_TransferHandleIRQ_2
   \      0x2D0   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \      0x2D4   0x2800             CMP      R0,#+0
   \      0x2D6   0xD008             BEQ.N    ??LPUART_TransferHandleIRQ_2
   \      0x2D8   0xF8D8 0x3028      LDR      R3,[R8, #+40]
   \      0x2DC   0xF240 0x5222      MOVW     R2,#+1314
   \      0x2E0   0x4641             MOV      R1,R8
   \      0x2E2   0x4638             MOV      R0,R7
   \      0x2E4   0xF8D8 0x4024      LDR      R4,[R8, #+36]
   \      0x2E8   0x47A0             BLX      R4
   \                     ??LPUART_TransferHandleIRQ_2: (+1)
   \      0x2EA   0x02A8             LSLS     R0,R5,#+10
   \      0x2EC   0xF57F 0xAF46      BPL.W    ??LPUART_TransferHandleIRQ_14
   \      0x2F0   0x02B0             LSLS     R0,R6,#+10
   \      0x2F2   0xF57F 0xAF43      BPL.W    ??LPUART_TransferHandleIRQ_14
   \      0x2F6   0x6AFC             LDR      R4,[R7, #+44]
   \      0x2F8   0x0E24             LSRS     R4,R4,#+24
   \      0x2FA   0xF004 0x0407      AND      R4,R4,#0x7
   \      0x2FE   0xE70B             B.N      ??LPUART_TransferHandleIRQ_11
   \                     ??LPUART_TransferHandleIRQ_12: (+1)
   \      0x300   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \      0x304   0x2800             CMP      R0,#+0
   \      0x306   0xF47F 0xAF4A      BNE.W    ??LPUART_TransferHandleIRQ_18
   \      0x30A   0xE72E             B.N      ??LPUART_TransferHandleIRQ_13
   1548          }
   \                     ??LPUART_TransferHandleIRQ_15: (+1)
   \      0x30C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1549          
   1550          /*!
   1551           * brief LPUART Error IRQ handle function.
   1552           *
   1553           * This function handles the LPUART error IRQ request.
   1554           *
   1555           * param base LPUART peripheral base address.
   1556           * param handle LPUART handle pointer.
   1557           */

   \                                 In section .text, align 2, keep-with-next
   1558          void LPUART_TransferHandleErrorIRQ(LPUART_Type *base, lpuart_handle_t *handle)
   1559          {
   1560              /* To be implemented by User. */
   1561          }
   \                     LPUART_TransferHandleErrorIRQ: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1562          #if defined(FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1) && FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1
   1563          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1564          void LPUART0_LPUART1_RX_DriverIRQHandler(void)
   1565          {
   1566              if (CLOCK_isEnabledClock(s_lpuartClock[0]))
   1567              {
   1568                  if ((LPUART_STAT_OR_MASK & LPUART0->STAT) ||
   1569                      ((LPUART_STAT_RDRF_MASK & LPUART0->STAT) && (LPUART_CTRL_RIE_MASK & LPUART0->CTRL)))
   1570                  {
   1571                      s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
   1572                  }
   1573              }
   1574              if (CLOCK_isEnabledClock(s_lpuartClock[1]))
   1575              {
   1576                  if ((LPUART_STAT_OR_MASK & LPUART1->STAT) ||
   1577                      ((LPUART_STAT_RDRF_MASK & LPUART1->STAT) && (LPUART_CTRL_RIE_MASK & LPUART1->CTRL)))
   1578                  {
   1579                      s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
   1580                  }
   1581              }
   1582          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1583            exception return operation might vector to incorrect interrupt */
   1584          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1585              __DSB();
   1586          #endif
   1587          }
   1588          void LPUART0_LPUART1_TX_DriverIRQHandler(void)
   1589          {
   1590              if (CLOCK_isEnabledClock(s_lpuartClock[0]))
   1591              {
   1592                  if ((LPUART_STAT_OR_MASK & LPUART0->STAT) ||
   1593                      ((LPUART0->STAT & LPUART_STAT_TDRE_MASK) && (LPUART0->CTRL & LPUART_CTRL_TIE_MASK)))
   1594                  {
   1595                      s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
   1596                  }
   1597              }
   1598              if (CLOCK_isEnabledClock(s_lpuartClock[1]))
   1599              {
   1600                  if ((LPUART_STAT_OR_MASK & LPUART1->STAT) ||
   1601                      ((LPUART1->STAT & LPUART_STAT_TDRE_MASK) && (LPUART1->CTRL & LPUART_CTRL_TIE_MASK)))
   1602                  {
   1603                      s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
   1604                  }
   1605              }
   1606          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1607            exception return operation might vector to incorrect interrupt */
   1608          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1609              __DSB();
   1610          #endif
   1611          }
   1612          #else
   1613          void LPUART0_LPUART1_DriverIRQHandler(void)
   1614          {
   1615              if (CLOCK_isEnabledClock(s_lpuartClock[0]))
   1616              {
   1617                  if ((LPUART_STAT_OR_MASK & LPUART0->STAT) ||
   1618                      ((LPUART_STAT_RDRF_MASK & LPUART0->STAT) && (LPUART_CTRL_RIE_MASK & LPUART0->CTRL)) ||
   1619                      ((LPUART0->STAT & LPUART_STAT_TDRE_MASK) && (LPUART0->CTRL & LPUART_CTRL_TIE_MASK)))
   1620                  {
   1621                      s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
   1622                  }
   1623              }
   1624              if (CLOCK_isEnabledClock(s_lpuartClock[1]))
   1625              {
   1626                  if ((LPUART_STAT_OR_MASK & LPUART1->STAT) ||
   1627                      ((LPUART_STAT_RDRF_MASK & LPUART1->STAT) && (LPUART_CTRL_RIE_MASK & LPUART1->CTRL)) ||
   1628                      ((LPUART1->STAT & LPUART_STAT_TDRE_MASK) && (LPUART1->CTRL & LPUART_CTRL_TIE_MASK)))
   1629                  {
   1630                      s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
   1631                  }
   1632              }
   1633          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1634            exception return operation might vector to incorrect interrupt */
   1635          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1636              __DSB();
   1637          #endif
   1638          }
   1639          #endif
   1640          #endif
   1641          
   1642          #if defined(LPUART0)
   1643          #if !(defined(FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1) && FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1)
   1644          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1645          void LPUART0_TX_DriverIRQHandler(void)
   1646          {
   1647              s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
   1648          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1649            exception return operation might vector to incorrect interrupt */
   1650          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1651              __DSB();
   1652          #endif
   1653          }
   1654          void LPUART0_RX_DriverIRQHandler(void)
   1655          {
   1656              s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
   1657          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1658            exception return operation might vector to incorrect interrupt */
   1659          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1660              __DSB();
   1661          #endif
   1662          }
   1663          #else
   1664          void LPUART0_DriverIRQHandler(void)
   1665          {
   1666              s_lpuartIsr(LPUART0, s_lpuartHandle[0]);
   1667          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1668            exception return operation might vector to incorrect interrupt */
   1669          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1670              __DSB();
   1671          #endif
   1672          }
   1673          #endif
   1674          #endif
   1675          #endif
   1676          
   1677          #if defined(LPUART1)
   1678          #if !(defined(FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1) && FSL_FEATURE_LPUART_HAS_SHARED_IRQ0_IRQ1)
   1679          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1680          void LPUART1_TX_DriverIRQHandler(void)
   1681          {
   1682              s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
   1683          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1684            exception return operation might vector to incorrect interrupt */
   1685          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1686              __DSB();
   1687          #endif
   1688          }
   1689          void LPUART1_RX_DriverIRQHandler(void)
   1690          {
   1691              s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
   1692          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1693            exception return operation might vector to incorrect interrupt */
   1694          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1695              __DSB();
   1696          #endif
   1697          }
   1698          #else

   \                                 In section .text, align 2, keep-with-next
   1699          void LPUART1_DriverIRQHandler(void)
   1700          {
   1701              s_lpuartIsr(LPUART1, s_lpuartHandle[1]);
   \                     LPUART1_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable32_5
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0x....             LDR.N    R0,??DataTable32_16  ;; 0x40184000
   \        0x6   0x....             LDR.N    R2,??DataTable32_6
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1702          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1703            exception return operation might vector to incorrect interrupt */
   1704          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1705              __DSB();
   1706          #endif
   1707          }
   1708          #endif
   1709          #endif
   1710          #endif
   1711          
   1712          #if defined(LPUART2)
   1713          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1714          void LPUART2_TX_DriverIRQHandler(void)
   1715          {
   1716              s_lpuartIsr(LPUART2, s_lpuartHandle[2]);
   1717          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1718            exception return operation might vector to incorrect interrupt */
   1719          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1720              __DSB();
   1721          #endif
   1722          }
   1723          void LPUART2_RX_DriverIRQHandler(void)
   1724          {
   1725              s_lpuartIsr(LPUART2, s_lpuartHandle[2]);
   1726          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1727            exception return operation might vector to incorrect interrupt */
   1728          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1729              __DSB();
   1730          #endif
   1731          }
   1732          #else

   \                                 In section .text, align 2, keep-with-next
   1733          void LPUART2_DriverIRQHandler(void)
   1734          {
   1735              s_lpuartIsr(LPUART2, s_lpuartHandle[2]);
   \                     LPUART2_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable32_5
   \        0x2   0x6881             LDR      R1,[R0, #+8]
   \        0x4   0x....             LDR.N    R0,??DataTable32_17  ;; 0x40188000
   \        0x6   0x....             LDR.N    R2,??DataTable32_6
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1736          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1737            exception return operation might vector to incorrect interrupt */
   1738          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1739              __DSB();
   1740          #endif
   1741          }
   1742          #endif
   1743          #endif
   1744          
   1745          #if defined(LPUART3)
   1746          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1747          void LPUART3_TX_DriverIRQHandler(void)
   1748          {
   1749              s_lpuartIsr(LPUART3, s_lpuartHandle[3]);
   1750          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1751            exception return operation might vector to incorrect interrupt */
   1752          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1753              __DSB();
   1754          #endif
   1755          }
   1756          void LPUART3_RX_DriverIRQHandler(void)
   1757          {
   1758              s_lpuartIsr(LPUART3, s_lpuartHandle[3]);
   1759          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1760            exception return operation might vector to incorrect interrupt */
   1761          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1762              __DSB();
   1763          #endif
   1764          }
   1765          #else

   \                                 In section .text, align 2, keep-with-next
   1766          void LPUART3_DriverIRQHandler(void)
   1767          {
   1768              s_lpuartIsr(LPUART3, s_lpuartHandle[3]);
   \                     LPUART3_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable32_5
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0x....             LDR.N    R0,??DataTable32_18  ;; 0x4018c000
   \        0x6   0x....             LDR.N    R2,??DataTable32_6
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1769          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1770            exception return operation might vector to incorrect interrupt */
   1771          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1772              __DSB();
   1773          #endif
   1774          }
   1775          #endif
   1776          #endif
   1777          
   1778          #if defined(LPUART4)
   1779          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1780          void LPUART4_TX_DriverIRQHandler(void)
   1781          {
   1782              s_lpuartIsr(LPUART4, s_lpuartHandle[4]);
   1783          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1784            exception return operation might vector to incorrect interrupt */
   1785          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1786              __DSB();
   1787          #endif
   1788          }
   1789          void LPUART4_RX_DriverIRQHandler(void)
   1790          {
   1791              s_lpuartIsr(LPUART4, s_lpuartHandle[4]);
   1792          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1793            exception return operation might vector to incorrect interrupt */
   1794          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1795              __DSB();
   1796          #endif
   1797          }
   1798          #else

   \                                 In section .text, align 2, keep-with-next
   1799          void LPUART4_DriverIRQHandler(void)
   1800          {
   1801              s_lpuartIsr(LPUART4, s_lpuartHandle[4]);
   \                     LPUART4_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable32_5
   \        0x2   0x6901             LDR      R1,[R0, #+16]
   \        0x4   0x....             LDR.N    R0,??DataTable32_19  ;; 0x40190000
   \        0x6   0x....             LDR.N    R2,??DataTable32_6
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1802          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1803            exception return operation might vector to incorrect interrupt */
   1804          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1805              __DSB();
   1806          #endif
   1807          }
   1808          #endif
   1809          #endif
   1810          
   1811          #if defined(LPUART5)
   1812          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1813          void LPUART5_TX_DriverIRQHandler(void)
   1814          {
   1815              s_lpuartIsr(LPUART5, s_lpuartHandle[5]);
   1816          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1817            exception return operation might vector to incorrect interrupt */
   1818          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1819              __DSB();
   1820          #endif
   1821          }
   1822          void LPUART5_RX_DriverIRQHandler(void)
   1823          {
   1824              s_lpuartIsr(LPUART5, s_lpuartHandle[5]);
   1825          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1826            exception return operation might vector to incorrect interrupt */
   1827          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1828              __DSB();
   1829          #endif
   1830          }
   1831          #else

   \                                 In section .text, align 2, keep-with-next
   1832          void LPUART5_DriverIRQHandler(void)
   1833          {
   1834              s_lpuartIsr(LPUART5, s_lpuartHandle[5]);
   \                     LPUART5_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable32_5
   \        0x2   0x6941             LDR      R1,[R0, #+20]
   \        0x4   0x....             LDR.N    R0,??DataTable32_20  ;; 0x40194000
   \        0x6   0x....             LDR.N    R2,??DataTable32_6
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1835          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1836            exception return operation might vector to incorrect interrupt */
   1837          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1838              __DSB();
   1839          #endif
   1840          }
   1841          #endif
   1842          #endif
   1843          
   1844          #if defined(LPUART6)
   1845          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1846          void LPUART6_TX_DriverIRQHandler(void)
   1847          {
   1848              s_lpuartIsr(LPUART6, s_lpuartHandle[6]);
   1849          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1850            exception return operation might vector to incorrect interrupt */
   1851          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1852              __DSB();
   1853          #endif
   1854          }
   1855          void LPUART6_RX_DriverIRQHandler(void)
   1856          {
   1857              s_lpuartIsr(LPUART6, s_lpuartHandle[6]);
   1858          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1859            exception return operation might vector to incorrect interrupt */
   1860          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1861              __DSB();
   1862          #endif
   1863          }
   1864          #else

   \                                 In section .text, align 2, keep-with-next
   1865          void LPUART6_DriverIRQHandler(void)
   1866          {
   1867              s_lpuartIsr(LPUART6, s_lpuartHandle[6]);
   \                     LPUART6_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable32_5
   \        0x2   0x6981             LDR      R1,[R0, #+24]
   \        0x4   0x....             LDR.N    R0,??DataTable32_21  ;; 0x40198000
   \        0x6   0x....             LDR.N    R2,??DataTable32_6
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1868          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1869            exception return operation might vector to incorrect interrupt */
   1870          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1871              __DSB();
   1872          #endif
   1873          }
   1874          #endif
   1875          #endif
   1876          
   1877          #if defined(LPUART7)
   1878          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1879          void LPUART7_TX_DriverIRQHandler(void)
   1880          {
   1881              s_lpuartIsr(LPUART7, s_lpuartHandle[7]);
   1882          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1883            exception return operation might vector to incorrect interrupt */
   1884          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1885              __DSB();
   1886          #endif
   1887          }
   1888          void LPUART7_RX_DriverIRQHandler(void)
   1889          {
   1890              s_lpuartIsr(LPUART7, s_lpuartHandle[7]);
   1891          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1892            exception return operation might vector to incorrect interrupt */
   1893          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1894              __DSB();
   1895          #endif
   1896          }
   1897          #else

   \                                 In section .text, align 2, keep-with-next
   1898          void LPUART7_DriverIRQHandler(void)
   1899          {
   1900              s_lpuartIsr(LPUART7, s_lpuartHandle[7]);
   \                     LPUART7_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable32_5
   \        0x2   0x69C1             LDR      R1,[R0, #+28]
   \        0x4   0x....             LDR.N    R0,??DataTable32_22  ;; 0x4019c000
   \        0x6   0x....             LDR.N    R2,??DataTable32_6
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1901          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1902            exception return operation might vector to incorrect interrupt */
   1903          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1904              __DSB();
   1905          #endif
   1906          }
   1907          #endif
   1908          #endif
   1909          
   1910          #if defined(LPUART8)
   1911          #if defined(FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ) && FSL_FEATURE_LPUART_HAS_SEPARATE_RX_TX_IRQ
   1912          void LPUART8_TX_DriverIRQHandler(void)
   1913          {
   1914              s_lpuartIsr(LPUART8, s_lpuartHandle[8]);
   1915          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1916            exception return operation might vector to incorrect interrupt */
   1917          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1918              __DSB();
   1919          #endif
   1920          }
   1921          void LPUART8_RX_DriverIRQHandler(void)
   1922          {
   1923              s_lpuartIsr(LPUART8, s_lpuartHandle[8]);
   1924          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1925            exception return operation might vector to incorrect interrupt */
   1926          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1927              __DSB();
   1928          #endif
   1929          }
   1930          #else

   \                                 In section .text, align 2, keep-with-next
   1931          void LPUART8_DriverIRQHandler(void)
   1932          {
   1933              s_lpuartIsr(LPUART8, s_lpuartHandle[8]);
   \                     LPUART8_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable32_5
   \        0x2   0x6A01             LDR      R1,[R0, #+32]
   \        0x4   0x....             LDR.N    R0,??DataTable32_23  ;; 0x401a0000
   \        0x6   0x....             LDR.N    R2,??DataTable32_6
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1934          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1935            exception return operation might vector to incorrect interrupt */
   1936          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1937              __DSB();
   1938          #endif
   1939          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \        0x0   0x400F'C068        DC32     0x400fc068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \        0x0   0x....'....        DC32     s_lpuartBases

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0x....'....        DC32     s_lpuartClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \        0x0   0xE0FF'E000        DC32     0xe0ffe000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0xFFFF'F8E8        DC32     0xfffff8e8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \        0x0   0xC01F'C000        DC32     0xc01fc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \        0x0   0xE01F'C000        DC32     0xe01fc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \        0x0   0x0FF0'C000        DC32     0xff0c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \        0x0   0x3FE0'3FFF        DC32     0x3fe03fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \        0x0   0x....'....        DC32     s_lpuartHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_6:
   \        0x0   0x....'....        DC32     s_lpuartIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_7:
   \        0x0   0x....'....        DC32     s_lpuartIRQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_8:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_9:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_10:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_11:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_12:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_13:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_14:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_15:
   \        0x0   0x3FE0'0000        DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_16:
   \        0x0   0x4018'4000        DC32     0x40184000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_17:
   \        0x0   0x4018'8000        DC32     0x40188000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_18:
   \        0x0   0x4018'C000        DC32     0x4018c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_19:
   \        0x0   0x4019'0000        DC32     0x40190000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_20:
   \        0x0   0x4019'4000        DC32     0x40194000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_21:
   \        0x0   0x4019'8000        DC32     0x40198000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_22:
   \        0x0   0x4019'C000        DC32     0x4019c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_23:
   \        0x0   0x401A'0000        DC32     0x401a0000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x6E          DC8 "index <= 6"
   \              0x64 0x65    
   \              0x78 0x20    
   \              0x3C 0x3D    
   \              0x20 0x36    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
   \              0x5C 0x44    
   \              0x65 0x76    
   \              0x65 0x6C    
   \        0x8   0x6F 0x70          DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73    
   \       0x10   0x6D 0x61          DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
   \              0x72 0x74    
   \              0x5F 0x77    
   \              0x61 0x73    
   \       0x18   0x68 0x69          DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
   \              0x6E 0x67    
   \              0x5F 0x6D    
   \              0x61 0x63    
   \       0x20   0x68 0x69          DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
   \              0x6E 0x65    
   \              0x5F 0x33    
   \              0x30 0x38    
   \       0x28   0x30 0x5C          DC8 30H, 5CH, 64H, 72H, 69H, 76H, 65H, 72H
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \       0x30   0x73 0x5C          DC8 73H, 5CH, 66H, 73H, 6CH, 5FH, 63H, 6CH
   \              0x66 0x73    
   \              0x6C 0x5F    
   \              0x63 0x6C    
   \       0x38   0x6F 0x63          DC8 6FH, 63H, 6BH, 2EH, 68H, 0
   \              0x6B 0x2E    
   \              0x68 0x00    
   \       0x3E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x69 0x6E          DC8 69H, 6EH, 73H, 74H, 61H, 6EH, 63H, 65H
   \              0x73 0x74    
   \              0x61 0x6E    
   \              0x63 0x65    
   \        0x8   0x20 0x3C          DC8 20H, 3CH, 20H, 28H, 73H, 69H, 7AH, 65H
   \              0x20 0x28    
   \              0x73 0x69    
   \              0x7A 0x65    
   \       0x10   0x6F 0x66          DC8 6FH, 66H, 28H, 73H, 5FH, 6CH, 70H, 75H
   \              0x28 0x73    
   \              0x5F 0x6C    
   \              0x70 0x75    
   \       0x18   0x61 0x72          DC8 61H, 72H, 74H, 42H, 61H, 73H, 65H, 73H
   \              0x74 0x42    
   \              0x61 0x73    
   \              0x65 0x73    
   \       0x20   0x29 0x20          DC8 29H, 20H, 2FH, 20H, 73H, 69H, 7AH, 65H
   \              0x2F 0x20    
   \              0x73 0x69    
   \              0x7A 0x65    
   \       0x28   0x6F 0x66          DC8 6FH, 66H, 28H, 28H, 73H, 5FH, 6CH, 70H
   \              0x28 0x28    
   \              0x73 0x5F    
   \              0x6C 0x70    
   \       0x30   0x75 0x61          DC8 75H, 61H, 72H, 74H, 42H, 61H, 73H, 65H
   \              0x72 0x74    
   \              0x42 0x61    
   \              0x73 0x65    
   \       0x38   0x73 0x29          DC8 73H, 29H, 5BH, 30H, 5DH, 29H, 29H, 0
   \              0x5B 0x30    
   \              0x5D 0x29    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
   \              0x5C 0x44    
   \              0x65 0x76    
   \              0x65 0x6C    
   \        0x8   0x6F 0x70          DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73    
   \       0x10   0x6D 0x61          DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
   \              0x72 0x74    
   \              0x5F 0x77    
   \              0x61 0x73    
   \       0x18   0x68 0x69          DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
   \              0x6E 0x67    
   \              0x5F 0x6D    
   \              0x61 0x63    
   \       0x20   0x68 0x69          DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
   \              0x6E 0x65    
   \              0x5F 0x33    
   \              0x30 0x38    
   \       0x28   0x30 0x5C          DC8 30H, 5CH, 64H, 72H, 69H, 76H, 65H, 72H
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \       0x30   0x73 0x5C          DC8 73H, 5CH, 66H, 73H, 6CH, 5FH, 6CH, 70H
   \              0x66 0x73    
   \              0x6C 0x5F    
   \              0x6C 0x70    
   \       0x38   0x75 0x61          DC8 75H, 61H, 72H, 74H, 2EH, 63H, 0
   \              0x72 0x74    
   \              0x2E 0x63    
   \              0x00         
   \       0x3F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x68 0x61          DC8 "handle"
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x64 0x61          DC8 "data"
   \              0x74 0x61    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x63 0x6F          DC8 "config"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x63 0x6F          DC8 "config->baudRate_Bps"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x2D 0x3E    
   \              0x62 0x61    
   \              0x75 0x64    
   \              0x52 0x61    
   \              0x74 0x65    
   \              0x5F 0x42    
   \              0x70 0x73    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x28 0x34          DC8 "(4) >= config->txFifoWatermark"
   \              0x29 0x20    
   \              0x3E 0x3D    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x2D    
   \              0x3E 0x74    
   \              0x78 0x46    
   \              0x69 0x66    
   \              0x6F 0x57    
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x6D 0x61    
   \              0x72 0x6B    
   \              0x00         
   \       0x1F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x28 0x34          DC8 "(4) >= config->rxFifoWatermark"
   \              0x29 0x20    
   \              0x3E 0x3D    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x2D    
   \              0x3E 0x72    
   \              0x78 0x46    
   \              0x69 0x66    
   \              0x6F 0x57    
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x6D 0x61    
   \              0x72 0x6B    
   \              0x00         
   \       0x1F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x62 0x61          DC8 "baudRate_Bps"
   \              0x75 0x64    
   \              0x52 0x61    
   \              0x74 0x65    
   \              0x5F 0x42    
   \              0x70 0x73    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x72 0x69          DC8 "ringBuffer"
   \              0x6E 0x67    
   \              0x42 0x75    
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x78 0x66          DC8 "xfer"
   \              0x65 0x72    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x78 0x66          DC8 "xfer->data"
   \              0x65 0x72    
   \              0x2D 0x3E    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x78 0x66          DC8 "xfer->dataSize"
   \              0x65 0x72    
   \              0x2D 0x3E    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x53 0x69    
   \              0x7A 0x65    
   \              0x00         
   \        0xF   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x63 0x6F          DC8 "count"
   \              0x75 0x6E    
   \              0x74 0x00    
   \        0x6   0x00 0x00          DC8 0, 0
   1940          #endif
   1941          #endif
   1942          
   1943          #if defined(CM4_0__LPUART)
   1944          void M4_0_LPUART_DriverIRQHandler(void)
   1945          {
   1946              s_lpuartIsr(CM4_0__LPUART, s_lpuartHandle[LPUART_GetInstance(CM4_0__LPUART)]);
   1947          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1948            exception return operation might vector to incorrect interrupt */
   1949          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1950              __DSB();
   1951          #endif
   1952          }
   1953          #endif
   1954          
   1955          #if defined(CM4_1__LPUART)
   1956          void M4_1_LPUART_DriverIRQHandler(void)
   1957          {
   1958              s_lpuartIsr(CM4_1__LPUART, s_lpuartHandle[LPUART_GetInstance(CM4_1__LPUART)]);
   1959          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1960            exception return operation might vector to incorrect interrupt */
   1961          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1962              __DSB();
   1963          #endif
   1964          }
   1965          #endif
   1966          
   1967          #if defined(CM4__LPUART)
   1968          void M4_LPUART_DriverIRQHandler(void)
   1969          {
   1970              s_lpuartIsr(CM4__LPUART, s_lpuartHandle[LPUART_GetInstance(CM4__LPUART)]);
   1971          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1972            exception return operation might vector to incorrect interrupt */
   1973          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1974              __DSB();
   1975          #endif
   1976          }
   1977          #endif
   1978          
   1979          #if defined(DMA__LPUART0)
   1980          void DMA_UART0_INT_DriverIRQHandler(void)
   1981          {
   1982              s_lpuartIsr(DMA__LPUART0, s_lpuartHandle[LPUART_GetInstance(DMA__LPUART0)]);
   1983          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1984            exception return operation might vector to incorrect interrupt */
   1985          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1986              __DSB();
   1987          #endif
   1988          }
   1989          #endif
   1990          
   1991          #if defined(DMA__LPUART1)
   1992          void DMA_UART1_INT_DriverIRQHandler(void)
   1993          {
   1994              s_lpuartIsr(DMA__LPUART1, s_lpuartHandle[LPUART_GetInstance(DMA__LPUART1)]);
   1995          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1996            exception return operation might vector to incorrect interrupt */
   1997          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1998              __DSB();
   1999          #endif
   2000          }
   2001          #endif
   2002          
   2003          #if defined(DMA__LPUART2)
   2004          void DMA_UART2_INT_DriverIRQHandler(void)
   2005          {
   2006              s_lpuartIsr(DMA__LPUART2, s_lpuartHandle[LPUART_GetInstance(DMA__LPUART2)]);
   2007          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   2008            exception return operation might vector to incorrect interrupt */
   2009          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   2010              __DSB();
   2011          #endif
   2012          }
   2013          #endif
   2014          
   2015          #if defined(DMA__LPUART3)
   2016          void DMA_UART3_INT_DriverIRQHandler(void)
   2017          {
   2018              s_lpuartIsr(DMA__LPUART3, s_lpuartHandle[LPUART_GetInstance(DMA__LPUART3)]);
   2019          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   2020            exception return operation might vector to incorrect interrupt */
   2021          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   2022              __DSB();
   2023          #endif
   2024          }
   2025          #endif
   2026          
   2027          #if defined(DMA__LPUART4)
   2028          void DMA_UART4_INT_DriverIRQHandler(void)
   2029          {
   2030              s_lpuartIsr(DMA__LPUART4, s_lpuartHandle[LPUART_GetInstance(DMA__LPUART4)]);
   2031          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   2032            exception return operation might vector to incorrect interrupt */
   2033          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   2034              __DSB();
   2035          #endif
   2036          }
   2037          #endif
   2038          
   2039          #if defined(ADMA__LPUART0)
   2040          void ADMA_UART0_INT_DriverIRQHandler(void)
   2041          {
   2042              s_lpuartIsr(ADMA__LPUART0, s_lpuartHandle[LPUART_GetInstance(ADMA__LPUART0)]);
   2043          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   2044            exception return operation might vector to incorrect interrupt */
   2045          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   2046              __DSB();
   2047          #endif
   2048          }
   2049          #endif
   2050          
   2051          #if defined(ADMA__LPUART1)
   2052          void ADMA_UART1_INT_DriverIRQHandler(void)
   2053          {
   2054              s_lpuartIsr(ADMA__LPUART1, s_lpuartHandle[LPUART_GetInstance(ADMA__LPUART1)]);
   2055          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   2056            exception return operation might vector to incorrect interrupt */
   2057          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   2058              __DSB();
   2059          #endif
   2060          }
   2061          #endif
   2062          
   2063          #if defined(ADMA__LPUART2)
   2064          void ADMA_UART2_INT_DriverIRQHandler(void)
   2065          {
   2066              s_lpuartIsr(ADMA__LPUART2, s_lpuartHandle[LPUART_GetInstance(ADMA__LPUART2)]);
   2067          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   2068            exception return operation might vector to incorrect interrupt */
   2069          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   2070              __DSB();
   2071          #endif
   2072          }
   2073          #endif
   2074          
   2075          #if defined(ADMA__LPUART3)
   2076          void ADMA_UART3_INT_DriverIRQHandler(void)
   2077          {
   2078              s_lpuartIsr(ADMA__LPUART3, s_lpuartHandle[LPUART_GetInstance(ADMA__LPUART3)]);
   2079          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   2080            exception return operation might vector to incorrect interrupt */
   2081          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   2082              __DSB();
   2083          #endif
   2084          }
   2085          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CLOCK_ControlGate
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   CLOCK_DisableClock
         0   -> CLOCK_ControlGate
       0   CLOCK_EnableClock
         0   -> CLOCK_ControlGate
       8   EnableIRQ
         8   -> __NVIC_EnableIRQ
       0   LPUART1_DriverIRQHandler
         0   -- Indirect call
       0   LPUART2_DriverIRQHandler
         0   -- Indirect call
       0   LPUART3_DriverIRQHandler
         0   -- Indirect call
       0   LPUART4_DriverIRQHandler
         0   -- Indirect call
       0   LPUART5_DriverIRQHandler
         0   -- Indirect call
       0   LPUART6_DriverIRQHandler
         0   -- Indirect call
       0   LPUART7_DriverIRQHandler
         0   -- Indirect call
       0   LPUART8_DriverIRQHandler
         0   -- Indirect call
       8   LPUART_ClearStatusFlags
         8   -> LPUART_GetStatusFlags
       8   LPUART_Deinit
         0   -> CLOCK_DisableClock
         8   -> LPUART_GetInstance
       0   LPUART_DisableInterrupts
       0   LPUART_EnableInterrupts
       8   LPUART_GetDefaultConfig
         8   -> __aeabi_assert
         8   -> __aeabi_memset4
         8   -> __iar_EmptyStepPoint
       0   LPUART_GetEnabledInterrupts
       8   LPUART_GetInstance
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   LPUART_GetStatusFlags
      24   LPUART_Init
        24   -> CLOCK_EnableClock
        24   -> LPUART_GetInstance
        24   -> LPUART_SoftwareReset
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   LPUART_ReadBlocking
        24   -> LPUART_ClearStatusFlags
        24   -> LPUART_GetStatusFlags
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      16   LPUART_ReadNonBlocking
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   LPUART_SetBaudRate
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       0   LPUART_SoftwareReset
      16   LPUART_TransferAbortReceive
        16   -> LPUART_DisableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   LPUART_TransferAbortSend
        16   -> LPUART_DisableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   LPUART_TransferCreateHandle
         0   -> EnableIRQ
        24   -> LPUART_GetInstance
        24   -> __aeabi_assert
        24   -> __aeabi_memset4
        24   -> __iar_EmptyStepPoint
      16   LPUART_TransferGetReceiveCount
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   LPUART_TransferGetRxRingBufferLength
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   LPUART_TransferGetSendCount
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   LPUART_TransferHandleErrorIRQ
      32   LPUART_TransferHandleIRQ
        32   -- Indirect call
        32   -> LPUART_DisableInterrupts
        32   -> LPUART_GetEnabledInterrupts
        32   -> LPUART_GetStatusFlags
        32   -> LPUART_ReadNonBlocking
        32   -> LPUART_TransferIsRxRingBufferFull
        32   -> LPUART_WriteNonBlocking
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
      16   LPUART_TransferIsRxRingBufferFull
        16   -> LPUART_TransferGetRxRingBufferLength
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      32   LPUART_TransferReceiveNonBlocking
        32   -- Indirect call
        32   -> LPUART_DisableInterrupts
        32   -> LPUART_EnableInterrupts
        32   -> LPUART_TransferGetRxRingBufferLength
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
      16   LPUART_TransferSendNonBlocking
        16   -> LPUART_EnableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   LPUART_TransferStartRingBuffer
         0   -> LPUART_EnableInterrupts
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      16   LPUART_TransferStopRingBuffer
        16   -> LPUART_DisableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   LPUART_WriteBlocking
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   LPUART_WriteNonBlocking
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   __NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable28
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_10
       4  ??DataTable32_11
       4  ??DataTable32_12
       4  ??DataTable32_13
       4  ??DataTable32_14
       4  ??DataTable32_15
       4  ??DataTable32_16
       4  ??DataTable32_17
       4  ??DataTable32_18
       4  ??DataTable32_19
       4  ??DataTable32_2
       4  ??DataTable32_20
       4  ??DataTable32_21
       4  ??DataTable32_22
       4  ??DataTable32_23
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable32_7
       4  ??DataTable32_8
       4  ??DataTable32_9
      12  ?_0
      64  ?_1
      16  ?_10
      12  ?_11
       8  ?_12
      12  ?_13
      16  ?_14
       8  ?_15
      64  ?_2
      64  ?_3
       8  ?_4
       8  ?_5
       8  ?_6
      24  ?_7
      32  ?_8
      32  ?_9
      64  CLOCK_ControlGate
       4  CLOCK_DisableClock
       4  CLOCK_EnableClock
      24  EnableIRQ
      12  LPUART1_DriverIRQHandler
      12  LPUART2_DriverIRQHandler
      12  LPUART3_DriverIRQHandler
      12  LPUART4_DriverIRQHandler
      12  LPUART5_DriverIRQHandler
      12  LPUART6_DriverIRQHandler
      12  LPUART7_DriverIRQHandler
      12  LPUART8_DriverIRQHandler
      48  LPUART_ClearStatusFlags
      50  LPUART_Deinit
      42  LPUART_DisableInterrupts
      40  LPUART_EnableInterrupts
      74  LPUART_GetDefaultConfig
      30  LPUART_GetEnabledInterrupts
      50  LPUART_GetInstance
      16  LPUART_GetStatusFlags
     534  LPUART_Init
     182  LPUART_ReadBlocking
      78  LPUART_ReadNonBlocking
     222  LPUART_SetBaudRate
      18  LPUART_SoftwareReset
      54  LPUART_TransferAbortReceive
      46  LPUART_TransferAbortSend
     128  LPUART_TransferCreateHandle
      72  LPUART_TransferGetReceiveCount
      52  LPUART_TransferGetRxRingBufferLength
      72  LPUART_TransferGetSendCount
       2  LPUART_TransferHandleErrorIRQ
     784  LPUART_TransferHandleIRQ
      50  LPUART_TransferIsRxRingBufferFull
     300  LPUART_TransferReceiveNonBlocking
     144  LPUART_TransferSendNonBlocking
      78  LPUART_TransferStartRingBuffer
      56  LPUART_TransferStopRingBuffer
      56  LPUART_WriteBlocking
      46  LPUART_WriteNonBlocking
      24  __NVIC_EnableIRQ
      36  s_lpuartBases
      20  s_lpuartClock
      36  s_lpuartHandle
      20  s_lpuartIRQ
       4  s_lpuartIsr

 
    40 bytes in section .bss
   464 bytes in section .rodata
 3 700 bytes in section .text
 
 3 700 bytes of CODE  memory
   464 bytes of CONST memory
    40 bytes of DATA  memory

Errors: none
Warnings: none
