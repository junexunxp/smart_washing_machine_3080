###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:08
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\CoAPMessage.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWABEB.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\CoAPMessage.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\CoAPMessage.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\CoAPMessage.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\CoAPMessage.c
      1          /*
      2           * Copyright (C) 2015-2018 Alibaba Group Holding Limited
      3           */
      4          
      5          
      6          
      7          
      8          
      9          #include <stdio.h>
     10          #include "CoAPExport.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __dlist_add(dlist_t *, dlist_t *, dlist_t *)
   \                     __dlist_add: (+1)
   \        0x0   0x6042             STR      R2,[R0, #+4]
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0x6048             STR      R0,[R1, #+4]
   \        0x6   0x6010             STR      R0,[R2, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void dlist_add_tail(dlist_t *, dlist_t *)
   \                     dlist_add_tail: (+1)
   \        0x0   0x460A             MOV      R2,R1
   \        0x2   0x6811             LDR      R1,[R2, #+0]
   \        0x4   0x....             B.N      __dlist_add

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void dlist_del(dlist_t *)
   \                     dlist_del: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x6840             LDR      R0,[R0, #+4]
   \        0x4   0x6048             STR      R0,[R1, #+4]
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void INIT_AOS_DLIST_HEAD(dlist_t *)
   \                     INIT_AOS_DLIST_HEAD: (+1)
   \        0x0   0x6040             STR      R0,[R0, #+4]
   \        0x2   0x6000             STR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void list_del_init(struct dlist_s *)
   \                     list_del_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x....'....        BL       dlist_del
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....             B.N      INIT_AOS_DLIST_HEAD
     11          #include "CoAPSerialize.h"
     12          #include "CoAPDeserialize.h"
     13          #include "CoAPResource.h"
     14          #include "CoAPObserve.h"
     15          #include "CoAPPlatform.h"
     16          #include "CoAPInternal.h"
     17          #include "iotx_coap_internal.h"
     18          
     19          #define COAPAckMsg(header) \
     20              ((header.code == COAP_MSG_CODE_EMPTY_MESSAGE) \
     21               &&(header.type == COAP_MESSAGE_TYPE_ACK))
     22          
     23          #define CoAPRespMsg(header)\
     24              ((header.code >= 0x40) && (header.code < 0xc0))
     25          
     26          #define CoAPPingMsg(header)\
     27              ((header.code == COAP_MSG_CODE_EMPTY_MESSAGE)\
     28               && (header.type == COAP_MESSAGE_TYPE_CON))
     29          
     30          #define CoAPResetMsg(header)\
     31              (header.type == COAP_MESSAGE_TYPE_RST)
     32          
     33          #define CoAPCONRespMsg(header)\
     34              ((header.code == COAP_MSG_CODE_205_CONTENT) \
     35               && (header.type == COAP_MESSAGE_TYPE_CON))
     36          
     37          #define CoAPReqMsg(header)\
     38              ((1 <= header.code) && (32 > header.code))
     39          
     40          
     41          #define NOKEEP 0
     42          #define KEEPING 1
     43          #define TOREMOVEKEEP 2
     44          #define COAP_CUR_VERSION        1
     45          #define COAP_MAX_MESSAGE_ID     65535
     46          #define COAP_MAX_RETRY_COUNT    8
     47          #define COAP_ACK_TIMEOUT        600
     48          #define COAP_ACK_RANDOM_FACTOR  1
     49          

   \                                 In section .text, align 2, keep-with-next
     50          unsigned short CoAPMessageId_gen(CoAPContext *context)
     51          {
   \                     CoAPMessageId_gen: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
     52              unsigned short msg_id = 0;
     53              CoAPIntContext *ctx = NULL;
     54              if (!context) {
   \        0x4   0xD101             BNE.N    ??CoAPMessageId_gen_0
     55                  return msg_id;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
     56              }
     57              ctx = (CoAPIntContext *)context;
     58              HAL_MutexLock(ctx->mutex);
   \                     ??CoAPMessageId_gen_0: (+1)
   \        0xA   0x6DE0             LDR      R0,[R4, #+92]
   \        0xC   0x....'....        BL       HAL_MutexLock
     59              msg_id = ((COAP_MAX_MESSAGE_ID == ctx->message_id)  ? (ctx->message_id = 1) : ctx->message_id++);
   \       0x10   0x8820             LDRH     R0,[R4, #+0]
   \       0x12   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD103             BNE.N    ??CoAPMessageId_gen_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x8020             STRH     R0,[R4, #+0]
   \       0x1E   0x4605             MOV      R5,R0
   \       0x20   0xE002             B.N      ??CoAPMessageId_gen_2
   \                     ??CoAPMessageId_gen_1: (+1)
   \       0x22   0x4605             MOV      R5,R0
   \       0x24   0x1C68             ADDS     R0,R5,#+1
   \       0x26   0x8020             STRH     R0,[R4, #+0]
     60              HAL_MutexUnlock(ctx->mutex);
   \                     ??CoAPMessageId_gen_2: (+1)
   \       0x28   0x6DE0             LDR      R0,[R4, #+92]
   \       0x2A   0x....'....        BL       HAL_MutexUnlock
     61              return msg_id;
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     62          }
     63          

   \                                 In section .text, align 2, keep-with-next
     64          int CoAPMessageHandler_set(CoAPMessage *message, CoAPSendMsgHandler handler)
     65          {
     66              if (NULL == message) {
   \                     CoAPMessageHandler_set: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD102             BNE.N    ??CoAPMessageHandler_set_0
     67                  return COAP_ERROR_NULL;
   \        0x4   0xF44F 0x7081      MOV      R0,#+258
   \        0x8   0x4770             BX       LR
     68              }
     69              message->handler = handler;
   \                     ??CoAPMessageHandler_set_0: (+1)
   \        0xA   0x6741             STR      R1,[R0, #+116]
     70              return COAP_SUCCESS;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
     71          }
     72          

   \                                 In section .text, align 2, keep-with-next
     73          static int CoAPMessageList_add(CoAPContext *context, NetworkAddr *remote,
     74                                         CoAPMessage *message, unsigned char *buffer, int len)
     75          {
   \                     CoAPMessageList_add: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x4699             MOV      R9,R3
     76              CoAPIntContext *ctx = (CoAPIntContext *)context;
     77              CoAPSendNode *node = NULL;
     78              uint64_t tick ;
     79              node = coap_malloc(sizeof(CoAPSendNode));
   \        0xC   0x2050             MOVS     R0,#+80
   \        0xE   0x....'....        BL       HAL_Malloc
   \       0x12   0x0004             MOVS     R4,R0
     80          
     81              if (NULL != node) {
   \       0x14   0xD066             BEQ.N    ??CoAPMessageList_add_0
   \       0x16   0x9F08             LDR      R7,[SP, #+32]
     82                  memset(node, 0x00, sizeof(CoAPSendNode));
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x2150             MOVS     R1,#+80
   \       0x1C   0x....'....        BL       __aeabi_memset4
     83                  node->acked        = 0;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x64A0             STR      R0,[R4, #+72]
     84                  node->user         = message->user;
   \       0x24   0x6FF0             LDR      R0,[R6, #+124]
   \       0x26   0x6420             STR      R0,[R4, #+64]
     85                  node->header       = message->header;
   \       0x28   0x6830             LDR      R0,[R6, #+0]
   \       0x2A   0x6020             STR      R0,[R4, #+0]
     86                  node->handler      = message->handler;
   \       0x2C   0x6F70             LDR      R0,[R6, #+116]
   \       0x2E   0x6220             STR      R0,[R4, #+32]
     87                  node->msglen       = len;
   \       0x30   0x61E7             STR      R7,[R4, #+28]
     88                  node->message      = buffer;
   \       0x32   0xF8C4 0x9044      STR      R9,[R4, #+68]
     89                  node->timeout_val   = COAP_ACK_TIMEOUT * COAP_ACK_RANDOM_FACTOR;
   \       0x36   0xF44F 0x7016      MOV      R0,#+600
   \       0x3A   0x8320             STRH     R0,[R4, #+24]
     90                  memcpy(&node->remote, remote, sizeof(NetworkAddr));
   \       0x3C   0x2212             MOVS     R2,#+18
   \       0x3E   0x4641             MOV      R1,R8
   \       0x40   0xF104 0x0024      ADD      R0,R4,#+36
   \       0x44   0x....'....        BL       __aeabi_memcpy
     91                  if (platform_is_multicast((const char *)remote->addr) || 1 == message->keep) {
   \       0x48   0x4640             MOV      R0,R8
   \       0x4A   0x....'....        BL       platform_is_multicast
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD103             BNE.N    ??CoAPMessageList_add_1
   \       0x52   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD102             BNE.N    ??CoAPMessageList_add_2
     92                      COAP_FLOW("The message %d need keep", message->header.msgid);
     93                      node->keep = KEEPING;
   \                     ??CoAPMessageList_add_1: (+1)
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x64E0             STR      R0,[R4, #+76]
   \       0x5E   0xE001             B.N      ??CoAPMessageList_add_3
     94                  } else {
     95                      node->keep = NOKEEP;
   \                     ??CoAPMessageList_add_2: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x64E0             STR      R0,[R4, #+76]
     96                  }
     97          
     98                  tick = HAL_UptimeMs ();
   \                     ??CoAPMessageList_add_3: (+1)
   \       0x64   0x....'....        BL       HAL_UptimeMs
     99          
    100                  if (COAP_MESSAGE_TYPE_CON == message->header.type) {
   \       0x68   0x7832             LDRB     R2,[R6, #+0]
   \       0x6A   0xF3C2 0x0281      UBFX     R2,R2,#+2,#+2
   \       0x6E   0x2A00             CMP      R2,#+0
   \       0x70   0x8B22             LDRH     R2,[R4, #+24]
   \       0x72   0xD107             BNE.N    ??CoAPMessageList_add_4
    101                      node->timeout = node->timeout_val + tick;
   \       0x74   0x2300             MOVS     R3,#+0
   \       0x76   0x1810             ADDS     R0,R2,R0
   \       0x78   0x4159             ADCS     R1,R3,R1
   \       0x7A   0xE9C4 0x0104      STRD     R0,R1,[R4, #+16]
    102                      node->retrans_count = COAP_MAX_RETRY_COUNT;
   \       0x7E   0x2008             MOVS     R0,#+8
   \       0x80   0x7120             STRB     R0,[R4, #+4]
   \       0x82   0xE007             B.N      ??CoAPMessageList_add_5
    103                  } else {
    104                      node->timeout = node->timeout_val * 4 + tick;
   \                     ??CoAPMessageList_add_4: (+1)
   \       0x84   0x0092             LSLS     R2,R2,#+2
   \       0x86   0x1810             ADDS     R0,R2,R0
   \       0x88   0xEB51 0x71E2      ADCS     R1,R1,R2, ASR #+31
   \       0x8C   0xE9C4 0x0104      STRD     R0,R1,[R4, #+16]
    105                      node->retrans_count = 0;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x7120             STRB     R0,[R4, #+4]
    106                  }
    107          
    108                  memcpy(node->token, message->token, message->header.tokenlen);
   \                     ??CoAPMessageList_add_5: (+1)
   \       0x94   0x7832             LDRB     R2,[R6, #+0]
   \       0x96   0x0912             LSRS     R2,R2,#+4
   \       0x98   0x1D31             ADDS     R1,R6,#+4
   \       0x9A   0x1D60             ADDS     R0,R4,#+5
   \       0x9C   0x....'....        BL       __aeabi_memcpy
    109          
    110                  HAL_MutexLock(ctx->sendlist.list_mutex);
   \       0xA0   0x6968             LDR      R0,[R5, #+20]
   \       0xA2   0x....'....        BL       HAL_MutexLock
    111                  if (ctx->sendlist.count >= ctx->sendlist.maxcount) {
   \       0xA6   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0xAA   0xF895 0x1021      LDRB     R1,[R5, #+33]
   \       0xAE   0x4288             CMP      R0,R1
   \       0xB0   0xD308             BCC.N    ??CoAPMessageList_add_6
    112                      HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \       0xB2   0x6968             LDR      R0,[R5, #+20]
   \       0xB4   0x....'....        BL       HAL_MutexUnlock
    113                      coap_free(node);
   \       0xB8   0x4620             MOV      R0,R4
   \       0xBA   0x....'....        BL       HAL_Free
    114                      COAP_INFO("The send list is full");
    115                      return COAP_ERROR_DATA_SIZE;
   \       0xBE   0xF240 0x1005      MOVW     R0,#+261
   \       0xC2   0xE011             B.N      ??CoAPMessageList_add_7
    116                  } else {
    117                      list_add_tail(&node->sendlist, &ctx->sendlist.list);
   \                     ??CoAPMessageList_add_6: (+1)
   \       0xC4   0xF105 0x0118      ADD      R1,R5,#+24
   \       0xC8   0xF104 0x0038      ADD      R0,R4,#+56
   \       0xCC   0x....'....        BL       dlist_add_tail
    118                      ctx->sendlist.count ++;
   \       0xD0   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0xD4   0x1C40             ADDS     R0,R0,#+1
   \       0xD6   0xF885 0x0020      STRB     R0,[R5, #+32]
    119                      HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \       0xDA   0x6968             LDR      R0,[R5, #+20]
   \       0xDC   0x....'....        BL       HAL_MutexUnlock
    120                      return COAP_SUCCESS;
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xE001             B.N      ??CoAPMessageList_add_7
    121                  }
    122              } else {
    123                  return COAP_ERROR_NULL;
   \                     ??CoAPMessageList_add_0: (+1)
   \       0xE4   0xF44F 0x7081      MOV      R0,#+258
   \                     ??CoAPMessageList_add_7: (+1)
   \       0xE8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    124              }
    125          }
    126          

   \                                 In section .text, align 2, keep-with-next
    127          void CoAPMessageToken_dump(unsigned char *token, unsigned char tokenlen)
    128          {
   \                     CoAPMessageToken_dump: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
    129              int index = 0, count = 0;
   \        0xA   0x2600             MOVS     R6,#+0
    130              int total = 2 * COAP_MSG_MAX_TOKEN_LEN;
   \        0xC   0x2710             MOVS     R7,#+16
    131              char   buff[2 * COAP_MSG_MAX_TOKEN_LEN + 1] = {0}, *ptr = NULL;
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x2114             MOVS     R1,#+20
   \       0x12   0x....'....        BL       __aeabi_memclr4
    132          
    133              ptr = buff;
   \       0x16   0x46E8             MOV      R8,SP
    134              for (index = 0; index < tokenlen; index++) {
   \       0x18   0xE009             B.N      ??CoAPMessageToken_dump_0
    135                  count = HAL_Snprintf(ptr, total, "%02X", token[index]);
   \                     ??CoAPMessageToken_dump_1: (+1)
   \       0x1A   0x5DA3             LDRB     R3,[R4, R6]
   \       0x1C   0x....'....        LDR.W    R2,??DataTable2
   \       0x20   0x4639             MOV      R1,R7
   \       0x22   0x4640             MOV      R0,R8
   \       0x24   0x....'....        BL       HAL_Snprintf
    136                  ptr += count;
   \       0x28   0x4480             ADD      R8,R8,R0
    137                  total -= count;
   \       0x2A   0x1A3F             SUBS     R7,R7,R0
    138              }
   \       0x2C   0x1C76             ADDS     R6,R6,#+1
   \                     ??CoAPMessageToken_dump_0: (+1)
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x4286             CMP      R6,R0
   \       0x32   0xDBF2             BLT.N    ??CoAPMessageToken_dump_1
    139          
    140              COAP_FLOW("Token Len   : %d", tokenlen);
    141              COAP_FLOW("Token       : %s", buff);
    142          }
   \       0x34   0xB006             ADD      SP,SP,#+24
   \       0x36   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    143          

   \                                 In section .text, align 2, keep-with-next
    144          void CoAPMessage_dump(NetworkAddr *remote, CoAPMessage *message)
    145          {
   \                     CoAPMessage_dump: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    146              int ret = COAP_SUCCESS;
    147              unsigned int ctype;
    148              unsigned char code, msgclass, detail;
                                         ^
Warning[Pe550]: variable "msgclass" was set but never used

      unsigned char code, msgclass, detail;
                                    ^
"C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\CoAPMessage.c",148  Warning[Pe550]: 
          variable "detail" was set but never used
    149          
    150              if (NULL == remote || NULL == message) {
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD00B             BEQ.N    ??CoAPMessage_dump_0
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD009             BEQ.N    ??CoAPMessage_dump_0
    151                  return;
    152              }
    153              code = (unsigned char)message->header.code;
    154              msgclass = code >> 5;
    155              detail = code & 0x1F;
    156          
    157              COAP_FLOW("*********Message Info**********");
    158              COAP_FLOW("Version     : %d", message->header.version);
    159              COAP_FLOW("Code        : %d.%02d(0x%x)", msgclass, detail, code);
    160              COAP_FLOW("Type        : 0x%x", message->header.type);
    161              COAP_FLOW("Msgid       : %d", message->header.msgid);
    162              COAP_FLOW("Option      : %d", message->optcount);
    163              COAP_FLOW("Payload Len : %d", message->payloadlen);
    164          
    165              CoAPMessageToken_dump(message->token, message->header.tokenlen);
   \        0xC   0x7821             LDRB     R1,[R4, #+0]
   \        0xE   0x0909             LSRS     R1,R1,#+4
   \       0x10   0x1D20             ADDS     R0,R4,#+4
   \       0x12   0x....'....        BL       CoAPMessageToken_dump
    166              COAP_FLOW("Remote      : %s:%d", remote->addr, remote->port);
    167              ret = CoAPUintOption_get(message, COAP_OPTION_CONTENT_FORMAT, &ctype);
   \       0x16   0x466A             MOV      R2,SP
   \       0x18   0x210C             MOVS     R1,#+12
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x....'....        BL       CoAPUintOption_get
    168              if (COAP_SUCCESS == ret && NULL != message->payload
    169                  && (COAP_CT_APP_OCTET_STREAM != ctype && COAP_CT_APP_CBOR != ctype)) {
    170                  /* COAP_FLOW("Payload     : %s", message->payload); */
    171              }
    172          
    173              COAP_FLOW("********************************");
    174          
    175          }
   \                     ??CoAPMessage_dump_0: (+1)
   \       0x20   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    176          

   \                                 In section .text, align 2, keep-with-next
    177          int CoAPMessage_send(CoAPContext *context, NetworkAddr *remote, CoAPMessage *message)
    178          {
   \                     CoAPMessage_send: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x0014             MOVS     R4,R2
    179              int   ret              = COAP_SUCCESS;
    180              unsigned short msglen  = 0;
    181              unsigned char  *buff   = NULL;
    182              unsigned short readlen = 0;
    183              CoAPIntContext *ctx    = NULL;
    184          
    185              if (NULL == message || NULL == context) {
   \        0xA   0xD001             BEQ.N    ??CoAPMessage_send_0
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD102             BNE.N    ??CoAPMessage_send_1
    186                  return (COAP_ERROR_INVALID_PARAM);
   \                     ??CoAPMessage_send_0: (+1)
   \       0x10   0xF240 0x1001      MOVW     R0,#+257
   \       0x14   0xE056             B.N      ??CoAPMessage_send_2
    187              }
    188          
    189              ctx = (CoAPIntContext *)context;
    190              msglen = CoAPSerialize_MessageLength(message);
   \                     ??CoAPMessage_send_1: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x....'....        BL       CoAPSerialize_MessageLength
   \       0x1C   0x4680             MOV      R8,R0
    191              if (COAP_MSG_MAX_PDU_LEN < msglen) {
   \       0x1E   0xF240 0x5001      MOVW     R0,#+1281
   \       0x22   0x4580             CMP      R8,R0
   \       0x24   0xDB02             BLT.N    ??CoAPMessage_send_3
    192                  COAP_INFO("The message length %d is too loog", msglen);
    193                  return COAP_ERROR_DATA_SIZE;
   \       0x26   0xF240 0x1005      MOVW     R0,#+261
   \       0x2A   0xE04B             B.N      ??CoAPMessage_send_2
    194              }
    195          
    196              buff = (unsigned char *)coap_malloc(msglen);
   \                     ??CoAPMessage_send_3: (+1)
   \       0x2C   0x4640             MOV      R0,R8
   \       0x2E   0x....'....        BL       HAL_Malloc
   \       0x32   0x0005             MOVS     R5,R0
    197              if (NULL == buff) {
   \       0x34   0xD102             BNE.N    ??CoAPMessage_send_4
    198                  COAP_INFO("Malloc memory failed");
    199                  return COAP_ERROR_NULL;
   \       0x36   0xF44F 0x7081      MOV      R0,#+258
   \       0x3A   0xE043             B.N      ??CoAPMessage_send_2
    200              }
    201              memset(buff, 0x00, msglen);
   \                     ??CoAPMessage_send_4: (+1)
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0x4641             MOV      R1,R8
   \       0x40   0x....'....        BL       __aeabi_memset
    202              msglen = CoAPSerialize_Message(message, buff, msglen);
   \       0x44   0x4642             MOV      R2,R8
   \       0x46   0x4629             MOV      R1,R5
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x....'....        BL       CoAPSerialize_Message
   \       0x4E   0x4680             MOV      R8,R0
   \       0x50   0xFA1F 0xF888      UXTH     R8,R8
    203          
    204          #ifndef COAP_OBSERVE_CLIENT_DISABLE
    205              CoAPObsClient_delete(ctx, message);
   \       0x54   0x4621             MOV      R1,R4
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0x....'....        BL       CoAPObsClient_delete
    206          #endif
    207              readlen = CoAPNetwork_write(ctx->p_network, remote,
    208                                          buff, (unsigned int)msglen, ctx->waittime);
   \       0x5C   0x6D70             LDR      R0,[R6, #+84]
   \       0x5E   0x9000             STR      R0,[SP, #+0]
   \       0x60   0x4643             MOV      R3,R8
   \       0x62   0x462A             MOV      R2,R5
   \       0x64   0x4639             MOV      R1,R7
   \       0x66   0x6870             LDR      R0,[R6, #+4]
   \       0x68   0x....'....        BL       CoAPNetwork_write
    209              if (msglen == readlen) {/*Send message success*/
   \       0x6C   0xB280             UXTH     R0,R0
   \       0x6E   0x4580             CMP      R8,R0
   \       0x70   0xD123             BNE.N    ??CoAPMessage_send_5
    210                  if (CoAPReqMsg(message->header) || CoAPCONRespMsg(message->header)) {
   \       0x72   0x7860             LDRB     R0,[R4, #+1]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD001             BEQ.N    ??CoAPMessage_send_6
   \       0x78   0x2820             CMP      R0,#+32
   \       0x7A   0xDB06             BLT.N    ??CoAPMessage_send_7
   \                     ??CoAPMessage_send_6: (+1)
   \       0x7C   0x2845             CMP      R0,#+69
   \       0x7E   0xD113             BNE.N    ??CoAPMessage_send_8
   \       0x80   0x7820             LDRB     R0,[R4, #+0]
   \       0x82   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD10E             BNE.N    ??CoAPMessage_send_8
    211                      COAP_FLOW("The message id %d len %d send success, add to the list",
    212                                message->header.msgid, msglen);
    213                      ret = CoAPMessageList_add(ctx, remote, message, buff, msglen);
   \                     ??CoAPMessage_send_7: (+1)
   \       0x8A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x8E   0x462B             MOV      R3,R5
   \       0x90   0x4622             MOV      R2,R4
   \       0x92   0x4639             MOV      R1,R7
   \       0x94   0x4630             MOV      R0,R6
   \       0x96   0x....'....        BL       CoAPMessageList_add
   \       0x9A   0x0006             MOVS     R6,R0
    214                      if (COAP_SUCCESS != ret) {
   \       0x9C   0xD007             BEQ.N    ??CoAPMessage_send_9
    215                          coap_free(buff);
   \       0x9E   0x4628             MOV      R0,R5
   \       0xA0   0x....'....        BL       HAL_Free
    216                          COAP_ERR("Add the message %d to list failed", message->header.msgid);
    217                          return ret;
   \       0xA4   0x4630             MOV      R0,R6
   \       0xA6   0xE00D             B.N      ??CoAPMessage_send_2
    218                      }
    219                  } else {
    220                      coap_free(buff);
   \                     ??CoAPMessage_send_8: (+1)
   \       0xA8   0x4628             MOV      R0,R5
   \       0xAA   0x....'....        BL       HAL_Free
    221                      COAP_FLOW("The message %d isn't CON msg, needless to be retransmitted",
    222                                message->header.msgid);
    223                  }
    224              } else {
    225                  coap_free(buff);
    226                  COAP_ERR("CoAP transport write failed, send message %d return %d", message->header.msgid, ret);
    227                  return COAP_ERROR_WRITE_FAILED;
    228              }
    229          
    230              CoAPMessage_dump(remote, message);
   \                     ??CoAPMessage_send_9: (+1)
   \       0xAE   0x4621             MOV      R1,R4
   \       0xB0   0x4638             MOV      R0,R7
   \       0xB2   0x....'....        BL       CoAPMessage_dump
    231              return COAP_SUCCESS;
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0xE004             B.N      ??CoAPMessage_send_2
   \                     ??CoAPMessage_send_5: (+1)
   \       0xBA   0x4628             MOV      R0,R5
   \       0xBC   0x....'....        BL       HAL_Free
   \       0xC0   0xF44F 0x7085      MOV      R0,#+266
   \                     ??CoAPMessage_send_2: (+1)
   \       0xC4   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    232          }
    233          

   \                                 In section .text, align 2, keep-with-next
    234          int CoAPMessage_cancel(CoAPContext *context, CoAPMessage *message)
    235          {
   \                     CoAPMessage_cancel: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    236              CoAPSendNode *node = NULL, *next = NULL;
    237              CoAPIntContext *ctx = (CoAPIntContext *)context;
    238          
    239              if (NULL == context || NULL == message) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??CoAPMessage_cancel_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD102             BNE.N    ??CoAPMessage_cancel_1
    240                  return COAP_ERROR_NULL;
   \                     ??CoAPMessage_cancel_0: (+1)
   \        0xE   0xF44F 0x7081      MOV      R0,#+258
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
    241              }
    242          
    243          
    244              HAL_MutexLock(ctx->sendlist.list_mutex);
   \                     ??CoAPMessage_cancel_1: (+1)
   \       0x14   0x6960             LDR      R0,[R4, #+20]
   \       0x16   0x....'....        BL       HAL_MutexLock
    245              list_for_each_entry_safe(node, next, &ctx->sendlist.list, sendlist, CoAPSendNode) {
   \       0x1A   0x69E0             LDR      R0,[R4, #+28]
   \       0x1C   0xF1A0 0x0638      SUB      R6,R0,#+56
   \       0x20   0x6BF0             LDR      R0,[R6, #+60]
   \       0x22   0xF1A0 0x0738      SUB      R7,R0,#+56
   \       0x26   0xE018             B.N      ??CoAPMessage_cancel_2
    246                  if (node->header.msgid == message->header.msgid) {
   \                     ??CoAPMessage_cancel_3: (+1)
   \       0x28   0x8870             LDRH     R0,[R6, #+2]
   \       0x2A   0x8869             LDRH     R1,[R5, #+2]
   \       0x2C   0x4288             CMP      R0,R1
   \       0x2E   0xD110             BNE.N    ??CoAPMessage_cancel_4
    247                      list_del(&node->sendlist);
   \       0x30   0xF106 0x0038      ADD      R0,R6,#+56
   \       0x34   0x....'....        BL       dlist_del
    248                      ctx->sendlist.count--;
   \       0x38   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x3C   0x1E40             SUBS     R0,R0,#+1
   \       0x3E   0xF884 0x0020      STRB     R0,[R4, #+32]
    249                      COAP_INFO("Cancel message %d from list, cur count %d",
    250                                node->header.msgid, ctx->sendlist.count);
    251                      coap_free(node->message);
   \       0x42   0x6C70             LDR      R0,[R6, #+68]
   \       0x44   0x....'....        BL       HAL_Free
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x6470             STR      R0,[R6, #+68]
    252                      coap_free(node);
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x....'....        BL       HAL_Free
    253                  }
    254              }
   \                     ??CoAPMessage_cancel_4: (+1)
   \       0x52   0x463E             MOV      R6,R7
   \       0x54   0x6BF8             LDR      R0,[R7, #+60]
   \       0x56   0xF1A0 0x0738      SUB      R7,R0,#+56
   \                     ??CoAPMessage_cancel_2: (+1)
   \       0x5A   0xF106 0x0038      ADD      R0,R6,#+56
   \       0x5E   0xF104 0x0118      ADD      R1,R4,#+24
   \       0x62   0x4288             CMP      R0,R1
   \       0x64   0xD1E0             BNE.N    ??CoAPMessage_cancel_3
    255              HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \       0x66   0x6960             LDR      R0,[R4, #+20]
   \       0x68   0x....'....        BL       HAL_MutexUnlock
    256              return COAP_SUCCESS;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    257          }
    258          

   \                                 In section .text, align 2, keep-with-next
    259          int CoAPMessageId_cancel(CoAPContext *context, unsigned short msgid)
    260          {
   \                     CoAPMessageId_cancel: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    261              CoAPSendNode *node = NULL, *next = NULL;
    262              CoAPIntContext *ctx = (CoAPIntContext *)context;
    263          
    264              if (NULL == context || NULL == ctx->sendlist.list_mutex) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD002             BEQ.N    ??CoAPMessageId_cancel_0
   \        0xA   0x6968             LDR      R0,[R5, #+20]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD102             BNE.N    ??CoAPMessageId_cancel_1
    265                  return COAP_ERROR_NULL;
   \                     ??CoAPMessageId_cancel_0: (+1)
   \       0x10   0xF44F 0x7081      MOV      R0,#+258
   \       0x14   0xBDF2             POP      {R1,R4-R7,PC}
    266              }
    267          
    268              HAL_MutexLock(ctx->sendlist.list_mutex);
   \                     ??CoAPMessageId_cancel_1: (+1)
   \       0x16   0x....'....        BL       HAL_MutexLock
    269              list_for_each_entry_safe(node, next, &ctx->sendlist.list, sendlist, CoAPSendNode) {
   \       0x1A   0x69E8             LDR      R0,[R5, #+28]
   \       0x1C   0xF1A0 0x0438      SUB      R4,R0,#+56
   \       0x20   0x6BE0             LDR      R0,[R4, #+60]
   \       0x22   0xF1A0 0x0738      SUB      R7,R0,#+56
   \       0x26   0xE01A             B.N      ??CoAPMessageId_cancel_2
    270                  if (NULL != node) {
   \                     ??CoAPMessageId_cancel_3: (+1)
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD014             BEQ.N    ??CoAPMessageId_cancel_4
    271                      if (node->header.msgid == msgid) {
   \       0x2C   0x8860             LDRH     R0,[R4, #+2]
   \       0x2E   0x4631             MOV      R1,R6
   \       0x30   0x4288             CMP      R0,R1
   \       0x32   0xD110             BNE.N    ??CoAPMessageId_cancel_4
    272                          list_del(&node->sendlist);
   \       0x34   0xF104 0x0038      ADD      R0,R4,#+56
   \       0x38   0x....'....        BL       dlist_del
    273                          ctx->sendlist.count--;
   \       0x3C   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x40   0x1E40             SUBS     R0,R0,#+1
   \       0x42   0xF885 0x0020      STRB     R0,[R5, #+32]
    274                          COAP_FLOW("Cancel message %d from list, cur count %d",
    275                                    node->header.msgid, ctx->sendlist.count);
    276                          coap_free(node->message);
   \       0x46   0x6C60             LDR      R0,[R4, #+68]
   \       0x48   0x....'....        BL       HAL_Free
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x6460             STR      R0,[R4, #+68]
    277                          coap_free(node);
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0x....'....        BL       HAL_Free
    278                      }
    279                  }
    280              }
   \                     ??CoAPMessageId_cancel_4: (+1)
   \       0x56   0x463C             MOV      R4,R7
   \       0x58   0x6BF8             LDR      R0,[R7, #+60]
   \       0x5A   0xF1A0 0x0738      SUB      R7,R0,#+56
   \                     ??CoAPMessageId_cancel_2: (+1)
   \       0x5E   0xF104 0x0038      ADD      R0,R4,#+56
   \       0x62   0xF105 0x0118      ADD      R1,R5,#+24
   \       0x66   0x4288             CMP      R0,R1
   \       0x68   0xD1DE             BNE.N    ??CoAPMessageId_cancel_3
    281              HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \       0x6A   0x6968             LDR      R0,[R5, #+20]
   \       0x6C   0x....'....        BL       HAL_MutexUnlock
    282          
    283              return COAP_SUCCESS;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    284          }
    285          

   \                                 In section .text, align 2, keep-with-next
    286          static int CoAPAckMessage_handle(CoAPContext *context, CoAPMessage *message)
    287          {
   \                     CoAPAckMessage_handle: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
    288              CoAPSendNode *node = NULL, *next;
    289              CoAPIntContext *ctx = (CoAPIntContext *)context;
    290          
    291              HAL_MutexLock(ctx->sendlist.list_mutex);
   \        0x8   0x6960             LDR      R0,[R4, #+20]
   \        0xA   0x....'....        BL       HAL_MutexLock
    292              list_for_each_entry_safe(node, next, &ctx->sendlist.list, sendlist, CoAPSendNode) {
   \        0xE   0x69E0             LDR      R0,[R4, #+28]
   \       0x10   0xF1A0 0x0538      SUB      R5,R0,#+56
   \       0x14   0x6BE8             LDR      R0,[R5, #+60]
   \       0x16   0x3838             SUBS     R0,R0,#+56
   \       0x18   0xE002             B.N      ??CoAPAckMessage_handle_0
   \                     ??CoAPAckMessage_handle_1: (+1)
   \       0x1A   0x4605             MOV      R5,R0
   \       0x1C   0x6BC0             LDR      R0,[R0, #+60]
   \       0x1E   0x3838             SUBS     R0,R0,#+56
   \                     ??CoAPAckMessage_handle_0: (+1)
   \       0x20   0xF105 0x0138      ADD      R1,R5,#+56
   \       0x24   0xF104 0x0218      ADD      R2,R4,#+24
   \       0x28   0x4291             CMP      R1,R2
   \       0x2A   0xD02F             BEQ.N    ??CoAPAckMessage_handle_2
    293                  if (node->header.msgid == message->header.msgid) {
   \       0x2C   0x8869             LDRH     R1,[R5, #+2]
   \       0x2E   0x8872             LDRH     R2,[R6, #+2]
   \       0x30   0x4291             CMP      R1,R2
   \       0x32   0xD1F2             BNE.N    ??CoAPAckMessage_handle_1
    294                      CoAPSendMsgHandler handler = node->handler;
   \       0x34   0x6A2E             LDR      R6,[R5, #+32]
    295                      void *user_data = node->user;
   \       0x36   0x6C2F             LDR      R7,[R5, #+64]
    296                      NetworkAddr remote = {0};
   \       0x38   0xA801             ADD      R0,SP,#+4
   \       0x3A   0x2114             MOVS     R1,#+20
   \       0x3C   0x....'....        BL       __aeabi_memclr4
    297                      memcpy(&remote, &node->remote, sizeof(remote));
   \       0x40   0x2212             MOVS     R2,#+18
   \       0x42   0xF105 0x0124      ADD      R1,R5,#+36
   \       0x46   0xA801             ADD      R0,SP,#+4
   \       0x48   0x....'....        BL       __aeabi_memcpy4
    298                      node->acked = 1;
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0x64A8             STR      R0,[R5, #+72]
    299                      if (CoAPRespMsg(node->header)) { /* CON response message */
   \       0x50   0x7868             LDRB     R0,[R5, #+1]
   \       0x52   0x3840             SUBS     R0,R0,#+64
   \       0x54   0x2880             CMP      R0,#+128
   \       0x56   0xD210             BCS.N    ??CoAPAckMessage_handle_3
    300                          list_del(&node->sendlist);
   \       0x58   0xF105 0x0038      ADD      R0,R5,#+56
   \       0x5C   0x....'....        BL       dlist_del
    301                          coap_free(node->message);
   \       0x60   0x6C68             LDR      R0,[R5, #+68]
   \       0x62   0x....'....        BL       HAL_Free
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x6468             STR      R0,[R5, #+68]
    302                          coap_free(node);
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x....'....        BL       HAL_Free
    303                          ctx->sendlist.count --;
   \       0x70   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x74   0x1E40             SUBS     R0,R0,#+1
   \       0x76   0xF884 0x0020      STRB     R0,[R4, #+32]
    304                          COAP_DEBUG("The CON response message %d receive ACK, remove it", message->header.msgid);
    305                      }
    306                      if (handler) handler(ctx, COAP_RECV_RESP_SUC, user_data, &remote, NULL);
   \                     ??CoAPAckMessage_handle_3: (+1)
   \       0x7A   0x0030             MOVS     R0,R6
   \       0x7C   0xD006             BEQ.N    ??CoAPAckMessage_handle_2
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x9000             STR      R0,[SP, #+0]
   \       0x82   0xAB01             ADD      R3,SP,#+4
   \       0x84   0x463A             MOV      R2,R7
   \       0x86   0x2102             MOVS     R1,#+2
   \       0x88   0x4620             MOV      R0,R4
   \       0x8A   0x47B0             BLX      R6
    307                      HAL_MutexUnlock(ctx->sendlist.list_mutex);
    308                      return COAP_SUCCESS;
    309                  }
    310              }
    311              HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \                     ??CoAPAckMessage_handle_2: (+1)
   \       0x8C   0x6960             LDR      R0,[R4, #+20]
   \       0x8E   0x....'....        BL       HAL_MutexUnlock
    312          
    313              return COAP_SUCCESS;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xB007             ADD      SP,SP,#+28
   \       0x96   0xBDF0             POP      {R4-R7,PC}       ;; return
    314          }
    315          

   \                                 In section .text, align 2, keep-with-next
    316          static int CoAPAckMessage_send(CoAPContext *context, NetworkAddr *remote, unsigned short msgid)
    317          {
   \                     CoAPAckMessage_send: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB0A1             SUB      SP,SP,#+132
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    318              int ret   = COAP_SUCCESS;
    319              CoAPMessage message;
    320              CoAPIntContext *ctx = (CoAPIntContext *)context;
    321          
    322              CoAPMessage_init(&message);
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x....'....        BL       CoAPMessage_init
    323              CoAPMessageId_set(&message, msgid);
   \       0x10   0x4631             MOV      R1,R6
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x....'....        BL       CoAPMessageId_set
    324              COAP_DEBUG("Send Ack Response Message");
    325              ret = CoAPMessage_send(ctx, remote, &message);
   \       0x18   0x466A             MOV      R2,SP
   \       0x1A   0x4629             MOV      R1,R5
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       CoAPMessage_send
   \       0x22   0x4604             MOV      R4,R0
    326              CoAPMessage_destory(&message);
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x....'....        BL       CoAPMessage_destory
    327              return ret;
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0xB022             ADD      SP,SP,#+136
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
    328          }
    329          

   \                                 In section .text, align 2, keep-with-next
    330          static int CoAPRestMessage_send(CoAPContext *context, NetworkAddr *remote, unsigned short msgid)
    331          {
   \                     CoAPRestMessage_send: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB0A1             SUB      SP,SP,#+132
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    332              int ret   = COAP_SUCCESS;
    333              CoAPMessage message;
    334              CoAPIntContext *ctx = (CoAPIntContext *)context;
    335          
    336              CoAPMessage_init(&message);
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x....'....        BL       CoAPMessage_init
    337              CoAPMessageType_set(&message, COAP_MESSAGE_TYPE_RST);
   \       0x10   0x2103             MOVS     R1,#+3
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x....'....        BL       CoAPMessageType_set
    338              CoAPMessageId_set(&message, msgid);
   \       0x18   0x4631             MOV      R1,R6
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0x....'....        BL       CoAPMessageId_set
    339              COAP_DEBUG("Send Rest Pong Message");
    340              ret = CoAPMessage_send(ctx, remote, &message);
   \       0x20   0x466A             MOV      R2,SP
   \       0x22   0x4629             MOV      R1,R5
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       CoAPMessage_send
   \       0x2A   0x4604             MOV      R4,R0
    341              CoAPMessage_destory(&message);
   \       0x2C   0x4668             MOV      R0,SP
   \       0x2E   0x....'....        BL       CoAPMessage_destory
    342              return ret;
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0xB022             ADD      SP,SP,#+136
   \       0x36   0xBD70             POP      {R4-R6,PC}       ;; return
    343          }
    344          

   \                                 In section .text, align 2, keep-with-next
    345          static int CoAPErrRespMessage_send(CoAPContext *context, NetworkAddr *remote, CoAPMessage *message,
    346                                             unsigned char err_code)
    347          {
   \                     CoAPErrRespMessage_send: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB0A1             SUB      SP,SP,#+132
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    348              CoAPMessage response;
    349              int ret   = COAP_SUCCESS;
    350              CoAPIntContext *ctx = (CoAPIntContext *)context;
    351          
    352              CoAPMessage_init(&response);
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x....'....        BL       CoAPMessage_init
    353              CoAPMessageCode_set(&response, err_code);
                                                    ^
Warning[Pe188]: enumerated type mixed with another type
   \       0x12   0x4639             MOV      R1,R7
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x....'....        BL       CoAPMessageCode_set
    354              CoAPMessageId_set(&response, message->header.msgid);
   \       0x1A   0x8871             LDRH     R1,[R6, #+2]
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x....'....        BL       CoAPMessageId_set
    355              CoAPMessageToken_set(&response, message->token, message->header.tokenlen);
   \       0x22   0x7832             LDRB     R2,[R6, #+0]
   \       0x24   0x0912             LSRS     R2,R2,#+4
   \       0x26   0x1D31             ADDS     R1,R6,#+4
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x....'....        BL       CoAPMessageToken_set
    356              if (COAP_MESSAGE_TYPE_CON == message->header.type) {
   \       0x2E   0x7830             LDRB     R0,[R6, #+0]
   \       0x30   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD104             BNE.N    ??CoAPErrRespMessage_send_0
    357                  CoAPMessageType_set(&response, COAP_MESSAGE_TYPE_ACK);
   \       0x38   0x2102             MOVS     R1,#+2
   \       0x3A   0x4668             MOV      R0,SP
   \       0x3C   0x....'....        BL       CoAPMessageType_set
   \       0x40   0xE005             B.N      ??CoAPErrRespMessage_send_1
    358              } else {
    359                  CoAPMessageType_set(&response, message->header.type);
   \                     ??CoAPErrRespMessage_send_0: (+1)
   \       0x42   0x7830             LDRB     R0,[R6, #+0]
   \       0x44   0xF3C0 0x0181      UBFX     R1,R0,#+2,#+2
   \       0x48   0x4668             MOV      R0,SP
   \       0x4A   0x....'....        BL       CoAPMessageType_set
    360              }
    361              COAP_FLOW("Send Error Response Message");
    362              ret = CoAPMessage_send(ctx, remote, &response);
   \                     ??CoAPErrRespMessage_send_1: (+1)
   \       0x4E   0x466A             MOV      R2,SP
   \       0x50   0x4629             MOV      R1,R5
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x....'....        BL       CoAPMessage_send
   \       0x58   0x4604             MOV      R4,R0
    363              CoAPMessage_destory(&response);
   \       0x5A   0x4668             MOV      R0,SP
   \       0x5C   0x....'....        BL       CoAPMessage_destory
    364              return ret;
   \       0x60   0x4620             MOV      R0,R4
   \       0x62   0xB021             ADD      SP,SP,#+132
   \       0x64   0xBDF0             POP      {R4-R7,PC}       ;; return
    365          }
    366          

   \                                 In section .text, align 2, keep-with-next
    367          static int CoAPRespMessage_handle(CoAPContext *context, NetworkAddr *remote, CoAPMessage *message)
    368          {
   \                     CoAPRespMessage_handle: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
    369              char                found = 0;
   \        0xA   0xF04F 0x0800      MOV      R8,#+0
    370              CoAPSendNode       *node = NULL, *next = NULL;
    371              CoAPIntContext     *ctx = (CoAPIntContext *)context;
    372          
    373              if (COAP_MESSAGE_TYPE_CON == message->header.type) {
   \        0xE   0x7838             LDRB     R0,[R7, #+0]
   \       0x10   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD103             BNE.N    ??CoAPRespMessage_handle_0
    374                  CoAPAckMessage_send(ctx, remote, message->header.msgid);
   \       0x18   0x887A             LDRH     R2,[R7, #+2]
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x....'....        BL       CoAPAckMessage_send
    375              }
    376          
    377              HAL_MutexLock(ctx->sendlist.list_mutex);
   \                     ??CoAPRespMessage_handle_0: (+1)
   \       0x20   0x6968             LDR      R0,[R5, #+20]
   \       0x22   0x....'....        BL       HAL_MutexLock
    378              list_for_each_entry_safe(node, next, &ctx->sendlist.list, sendlist, CoAPSendNode) {
   \       0x26   0x69E8             LDR      R0,[R5, #+28]
   \       0x28   0xF1A0 0x0438      SUB      R4,R0,#+56
   \       0x2C   0x6BE0             LDR      R0,[R4, #+60]
   \       0x2E   0xF1A0 0x0938      SUB      R9,R0,#+56
   \       0x32   0xE004             B.N      ??CoAPRespMessage_handle_1
   \                     ??CoAPRespMessage_handle_2: (+1)
   \       0x34   0x464C             MOV      R4,R9
   \       0x36   0xF8D9 0x003C      LDR      R0,[R9, #+60]
   \       0x3A   0xF1A0 0x0938      SUB      R9,R0,#+56
   \                     ??CoAPRespMessage_handle_1: (+1)
   \       0x3E   0xF104 0x0038      ADD      R0,R4,#+56
   \       0x42   0xF105 0x0118      ADD      R1,R5,#+24
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD01E             BEQ.N    ??CoAPRespMessage_handle_3
    379                  if (0 != node->header.tokenlen && node->header.tokenlen == message->header.tokenlen
    380                      && 0 == memcmp(node->token, message->token, message->header.tokenlen)) {
   \       0x4A   0x7820             LDRB     R0,[R4, #+0]
   \       0x4C   0x0900             LSRS     R0,R0,#+4
   \       0x4E   0xD0F1             BEQ.N    ??CoAPRespMessage_handle_2
   \       0x50   0x7820             LDRB     R0,[R4, #+0]
   \       0x52   0x0900             LSRS     R0,R0,#+4
   \       0x54   0x7839             LDRB     R1,[R7, #+0]
   \       0x56   0xEBB0 0x1F11      CMP      R0,R1, LSR #+4
   \       0x5A   0xD1EB             BNE.N    ??CoAPRespMessage_handle_2
   \       0x5C   0x460A             MOV      R2,R1
   \       0x5E   0x0912             LSRS     R2,R2,#+4
   \       0x60   0x1D39             ADDS     R1,R7,#+4
   \       0x62   0x1D60             ADDS     R0,R4,#+5
   \       0x64   0x....'....        BL       memcmp
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD1E3             BNE.N    ??CoAPRespMessage_handle_2
    381                      if (!node->keep) {
   \       0x6C   0x6CE0             LDR      R0,[R4, #+76]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD108             BNE.N    ??CoAPRespMessage_handle_4
    382                          list_del(&node->sendlist);
   \       0x72   0xF104 0x0038      ADD      R0,R4,#+56
   \       0x76   0x....'....        BL       dlist_del
    383                          ctx->sendlist.count--;
   \       0x7A   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x7E   0x1E40             SUBS     R0,R0,#+1
   \       0x80   0xF885 0x0020      STRB     R0,[R5, #+32]
    384                          COAP_FLOW("Remove the message id %d from list", node->header.msgid);
    385                      } else {
    386                          COAP_FLOW("Find the message id %d, It need keep", node->header.msgid);
    387                      }
    388                      found = 1;
   \                     ??CoAPRespMessage_handle_4: (+1)
   \       0x84   0xF04F 0x0801      MOV      R8,#+1
    389          
    390                      break;
    391                  }
    392              }
    393          
    394              if (found && NULL != node) {
   \                     ??CoAPRespMessage_handle_3: (+1)
   \       0x88   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x8C   0xD028             BEQ.N    ??CoAPRespMessage_handle_5
   \       0x8E   0x2C00             CMP      R4,#+0
   \       0x90   0xD026             BEQ.N    ??CoAPRespMessage_handle_5
    395                  message->user  = node->user;
   \       0x92   0x6C20             LDR      R0,[R4, #+64]
   \       0x94   0x67F8             STR      R0,[R7, #+124]
    396                  /* TODO: comment it */
    397                  /*
    398                  if (COAP_MSG_CODE_400_BAD_REQUEST <= message->header.code) {
    399                      if (NULL != ctx->notifier) {
    400                          ctx->notifier(message->header.code, remote, message);
    401                      }
    402                  }
    403                  */
    404                  if (NULL != node->handler) {
   \       0x96   0x6A20             LDR      R0,[R4, #+32]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD010             BEQ.N    ??CoAPRespMessage_handle_6
    405                      CoAPSendMsgHandler handler = node->handler;
   \       0x9C   0x4680             MOV      R8,R0
    406          #ifndef COAP_OBSERVE_CLIENT_DISABLE
    407                      CoAPObsClient_add(ctx, message, remote, node);
   \       0x9E   0x4623             MOV      R3,R4
   \       0xA0   0x4632             MOV      R2,R6
   \       0xA2   0x4639             MOV      R1,R7
   \       0xA4   0x4628             MOV      R0,R5
   \       0xA6   0x....'....        BL       CoAPObsClient_add
    408          #endif
    409                      HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \       0xAA   0x6968             LDR      R0,[R5, #+20]
   \       0xAC   0x....'....        BL       HAL_MutexUnlock
    410                      COAP_FLOW("Call the response message callback %p", handler);
    411                      handler(ctx, COAP_REQUEST_SUCCESS, message->user, remote, message);
   \       0xB0   0x9700             STR      R7,[SP, #+0]
   \       0xB2   0x4633             MOV      R3,R6
   \       0xB4   0x6FFA             LDR      R2,[R7, #+124]
   \       0xB6   0x2100             MOVS     R1,#+0
   \       0xB8   0x4628             MOV      R0,R5
   \       0xBA   0x47C0             BLX      R8
   \       0xBC   0xE002             B.N      ??CoAPRespMessage_handle_7
    412                  } else {
    413                      HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \                     ??CoAPRespMessage_handle_6: (+1)
   \       0xBE   0x6968             LDR      R0,[R5, #+20]
   \       0xC0   0x....'....        BL       HAL_MutexUnlock
    414                  }
    415          
    416                  if (!node->keep) {
   \                     ??CoAPRespMessage_handle_7: (+1)
   \       0xC4   0x6CE0             LDR      R0,[R4, #+76]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD113             BNE.N    ??CoAPRespMessage_handle_8
    417                      if (NULL != node->message) {
   \       0xCA   0x6C60             LDR      R0,[R4, #+68]
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD003             BEQ.N    ??CoAPRespMessage_handle_9
    418                          coap_free(node->message);
   \       0xD0   0x....'....        BL       HAL_Free
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0x6460             STR      R0,[R4, #+68]
    419                      }
    420                      coap_free(node);
   \                     ??CoAPRespMessage_handle_9: (+1)
   \       0xD8   0x4620             MOV      R0,R4
   \       0xDA   0x....'....        BL       HAL_Free
   \       0xDE   0xE008             B.N      ??CoAPRespMessage_handle_8
    421                      COAP_DEBUG("The message needless keep, free it");
    422                  }
    423              } else {
    424                  HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \                     ??CoAPRespMessage_handle_5: (+1)
   \       0xE0   0x6968             LDR      R0,[R5, #+20]
   \       0xE2   0x....'....        BL       HAL_MutexUnlock
    425          #ifndef COAP_OBSERVE_CLIENT_DISABLE
    426                  CoAPObsClient_add(ctx, message, remote, NULL);
   \       0xE6   0x2300             MOVS     R3,#+0
   \       0xE8   0x4632             MOV      R2,R6
   \       0xEA   0x4639             MOV      R1,R7
   \       0xEC   0x4628             MOV      R0,R5
   \       0xEE   0x....'....        BL       CoAPObsClient_add
    427          #endif
    428              }
    429              return COAP_ERROR_NOT_FOUND;
   \                     ??CoAPRespMessage_handle_8: (+1)
   \       0xF2   0xF240 0x1007      MOVW     R0,#+263
   \       0xF6   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    430          }
    431          
    432          #define PACKET_INTERVAL_THRE_MS     800
    433          #define PACKET_TRIGGER_NUM          100
    434          

   \                                 In section .text, align 2, keep-with-next
    435          static int CoAPRequestMessage_ack_send(CoAPContext *context, NetworkAddr *remote, unsigned short msgid)
    436          {
   \                     CoAPRequestMessage_ack_send: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB0A1             SUB      SP,SP,#+132
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    437              int ret   = COAP_SUCCESS;
    438              CoAPMessage message;
    439              CoAPIntContext *ctx = (CoAPIntContext *)context;
    440          
    441              CoAPMessage_init(&message);
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x....'....        BL       CoAPMessage_init
    442              CoAPMessageId_set(&message, msgid);
   \       0x10   0x4631             MOV      R1,R6
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x....'....        BL       CoAPMessageId_set
    443              COAP_INFO("Send Ack Response Message: %d", msgid);
    444              ret = CoAPMessage_send(ctx, remote, &message);
   \       0x18   0x466A             MOV      R2,SP
   \       0x1A   0x4629             MOV      R1,R5
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       CoAPMessage_send
   \       0x22   0x4604             MOV      R4,R0
    445              CoAPMessage_destory(&message);
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x....'....        BL       CoAPMessage_destory
    446              return ret;
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0xB022             ADD      SP,SP,#+136
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
    447          }
    448          

   \                                 In section .text, align 2, keep-with-next
    449          static int CoAPRequestMessage_handle(CoAPContext *context, NetworkAddr *remote, CoAPMessage *message)
    450          {
   \                     CoAPRequestMessage_handle: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB0A0             SUB      SP,SP,#+128
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4614             MOV      R4,R2
    451              int             index = 0;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    452              int             ret   = COAP_SUCCESS;
   \       0x10   0x4647             MOV      R7,R8
    453              CoAPResource   *resource = NULL;
    454              unsigned char   path[COAP_MSG_MAX_PATH_LEN] = {0};
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x2180             MOVS     R1,#+128
   \       0x16   0x....'....        BL       __aeabi_memclr4
    455              unsigned char  *tmp = path;
   \       0x1A   0x46E9             MOV      R9,SP
    456              CoAPIntContext *ctx = (CoAPIntContext *)context;
    457          
    458              COAP_FLOW("CoAPRequestMessage_handle: %p", ctx);
    459              /* TODO: if need only one callback */
    460              for (index = 0; index < message->optcount; index++) {
   \       0x1C   0xE01D             B.N      ??CoAPRequestMessage_handle_0
    461                  if (COAP_OPTION_URI_PATH == message->options[index].num) {
   \                     ??CoAPRequestMessage_handle_1: (+1)
   \       0x1E   0xEB04 0x00C8      ADD      R0,R4,R8, LSL #+3
   \       0x22   0x8980             LDRH     R0,[R0, #+12]
   \       0x24   0x280B             CMP      R0,#+11
   \       0x26   0xD116             BNE.N    ??CoAPRequestMessage_handle_2
    462                      if ((COAP_MSG_MAX_PATH_LEN - 1) >= (tmp - path + message->options[index].len)) {
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0xEBA9 0x0000      SUB      R0,R9,R0
   \       0x2E   0xEB04 0x01C8      ADD      R1,R4,R8, LSL #+3
   \       0x32   0x89C9             LDRH     R1,[R1, #+14]
   \       0x34   0x1840             ADDS     R0,R0,R1
   \       0x36   0x2880             CMP      R0,#+128
   \       0x38   0xDA0D             BGE.N    ??CoAPRequestMessage_handle_2
    463                          *tmp = '/';
   \       0x3A   0x202F             MOVS     R0,#+47
   \       0x3C   0xF809 0x0B01      STRB     R0,[R9], #+1
    464                          tmp += 1;
    465                          strncpy((char *)tmp, (const char *)message->options[index].val, message->options[index].len);
   \       0x40   0xEB04 0x00C8      ADD      R0,R4,R8, LSL #+3
   \       0x44   0x89C2             LDRH     R2,[R0, #+14]
   \       0x46   0x6901             LDR      R1,[R0, #+16]
   \       0x48   0x4648             MOV      R0,R9
   \       0x4A   0x....'....        BL       strncpy
    466                          tmp += message->options[index].len;
   \       0x4E   0xEB04 0x00C8      ADD      R0,R4,R8, LSL #+3
   \       0x52   0x89C0             LDRH     R0,[R0, #+14]
   \       0x54   0x4481             ADD      R9,R9,R0
    467                      }
    468                  }
    469              }
   \                     ??CoAPRequestMessage_handle_2: (+1)
   \       0x56   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??CoAPRequestMessage_handle_0: (+1)
   \       0x5A   0xF894 0x006C      LDRB     R0,[R4, #+108]
   \       0x5E   0x4580             CMP      R8,R0
   \       0x60   0xDBDD             BLT.N    ??CoAPRequestMessage_handle_1
   \       0x62   0x46A8             MOV      R8,R5
    470              if (strcmp("/sys/device/info/notify", (const char *)path)) {
    471                  COAP_DEBUG("Request path is %s", path);
    472              }
    473          
    474              resource = CoAPResourceByPath_get(ctx, (char *)path);
   \       0x64   0x4669             MOV      R1,SP
   \       0x66   0x4640             MOV      R0,R8
   \       0x68   0x....'....        BL       CoAPResourceByPath_get
   \       0x6C   0x0005             MOVS     R5,R0
    475              if (NULL != resource) {
   \       0x6E   0xD023             BEQ.N    ??CoAPRequestMessage_handle_3
    476                  if (NULL != resource->callback) {
   \       0x70   0x6868             LDR      R0,[R5, #+4]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD018             BEQ.N    ??CoAPRequestMessage_handle_4
    477                      if (((resource->permission) & (1 << ((message->header.code) - 1))) > 0) {
   \       0x76   0x8829             LDRH     R1,[R5, #+0]
   \       0x78   0x2201             MOVS     R2,#+1
   \       0x7A   0x7860             LDRB     R0,[R4, #+1]
   \       0x7C   0x1E40             SUBS     R0,R0,#+1
   \       0x7E   0x4082             LSLS     R2,R2,R0
   \       0x80   0x4011             ANDS     R1,R2,R1
   \       0x82   0x2901             CMP      R1,#+1
   \       0x84   0xDB10             BLT.N    ??CoAPRequestMessage_handle_4
    478                          if (message->header.type == COAP_MESSAGE_TYPE_CON) {
   \       0x86   0x7820             LDRB     R0,[R4, #+0]
   \       0x88   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD104             BNE.N    ??CoAPRequestMessage_handle_5
    479                              CoAPRequestMessage_ack_send(ctx, remote, message->header.msgid);
   \       0x90   0x8862             LDRH     R2,[R4, #+2]
   \       0x92   0x4631             MOV      R1,R6
   \       0x94   0x4640             MOV      R0,R8
   \       0x96   0x....'....        BL       CoAPRequestMessage_ack_send
    480                          }
    481                          resource->callback(ctx, (char *)path, remote, message);
   \                     ??CoAPRequestMessage_handle_5: (+1)
   \       0x9A   0x4623             MOV      R3,R4
   \       0x9C   0x4632             MOV      R2,R6
   \       0x9E   0x4669             MOV      R1,SP
   \       0xA0   0x4640             MOV      R0,R8
   \       0xA2   0x686C             LDR      R4,[R5, #+4]
   \       0xA4   0x47A0             BLX      R4
   \       0xA6   0xE00E             B.N      ??CoAPRequestMessage_handle_6
    482                      } else {
    483                          COAP_FLOW("The resource %s isn't allowed", resource->path);
    484                          ret = CoAPErrRespMessage_send(ctx, remote, message, COAP_MSG_CODE_405_METHOD_NOT_ALLOWED);
    485                      }
    486                  } else {
    487                      COAP_FLOW("The resource %s handler isn't exist", resource->path);
    488                      ret = CoAPErrRespMessage_send(ctx, remote, message, COAP_MSG_CODE_405_METHOD_NOT_ALLOWED);
   \                     ??CoAPRequestMessage_handle_4: (+1)
   \       0xA8   0x2385             MOVS     R3,#+133
   \       0xAA   0x4622             MOV      R2,R4
   \       0xAC   0x4631             MOV      R1,R6
   \       0xAE   0x4640             MOV      R0,R8
   \       0xB0   0x....'....        BL       CoAPErrRespMessage_send
   \       0xB4   0x4607             MOV      R7,R0
   \       0xB6   0xE006             B.N      ??CoAPRequestMessage_handle_6
    489                  }
    490              } else {
    491                  COAP_FLOW("The resource %s isn't found", path);
    492                  ret = CoAPErrRespMessage_send(ctx, remote, message, COAP_MSG_CODE_404_NOT_FOUND);
   \                     ??CoAPRequestMessage_handle_3: (+1)
   \       0xB8   0x2384             MOVS     R3,#+132
   \       0xBA   0x4622             MOV      R2,R4
   \       0xBC   0x4631             MOV      R1,R6
   \       0xBE   0x4640             MOV      R0,R8
   \       0xC0   0x....'....        BL       CoAPErrRespMessage_send
   \       0xC4   0x4607             MOV      R7,R0
    493              }
    494          
    495              return ret;
   \                     ??CoAPRequestMessage_handle_6: (+1)
   \       0xC6   0x4638             MOV      R0,R7
   \       0xC8   0xB021             ADD      SP,SP,#+132
   \       0xCA   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    496          }
    497          
    498          

   \                                 In section .text, align 2, keep-with-next
    499          static void CoAPMessage_handle(CoAPContext *context,
    500                                         NetworkAddr       *remote,
    501                                         unsigned char     *buf,
    502                                         unsigned short     datalen)
    503          {
   \                     CoAPMessage_handle: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB0A1             SUB      SP,SP,#+132
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    504              int                 ret  = COAP_SUCCESS;
    505              CoAPMessage         message;
    506              CoAPIntContext     *ctx = (CoAPIntContext *)context;
    507          
    508              COAP_FLOW("CoAPMessage_handle: %p", ctx);
    509              memset(&message, 0x00, sizeof(CoAPMessage));
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2184             MOVS     R1,#+132
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x....'....        BL       __aeabi_memset4
    510          
    511              ret = CoAPDeserialize_Message(&message, buf, datalen);
   \       0x16   0x463A             MOV      R2,R7
   \       0x18   0x4631             MOV      R1,R6
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0x....'....        BL       CoAPDeserialize_Message
    512              if (COAP_SUCCESS != ret) {
    513                  if (NULL != ctx->notifier) {
    514                      /* TODO: */
    515                      /* context->notifier(context, event); */
    516                  }
    517              }
    518          
    519              COAP_FLOW("--------Receive a Message------");
    520              CoAPMessage_dump(remote, &message);
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0x....'....        BL       CoAPMessage_dump
    521          
    522              if (COAPAckMsg(message.header) || CoAPResetMsg(message.header)) {
   \       0x28   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD105             BNE.N    ??CoAPMessage_handle_0
   \       0x30   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x34   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x38   0x2802             CMP      R0,#+2
   \       0x3A   0xD005             BEQ.N    ??CoAPMessage_handle_1
   \                     ??CoAPMessage_handle_0: (+1)
   \       0x3C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x40   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x44   0x2803             CMP      R0,#+3
   \       0x46   0xD104             BNE.N    ??CoAPMessage_handle_2
    523                  /* TODO: implement handle client observe */
    524          
    525                  /* TODO: if need call response callback */
    526                  CoAPAckMessage_handle(ctx, &message);
   \                     ??CoAPMessage_handle_1: (+1)
   \       0x48   0x4669             MOV      R1,SP
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x....'....        BL       CoAPAckMessage_handle
   \       0x50   0xE026             B.N      ??CoAPMessage_handle_3
    527          
    528              } else if (CoAPRespMsg(message.header)) {
   \                     ??CoAPMessage_handle_2: (+1)
   \       0x52   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x56   0x3840             SUBS     R0,R0,#+64
   \       0x58   0x2880             CMP      R0,#+128
   \       0x5A   0xD205             BCS.N    ??CoAPMessage_handle_4
    529                  CoAPRespMessage_handle(ctx, remote, &message);
   \       0x5C   0x466A             MOV      R2,SP
   \       0x5E   0x4629             MOV      R1,R5
   \       0x60   0x4620             MOV      R0,R4
   \       0x62   0x....'....        BL       CoAPRespMessage_handle
   \       0x66   0xE01B             B.N      ??CoAPMessage_handle_3
    530              } else if (CoAPPingMsg(message.header)) {
   \                     ??CoAPMessage_handle_4: (+1)
   \       0x68   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD10C             BNE.N    ??CoAPMessage_handle_5
   \       0x70   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x74   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD106             BNE.N    ??CoAPMessage_handle_5
    531                  CoAPRestMessage_send(ctx, remote, message.header.msgid);
   \       0x7C   0xF8BD 0x2002      LDRH     R2,[SP, #+2]
   \       0x80   0x4629             MOV      R1,R5
   \       0x82   0x4620             MOV      R0,R4
   \       0x84   0x....'....        BL       CoAPRestMessage_send
   \       0x88   0xE00A             B.N      ??CoAPMessage_handle_3
    532              } else if (CoAPReqMsg(message.header)) {
   \                     ??CoAPMessage_handle_5: (+1)
   \       0x8A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD006             BEQ.N    ??CoAPMessage_handle_3
   \       0x92   0x2820             CMP      R0,#+32
   \       0x94   0xDA04             BGE.N    ??CoAPMessage_handle_3
    533                  CoAPRequestMessage_handle(ctx, remote, &message);
   \       0x96   0x466A             MOV      R2,SP
   \       0x98   0x4629             MOV      R1,R5
   \       0x9A   0x4620             MOV      R0,R4
   \       0x9C   0x....'....        BL       CoAPRequestMessage_handle
    534              } else {
    535                  COAP_INFO("Weird packet,drop it");
    536              }
    537          
    538          }
   \                     ??CoAPMessage_handle_3: (+1)
   \       0xA0   0xB021             ADD      SP,SP,#+132
   \       0xA2   0xBDF0             POP      {R4-R7,PC}       ;; return
    539          

   \                                 In section .text, align 2, keep-with-next
    540          int CoAPMessage_process(CoAPContext *context, unsigned int timeout)
    541          {
   \                     CoAPMessage_process: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
    542              int len = 0;
    543              NetworkAddr remote;
    544              char ip_addr[17] = {0};
   \        0x8   0xA801             ADD      R0,SP,#+4
   \        0xA   0x2114             MOVS     R1,#+20
   \        0xC   0x....'....        BL       __aeabi_memclr4
    545              CoAPIntContext *ctx = (CoAPIntContext *)context;
    546          
    547              if (NULL == context) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD102             BNE.N    ??CoAPMessage_process_0
    548                  return COAP_ERROR_NULL;
   \       0x14   0xF44F 0x7081      MOV      R0,#+258
   \       0x18   0xE029             B.N      ??CoAPMessage_process_1
    549              }
    550          
    551              HAL_Wifi_Get_IP(ip_addr, NULL);
   \                     ??CoAPMessage_process_0: (+1)
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0xA801             ADD      R0,SP,#+4
   \       0x1E   0x....'....        BL       HAL_Wifi_Get_IP
   \       0x22   0xE006             B.N      ??CoAPMessage_process_2
    552          
    553              while (1) {
    554                  memset(&remote, 0x00, sizeof(NetworkAddr));
    555                  memset(ctx->recvbuf, 0x00, COAP_MSG_MAX_PDU_LEN);
    556                  len = CoAPNetwork_read(ctx->p_network,
    557                                         &remote,
    558                                         ctx->recvbuf,
    559                                         COAP_MSG_MAX_PDU_LEN, timeout);
    560                  if (strncmp((const char *)ip_addr, (const char *)remote.addr, sizeof(ip_addr)) == 0) /* drop the packet from itself*/
    561                      continue;
    562                  if (len > 0) {
    563                      CoAPMessage_handle(ctx, &remote, ctx->recvbuf, len);
   \                     ??CoAPMessage_process_3: (+1)
   \       0x24   0x4633             MOV      R3,R6
   \       0x26   0xB29B             UXTH     R3,R3
   \       0x28   0x6922             LDR      R2,[R4, #+16]
   \       0x2A   0xA906             ADD      R1,SP,#+24
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x....'....        BL       CoAPMessage_handle
    564                  } else {
   \                     ??CoAPMessage_process_2: (+1)
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x2112             MOVS     R1,#+18
   \       0x36   0xA806             ADD      R0,SP,#+24
   \       0x38   0x....'....        BL       __aeabi_memset4
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0xF44F 0x61A0      MOV      R1,#+1280
   \       0x42   0x6920             LDR      R0,[R4, #+16]
   \       0x44   0x....'....        BL       __aeabi_memset
   \       0x48   0x9500             STR      R5,[SP, #+0]
   \       0x4A   0xF44F 0x63A0      MOV      R3,#+1280
   \       0x4E   0x6922             LDR      R2,[R4, #+16]
   \       0x50   0xA906             ADD      R1,SP,#+24
   \       0x52   0x6860             LDR      R0,[R4, #+4]
   \       0x54   0x....'....        BL       CoAPNetwork_read
   \       0x58   0x4606             MOV      R6,R0
   \       0x5A   0x2211             MOVS     R2,#+17
   \       0x5C   0xA906             ADD      R1,SP,#+24
   \       0x5E   0xA801             ADD      R0,SP,#+4
   \       0x60   0x....'....        BL       strncmp
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD0E4             BEQ.N    ??CoAPMessage_process_2
   \       0x68   0x2E01             CMP      R6,#+1
   \       0x6A   0xDADB             BGE.N    ??CoAPMessage_process_3
    565                      return len;
   \       0x6C   0x4630             MOV      R0,R6
   \                     ??CoAPMessage_process_1: (+1)
   \       0x6E   0xB00C             ADD      SP,SP,#+48
   \       0x70   0xBD70             POP      {R4-R6,PC}       ;; return
    566                  }
    567              }
    568          }
    569          

   \                                 In section .text, align 2, keep-with-next
    570          static void Check_timeout (void *context)
    571          {
   \                     Check_timeout: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
    572              CoAPIntContext *ctx = (CoAPIntContext *)context;
    573              CoAPSendNode *node = NULL, *next = NULL, *timeout_node = NULL;
    574              uint64_t tick = HAL_UptimeMs ();
   \        0x6   0x....'....        BL       HAL_UptimeMs
   \        0xA   0x4606             MOV      R6,R0
   \        0xC   0x460F             MOV      R7,R1
    575              do {
    576                  timeout_node = NULL;
   \                     ??Check_timeout_0: (+1)
   \        0xE   0x2400             MOVS     R4,#+0
    577                  HAL_MutexLock(ctx->sendlist.list_mutex);
   \       0x10   0x6968             LDR      R0,[R5, #+20]
   \       0x12   0x....'....        BL       HAL_MutexLock
    578                  list_for_each_entry_safe(node, next, &ctx->sendlist.list, sendlist, CoAPSendNode) {
   \       0x16   0x69E8             LDR      R0,[R5, #+28]
   \       0x18   0xF1A0 0x0838      SUB      R8,R0,#+56
   \       0x1C   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \       0x20   0xF1A0 0x0138      SUB      R1,R0,#+56
   \       0x24   0xE003             B.N      ??Check_timeout_1
   \                     ??Check_timeout_2: (+1)
   \       0x26   0x4688             MOV      R8,R1
   \       0x28   0x6BC8             LDR      R0,[R1, #+60]
   \       0x2A   0xF1A0 0x0138      SUB      R1,R0,#+56
   \                     ??Check_timeout_1: (+1)
   \       0x2E   0xF108 0x0038      ADD      R0,R8,#+56
   \       0x32   0xF105 0x0218      ADD      R2,R5,#+24
   \       0x36   0x4290             CMP      R0,R2
   \       0x38   0xD01D             BEQ.N    ??Check_timeout_3
    579          
    580                      if (node->keep != NOKEEP) {
   \       0x3A   0xF8D8 0x004C      LDR      R0,[R8, #+76]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD1F1             BNE.N    ??Check_timeout_2
    581                          continue;
    582                      }
    583                      if ((node->retrans_count > 0) || (node->timeout >= tick)) {
   \       0x42   0xF898 0x0004      LDRB     R0,[R8, #+4]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD1ED             BNE.N    ??Check_timeout_2
   \       0x4A   0xE9D8 0x2304      LDRD     R2,R3,[R8, #+16]
   \       0x4E   0x42BB             CMP      R3,R7
   \       0x50   0xD8E9             BHI.N    ??Check_timeout_2
   \       0x52   0xD301             BCC.N    ??Check_timeout_4
   \       0x54   0x42B2             CMP      R2,R6
   \       0x56   0xD2E6             BCS.N    ??Check_timeout_2
    584                          continue;
    585                      }
    586          
    587                      /*Remove the node from the list*/
    588                      list_del_init(&node->sendlist);
   \                     ??Check_timeout_4: (+1)
   \       0x58   0xF108 0x0038      ADD      R0,R8,#+56
   \       0x5C   0x....'....        BL       list_del_init
    589                      ctx->sendlist.count--;
   \       0x60   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x64   0x1E40             SUBS     R0,R0,#+1
   \       0x66   0xF885 0x0020      STRB     R0,[R5, #+32]
    590                      COAP_INFO("Retransmit timeout,remove the message id %d count %d",
    591                                        node->header.msgid, ctx->sendlist.count);
    592                      #ifndef COAP_OBSERVE_SERVER_DISABLE
    593                          CoapObsServerAll_delete(ctx, &node->remote);
   \       0x6A   0xF108 0x0124      ADD      R1,R8,#+36
   \       0x6E   0x4628             MOV      R0,R5
   \       0x70   0x....'....        BL       CoapObsServerAll_delete
    594                      #endif
    595                      timeout_node = node;
   \       0x74   0x4644             MOV      R4,R8
    596                      break;
    597                  }
    598                  HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \                     ??Check_timeout_3: (+1)
   \       0x76   0x6968             LDR      R0,[R5, #+20]
   \       0x78   0x....'....        BL       HAL_MutexUnlock
    599          
    600                  if (timeout_node) {
   \       0x7C   0x2C00             CMP      R4,#+0
   \       0x7E   0xD015             BEQ.N    ??Check_timeout_5
    601                      if(NULL != timeout_node->handler){
   \       0x80   0x6A20             LDR      R0,[R4, #+32]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD009             BEQ.N    ??Check_timeout_6
    602                          timeout_node->handler(ctx, COAP_RECV_RESP_TIMEOUT, timeout_node->user, &timeout_node->remote, NULL);
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x9000             STR      R0,[SP, #+0]
   \       0x8A   0xF104 0x0324      ADD      R3,R4,#+36
   \       0x8E   0x6C22             LDR      R2,[R4, #+64]
   \       0x90   0x2101             MOVS     R1,#+1
   \       0x92   0x4628             MOV      R0,R5
   \       0x94   0xF8D4 0xC020      LDR      R12,[R4, #+32]
   \       0x98   0x47E0             BLX      R12
    603                      }
    604                      coap_free(timeout_node->message);
   \                     ??Check_timeout_6: (+1)
   \       0x9A   0x6C60             LDR      R0,[R4, #+68]
   \       0x9C   0x....'....        BL       HAL_Free
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x6460             STR      R0,[R4, #+68]
    605                      coap_free(timeout_node);
   \       0xA4   0x4620             MOV      R0,R4
   \       0xA6   0x....'....        BL       HAL_Free
   \       0xAA   0x2400             MOVS     R4,#+0
    606                  }
    607              } while (timeout_node);
   \                     ??Check_timeout_5: (+1)
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD1AE             BNE.N    ??Check_timeout_0
    608          }
   \       0xB0   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    609          

   \                                 In section .text, align 2, keep-with-next
    610          static void Retansmit (void *context)
    611          {
   \                     Retansmit: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
    612              CoAPIntContext *ctx = (CoAPIntContext *)context;
    613              CoAPSendNode *node = NULL, *next = NULL;
    614              unsigned int ret = 0;
    615          
    616              uint64_t tick = HAL_UptimeMs (); 
   \        0x6   0x....'....        BL       HAL_UptimeMs
   \        0xA   0x4604             MOV      R4,R0
   \        0xC   0x460D             MOV      R5,R1
    617              HAL_MutexLock(ctx->sendlist.list_mutex);
   \        0xE   0x6978             LDR      R0,[R7, #+20]
   \       0x10   0x....'....        BL       HAL_MutexLock
    618              list_for_each_entry_safe(node, next, &ctx->sendlist.list, sendlist, CoAPSendNode) {
   \       0x14   0x69F8             LDR      R0,[R7, #+28]
   \       0x16   0xF1A0 0x0638      SUB      R6,R0,#+56
   \       0x1A   0x6BF0             LDR      R0,[R6, #+60]
   \       0x1C   0xF1A0 0x0838      SUB      R8,R0,#+56
   \                     ??Retansmit_0: (+1)
   \       0x20   0xF106 0x0038      ADD      R0,R6,#+56
   \       0x24   0xF107 0x0118      ADD      R1,R7,#+24
   \       0x28   0x4288             CMP      R0,R1
   \       0x2A   0xD037             BEQ.N    ??Retansmit_1
    619                  if (NULL == node || node->timeout > tick ) {
   \       0x2C   0x2E00             CMP      R6,#+0
   \       0x2E   0xD02F             BEQ.N    ??Retansmit_2
   \       0x30   0xE9D6 0x0104      LDRD     R0,R1,[R6, #+16]
   \       0x34   0x428D             CMP      R5,R1
   \       0x36   0xD32B             BCC.N    ??Retansmit_2
   \       0x38   0xD801             BHI.N    ??Retansmit_3
   \       0x3A   0x4284             CMP      R4,R0
   \       0x3C   0xD328             BCC.N    ??Retansmit_2
    620                      continue;
    621                  }    
    622          
    623                  if (node->retrans_count > 0) {
   \                     ??Retansmit_3: (+1)
   \       0x3E   0x7930             LDRB     R0,[R6, #+4]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD025             BEQ.N    ??Retansmit_2
    624                      /*If has received ack message, don't resend the message*/
    625                      if(0 == node->acked){
   \       0x44   0x6CB0             LDR      R0,[R6, #+72]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD108             BNE.N    ??Retansmit_4
    626                          COAP_DEBUG("Retansmit the message id %d len %d", node->header.msgid, node->msglen);
    627                          ret = CoAPNetwork_write(ctx->p_network, &node->remote, node->message, node->msglen, ctx->waittime);
   \       0x4A   0x6D78             LDR      R0,[R7, #+84]
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x69F3             LDR      R3,[R6, #+28]
   \       0x50   0x6C72             LDR      R2,[R6, #+68]
   \       0x52   0xF106 0x0124      ADD      R1,R6,#+36
   \       0x56   0x6878             LDR      R0,[R7, #+4]
   \       0x58   0x....'....        BL       CoAPNetwork_write
    628                          if (ret != COAP_SUCCESS) {
    629                          }    
    630                      }
    631                      node->timeout_val = node->timeout_val * 3 / 2;
   \                     ??Retansmit_4: (+1)
   \       0x5C   0x8B30             LDRH     R0,[R6, #+24]
   \       0x5E   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \       0x62   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \       0x66   0x1040             ASRS     R0,R0,#+1
   \       0x68   0x8330             STRH     R0,[R6, #+24]
    632                      -- node->retrans_count;
   \       0x6A   0x7930             LDRB     R0,[R6, #+4]
   \       0x6C   0x1E40             SUBS     R0,R0,#+1
   \       0x6E   0x7130             STRB     R0,[R6, #+4]
    633                      if (node->retrans_count == 0) {
   \       0x70   0x7930             LDRB     R0,[R6, #+4]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD006             BEQ.N    ??Retansmit_5
    634                          node->timeout = tick + COAP_ACK_TIMEOUT;
    635                      } else {
    636                          node->timeout = tick + node->timeout_val;
   \       0x76   0x8B30             LDRH     R0,[R6, #+24]
   \       0x78   0x2100             MOVS     R1,#+0
   \       0x7A   0x1820             ADDS     R0,R4,R0
   \       0x7C   0x4169             ADCS     R1,R5,R1
   \       0x7E   0xE9C6 0x0104      STRD     R0,R1,[R6, #+16]
   \       0x82   0xE005             B.N      ??Retansmit_2
    637                      }
   \                     ??Retansmit_5: (+1)
   \       0x84   0xF514 0x7016      ADDS     R0,R4,#+600
   \       0x88   0xF145 0x0100      ADC      R1,R5,#+0
   \       0x8C   0xE9C6 0x0104      STRD     R0,R1,[R6, #+16]
    638          
    639                      COAP_FLOW("node->timeout_val = %d , node->timeout=%d ,tick=%d", node->timeout_val,node->timeout,tick);
    640                  }
    641              }
   \                     ??Retansmit_2: (+1)
   \       0x90   0x4646             MOV      R6,R8
   \       0x92   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \       0x96   0xF1A0 0x0838      SUB      R8,R0,#+56
   \       0x9A   0xE7C1             B.N      ??Retansmit_0
    642              HAL_MutexUnlock(ctx->sendlist.list_mutex);
   \                     ??Retansmit_1: (+1)
   \       0x9C   0x6978             LDR      R0,[R7, #+20]
   \       0x9E   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \       0xA2   0x....'....        B.W      HAL_MutexUnlock
    643          }
    644          
    645          extern void *coap_yield_mutex;
    646          

   \                                 In section .text, align 2, keep-with-next
    647          int CoAPMessage_cycle(CoAPContext *context)
    648          {
   \                     CoAPMessage_cycle: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    649              int res = 0;
    650          
    651              CoAPIntContext *ctx = (CoAPIntContext *)context;
    652          
    653              if (NULL == context) {
   \        0x4   0xD102             BNE.N    ??CoAPMessage_cycle_0
    654                  return COAP_ERROR_NULL;
   \        0x6   0xF44F 0x7081      MOV      R0,#+258
   \        0xA   0xBD70             POP      {R4-R6,PC}
    655              }
    656          
    657              if (coap_yield_mutex != NULL) {
   \                     ??CoAPMessage_cycle_0: (+1)
   \        0xC   0x....             LDR.N    R5,??DataTable2_1
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD001             BEQ.N    ??CoAPMessage_cycle_1
    658                  HAL_MutexLock(coap_yield_mutex);
   \       0x14   0x....'....        BL       HAL_MutexLock
    659              }
    660          
    661              res = CoAPMessage_process(ctx, ctx->waittime);
   \                     ??CoAPMessage_cycle_1: (+1)
   \       0x18   0x6D61             LDR      R1,[R4, #+84]
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x....'....        BL       CoAPMessage_process
   \       0x20   0x4606             MOV      R6,R0
    662              Retansmit (ctx);
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x....'....        BL       Retansmit
    663              Check_timeout (ctx);
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       Check_timeout
    664          
    665              if (coap_yield_mutex != NULL) {
   \       0x2E   0x6828             LDR      R0,[R5, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD001             BEQ.N    ??CoAPMessage_cycle_2
    666                  HAL_MutexUnlock(coap_yield_mutex);
   \       0x34   0x....'....        BL       HAL_MutexUnlock
    667              }
    668          
    669              if (res < 0) {
   \                     ??CoAPMessage_cycle_2: (+1)
   \       0x38   0x2E00             CMP      R6,#+0
   \       0x3A   0xD502             BPL.N    ??CoAPMessage_cycle_3
    670                  HAL_SleepMs(20);
   \       0x3C   0x2014             MOVS     R0,#+20
   \       0x3E   0x....'....        BL       HAL_SleepMs
    671              }
    672          
    673              return res;
   \                     ??CoAPMessage_cycle_3: (+1)
   \       0x42   0x4630             MOV      R0,R6
   \       0x44   0xBD70             POP      {R4-R6,PC}       ;; return
    674          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     coap_yield_mutex

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x25 0x30          DC8 "%02X"
   \              0x32 0x58    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x10   0x0000             DC16 0
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x17   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x2E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x45   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x5C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x73   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    675          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   Check_timeout
        32   -- Indirect call
        32   -> CoapObsServerAll_delete
        32   -> HAL_Free
        32   -> HAL_MutexLock
        32   -> HAL_MutexUnlock
        32   -> HAL_UptimeMs
        32   -> list_del_init
      48   CoAPAckMessage_handle
        48   -- Indirect call
        48   -> HAL_Free
        48   -> HAL_MutexLock
        48   -> HAL_MutexUnlock
        48   -> __aeabi_memclr4
        48   -> __aeabi_memcpy4
        48   -> dlist_del
     152   CoAPAckMessage_send
       152   -> CoAPMessageId_set
       152   -> CoAPMessage_destory
       152   -> CoAPMessage_init
       152   -> CoAPMessage_send
     152   CoAPErrRespMessage_send
       152   -> CoAPMessageCode_set
       152   -> CoAPMessageId_set
       152   -> CoAPMessageToken_set
       152   -> CoAPMessageType_set
       152   -> CoAPMessage_destory
       152   -> CoAPMessage_init
       152   -> CoAPMessage_send
       0   CoAPMessageHandler_set
      24   CoAPMessageId_cancel
        24   -> HAL_Free
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> dlist_del
      16   CoAPMessageId_gen
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      32   CoAPMessageList_add
        32   -> HAL_Free
        32   -> HAL_Malloc
        32   -> HAL_MutexLock
        32   -> HAL_MutexUnlock
        32   -> HAL_UptimeMs
        32   -> __aeabi_memcpy
        32   -> __aeabi_memset4
        32   -> dlist_add_tail
        32   -> platform_is_multicast
      48   CoAPMessageToken_dump
        48   -> HAL_Snprintf
        48   -> __aeabi_memclr4
      24   CoAPMessage_cancel
        24   -> HAL_Free
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> dlist_del
      16   CoAPMessage_cycle
        16   -> Check_timeout
        16   -> CoAPMessage_process
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> HAL_SleepMs
        16   -> Retansmit
      16   CoAPMessage_dump
        16   -> CoAPMessageToken_dump
        16   -> CoAPUintOption_get
     152   CoAPMessage_handle
       152   -> CoAPAckMessage_handle
       152   -> CoAPDeserialize_Message
       152   -> CoAPMessage_dump
       152   -> CoAPRequestMessage_handle
       152   -> CoAPRespMessage_handle
       152   -> CoAPRestMessage_send
       152   -> __aeabi_memset4
      64   CoAPMessage_process
        64   -> CoAPMessage_handle
        64   -> CoAPNetwork_read
        64   -> HAL_Wifi_Get_IP
        64   -> __aeabi_memclr4
        64   -> __aeabi_memset
        64   -> __aeabi_memset4
        64   -> strncmp
      32   CoAPMessage_send
        32   -> CoAPMessageList_add
        32   -> CoAPMessage_dump
        32   -> CoAPNetwork_write
        32   -> CoAPObsClient_delete
        32   -> CoAPSerialize_Message
        32   -> CoAPSerialize_MessageLength
        32   -> HAL_Free
        32   -> HAL_Malloc
        32   -> __aeabi_memset
     152   CoAPRequestMessage_ack_send
       152   -> CoAPMessageId_set
       152   -> CoAPMessage_destory
       152   -> CoAPMessage_init
       152   -> CoAPMessage_send
     160   CoAPRequestMessage_handle
       160   -- Indirect call
       160   -> CoAPErrRespMessage_send
       160   -> CoAPRequestMessage_ack_send
       160   -> CoAPResourceByPath_get
       160   -> __aeabi_memclr4
       160   -> strncpy
      32   CoAPRespMessage_handle
        32   -- Indirect call
        32   -> CoAPAckMessage_send
        32   -> CoAPObsClient_add
        32   -> HAL_Free
        32   -> HAL_MutexLock
        32   -> HAL_MutexUnlock
        32   -> dlist_del
        32   -> memcmp
     152   CoAPRestMessage_send
       152   -> CoAPMessageId_set
       152   -> CoAPMessageType_set
       152   -> CoAPMessage_destory
       152   -> CoAPMessage_init
       152   -> CoAPMessage_send
       0   INIT_AOS_DLIST_HEAD
      32   Retansmit
        32   -> CoAPNetwork_write
        32   -> HAL_MutexLock
         0   -> HAL_MutexUnlock
        32   -> HAL_UptimeMs
       0   __dlist_add
       0   dlist_add_tail
         0   -> __dlist_add
       0   dlist_del
       8   list_del_init
         0   -> INIT_AOS_DLIST_HEAD
         8   -> dlist_del


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
      20  ?_0
       8  ?_1
      20  ?_2
     128  ?_3
      20  ?_4
     180  Check_timeout
     152  CoAPAckMessage_handle
      48  CoAPAckMessage_send
     102  CoAPErrRespMessage_send
      16  CoAPMessageHandler_set
     116  CoAPMessageId_cancel
      50  CoAPMessageId_gen
     236  CoAPMessageList_add
      58  CoAPMessageToken_dump
     112  CoAPMessage_cancel
      70  CoAPMessage_cycle
      34  CoAPMessage_dump
     164  CoAPMessage_handle
     114  CoAPMessage_process
     200  CoAPMessage_send
      48  CoAPRequestMessage_ack_send
     206  CoAPRequestMessage_handle
     250  CoAPRespMessage_handle
      56  CoAPRestMessage_send
       6  INIT_AOS_DLIST_HEAD
     166  Retansmit
      10  __dlist_add
       6  dlist_add_tail
      10  dlist_del
      16  list_del_init

 
   196 bytes in section .rodata
 2 434 bytes in section .text
 
 2 434 bytes of CODE  memory
   196 bytes of CONST memory

Errors: none
Warnings: 3
