###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:15
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\dm_utils.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWC8DB.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\dm_utils.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\dm_utils.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\dm_utils.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\dm_utils.c
      1          /*
      2           * Copyright (C) 2015-2018 Alibaba Group Holding Limited
      3           */
      4          
      5          
      6          
      7          #include "iotx_dm_internal.h"
      8          

   \                                 In section .text, align 2, keep-with-next
      9          int dm_utils_copy_direct(_IN_ void *input, _IN_ int input_len, _OU_ void **output, _IN_ int output_len)
     10          {
   \                     dm_utils_copy_direct: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461F             MOV      R7,R3
     11              if (input == NULL || output == NULL || *output != NULL) {
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD004             BEQ.N    ??dm_utils_copy_direct_0
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD002             BEQ.N    ??dm_utils_copy_direct_0
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??dm_utils_copy_direct_1
     12                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_copy_direct_0: (+1)
   \       0x18   0xF06F 0x0001      MVN      R0,#+1
   \       0x1C   0xBDF2             POP      {R1,R4-R7,PC}
     13              }
     14          
     15              *output = HAL_Malloc(output_len);
   \                     ??dm_utils_copy_direct_1: (+1)
   \       0x1E   0x4638             MOV      R0,R7
   \       0x20   0x....'....        BL       HAL_Malloc
   \       0x24   0x6020             STR      R0,[R4, #+0]
     16              if (*output == NULL) {
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE.N    ??dm_utils_copy_direct_2
     17                  return DM_MEMORY_NOT_ENOUGH;
   \       0x2A   0xF06F 0x0002      MVN      R0,#+2
   \       0x2E   0xBDF2             POP      {R1,R4-R7,PC}
     18              }
     19              memset(*output, 0, output_len);
   \                     ??dm_utils_copy_direct_2: (+1)
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x4639             MOV      R1,R7
   \       0x34   0x....'....        BL       __aeabi_memset
     20              memcpy(*output, input, input_len);
   \       0x38   0x4632             MOV      R2,R6
   \       0x3A   0x4629             MOV      R1,R5
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x....'....        BL       __aeabi_memcpy
     21          
     22              return SUCCESS_RETURN;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     23          }
     24          

   \                                 In section .text, align 2, keep-with-next
     25          int dm_utils_copy(_IN_ void *input, _IN_ int input_len, _OU_ void **output, _IN_ int output_len)
     26          {
   \                     dm_utils_copy: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461F             MOV      R7,R3
     27              if (input == NULL || output == NULL || *output != NULL) {
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD004             BEQ.N    ??dm_utils_copy_0
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD002             BEQ.N    ??dm_utils_copy_0
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??dm_utils_copy_1
     28                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_copy_0: (+1)
   \       0x18   0xF06F 0x0001      MVN      R0,#+1
   \       0x1C   0xBDF2             POP      {R1,R4-R7,PC}
     29              }
     30          
     31              *output = DM_malloc(output_len);
   \                     ??dm_utils_copy_1: (+1)
   \       0x1E   0x4638             MOV      R0,R7
   \       0x20   0x....'....        BL       HAL_Malloc
   \       0x24   0x6020             STR      R0,[R4, #+0]
     32              if (*output == NULL) {
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE.N    ??dm_utils_copy_2
     33                  return DM_MEMORY_NOT_ENOUGH;
   \       0x2A   0xF06F 0x0002      MVN      R0,#+2
   \       0x2E   0xBDF2             POP      {R1,R4-R7,PC}
     34              }
     35              memset(*output, 0, output_len);
   \                     ??dm_utils_copy_2: (+1)
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x4639             MOV      R1,R7
   \       0x34   0x....'....        BL       __aeabi_memset
     36              memcpy(*output, input, input_len);
   \       0x38   0x4632             MOV      R2,R6
   \       0x3A   0x4629             MOV      R1,R5
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x....'....        BL       __aeabi_memcpy
     37          
     38              return SUCCESS_RETURN;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     39          }
     40          

   \                                 In section .text, align 2, keep-with-next
     41          int dm_utils_strarr_index(_IN_ char *input, _IN_ int input_len,
     42                                    _OU_ int *partial_input_len, _OU_ int *array_input_len, _OU_ int *array_index)
     43          {
   \                     dm_utils_strarr_index: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4611             MOV      R1,R2
     44              int index = 0;
   \        0xA   0xF04F 0x0C00      MOV      R12,#+0
     45              int deep = 0;
   \        0xE   0x4665             MOV      R5,R12
     46              char *bracket_pre = NULL;
   \       0x10   0x4628             MOV      R0,R5
     47              char *bracket_suf = NULL;
   \       0x12   0x4602             MOV      R2,R0
     48              char array_index_str[10] = {0};
   \       0x14   0x466E             MOV      R6,SP
   \       0x16   0x4686             MOV      LR,R0
   \       0x18   0x4680             MOV      R8,R0
   \       0x1A   0x4681             MOV      R9,R0
   \       0x1C   0xE886 0x4300      STM      R6,{R8,R9,LR}
     49          
     50              if (input == NULL || input_len <= 1 || array_index == NULL) {
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD004             BEQ.N    ??dm_utils_strarr_index_0
   \       0x24   0x2F02             CMP      R7,#+2
   \       0x26   0xDB02             BLT.N    ??dm_utils_strarr_index_0
   \       0x28   0x9E0A             LDR      R6,[SP, #+40]
   \       0x2A   0x2E00             CMP      R6,#+0
   \       0x2C   0xD118             BNE.N    ??dm_utils_strarr_index_1
     51                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_strarr_index_0: (+1)
   \       0x2E   0xF06F 0x0001      MVN      R0,#+1
   \       0x32   0xE024             B.N      ??dm_utils_strarr_index_2
     52              }
     53          
     54              for (index = 0; index < input_len; index++) {
     55                  switch (input[index]) {
     56                      case '[': {
     57                          if (deep != 0) {
     58                              return FAIL_RETURN;
     59                          }
     60                          deep++;
     61                          if (!bracket_pre) {
     62                              bracket_pre = (char *)&input[index];
     63                          }
     64                      }
     65                      break;
     66                      case ']': {
     67                          if (deep != 1) {
   \                     ??dm_utils_strarr_index_3: (+1)
   \       0x34   0x2D01             CMP      R5,#+1
   \       0x36   0xD120             BNE.N    ??dm_utils_strarr_index_4
     68                              return FAIL_RETURN;
     69                          }
     70                          deep--;
   \       0x38   0x4645             MOV      R5,R8
     71                          if (input[index  - 1] == '[') {
   \       0x3A   0xEB04 0x0E0C      ADD      LR,R4,R12
   \       0x3E   0xF81E 0xEC01      LDRB     LR,[LR, #-1]
   \       0x42   0xF1BE 0x0F5B      CMP      LR,#+91
   \       0x46   0xD018             BEQ.N    ??dm_utils_strarr_index_4
     72                              return FAIL_RETURN;
     73                          }
     74                          if (!bracket_suf) {
   \       0x48   0x2A00             CMP      R2,#+0
   \       0x4A   0xD107             BNE.N    ??dm_utils_strarr_index_5
     75                              bracket_suf = (char *)&input[index];
   \       0x4C   0xEB04 0x020C      ADD      R2,R4,R12
   \       0x50   0xE004             B.N      ??dm_utils_strarr_index_5
     76                          }
     77                      }
   \                     ??dm_utils_strarr_index_6: (+1)
   \       0x52   0x2501             MOVS     R5,#+1
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD101             BNE.N    ??dm_utils_strarr_index_5
   \       0x58   0xEB04 0x000C      ADD      R0,R4,R12
   \                     ??dm_utils_strarr_index_5: (+1)
   \       0x5C   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??dm_utils_strarr_index_1: (+1)
   \       0x60   0x45BC             CMP      R12,R7
   \       0x62   0xDA0E             BGE.N    ??dm_utils_strarr_index_7
   \       0x64   0xF814 0xE00C      LDRB     LR,[R4, R12]
   \       0x68   0xF1BE 0x0F5B      CMP      LR,#+91
   \       0x6C   0xD003             BEQ.N    ??dm_utils_strarr_index_8
   \       0x6E   0xF1BE 0x0F5D      CMP      LR,#+93
   \       0x72   0xD0DF             BEQ.N    ??dm_utils_strarr_index_3
   \       0x74   0xE7F2             B.N      ??dm_utils_strarr_index_5
   \                     ??dm_utils_strarr_index_8: (+1)
   \       0x76   0x2D00             CMP      R5,#+0
   \       0x78   0xD0EB             BEQ.N    ??dm_utils_strarr_index_6
     78                      break;
     79                      default:
     80                          break;
     81                  }
     82              }
     83          
     84              if (bracket_pre && bracket_suf && ((bracket_suf - input + 1) == input_len)) {
     85                  if (partial_input_len) {
     86                      *partial_input_len = bracket_pre - input;
     87                  }
     88                  if (array_input_len) {
     89                      *array_input_len = bracket_suf - input + 1;
     90                  }
     91          
     92                  /* Get Index */
     93                  memcpy(array_index_str, bracket_pre + 1, bracket_suf - bracket_pre - 1);
     94                  *array_index = atoi(array_index_str);
     95                  return SUCCESS_RETURN;
     96              }
     97          
     98              return FAIL_RETURN;
   \                     ??dm_utils_strarr_index_4: (+1)
   \       0x7A   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??dm_utils_strarr_index_2: (+1)
   \       0x7E   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   \                     ??dm_utils_strarr_index_7: (+1)
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD0F9             BEQ.N    ??dm_utils_strarr_index_4
   \       0x86   0x2A00             CMP      R2,#+0
   \       0x88   0xD0F7             BEQ.N    ??dm_utils_strarr_index_4
   \       0x8A   0x1B15             SUBS     R5,R2,R4
   \       0x8C   0x1C6D             ADDS     R5,R5,#+1
   \       0x8E   0x42BD             CMP      R5,R7
   \       0x90   0xD1F3             BNE.N    ??dm_utils_strarr_index_4
   \       0x92   0x2900             CMP      R1,#+0
   \       0x94   0xD001             BEQ.N    ??dm_utils_strarr_index_9
   \       0x96   0x1B05             SUBS     R5,R0,R4
   \       0x98   0x600D             STR      R5,[R1, #+0]
   \                     ??dm_utils_strarr_index_9: (+1)
   \       0x9A   0x2B00             CMP      R3,#+0
   \       0x9C   0xD002             BEQ.N    ??dm_utils_strarr_index_10
   \       0x9E   0x1B14             SUBS     R4,R2,R4
   \       0xA0   0x1C64             ADDS     R4,R4,#+1
   \       0xA2   0x601C             STR      R4,[R3, #+0]
   \                     ??dm_utils_strarr_index_10: (+1)
   \       0xA4   0x1A12             SUBS     R2,R2,R0
   \       0xA6   0x1E52             SUBS     R2,R2,#+1
   \       0xA8   0x1C41             ADDS     R1,R0,#+1
   \       0xAA   0x4668             MOV      R0,SP
   \       0xAC   0x....'....        BL       __aeabi_memcpy
   \       0xB0   0x4668             MOV      R0,SP
   \       0xB2   0x....'....        BL       atoi
   \       0xB6   0x6030             STR      R0,[R6, #+0]
   \       0xB8   0x4640             MOV      R0,R8
   \       0xBA   0xE7E0             B.N      ??dm_utils_strarr_index_2
     99          }
    100          

   \                                 In section .text, align 2, keep-with-next
    101          int dm_utils_itoa_direct(_IN_ int input, _OU_ char **output)
    102          {
   \                     dm_utils_itoa_direct: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x4603             MOV      R3,R0
   \        0x4   0x460C             MOV      R4,R1
    103              int res = 0;
    104              char temp_output[10 + 1] = {0};
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x460A             MOV      R2,R1
   \        0xC   0x460D             MOV      R5,R1
   \        0xE   0xE880 0x0026      STM      R0,{R1,R2,R5}
    105          
    106              if (output == NULL || *output != NULL) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD002             BEQ.N    ??dm_utils_itoa_direct_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD002             BEQ.N    ??dm_utils_itoa_direct_1
    107                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_itoa_direct_0: (+1)
   \       0x1C   0xF06F 0x0001      MVN      R0,#+1
   \       0x20   0xBD3E             POP      {R1-R5,PC}
    108              }
    109          
    110              res = HAL_Snprintf(temp_output, 10, "%d", input);
    111              if (res < 0) {
   \                     ??dm_utils_itoa_direct_1: (+1)
   \       0x22   0x....             ADR.N    R2,??DataTable4  ;; 0x25, 0x64, 0x00, 0x00
   \       0x24   0x210A             MOVS     R1,#+10
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x....'....        BL       HAL_Snprintf
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD502             BPL.N    ??dm_utils_itoa_direct_2
    112                  return FAIL_RETURN;
   \       0x30   0xF04F 0x30FF      MOV      R0,#-1
   \       0x34   0xBD3E             POP      {R1-R5,PC}
    113              }
    114          
    115              *output = HAL_Malloc(strlen(temp_output) + 1);
   \                     ??dm_utils_itoa_direct_2: (+1)
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x....'....        BL       strlen
   \       0x3C   0x1C40             ADDS     R0,R0,#+1
   \       0x3E   0x....'....        BL       HAL_Malloc
   \       0x42   0x6020             STR      R0,[R4, #+0]
    116              if (*output == NULL) {
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD102             BNE.N    ??dm_utils_itoa_direct_3
    117                  return DM_MEMORY_NOT_ENOUGH;
   \       0x48   0xF06F 0x0002      MVN      R0,#+2
   \       0x4C   0xBD3E             POP      {R1-R5,PC}
    118              }
    119              memset(*output, 0, strlen(temp_output) + 1);
   \                     ??dm_utils_itoa_direct_3: (+1)
   \       0x4E   0x4668             MOV      R0,SP
   \       0x50   0x....'....        BL       strlen
   \       0x54   0x1C40             ADDS     R0,R0,#+1
   \       0x56   0x462A             MOV      R2,R5
   \       0x58   0x4601             MOV      R1,R0
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x....'....        BL       __aeabi_memset
    120              memcpy(*output, temp_output, strlen(temp_output));
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0x....'....        BL       strlen
   \       0x66   0x4602             MOV      R2,R0
   \       0x68   0x4669             MOV      R1,SP
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x....'....        BL       __aeabi_memcpy
    121          
    122              return SUCCESS_RETURN;
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0xBD3E             POP      {R1-R5,PC}       ;; return
    123          }
    124          

   \                                 In section .text, align 2, keep-with-next
    125          int dm_utils_itoa(_IN_ int input, _OU_ char **output)
    126          {
   \                     dm_utils_itoa: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x4603             MOV      R3,R0
   \        0x4   0x460C             MOV      R4,R1
    127              int res = 0;
    128              char temp_output[10 + 1] = {0};
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x460A             MOV      R2,R1
   \        0xC   0x460D             MOV      R5,R1
   \        0xE   0xE880 0x0026      STM      R0,{R1,R2,R5}
    129          
    130              if (output == NULL || *output != NULL) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD002             BEQ.N    ??dm_utils_itoa_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD002             BEQ.N    ??dm_utils_itoa_1
    131                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_itoa_0: (+1)
   \       0x1C   0xF06F 0x0001      MVN      R0,#+1
   \       0x20   0xBD3E             POP      {R1-R5,PC}
    132              }
    133          
    134              res = HAL_Snprintf(temp_output, 10, "%d", input);
    135              if (res < 0) {
   \                     ??dm_utils_itoa_1: (+1)
   \       0x22   0x....             ADR.N    R2,??DataTable4  ;; 0x25, 0x64, 0x00, 0x00
   \       0x24   0x210A             MOVS     R1,#+10
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x....'....        BL       HAL_Snprintf
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD502             BPL.N    ??dm_utils_itoa_2
    136                  return FAIL_RETURN;
   \       0x30   0xF04F 0x30FF      MOV      R0,#-1
   \       0x34   0xBD3E             POP      {R1-R5,PC}
    137              }
    138          
    139              *output = DM_malloc(strlen(temp_output) + 1);
   \                     ??dm_utils_itoa_2: (+1)
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x....'....        BL       strlen
   \       0x3C   0x1C40             ADDS     R0,R0,#+1
   \       0x3E   0x....'....        BL       HAL_Malloc
   \       0x42   0x6020             STR      R0,[R4, #+0]
    140              if (*output == NULL) {
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD102             BNE.N    ??dm_utils_itoa_3
    141                  return DM_MEMORY_NOT_ENOUGH;
   \       0x48   0xF06F 0x0002      MVN      R0,#+2
   \       0x4C   0xBD3E             POP      {R1-R5,PC}
    142              }
    143              memset(*output, 0, strlen(temp_output) + 1);
   \                     ??dm_utils_itoa_3: (+1)
   \       0x4E   0x4668             MOV      R0,SP
   \       0x50   0x....'....        BL       strlen
   \       0x54   0x1C40             ADDS     R0,R0,#+1
   \       0x56   0x462A             MOV      R2,R5
   \       0x58   0x4601             MOV      R1,R0
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x....'....        BL       __aeabi_memset
    144              memcpy(*output, temp_output, strlen(temp_output));
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0x....'....        BL       strlen
   \       0x66   0x4602             MOV      R2,R0
   \       0x68   0x4669             MOV      R1,SP
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x....'....        BL       __aeabi_memcpy
    145          
    146              return SUCCESS_RETURN;
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0xBD3E             POP      {R1-R5,PC}       ;; return
    147          }
    148          

   \                                 In section .text, align 2, keep-with-next
    149          int dm_utils_ftoa_direct(_IN_ double input, _OU_ char **output)
    150          {
   \                     dm_utils_ftoa_direct: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
   \        0x4   0x4604             MOV      R4,R0
    151              int res = 0;
    152              char temp_output[30 + 1] = {0};
   \        0x6   0xA802             ADD      R0,SP,#+8
   \        0x8   0x2120             MOVS     R1,#+32
   \        0xA   0x....'....        BL       __aeabi_memclr4
    153          
    154              if (output == NULL || *output != NULL) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD002             BEQ.N    ??dm_utils_ftoa_direct_0
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??dm_utils_ftoa_direct_1
    155                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_ftoa_direct_0: (+1)
   \       0x18   0xF06F 0x0001      MVN      R0,#+1
   \       0x1C   0xE029             B.N      ??dm_utils_ftoa_direct_2
    156              }
    157          
    158              res = HAL_Snprintf(temp_output, 30, "%f", input);
    159              if (res < 0) {
   \                     ??dm_utils_ftoa_direct_1: (+1)
   \       0x1E   0xED8D 0x0B00      VSTR     D0,[SP, #+0]
   \       0x22   0x....             ADR.N    R2,??DataTable4_1  ;; 0x25, 0x66, 0x00, 0x00
   \       0x24   0x211E             MOVS     R1,#+30
   \       0x26   0xA802             ADD      R0,SP,#+8
   \       0x28   0x....'....        BL       HAL_Snprintf
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD502             BPL.N    ??dm_utils_ftoa_direct_3
    160                  return FAIL_RETURN;
   \       0x30   0xF04F 0x30FF      MOV      R0,#-1
   \       0x34   0xE01D             B.N      ??dm_utils_ftoa_direct_2
    161              }
    162          
    163              *output = HAL_Malloc(strlen(temp_output) + 1);
   \                     ??dm_utils_ftoa_direct_3: (+1)
   \       0x36   0xA802             ADD      R0,SP,#+8
   \       0x38   0x....'....        BL       strlen
   \       0x3C   0x1C40             ADDS     R0,R0,#+1
   \       0x3E   0x....'....        BL       HAL_Malloc
   \       0x42   0x6020             STR      R0,[R4, #+0]
    164              if (*output == NULL) {
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD102             BNE.N    ??dm_utils_ftoa_direct_4
    165                  return DM_MEMORY_NOT_ENOUGH;
   \       0x48   0xF06F 0x0002      MVN      R0,#+2
   \       0x4C   0xE011             B.N      ??dm_utils_ftoa_direct_2
    166              }
    167              memset(*output, 0, strlen(temp_output) + 1);
   \                     ??dm_utils_ftoa_direct_4: (+1)
   \       0x4E   0xA802             ADD      R0,SP,#+8
   \       0x50   0x....'....        BL       strlen
   \       0x54   0x4601             MOV      R1,R0
   \       0x56   0x1C49             ADDS     R1,R1,#+1
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x....'....        BL       __aeabi_memset
    168              memcpy(*output, temp_output, strlen(temp_output));
   \       0x60   0xA802             ADD      R0,SP,#+8
   \       0x62   0x....'....        BL       strlen
   \       0x66   0x4602             MOV      R2,R0
   \       0x68   0xA902             ADD      R1,SP,#+8
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x....'....        BL       __aeabi_memcpy
    169          
    170              return SUCCESS_RETURN;
   \       0x70   0x2000             MOVS     R0,#+0
   \                     ??dm_utils_ftoa_direct_2: (+1)
   \       0x72   0xB00A             ADD      SP,SP,#+40
   \       0x74   0xBD10             POP      {R4,PC}          ;; return
    171          }
    172          

   \                                 In section .text, align 2, keep-with-next
    173          int dm_utils_ftoa(_IN_ double input, _OU_ char **output)
    174          {
   \                     dm_utils_ftoa: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
   \        0x4   0x4604             MOV      R4,R0
    175              int res = 0;
    176              char temp_output[30 + 1] = {0};
   \        0x6   0xA802             ADD      R0,SP,#+8
   \        0x8   0x2120             MOVS     R1,#+32
   \        0xA   0x....'....        BL       __aeabi_memclr4
    177          
    178              if (output == NULL || *output != NULL) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD002             BEQ.N    ??dm_utils_ftoa_0
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??dm_utils_ftoa_1
    179                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_ftoa_0: (+1)
   \       0x18   0xF06F 0x0001      MVN      R0,#+1
   \       0x1C   0xE029             B.N      ??dm_utils_ftoa_2
    180              }
    181          
    182              res = HAL_Snprintf(temp_output, 30, "%f", input);
    183              if (res < 0) {
   \                     ??dm_utils_ftoa_1: (+1)
   \       0x1E   0xED8D 0x0B00      VSTR     D0,[SP, #+0]
   \       0x22   0x....             ADR.N    R2,??DataTable4_1  ;; 0x25, 0x66, 0x00, 0x00
   \       0x24   0x211E             MOVS     R1,#+30
   \       0x26   0xA802             ADD      R0,SP,#+8
   \       0x28   0x....'....        BL       HAL_Snprintf
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD502             BPL.N    ??dm_utils_ftoa_3
    184                  return FAIL_RETURN;
   \       0x30   0xF04F 0x30FF      MOV      R0,#-1
   \       0x34   0xE01D             B.N      ??dm_utils_ftoa_2
    185              }
    186          
    187              *output = DM_malloc(strlen(temp_output) + 1);
   \                     ??dm_utils_ftoa_3: (+1)
   \       0x36   0xA802             ADD      R0,SP,#+8
   \       0x38   0x....'....        BL       strlen
   \       0x3C   0x1C40             ADDS     R0,R0,#+1
   \       0x3E   0x....'....        BL       HAL_Malloc
   \       0x42   0x6020             STR      R0,[R4, #+0]
    188              if (*output == NULL) {
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD102             BNE.N    ??dm_utils_ftoa_4
    189                  return DM_MEMORY_NOT_ENOUGH;
   \       0x48   0xF06F 0x0002      MVN      R0,#+2
   \       0x4C   0xE011             B.N      ??dm_utils_ftoa_2
    190              }
    191              memset(*output, 0, strlen(temp_output) + 1);
   \                     ??dm_utils_ftoa_4: (+1)
   \       0x4E   0xA802             ADD      R0,SP,#+8
   \       0x50   0x....'....        BL       strlen
   \       0x54   0x4601             MOV      R1,R0
   \       0x56   0x1C49             ADDS     R1,R1,#+1
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x....'....        BL       __aeabi_memset
    192              memcpy(*output, temp_output, strlen(temp_output));
   \       0x60   0xA802             ADD      R0,SP,#+8
   \       0x62   0x....'....        BL       strlen
   \       0x66   0x4602             MOV      R2,R0
   \       0x68   0xA902             ADD      R1,SP,#+8
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x....'....        BL       __aeabi_memcpy
    193          
    194              return SUCCESS_RETURN;
   \       0x70   0x2000             MOVS     R0,#+0
   \                     ??dm_utils_ftoa_2: (+1)
   \       0x72   0xB00A             ADD      SP,SP,#+40
   \       0x74   0xBD10             POP      {R4,PC}          ;; return
    195          }
    196          

   \                                 In section .text, align 2, keep-with-next
    197          int dm_utils_hex_to_str(_IN_ unsigned char *input, _IN_ int input_len, _OU_ char **output)
    198          {
   \                     dm_utils_hex_to_str: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
    199              int index = 0, output_len = 0;
   \        0xA   0x2700             MOVS     R7,#+0
    200              unsigned char iter_char = 0;
    201          
    202              if (input == NULL || input_len <= 0 || output == NULL || *output != NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD006             BEQ.N    ??dm_utils_hex_to_str_0
   \       0x10   0x2E01             CMP      R6,#+1
   \       0x12   0xDB04             BLT.N    ??dm_utils_hex_to_str_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD002             BEQ.N    ??dm_utils_hex_to_str_0
   \       0x18   0x6828             LDR      R0,[R5, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD002             BEQ.N    ??dm_utils_hex_to_str_1
    203                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_hex_to_str_0: (+1)
   \       0x1E   0xF06F 0x0001      MVN      R0,#+1
   \       0x22   0xE034             B.N      ??dm_utils_hex_to_str_2
    204              }
    205          
    206              output_len = input_len * 2;
   \                     ??dm_utils_hex_to_str_1: (+1)
   \       0x24   0xEA4F 0x0846      LSL      R8,R6,#+1
    207              *output = DM_malloc(output_len + 1);
   \       0x28   0xF108 0x0001      ADD      R0,R8,#+1
   \       0x2C   0x....'....        BL       HAL_Malloc
   \       0x30   0x6028             STR      R0,[R5, #+0]
    208              if (*output == NULL) {
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD102             BNE.N    ??dm_utils_hex_to_str_3
    209                  return DM_MEMORY_NOT_ENOUGH;
   \       0x36   0xF06F 0x0002      MVN      R0,#+2
   \       0x3A   0xE028             B.N      ??dm_utils_hex_to_str_2
    210              }
    211              memset(*output, 0, output_len + 1);
   \                     ??dm_utils_hex_to_str_3: (+1)
   \       0x3C   0x463A             MOV      R2,R7
   \       0x3E   0xF108 0x0801      ADD      R8,R8,#+1
   \       0x42   0x4641             MOV      R1,R8
   \       0x44   0x....'....        BL       __aeabi_memset
    212          
    213              for (index = 0; index < input_len; index++) {
   \       0x48   0xE018             B.N      ??dm_utils_hex_to_str_4
    214                  iter_char = (input[index] >> 4) & 0x0F;
    215                  if (iter_char <= 0x09) {
    216                      iter_char += '0';
    217                  } else if (iter_char >= 0x0A && iter_char <= 0x0F) {
    218                      iter_char += 'A' - 0x0A;
    219                  }
    220                  (*output)[index * 2] = iter_char;
    221          
    222                  iter_char = (input[index]) & 0x0F;
    223                  if (iter_char <= 0x09) {
    224                      iter_char += '0';
    225                  } else if (iter_char >= 0x0A && iter_char <= 0x0F) {
   \                     ??dm_utils_hex_to_str_5: (+1)
   \       0x4A   0xF1A0 0x010A      SUB      R1,R0,#+10
   \       0x4E   0x2906             CMP      R1,#+6
   \       0x50   0xD20F             BCS.N    ??dm_utils_hex_to_str_6
    226                      iter_char += 'A' - 0x0A;
   \       0x52   0x3037             ADDS     R0,R0,#+55
   \       0x54   0xE00D             B.N      ??dm_utils_hex_to_str_6
    227                  }
   \                     ??dm_utils_hex_to_str_7: (+1)
   \       0x56   0xF1A0 0x010A      SUB      R1,R0,#+10
   \       0x5A   0x2906             CMP      R1,#+6
   \       0x5C   0xD200             BCS.N    ??dm_utils_hex_to_str_8
   \       0x5E   0x3037             ADDS     R0,R0,#+55
   \                     ??dm_utils_hex_to_str_8: (+1)
   \       0x60   0x6829             LDR      R1,[R5, #+0]
   \       0x62   0xF801 0x0017      STRB     R0,[R1, R7, LSL #+1]
   \       0x66   0x5DE0             LDRB     R0,[R4, R7]
   \       0x68   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x6C   0x280A             CMP      R0,#+10
   \       0x6E   0xDAEC             BGE.N    ??dm_utils_hex_to_str_5
   \       0x70   0x3030             ADDS     R0,R0,#+48
    228                  (*output)[index * 2 + 1] = iter_char;
   \                     ??dm_utils_hex_to_str_6: (+1)
   \       0x72   0x6829             LDR      R1,[R5, #+0]
   \       0x74   0xEB01 0x0147      ADD      R1,R1,R7, LSL #+1
   \       0x78   0x7048             STRB     R0,[R1, #+1]
   \       0x7A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??dm_utils_hex_to_str_4: (+1)
   \       0x7C   0x42B7             CMP      R7,R6
   \       0x7E   0xDA05             BGE.N    ??dm_utils_hex_to_str_9
   \       0x80   0x5DE0             LDRB     R0,[R4, R7]
   \       0x82   0x0900             LSRS     R0,R0,#+4
   \       0x84   0x280A             CMP      R0,#+10
   \       0x86   0xDAE6             BGE.N    ??dm_utils_hex_to_str_7
   \       0x88   0x3030             ADDS     R0,R0,#+48
   \       0x8A   0xE7E9             B.N      ??dm_utils_hex_to_str_8
    229              }
    230          
    231              return SUCCESS_RETURN;
   \                     ??dm_utils_hex_to_str_9: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \                     ??dm_utils_hex_to_str_2: (+1)
   \       0x8E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    232          }
    233          

   \                                 In section .text, align 2, keep-with-next
    234          int dm_utils_str_to_hex(_IN_ char *input, _IN_ int input_len, _OU_ unsigned char **output, _OU_ int *output_len)
    235          {
   \                     dm_utils_str_to_hex: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461E             MOV      R6,R3
    236              int index = 0;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    237              char iter_char = 0;
   \       0x10   0x46C1             MOV      R9,R8
    238          
    239              if (input == NULL || input_len <= 0 || input_len % 2 != 0 ||
    240                  output == NULL || *output != NULL || output_len == NULL) {
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD00E             BEQ.N    ??dm_utils_str_to_hex_0
   \       0x16   0x2F01             CMP      R7,#+1
   \       0x18   0xDB0C             BLT.N    ??dm_utils_str_to_hex_0
   \       0x1A   0xEB07 0x70D7      ADD      R0,R7,R7, LSR #+31
   \       0x1E   0x1040             ASRS     R0,R0,#+1
   \       0x20   0xEBB7 0x0040      SUBS     R0,R7,R0, LSL #+1
   \       0x24   0xD106             BNE.N    ??dm_utils_str_to_hex_0
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD004             BEQ.N    ??dm_utils_str_to_hex_0
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD101             BNE.N    ??dm_utils_str_to_hex_0
   \       0x30   0x2E00             CMP      R6,#+0
   \       0x32   0xD102             BNE.N    ??dm_utils_str_to_hex_1
    241                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_str_to_hex_0: (+1)
   \       0x34   0xF06F 0x0001      MVN      R0,#+1
   \       0x38   0xE058             B.N      ??dm_utils_str_to_hex_2
    242              }
    243          
    244              *output_len = input_len / 2;
   \                     ??dm_utils_str_to_hex_1: (+1)
   \       0x3A   0xEB07 0x70D7      ADD      R0,R7,R7, LSR #+31
   \       0x3E   0x1040             ASRS     R0,R0,#+1
   \       0x40   0x6030             STR      R0,[R6, #+0]
    245              *output = DM_malloc(*output_len);
   \       0x42   0x....'....        BL       HAL_Malloc
   \       0x46   0x6020             STR      R0,[R4, #+0]
    246              if (*output == NULL) {
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD102             BNE.N    ??dm_utils_str_to_hex_3
    247                  return DM_MEMORY_NOT_ENOUGH;
   \       0x4C   0xF06F 0x0002      MVN      R0,#+2
   \       0x50   0xE04C             B.N      ??dm_utils_str_to_hex_2
    248              }
    249              memset(*output, 0, *output_len);
   \                     ??dm_utils_str_to_hex_3: (+1)
   \       0x52   0x4642             MOV      R2,R8
   \       0x54   0x6831             LDR      R1,[R6, #+0]
   \       0x56   0x....'....        BL       __aeabi_memset
    250          
    251              for (index = 0; index < input_len; index += 2) {
   \       0x5A   0xE03A             B.N      ??dm_utils_str_to_hex_4
    252                  if (input[index] >= '0' && input[index] <= '9') {
    253                      iter_char = input[index] - '0';
    254                  } else if (input[index] >= 'A' && input[index] <= 'F') {
    255                      iter_char = input[index] - 'A' + 0x0A;
    256                  }
    257                  (*output)[index / 2] |= (iter_char << 4) & 0xF0;
    258          
    259                  if (input[index + 1] >= '0' && input[index + 1] <= '9') {
    260                      iter_char = input[index + 1] - '0';
    261                  } else if (input[index + 1] >= 'A' && input[index + 1] <= 'F') {
   \                     ??dm_utils_str_to_hex_5: (+1)
   \       0x5C   0x7840             LDRB     R0,[R0, #+1]
   \       0x5E   0x3841             SUBS     R0,R0,#+65
   \       0x60   0x2806             CMP      R0,#+6
   \       0x62   0xD227             BCS.N    ??dm_utils_str_to_hex_6
    262                      iter_char = input[index + 1] - 'A' + 0x0A;
   \       0x64   0xEB05 0x0008      ADD      R0,R5,R8
   \       0x68   0xF890 0x9001      LDRB     R9,[R0, #+1]
   \       0x6C   0xF1A9 0x0937      SUB      R9,R9,#+55
   \       0x70   0xE020             B.N      ??dm_utils_str_to_hex_6
    263                  }
   \                     ??dm_utils_str_to_hex_7: (+1)
   \       0x72   0xF815 0x0008      LDRB     R0,[R5, R8]
   \       0x76   0x3841             SUBS     R0,R0,#+65
   \       0x78   0x2806             CMP      R0,#+6
   \       0x7A   0xD203             BCS.N    ??dm_utils_str_to_hex_8
   \       0x7C   0xF815 0x9008      LDRB     R9,[R5, R8]
   \       0x80   0xF1A9 0x0937      SUB      R9,R9,#+55
   \                     ??dm_utils_str_to_hex_8: (+1)
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0xEB08 0x71D8      ADD      R1,R8,R8, LSR #+31
   \       0x8A   0x1049             ASRS     R1,R1,#+1
   \       0x8C   0x4602             MOV      R2,R0
   \       0x8E   0xEB08 0x73D8      ADD      R3,R8,R8, LSR #+31
   \       0x92   0x105B             ASRS     R3,R3,#+1
   \       0x94   0x5CD2             LDRB     R2,[R2, R3]
   \       0x96   0xEA42 0x1209      ORR      R2,R2,R9, LSL #+4
   \       0x9A   0x5442             STRB     R2,[R0, R1]
   \       0x9C   0xEB05 0x0008      ADD      R0,R5,R8
   \       0xA0   0x7840             LDRB     R0,[R0, #+1]
   \       0xA2   0x3830             SUBS     R0,R0,#+48
   \       0xA4   0x280A             CMP      R0,#+10
   \       0xA6   0xEB05 0x0008      ADD      R0,R5,R8
   \       0xAA   0xD2D7             BCS.N    ??dm_utils_str_to_hex_5
   \       0xAC   0xF890 0x9001      LDRB     R9,[R0, #+1]
   \       0xB0   0xF1A9 0x0930      SUB      R9,R9,#+48
    264                  (*output)[index / 2] |= (iter_char) & 0x0F;
   \                     ??dm_utils_str_to_hex_6: (+1)
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0xEB08 0x71D8      ADD      R1,R8,R8, LSR #+31
   \       0xBA   0x1049             ASRS     R1,R1,#+1
   \       0xBC   0x4602             MOV      R2,R0
   \       0xBE   0xEB08 0x73D8      ADD      R3,R8,R8, LSR #+31
   \       0xC2   0x105B             ASRS     R3,R3,#+1
   \       0xC4   0x5CD2             LDRB     R2,[R2, R3]
   \       0xC6   0xF009 0x030F      AND      R3,R9,#0xF
   \       0xCA   0x431A             ORRS     R2,R3,R2
   \       0xCC   0x5442             STRB     R2,[R0, R1]
   \       0xCE   0xF108 0x0802      ADD      R8,R8,#+2
   \                     ??dm_utils_str_to_hex_4: (+1)
   \       0xD2   0x45B8             CMP      R8,R7
   \       0xD4   0xDA09             BGE.N    ??dm_utils_str_to_hex_9
   \       0xD6   0xF815 0x0008      LDRB     R0,[R5, R8]
   \       0xDA   0x3830             SUBS     R0,R0,#+48
   \       0xDC   0x280A             CMP      R0,#+10
   \       0xDE   0xD2C8             BCS.N    ??dm_utils_str_to_hex_7
   \       0xE0   0xF815 0x9008      LDRB     R9,[R5, R8]
   \       0xE4   0xF1A9 0x0930      SUB      R9,R9,#+48
   \       0xE8   0xE7CC             B.N      ??dm_utils_str_to_hex_8
    265              }
    266          
    267              return SUCCESS_RETURN;
   \                     ??dm_utils_str_to_hex_9: (+1)
   \       0xEA   0x2000             MOVS     R0,#+0
   \                     ??dm_utils_str_to_hex_2: (+1)
   \       0xEC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    268          }
    269          

   \                                 In section .text, align 2, keep-with-next
    270          int dm_utils_memtok(_IN_ char *input, _IN_ int input_len, _IN_ char delimiter, _IN_ int index, _OU_ int *offset)
    271          {
   \                     dm_utils_memtok: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    272              int item_index = 0;
   \        0x2   0x2500             MOVS     R5,#+0
    273              int count = 0;
   \        0x4   0x462E             MOV      R6,R5
    274          
    275              if (input == NULL || input_len <= 0 || offset == NULL) {
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD005             BEQ.N    ??dm_utils_memtok_0
   \        0xA   0x2901             CMP      R1,#+1
   \        0xC   0xDB03             BLT.N    ??dm_utils_memtok_0
   \        0xE   0x9C04             LDR      R4,[SP, #+16]
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0x4694             MOV      R12,R2
   \       0x14   0xD103             BNE.N    ??dm_utils_memtok_1
    276                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_memtok_0: (+1)
   \       0x16   0xF06F 0x0001      MVN      R0,#+1
   \       0x1A   0xE010             B.N      ??dm_utils_memtok_2
    277              }
    278          
    279              for (item_index = 0; item_index < input_len; item_index++) {
   \                     ??dm_utils_memtok_3: (+1)
   \       0x1C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dm_utils_memtok_1: (+1)
   \       0x1E   0x428D             CMP      R5,R1
   \       0x20   0xDA0B             BGE.N    ??dm_utils_memtok_4
    280                  if (input[item_index] == delimiter && (item_index + 1) < input_len) {
   \       0x22   0x5D47             LDRB     R7,[R0, R5]
   \       0x24   0x4567             CMP      R7,R12
   \       0x26   0xD1F9             BNE.N    ??dm_utils_memtok_3
   \       0x28   0x1C6F             ADDS     R7,R5,#+1
   \       0x2A   0x428F             CMP      R7,R1
   \       0x2C   0xDAF6             BGE.N    ??dm_utils_memtok_3
    281                      count++;
   \       0x2E   0x1C76             ADDS     R6,R6,#+1
    282                      if (count == index) {
   \       0x30   0x429E             CMP      R6,R3
   \       0x32   0xD1F3             BNE.N    ??dm_utils_memtok_3
    283                          *offset = item_index;
   \       0x34   0x6025             STR      R5,[R4, #+0]
    284                          return SUCCESS_RETURN;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE001             B.N      ??dm_utils_memtok_2
    285                      }
    286                  }
    287              }
    288          
    289              return FAIL_RETURN;
   \                     ??dm_utils_memtok_4: (+1)
   \       0x3A   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??dm_utils_memtok_2: (+1)
   \       0x3E   0xBCF0             POP      {R4-R7}
   \       0x40   0x4770             BX       LR               ;; return
    290          }
    291          

   \                                 In section .text, align 2, keep-with-next
    292          int dm_utils_replace_char(_IN_ char *input, _IN_ int input_len, _IN_ char src, _IN_ char dest)
    293          {
   \                     dm_utils_replace_char: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
    294              int index = 0;
   \        0x2   0x2400             MOVS     R4,#+0
    295          
    296              if (input == NULL || input_len <= 0) {
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD001             BEQ.N    ??dm_utils_replace_char_0
   \        0x8   0x2901             CMP      R1,#+1
   \        0xA   0xDA08             BGE.N    ??dm_utils_replace_char_1
    297                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_replace_char_0: (+1)
   \        0xC   0xF06F 0x0001      MVN      R0,#+1
   \       0x10   0xE008             B.N      ??dm_utils_replace_char_2
    298              }
    299          
    300              for (index = 0; index < input_len; index++) {
    301                  if (input[index] == src) {
   \                     ??dm_utils_replace_char_3: (+1)
   \       0x12   0x5D05             LDRB     R5,[R0, R4]
   \       0x14   0x4616             MOV      R6,R2
   \       0x16   0x42B5             CMP      R5,R6
   \       0x18   0xD100             BNE.N    ??dm_utils_replace_char_4
    302                      input[index] = dest;
   \       0x1A   0x5503             STRB     R3,[R0, R4]
    303                  }
    304              }
   \                     ??dm_utils_replace_char_4: (+1)
   \       0x1C   0x1C64             ADDS     R4,R4,#+1
   \                     ??dm_utils_replace_char_1: (+1)
   \       0x1E   0x428C             CMP      R4,R1
   \       0x20   0xDBF7             BLT.N    ??dm_utils_replace_char_3
    305          
    306              return SUCCESS_RETURN;
   \       0x22   0x2000             MOVS     R0,#+0
   \                     ??dm_utils_replace_char_2: (+1)
   \       0x24   0xBC70             POP      {R4-R6}
   \       0x26   0x4770             BX       LR               ;; return
    307          }
    308          

   \                                 In section .text, align 2, keep-with-next
    309          int dm_utils_service_name(_IN_ const char *prefix, _IN_ const char *name, _IN_ char product_key[IOTX_PRODUCT_KEY_LEN + 1],
    310                                    _IN_ char device_name[IOTX_DEVICE_NAME_LEN + 1], _OU_ char **service_name)
    311          {
   \                     dm_utils_service_name: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    312              int prefix_len = (prefix == NULL) ? (0) : (strlen(prefix));
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD102             BNE.N    ??dm_utils_service_name_0
   \       0x10   0xF04F 0x0A00      MOV      R10,#+0
   \       0x14   0xE002             B.N      ??dm_utils_service_name_1
   \                     ??dm_utils_service_name_0: (+1)
   \       0x16   0x....'....        BL       strlen
   \       0x1A   0x4682             MOV      R10,R0
    313              int name_len = (name == NULL) ? (0) : (strlen(name));
   \                     ??dm_utils_service_name_1: (+1)
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD102             BNE.N    ??dm_utils_service_name_2
   \       0x20   0xF04F 0x0900      MOV      R9,#+0
   \       0x24   0xE003             B.N      ??dm_utils_service_name_3
   \                     ??dm_utils_service_name_2: (+1)
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x....'....        BL       strlen
   \       0x2C   0x4681             MOV      R9,R0
    314              int service_name_len = 0;
    315              if ((prefix == NULL && name == NULL) || product_key == NULL || device_name == NULL ||
    316                  service_name == NULL || *service_name != NULL) {
   \                     ??dm_utils_service_name_3: (+1)
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD101             BNE.N    ??dm_utils_service_name_4
   \       0x32   0x2D00             CMP      R5,#+0
   \       0x34   0xD00C             BEQ.N    ??dm_utils_service_name_5
   \                     ??dm_utils_service_name_4: (+1)
   \       0x36   0x2E00             CMP      R6,#+0
   \       0x38   0xD00A             BEQ.N    ??dm_utils_service_name_5
   \       0x3A   0x2F00             CMP      R7,#+0
   \       0x3C   0xD008             BEQ.N    ??dm_utils_service_name_5
   \       0x3E   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \       0x42   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x46   0xD003             BEQ.N    ??dm_utils_service_name_5
   \       0x48   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD002             BEQ.N    ??dm_utils_service_name_6
    317                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_service_name_5: (+1)
   \       0x50   0xF06F 0x0001      MVN      R0,#+1
   \       0x54   0xE030             B.N      ??dm_utils_service_name_7
    318              }
    319          
    320              service_name_len = prefix_len + name_len + strlen(product_key) + strlen(device_name) + 1;
   \                     ??dm_utils_service_name_6: (+1)
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0x....'....        BL       strlen
   \       0x5C   0x44CA             ADD      R10,R9,R10
   \       0x5E   0x4482             ADD      R10,R0,R10
   \       0x60   0x4638             MOV      R0,R7
   \       0x62   0x....'....        BL       strlen
   \       0x66   0x4482             ADD      R10,R0,R10
   \       0x68   0xF10A 0x0A01      ADD      R10,R10,#+1
    321              *service_name = DM_malloc(service_name_len);
   \       0x6C   0x4650             MOV      R0,R10
   \       0x6E   0x....'....        BL       HAL_Malloc
   \       0x72   0xF8C8 0x0000      STR      R0,[R8, #+0]
    322              if (*service_name == NULL) {
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD102             BNE.N    ??dm_utils_service_name_8
    323                  return DM_MEMORY_NOT_ENOUGH;
   \       0x7A   0xF06F 0x0002      MVN      R0,#+2
   \       0x7E   0xE01B             B.N      ??dm_utils_service_name_7
    324              }
    325              memset(*service_name, 0, service_name_len);
   \                     ??dm_utils_service_name_8: (+1)
   \       0x80   0x2200             MOVS     R2,#+0
   \       0x82   0x4651             MOV      R1,R10
   \       0x84   0x....'....        BL       __aeabi_memset
    326          
    327              if (prefix != NULL) {
   \       0x88   0x2C00             CMP      R4,#+0
   \       0x8A   0xD007             BEQ.N    ??dm_utils_service_name_9
    328                  HAL_Snprintf(*service_name, service_name_len, prefix, product_key, device_name);
   \       0x8C   0x9700             STR      R7,[SP, #+0]
   \       0x8E   0x4633             MOV      R3,R6
   \       0x90   0x4622             MOV      R2,R4
   \       0x92   0x4651             MOV      R1,R10
   \       0x94   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x98   0x....'....        BL       HAL_Snprintf
    329              }
    330          
    331              if (name != NULL) {
   \                     ??dm_utils_service_name_9: (+1)
   \       0x9C   0x2D00             CMP      R5,#+0
   \       0x9E   0xD00A             BEQ.N    ??dm_utils_service_name_10
    332                  memcpy(*service_name + strlen(*service_name), name, name_len);
   \       0xA0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xA4   0x....'....        BL       strlen
   \       0xA8   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xAC   0x4408             ADD      R0,R1,R0
   \       0xAE   0x464A             MOV      R2,R9
   \       0xB0   0x4629             MOV      R1,R5
   \       0xB2   0x....'....        BL       __aeabi_memcpy
    333              }
    334          
    335              return SUCCESS_RETURN;
   \                     ??dm_utils_service_name_10: (+1)
   \       0xB6   0x2000             MOVS     R0,#+0
   \                     ??dm_utils_service_name_7: (+1)
   \       0xB8   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    336          }
    337          

   \                                 In section .text, align 2, keep-with-next
    338          int dm_utils_uri_add_prefix(_IN_ const char *prefix, _IN_ char *uri, _OU_ char **new_uri)
    339          {
   \                     dm_utils_uri_add_prefix: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
    340              int new_uri_len = 0;
    341          
    342              if (prefix == NULL || uri == NULL || new_uri == NULL || *new_uri != NULL) {
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD006             BEQ.N    ??dm_utils_uri_add_prefix_0
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD004             BEQ.N    ??dm_utils_uri_add_prefix_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD002             BEQ.N    ??dm_utils_uri_add_prefix_0
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD002             BEQ.N    ??dm_utils_uri_add_prefix_1
    343                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_uri_add_prefix_0: (+1)
   \       0x1A   0xF06F 0x0001      MVN      R0,#+1
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}
    344              }
    345          
    346              new_uri_len = strlen(prefix) + strlen(uri) + 1;
   \                     ??dm_utils_uri_add_prefix_1: (+1)
   \       0x20   0x4630             MOV      R0,R6
   \       0x22   0x....'....        BL       strlen
   \       0x26   0x4607             MOV      R7,R0
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       strlen
   \       0x2E   0x19C7             ADDS     R7,R0,R7
   \       0x30   0x1C7F             ADDS     R7,R7,#+1
    347              *new_uri = DM_malloc(new_uri_len);
   \       0x32   0x4638             MOV      R0,R7
   \       0x34   0x....'....        BL       HAL_Malloc
   \       0x38   0x6028             STR      R0,[R5, #+0]
    348              if (*new_uri == NULL) {
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD102             BNE.N    ??dm_utils_uri_add_prefix_2
    349                  return DM_MEMORY_NOT_ENOUGH;
   \       0x3E   0xF06F 0x0002      MVN      R0,#+2
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}
    350              }
    351              memset(*new_uri, 0, new_uri_len);
   \                     ??dm_utils_uri_add_prefix_2: (+1)
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x4639             MOV      R1,R7
   \       0x48   0x....'....        BL       __aeabi_memset
    352          
    353              memcpy(*new_uri, prefix, strlen(prefix));
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x....'....        BL       strlen
   \       0x52   0x4602             MOV      R2,R0
   \       0x54   0x4631             MOV      R1,R6
   \       0x56   0x6828             LDR      R0,[R5, #+0]
   \       0x58   0x....'....        BL       __aeabi_memcpy
    354              memcpy(*new_uri + strlen(*new_uri), uri, strlen(uri));
   \       0x5C   0x4620             MOV      R0,R4
   \       0x5E   0x....'....        BL       strlen
   \       0x62   0x4606             MOV      R6,R0
   \       0x64   0x6828             LDR      R0,[R5, #+0]
   \       0x66   0x....'....        BL       strlen
   \       0x6A   0x6829             LDR      R1,[R5, #+0]
   \       0x6C   0x4408             ADD      R0,R1,R0
   \       0x6E   0x4632             MOV      R2,R6
   \       0x70   0x4621             MOV      R1,R4
   \       0x72   0x....'....        BL       __aeabi_memcpy
    355          
    356              return SUCCESS_RETURN;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    357          }
    358          

   \                                 In section .text, align 2, keep-with-next
    359          int dm_utils_json_parse(_IN_ const char *payload, _IN_ int payload_len, _IN_ int type, _OU_ lite_cjson_t *lite)
    360          {
   \                     dm_utils_json_parse: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461C             MOV      R4,R3
    361              int res = 0;
    362          
    363              if (payload == NULL || payload_len <= 0 || type < 0 || lite == NULL) {
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD005             BEQ.N    ??dm_utils_json_parse_0
   \        0xE   0x2F01             CMP      R7,#+1
   \       0x10   0xDB03             BLT.N    ??dm_utils_json_parse_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD401             BMI.N    ??dm_utils_json_parse_0
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??dm_utils_json_parse_1
    364                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_json_parse_0: (+1)
   \       0x1A   0xF06F 0x0001      MVN      R0,#+1
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}
    365              }
    366              memset(lite, 0, sizeof(lite_cjson_t));
   \                     ??dm_utils_json_parse_1: (+1)
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x2120             MOVS     R1,#+32
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       __aeabi_memset4
    367          
    368              res = lite_cjson_parse(payload, payload_len, lite);
    369              if (res != SUCCESS_RETURN) {
   \       0x2A   0x4622             MOV      R2,R4
   \       0x2C   0x4639             MOV      R1,R7
   \       0x2E   0x4630             MOV      R0,R6
   \       0x30   0x....'....        BL       lite_cjson_parse
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD007             BEQ.N    ??dm_utils_json_parse_2
    370                  memset(lite, 0, sizeof(lite_cjson_t));
   \       0x38   0x2200             MOVS     R2,#+0
   \       0x3A   0x2120             MOVS     R1,#+32
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x....'....        BL       __aeabi_memset4
    371                  return FAIL_RETURN;
   \       0x42   0xF04F 0x30FF      MOV      R0,#-1
   \       0x46   0xBDF2             POP      {R1,R4-R7,PC}
    372              }
    373          
    374              if (type != cJSON_Invalid && lite->type != type) {
   \                     ??dm_utils_json_parse_2: (+1)
   \       0x48   0x2D00             CMP      R5,#+0
   \       0x4A   0xD00A             BEQ.N    ??dm_utils_json_parse_3
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x42A8             CMP      R0,R5
   \       0x50   0xD007             BEQ.N    ??dm_utils_json_parse_3
    375                  memset(lite, 0, sizeof(lite_cjson_t));
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x2120             MOVS     R1,#+32
   \       0x56   0x4620             MOV      R0,R4
   \       0x58   0x....'....        BL       __aeabi_memset4
    376                  return FAIL_RETURN;
   \       0x5C   0xF04F 0x30FF      MOV      R0,#-1
   \       0x60   0xBDF2             POP      {R1,R4-R7,PC}
    377              }
    378          
    379              return SUCCESS_RETURN;
   \                     ??dm_utils_json_parse_3: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    380          }
    381          

   \                                 In section .text, align 2, keep-with-next
    382          int dm_utils_json_object_item(_IN_ lite_cjson_t *lite, _IN_ const char *key, _IN_ int key_len, _IN_ int type,
    383                                        _OU_ lite_cjson_t *lite_item)
    384          {
   \                     dm_utils_json_object_item: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x461D             MOV      R5,R3
    385              int res = 0;
    386          
    387              if (lite == NULL || lite->type != cJSON_Object || key == NULL || key_len <= 0 || type < 0 || lite_item == NULL) {
   \        0xC   0x2F00             CMP      R7,#+0
   \        0xE   0xD00C             BEQ.N    ??dm_utils_json_object_item_0
   \       0x10   0x6838             LDR      R0,[R7, #+0]
   \       0x12   0x2840             CMP      R0,#+64
   \       0x14   0xD109             BNE.N    ??dm_utils_json_object_item_0
   \       0x16   0x2E00             CMP      R6,#+0
   \       0x18   0xD007             BEQ.N    ??dm_utils_json_object_item_0
   \       0x1A   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x1E   0xDB04             BLT.N    ??dm_utils_json_object_item_0
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD402             BMI.N    ??dm_utils_json_object_item_0
   \       0x24   0x9C06             LDR      R4,[SP, #+24]
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD102             BNE.N    ??dm_utils_json_object_item_1
    388                  return DM_INVALID_PARAMETER;
   \                     ??dm_utils_json_object_item_0: (+1)
   \       0x2A   0xF06F 0x0001      MVN      R0,#+1
   \       0x2E   0xE022             B.N      ??dm_utils_json_object_item_2
    389              }
    390          
    391              if (lite->type != cJSON_Object) {
    392                  dm_log_err("lite->type != cJSON_Object, %d", lite->type);
    393              }
    394          
    395              memset(lite_item, 0, sizeof(lite_cjson_t));
   \                     ??dm_utils_json_object_item_1: (+1)
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x2120             MOVS     R1,#+32
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       __aeabi_memset4
    396          
    397              res = lite_cjson_object_item(lite, key, key_len, lite_item);
    398              if (res != SUCCESS_RETURN) {
   \       0x3A   0x4623             MOV      R3,R4
   \       0x3C   0x4642             MOV      R2,R8
   \       0x3E   0x4631             MOV      R1,R6
   \       0x40   0x4638             MOV      R0,R7
   \       0x42   0x....'....        BL       lite_cjson_object_item
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD007             BEQ.N    ??dm_utils_json_object_item_3
    399                  /* dm_log_err(DM_UTILS_LOG_JSON_PARSE_FAILED, lite->value_length, lite->value); */
    400                  memset(lite_item, 0, sizeof(lite_cjson_t));
   \       0x4A   0x2200             MOVS     R2,#+0
   \       0x4C   0x2120             MOVS     R1,#+32
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x....'....        BL       __aeabi_memset4
    401                  return FAIL_RETURN;
   \       0x54   0xF04F 0x30FF      MOV      R0,#-1
   \       0x58   0xE00D             B.N      ??dm_utils_json_object_item_2
    402              }
    403          
    404              if (type != cJSON_Invalid && lite_item->type != type) {
   \                     ??dm_utils_json_object_item_3: (+1)
   \       0x5A   0x2D00             CMP      R5,#+0
   \       0x5C   0xD00A             BEQ.N    ??dm_utils_json_object_item_4
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x42A8             CMP      R0,R5
   \       0x62   0xD007             BEQ.N    ??dm_utils_json_object_item_4
    405                  memset(lite_item, 0, sizeof(lite_cjson_t));
   \       0x64   0x2200             MOVS     R2,#+0
   \       0x66   0x2120             MOVS     R1,#+32
   \       0x68   0x4620             MOV      R0,R4
   \       0x6A   0x....'....        BL       __aeabi_memset4
    406                  return FAIL_RETURN;
   \       0x6E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x72   0xE000             B.N      ??dm_utils_json_object_item_2
    407              }
    408          
    409              return SUCCESS_RETURN;
   \                     ??dm_utils_json_object_item_4: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \                     ??dm_utils_json_object_item_2: (+1)
   \       0x76   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    410          }
    411          

   \                                 In section .text, align 2, keep-with-next
    412          void *dm_utils_malloc(unsigned int size)
    413          {
    414          #ifdef INFRA_MEM_STATS
    415              return LITE_malloc(size, MEM_MAGIC, "lite_cjson");
    416          #else
    417              return HAL_Malloc(size);
   \                     dm_utils_malloc: (+1)
   \        0x0   0x....'....        B.W      HAL_Malloc
    418          #endif
    419          }
    420          

   \                                 In section .text, align 2, keep-with-next
    421          void dm_utils_free(void *ptr)
    422          {
    423          #ifdef INFRA_MEM_STATS
    424              LITE_free(ptr);
    425          #else
    426              HAL_Free((void *)ptr);
   \                     dm_utils_free: (+1)
   \        0x0   0x....'....        B.W      HAL_Free
    427          #endif
    428          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x25 0x64          DC8 "%d"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x17   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4
   \        0x0   0x25 0x66          DC8 "%f"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x17   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   dm_utils_copy
        24   -> HAL_Malloc
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      24   dm_utils_copy_direct
        24   -> HAL_Malloc
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
       0   dm_utils_free
         0   -> HAL_Free
      48   dm_utils_ftoa
        48   -> HAL_Malloc
        48   -> HAL_Snprintf
        48   -> __aeabi_memclr4
        48   -> __aeabi_memcpy
        48   -> __aeabi_memset
        48   -> strlen
      48   dm_utils_ftoa_direct
        48   -> HAL_Malloc
        48   -> HAL_Snprintf
        48   -> __aeabi_memclr4
        48   -> __aeabi_memcpy
        48   -> __aeabi_memset
        48   -> strlen
      24   dm_utils_hex_to_str
        24   -> HAL_Malloc
        24   -> __aeabi_memset
      24   dm_utils_itoa
        24   -> HAL_Malloc
        24   -> HAL_Snprintf
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
        24   -> strlen
      24   dm_utils_itoa_direct
        24   -> HAL_Malloc
        24   -> HAL_Snprintf
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
        24   -> strlen
      24   dm_utils_json_object_item
        24   -> __aeabi_memset4
        24   -> lite_cjson_object_item
      24   dm_utils_json_parse
        24   -> __aeabi_memset4
        24   -> lite_cjson_parse
       0   dm_utils_malloc
         0   -> HAL_Malloc
      16   dm_utils_memtok
      12   dm_utils_replace_char
      40   dm_utils_service_name
        40   -> HAL_Malloc
        40   -> HAL_Snprintf
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> strlen
      32   dm_utils_str_to_hex
        32   -> HAL_Malloc
        32   -> __aeabi_memset
      40   dm_utils_strarr_index
        40   -> __aeabi_memcpy
        40   -> atoi
      24   dm_utils_uri_add_prefix
        24   -> HAL_Malloc
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
        24   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
      12  ?_0
      12  ?_1
       4  ?_2
      12  ?_3
      32  ?_4
       4  ?_5
      32  ?_6
      70  dm_utils_copy
      70  dm_utils_copy_direct
       4  dm_utils_free
     118  dm_utils_ftoa
     118  dm_utils_ftoa_direct
     146  dm_utils_hex_to_str
     116  dm_utils_itoa
     116  dm_utils_itoa_direct
     122  dm_utils_json_object_item
     102  dm_utils_json_parse
       4  dm_utils_malloc
      66  dm_utils_memtok
      40  dm_utils_replace_char
     188  dm_utils_service_name
     240  dm_utils_str_to_hex
     188  dm_utils_strarr_index
     122  dm_utils_uri_add_prefix

 
   108 bytes in section .rodata
 1 838 bytes in section .text
 
 1 838 bytes of CODE  memory
   108 bytes of CONST memory

Errors: none
Warnings: none
