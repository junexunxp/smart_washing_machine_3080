///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM        10/Jun/2019  13:47:56
// Copyright 1999-2019 IAR Systems AB.
//
//    Cpu mode     =  
//    Endian       =  little
//    Source file  =  
//        C:\Development\smart_washing_machine_3080\mbedtls\library\aes.c
//    Command line =  
//        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW7E99.tmp
//        (C:\Development\smart_washing_machine_3080\mbedtls\library\aes.c -D
//        DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1
//        -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D
//        PRINTF_ADVANCED_ENABLE -D
//        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
//        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
//        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
//        --diag_suppress Pa082,Pa050 -o
//        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
//        --no_clustering --no_scheduling --debug --endian=little
//        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
//        (x86)\IAR Systems\Embedded Workbench
//        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
//        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
//        C:\Development\smart_washing_machine_3080/board\ -I
//        C:\Development\smart_washing_machine_3080/source\ -I
//        C:\Development\smart_washing_machine_3080/CMSIS\ -I
//        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
//        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
//        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
//        C:\Development\smart_washing_machine_3080/component/serial_manager\
//        -I C:\Development\smart_washing_machine_3080/component/uart\ -I
//        C:\Development\smart_washing_machine_3080/component/kv\ -I
//        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
//        C:\Development\smart_washing_machine_3080/device\ -I
//        C:\Development\smart_washing_machine_3080/doc\ -I
//        C:\Development\smart_washing_machine_3080/drivers\ -I
//        C:\Development\smart_washing_machine_3080/src\ -I
//        C:\Development\smart_washing_machine_3080/startup\ -I
//        C:\Development\smart_washing_machine_3080/utilities\ -I
//        C:\Development\smart_washing_machine_3080/xip\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
//        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
//        -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
//        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
//        -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
//        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
//        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
//        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
//    Locale       =  C
//    List file    =  
//        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\aes.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "0"
        RTMODEL "__dlib_full_locale_support", "0"
        RTMODEL "__dlib_version", "6"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN DbgConsole_Printf
        EXTERN __aeabi_memcpy
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_memset4
        EXTERN mbedtls_platform_zeroize
        EXTERN memcmp

        PUBLIC mbedtls_aes_crypt_cbc
        PUBLIC mbedtls_aes_crypt_cfb128
        PUBLIC mbedtls_aes_crypt_cfb8
        PUBLIC mbedtls_aes_crypt_ctr
        PUBLIC mbedtls_aes_crypt_ecb
        PUBLIC mbedtls_aes_decrypt
        PUBLIC mbedtls_aes_encrypt
        PUBLIC mbedtls_aes_free
        PUBLIC mbedtls_aes_init
        PUBLIC mbedtls_aes_self_test
        PUBLIC mbedtls_aes_setkey_dec
        PUBLIC mbedtls_aes_setkey_enc
        PUBLIC mbedtls_internal_aes_decrypt
        PUBLIC mbedtls_internal_aes_encrypt
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_0:
        DC8 "  AES-ECB-%3d (%s): "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
        DC8 "dec"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
        DC8 "enc"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_3:
        DC8 "skipped\012\015"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_4:
        DC8 "passed\012\015"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
        DC8 "\012\015"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_6:
        DC8 "  AES-CBC-%3d (%s): "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
        DATA
        DC8 "\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_8:
        DC8 "  AES-CFB128-%3d (%s): "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_9:
        DC8 "  AES-CTR-128 (%s): "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_10:
        DC8 "failed\012\015"
        DC8 0, 0, 0
// C:\Development\smart_washing_machine_3080\mbedtls\library\aes.c
//    1 /*
//    2  *  FIPS-197 compliant AES implementation
//    3  *
//    4  *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
//    5  *  SPDX-License-Identifier: Apache-2.0
//    6  *
//    7  *  Licensed under the Apache License, Version 2.0 (the "License"); you may
//    8  *  not use this file except in compliance with the License.
//    9  *  You may obtain a copy of the License at
//   10  *
//   11  *  http://www.apache.org/licenses/LICENSE-2.0
//   12  *
//   13  *  Unless required by applicable law or agreed to in writing, software
//   14  *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//   15  *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   16  *  See the License for the specific language governing permissions and
//   17  *  limitations under the License.
//   18  *
//   19  *  This file is part of mbed TLS (https://tls.mbed.org)
//   20  */
//   21 /*
//   22  *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.
//   23  *
//   24  *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf
//   25  *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
//   26  */
//   27 
//   28 #if !defined(MBEDTLS_CONFIG_FILE)
//   29 #include "mbedtls/config.h"
//   30 #else
//   31 #include MBEDTLS_CONFIG_FILE
//   32 #endif
//   33 
//   34 #if defined(MBEDTLS_AES_C)
//   35 
//   36 #include <string.h>
//   37 
//   38 #include "mbedtls/aes.h"
//   39 #include "mbedtls/platform_util.h"
//   40 #if defined(MBEDTLS_PADLOCK_C)
//   41 #include "mbedtls/padlock.h"
//   42 #endif
//   43 #if defined(MBEDTLS_AESNI_C)
//   44 #include "mbedtls/aesni.h"
//   45 #endif
//   46 
//   47 #if defined(MBEDTLS_SELF_TEST)
//   48 #if defined(MBEDTLS_PLATFORM_C)
//   49 #include "mbedtls/platform.h"
//   50 #else
//   51 #include <stdio.h>
//   52 #define mbedtls_printf printf
//   53 #endif /* MBEDTLS_PLATFORM_C */
//   54 #endif /* MBEDTLS_SELF_TEST */
//   55 
//   56 #if !defined(MBEDTLS_AES_ALT)
//   57 
//   58 /*
//   59  * 32-bit integer manipulation macros (little endian)
//   60  */
//   61 #ifndef GET_UINT32_LE
//   62 #define GET_UINT32_LE(n,b,i)                            \ 
//   63 {                                                       \ 
//   64     (n) = ( (uint32_t) (b)[(i)    ]       )             \ 
//   65         | ( (uint32_t) (b)[(i) + 1] <<  8 )             \ 
//   66         | ( (uint32_t) (b)[(i) + 2] << 16 )             \ 
//   67         | ( (uint32_t) (b)[(i) + 3] << 24 );            \ 
//   68 }
//   69 #endif
//   70 
//   71 #ifndef PUT_UINT32_LE
//   72 #define PUT_UINT32_LE(n,b,i)                                    \ 
//   73 {                                                               \ 
//   74     (b)[(i)    ] = (unsigned char) ( ( (n)       ) & 0xFF );    \ 
//   75     (b)[(i) + 1] = (unsigned char) ( ( (n) >>  8 ) & 0xFF );    \ 
//   76     (b)[(i) + 2] = (unsigned char) ( ( (n) >> 16 ) & 0xFF );    \ 
//   77     (b)[(i) + 3] = (unsigned char) ( ( (n) >> 24 ) & 0xFF );    \ 
//   78 }
//   79 #endif
//   80 
//   81 #if defined(MBEDTLS_PADLOCK_C) &&                      \ 
//   82     ( defined(MBEDTLS_HAVE_X86) || defined(MBEDTLS_PADLOCK_ALIGN16) )
//   83 static int aes_padlock_ace = -1;
//   84 #endif
//   85 
//   86 #if defined(MBEDTLS_AES_ROM_TABLES)
//   87 /*
//   88  * Forward S-box
//   89  */

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//   90 static const unsigned char FSb[256] =
FSb:
        DATA8
        DC8 99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215
        DC8 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175
        DC8 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165
        DC8 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18
        DC8 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82
        DC8 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91
        DC8 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51
        DC8 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157
        DC8 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95
        DC8 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220
        DC8 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58
        DC8 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200
        DC8 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8
        DC8 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189
        DC8 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134
        DC8 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135
        DC8 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65
        DC8 153, 45, 15, 176, 84, 187, 22
//   91 {
//   92     0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
//   93     0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
//   94     0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
//   95     0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
//   96     0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
//   97     0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
//   98     0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
//   99     0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
//  100     0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
//  101     0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
//  102     0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
//  103     0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
//  104     0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
//  105     0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
//  106     0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
//  107     0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
//  108     0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
//  109     0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
//  110     0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
//  111     0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
//  112     0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
//  113     0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
//  114     0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
//  115     0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
//  116     0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
//  117     0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
//  118     0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
//  119     0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
//  120     0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
//  121     0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
//  122     0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
//  123     0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
//  124 };
//  125 
//  126 /*
//  127  * Forward tables
//  128  */
//  129 #define FT \ 
//  130 \ 
//  131     V(A5,63,63,C6), V(84,7C,7C,F8), V(99,77,77,EE), V(8D,7B,7B,F6), \ 
//  132     V(0D,F2,F2,FF), V(BD,6B,6B,D6), V(B1,6F,6F,DE), V(54,C5,C5,91), \ 
//  133     V(50,30,30,60), V(03,01,01,02), V(A9,67,67,CE), V(7D,2B,2B,56), \ 
//  134     V(19,FE,FE,E7), V(62,D7,D7,B5), V(E6,AB,AB,4D), V(9A,76,76,EC), \ 
//  135     V(45,CA,CA,8F), V(9D,82,82,1F), V(40,C9,C9,89), V(87,7D,7D,FA), \ 
//  136     V(15,FA,FA,EF), V(EB,59,59,B2), V(C9,47,47,8E), V(0B,F0,F0,FB), \ 
//  137     V(EC,AD,AD,41), V(67,D4,D4,B3), V(FD,A2,A2,5F), V(EA,AF,AF,45), \ 
//  138     V(BF,9C,9C,23), V(F7,A4,A4,53), V(96,72,72,E4), V(5B,C0,C0,9B), \ 
//  139     V(C2,B7,B7,75), V(1C,FD,FD,E1), V(AE,93,93,3D), V(6A,26,26,4C), \ 
//  140     V(5A,36,36,6C), V(41,3F,3F,7E), V(02,F7,F7,F5), V(4F,CC,CC,83), \ 
//  141     V(5C,34,34,68), V(F4,A5,A5,51), V(34,E5,E5,D1), V(08,F1,F1,F9), \ 
//  142     V(93,71,71,E2), V(73,D8,D8,AB), V(53,31,31,62), V(3F,15,15,2A), \ 
//  143     V(0C,04,04,08), V(52,C7,C7,95), V(65,23,23,46), V(5E,C3,C3,9D), \ 
//  144     V(28,18,18,30), V(A1,96,96,37), V(0F,05,05,0A), V(B5,9A,9A,2F), \ 
//  145     V(09,07,07,0E), V(36,12,12,24), V(9B,80,80,1B), V(3D,E2,E2,DF), \ 
//  146     V(26,EB,EB,CD), V(69,27,27,4E), V(CD,B2,B2,7F), V(9F,75,75,EA), \ 
//  147     V(1B,09,09,12), V(9E,83,83,1D), V(74,2C,2C,58), V(2E,1A,1A,34), \ 
//  148     V(2D,1B,1B,36), V(B2,6E,6E,DC), V(EE,5A,5A,B4), V(FB,A0,A0,5B), \ 
//  149     V(F6,52,52,A4), V(4D,3B,3B,76), V(61,D6,D6,B7), V(CE,B3,B3,7D), \ 
//  150     V(7B,29,29,52), V(3E,E3,E3,DD), V(71,2F,2F,5E), V(97,84,84,13), \ 
//  151     V(F5,53,53,A6), V(68,D1,D1,B9), V(00,00,00,00), V(2C,ED,ED,C1), \ 
//  152     V(60,20,20,40), V(1F,FC,FC,E3), V(C8,B1,B1,79), V(ED,5B,5B,B6), \ 
//  153     V(BE,6A,6A,D4), V(46,CB,CB,8D), V(D9,BE,BE,67), V(4B,39,39,72), \ 
//  154     V(DE,4A,4A,94), V(D4,4C,4C,98), V(E8,58,58,B0), V(4A,CF,CF,85), \ 
//  155     V(6B,D0,D0,BB), V(2A,EF,EF,C5), V(E5,AA,AA,4F), V(16,FB,FB,ED), \ 
//  156     V(C5,43,43,86), V(D7,4D,4D,9A), V(55,33,33,66), V(94,85,85,11), \ 
//  157     V(CF,45,45,8A), V(10,F9,F9,E9), V(06,02,02,04), V(81,7F,7F,FE), \ 
//  158     V(F0,50,50,A0), V(44,3C,3C,78), V(BA,9F,9F,25), V(E3,A8,A8,4B), \ 
//  159     V(F3,51,51,A2), V(FE,A3,A3,5D), V(C0,40,40,80), V(8A,8F,8F,05), \ 
//  160     V(AD,92,92,3F), V(BC,9D,9D,21), V(48,38,38,70), V(04,F5,F5,F1), \ 
//  161     V(DF,BC,BC,63), V(C1,B6,B6,77), V(75,DA,DA,AF), V(63,21,21,42), \ 
//  162     V(30,10,10,20), V(1A,FF,FF,E5), V(0E,F3,F3,FD), V(6D,D2,D2,BF), \ 
//  163     V(4C,CD,CD,81), V(14,0C,0C,18), V(35,13,13,26), V(2F,EC,EC,C3), \ 
//  164     V(E1,5F,5F,BE), V(A2,97,97,35), V(CC,44,44,88), V(39,17,17,2E), \ 
//  165     V(57,C4,C4,93), V(F2,A7,A7,55), V(82,7E,7E,FC), V(47,3D,3D,7A), \ 
//  166     V(AC,64,64,C8), V(E7,5D,5D,BA), V(2B,19,19,32), V(95,73,73,E6), \ 
//  167     V(A0,60,60,C0), V(98,81,81,19), V(D1,4F,4F,9E), V(7F,DC,DC,A3), \ 
//  168     V(66,22,22,44), V(7E,2A,2A,54), V(AB,90,90,3B), V(83,88,88,0B), \ 
//  169     V(CA,46,46,8C), V(29,EE,EE,C7), V(D3,B8,B8,6B), V(3C,14,14,28), \ 
//  170     V(79,DE,DE,A7), V(E2,5E,5E,BC), V(1D,0B,0B,16), V(76,DB,DB,AD), \ 
//  171     V(3B,E0,E0,DB), V(56,32,32,64), V(4E,3A,3A,74), V(1E,0A,0A,14), \ 
//  172     V(DB,49,49,92), V(0A,06,06,0C), V(6C,24,24,48), V(E4,5C,5C,B8), \ 
//  173     V(5D,C2,C2,9F), V(6E,D3,D3,BD), V(EF,AC,AC,43), V(A6,62,62,C4), \ 
//  174     V(A8,91,91,39), V(A4,95,95,31), V(37,E4,E4,D3), V(8B,79,79,F2), \ 
//  175     V(32,E7,E7,D5), V(43,C8,C8,8B), V(59,37,37,6E), V(B7,6D,6D,DA), \ 
//  176     V(8C,8D,8D,01), V(64,D5,D5,B1), V(D2,4E,4E,9C), V(E0,A9,A9,49), \ 
//  177     V(B4,6C,6C,D8), V(FA,56,56,AC), V(07,F4,F4,F3), V(25,EA,EA,CF), \ 
//  178     V(AF,65,65,CA), V(8E,7A,7A,F4), V(E9,AE,AE,47), V(18,08,08,10), \ 
//  179     V(D5,BA,BA,6F), V(88,78,78,F0), V(6F,25,25,4A), V(72,2E,2E,5C), \ 
//  180     V(24,1C,1C,38), V(F1,A6,A6,57), V(C7,B4,B4,73), V(51,C6,C6,97), \ 
//  181     V(23,E8,E8,CB), V(7C,DD,DD,A1), V(9C,74,74,E8), V(21,1F,1F,3E), \ 
//  182     V(DD,4B,4B,96), V(DC,BD,BD,61), V(86,8B,8B,0D), V(85,8A,8A,0F), \ 
//  183     V(90,70,70,E0), V(42,3E,3E,7C), V(C4,B5,B5,71), V(AA,66,66,CC), \ 
//  184     V(D8,48,48,90), V(05,03,03,06), V(01,F6,F6,F7), V(12,0E,0E,1C), \ 
//  185     V(A3,61,61,C2), V(5F,35,35,6A), V(F9,57,57,AE), V(D0,B9,B9,69), \ 
//  186     V(91,86,86,17), V(58,C1,C1,99), V(27,1D,1D,3A), V(B9,9E,9E,27), \ 
//  187     V(38,E1,E1,D9), V(13,F8,F8,EB), V(B3,98,98,2B), V(33,11,11,22), \ 
//  188     V(BB,69,69,D2), V(70,D9,D9,A9), V(89,8E,8E,07), V(A7,94,94,33), \ 
//  189     V(B6,9B,9B,2D), V(22,1E,1E,3C), V(92,87,87,15), V(20,E9,E9,C9), \ 
//  190     V(49,CE,CE,87), V(FF,55,55,AA), V(78,28,28,50), V(7A,DF,DF,A5), \ 
//  191     V(8F,8C,8C,03), V(F8,A1,A1,59), V(80,89,89,09), V(17,0D,0D,1A), \ 
//  192     V(DA,BF,BF,65), V(31,E6,E6,D7), V(C6,42,42,84), V(B8,68,68,D0), \ 
//  193     V(C3,41,41,82), V(B0,99,99,29), V(77,2D,2D,5A), V(11,0F,0F,1E), \ 
//  194     V(CB,B0,B0,7B), V(FC,54,54,A8), V(D6,BB,BB,6D), V(3A,16,16,2C)
//  195 
//  196 #define V(a,b,c,d) 0x##a##b##c##d

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  197 static const uint32_t FT0[256] = { FT };
FT0:
        DATA32
        DC32 2774754246, 2222750968, 2574743534, 2373680118, 234025727
        DC32 3177933782, 2976870366, 1422247313, 1345335392, 50397442
        DC32 2842126286, 2099981142, 436141799, 1658312629, 3870010189
        DC32 2591454956, 1170918031, 2642575903, 1086966153, 2273148410
        DC32 368769775, 3948501426, 3376891790, 200339707, 3970805057
        DC32 1742001331, 4255294047, 3937382213, 3214711843, 4154762323
        DC32 2524082916, 1539358875, 3266819957, 486407649, 2928907069
        DC32 1780885068, 1513502316, 1094664062, 49805301, 1338821763
        DC32 1546925160, 4104496465, 887481809, 150073849, 2473685474
        DC32 1943591083, 1395732834, 1058346282, 201589768, 1388824469
        DC32 1696801606, 1589887901, 672667696, 2711000631, 251987210
        DC32 3046808111, 151455502, 907153956, 2608889883, 1038279391
        DC32 652995533, 1764173646, 3451040383, 2675275242, 453576978
        DC32 2659418909, 1949051992, 773462580, 756751158, 2993581788
        DC32 3998898868, 4221608027, 4132590244, 1295727478, 1641469623
        DC32 3467883389, 2066295122, 1055122397, 1898917726, 2542044179
        DC32 4115878822, 1758581177, 0, 753790401, 1612718144, 536673507
        DC32 3367088505, 3982187446, 3194645204, 1187761037, 3653156455
        DC32 1262041458, 3729410708, 3561770136, 3898103984, 1255133061
        DC32 1808847035, 720367557, 3853167183, 385612781, 3309519750
        DC32 3612167578, 1429418854, 2491778321, 3477423498, 284817897
        DC32 100794884, 2172616702, 4031795360, 1144798328, 3131023141
        DC32 3819481163, 4082192802, 4272137053, 3225436288, 2324664069
        DC32 2912064063, 3164445985, 1211644016, 83228145, 3753688163
        DC32 3249976951, 1977277103, 1663115586, 806359072, 452984805
        DC32 250868733, 1842533055, 1288555905, 336333848, 890442534, 804056259
        DC32 3781124030, 2727843637, 3427026056, 957814574, 1472513171
        DC32 4071073621, 2189328124, 1195195770, 2892260552, 3881655738
        DC32 723065138, 2507371494, 2690670784, 2558624025, 3511635870
        DC32 2145180835, 1713513028, 2116692564, 2878378043, 2206763019
        DC32 3393603212, 703524551, 3552098411, 1007948840, 2044649127
        DC32 3797835452, 487262998, 1994120109, 1004593371, 1446130276
        DC32 1312438900, 503974420, 3679013266, 168166924, 1814307912
        DC32 3831258296, 1573044895, 1859376061, 4021070915, 2791465668
        DC32 2828112185, 2761266481, 937747667, 2339994098, 854058965
        DC32 1137232011, 1496790894, 3077402074, 2358086913, 1691735473
        DC32 3528347292, 3769215305, 3027004632, 4199962284, 133494003
        DC32 636152527, 2942657994, 2390391540, 3920539207, 403179536
        DC32 3585784431, 2289596656, 1864705354, 1915629148, 605822008
        DC32 4054230615, 3350508659, 1371981463, 602466507, 2094914977
        DC32 2624877800, 555687742, 3712699286, 3703422305, 2257292045
        DC32 2240449039, 2423288032, 1111375484, 3300242801, 2858837708
        DC32 3628615824, 84083462, 32962295, 302911004, 2741068226, 1597322602
        DC32 4183250862, 3501832553, 2441512471, 1489093017, 656219450
        DC32 3114180135, 954327513, 335083755, 3013122091, 856756514
        DC32 3144247762, 1893325225, 2307821063, 2811532339, 3063651117
        DC32 572399164, 2458355477, 552200649, 1238290055, 4283782570
        DC32 2015897680, 2061492133, 2408352771, 4171342169, 2156497161
        DC32 386731290, 3669999461, 837215959, 3326231172, 3093850320
        DC32 3275833730, 2962856233, 1999449434, 286199582, 3417354363
        DC32 4233385128, 3602627437, 974525996
//  198 #undef V
//  199 
//  200 #if !defined(MBEDTLS_AES_FEWER_TABLES)
//  201 
//  202 #define V(a,b,c,d) 0x##b##c##d##a

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  203 static const uint32_t FT1[256] = { FT };
FT1:
        DATA32
        DC32 1667483301, 2088564868, 2004348569, 2071721613, 4076011277
        DC32 1802229437, 1869602481, 3318059348, 808476752, 16843267
        DC32 1734856361, 724260477, 4278118169, 3621238114, 2880130534
        DC32 1987505306, 3402272581, 2189565853, 3385428288, 2105408135
        DC32 4210749205, 1499050731, 1195871945, 4042324747, 2913812972
        DC32 3570709351, 2728550397, 2947499498, 2627478463, 2762232823
        DC32 1920132246, 3233848155, 3082253762, 4261273884, 2475900334
        DC32 640044138, 909536346, 1061125697, 4160222466, 3435955023
        DC32 875849820, 2779075060, 3857043764, 4059166984, 1903288979
        DC32 3638078323, 825320019, 353708607, 67373068, 3351745874, 589514341
        DC32 3284376926, 404238376, 2526427041, 84216335, 2593796021, 117902857
        DC32 303178806, 2155879323, 3806519101, 3958099238, 656887401
        DC32 2998042573, 1970662047, 151589403, 2206408094, 741103732
        DC32 437924910, 454768173, 1852759218, 1515893998, 2694863867
        DC32 1381147894, 993752653, 3604395873, 3014884814, 690573947
        DC32 3823361342, 791633521, 2223248279, 1397991157, 3520182632, 0
        DC32 3991781676, 538984544, 4244431647, 2981198280, 1532737261
        DC32 1785386174, 3419114822, 3200149465, 960066123, 1246401758
        DC32 1280088276, 1482207464, 3486483786, 3503340395, 4025468202
        DC32 2863288293, 4227591446, 1128498885, 1296931543, 859006549
        DC32 2240090516, 1162185423, 4193904912, 33686534, 2139094657
        DC32 1347461360, 1010595908, 2678007226, 2829601763, 1364304627
        DC32 2745392638, 1077969088, 2408514954, 2459058093, 2644320700
        DC32 943222856, 4126535940, 3166462943, 3065411521, 3671764853
        DC32 555827811, 269492272, 4294960410, 4092853518, 3537026925
        DC32 3452797260, 202119188, 320022069, 3974939439, 1600110305
        DC32 2543269282, 1145342156, 387395129, 3301217111, 2812761586
        DC32 2122251394, 1027439175, 1684326572, 1566423783, 421081643
        DC32 1936975509, 1616953504, 2172721560, 1330618065, 3705447295
        DC32 572671078, 707417214, 2425371563, 2290617219, 1179028682
        DC32 4008625961, 3099093971, 336865340, 3739133817, 1583267042
        DC32 185275933, 3688607094, 3772832571, 842163286, 976909390, 168432670
        DC32 1229558491, 101059594, 606357612, 1549580516, 3267534685
        DC32 3553869166, 2896970735, 1650640038, 2442213800, 2509582756
        DC32 3840201527, 2038035083, 3890730290, 3368586051, 926379609
        DC32 1835915959, 2374828428, 3587551588, 1313774802, 2846444000
        DC32 1819072692, 1448520954, 4109693703, 3941256997, 1701169839
        DC32 2054878350, 2930657257, 134746136, 3132780501, 2021191816
        DC32 623200879, 774790258, 471611428, 2795919345, 3031724999
        DC32 3334903633, 3907570467, 3722289532, 1953818780, 522141217
        DC32 1263245021, 3183305180, 2341145990, 2324303749, 1886445712
        DC32 1044282434, 3048567236, 1718013098, 1212715224, 50529797
        DC32 4143380225, 235805714, 1633796771, 892693087, 1465364217
        DC32 3115936208, 2256934801, 3250690392, 488454695, 2661164985
        DC32 3789674808, 4177062675, 2560109491, 286335539, 1768542907
        DC32 3654920560, 2391672713, 2492740519, 2610638262, 505297954
        DC32 2273777042, 3924412704, 3469641545, 1431677695, 673730680
        DC32 3755976058, 2357986191, 2711706104, 2307459456, 218962455
        DC32 3216991706, 3873888049, 1111655622, 1751699640, 1094812355
        DC32 2576951728, 757946999, 252648977, 2964356043, 1414834428
        DC32 3149622742, 370551866
//  204 #undef V
//  205 
//  206 #define V(a,b,c,d) 0x##c##d##a##b

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  207 static const uint32_t FT2[256] = { FT };
FT2:
        DATA32
        DC32 1673962851, 2096661628, 2012125559, 2079755643, 4076801522
        DC32 1809235307, 1876865391, 3314635973, 811618352, 16909057
        DC32 1741597031, 727088427, 4276558334, 3618988759, 2874009259
        DC32 1995217526, 3398387146, 2183110018, 3381215433, 2113570685
        DC32 4209972730, 1504897881, 1200539975, 4042984432, 2906778797
        DC32 3568527316, 2724199842, 2940594863, 2619588508, 2756966308
        DC32 1927583346, 3231407040, 3077948087, 4259388669, 2470293139
        DC32 642542118, 913070646, 1065238847, 4160029431, 3431157708
        DC32 879254580, 2773611685, 3855693029, 4059629809, 1910674289
        DC32 3635114968, 828527409, 355090197, 67636228, 3348452039, 591815971
        DC32 3281870531, 405809176, 2520228246, 84545285, 2586817946, 118360327
        DC32 304363026, 2149292928, 3806281186, 3956090603, 659450151
        DC32 2994720178, 1978310517, 152181513, 2199756419, 743994412
        DC32 439627290, 456535323, 1859957358, 1521806938, 2690382752
        DC32 1386542674, 997608763, 3602342358, 3011366579, 693271337
        DC32 3822927587, 794718511, 2215876484, 1403450707, 3518589137, 0
        DC32 3988860141, 541089824, 4242743292, 2977548465, 1538714971
        DC32 1792327274, 3415033547, 3194476990, 963791673, 1251270218
        DC32 1285084236, 1487988824, 3481619151, 3501943760, 4022676207
        DC32 2857362858, 4226619131, 1132905795, 1301993293, 862344499
        DC32 2232521861, 1166724933, 4192801017, 33818114, 2147385727
        DC32 1352724560, 1014514748, 2670049951, 2823545768, 1369633617
        DC32 2740846243, 1082179648, 2399505039, 2453646738, 2636233885
        DC32 946882616, 4126213365, 3160661948, 3061301686, 3668932058
        DC32 557998881, 270544912, 4293204735, 4093447923, 3535760850
        DC32 3447803085, 202904588, 321271059, 3972214764, 1606345055
        DC32 2536874647, 1149815876, 388905239, 3297990596, 2807427751
        DC32 2130477694, 1031423805, 1690872932, 1572530013, 422718233
        DC32 1944491379, 1623236704, 2165938305, 1335808335, 3701702620
        DC32 574907938, 710180394, 2419829648, 2282455944, 1183631942
        DC32 4006029806, 3094074296, 338181140, 3735517662, 1589437022
        DC32 185998603, 3685578459, 3772464096, 845436466, 980700730, 169090570
        DC32 1234361161, 101452294, 608726052, 1555620956, 3265224130
        DC32 3552407251, 2890133420, 1657054818, 2436475025, 2503058581
        DC32 3839047652, 2045938553, 3889509095, 3364570056, 929978679
        DC32 1843050349, 2365688973, 3585172693, 1318900302, 2840191145
        DC32 1826141292, 1454176854, 4109567988, 3939444202, 1707781989
        DC32 2062847610, 2923948462, 135272456, 3127891386, 2029029496
        DC32 625635109, 777810478, 473441308, 2790781350, 3027486644
        DC32 3331805638, 3905627112, 3718347997, 1961401460, 524165407
        DC32 1268178251, 3177307325, 2332919435, 2316273034, 1893765232
        DC32 1048330814, 3044132021, 1724688998, 1217452104, 50726147
        DC32 4143383030, 236720654, 1640145761, 896163637, 1471084887
        DC32 3110719673, 2249691526, 3248052417, 490350365, 2653403550
        DC32 3789109473, 4176155640, 2553000856, 287453969, 1775418217
        DC32 3651760345, 2382858638, 2486413204, 2603464347, 507257374
        DC32 2266337927, 3922272489, 3464972750, 1437269845, 676362280
        DC32 3752164063, 2349043596, 2707028129, 2299101321, 219813645
        DC32 3211123391, 3872862694, 1115997762, 1758509160, 1099088705
        DC32 2569646233, 760903469, 253628687, 2960903088, 1420360788
        DC32 3144537787, 371997206
//  208 #undef V
//  209 
//  210 #define V(a,b,c,d) 0x##d##a##b##c

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  211 static const uint32_t FT3[256] = { FT };
FT3:
        DATA32
        DC32 3332727651, 4169432188, 4003034999, 4136467323, 4279104242
        DC32 3602738027, 3736170351, 2438251973, 1615867952, 33751297
        DC32 3467208551, 1451043627, 3877240574, 3043153879, 1306962859
        DC32 3969545846, 2403715786, 530416258, 2302724553, 4203183485
        DC32 4011195130, 3001768281, 2395555655, 4211863792, 1106029997
        DC32 3009926356, 1610457762, 1173008303, 599760028, 1408738468
        DC32 3835064946, 2606481600, 1975695287, 3776773629, 1034851219
        DC32 1282024998, 1817851446, 2118205247, 4110612471, 2203045068
        DC32 1750873140, 1374987685, 3509904869, 4178113009, 3801313649
        DC32 2876496088, 1649619249, 708777237, 135005188, 2505230279
        DC32 1181033251, 2640233411, 807933976, 933336726, 168756485, 800430746
        DC32 235472647, 607523346, 463175808, 3745374946, 3441880043
        DC32 1315514151, 2144187058, 3936318837, 303761673, 496927619
        DC32 1484008492, 875436570, 908925723, 3702681198, 3035519578
        DC32 1543217312, 2767606354, 1984772923, 3076642518, 2110698419
        DC32 1383803177, 3711886307, 1584475951, 328696964, 2801095507
        DC32 3110654417, 0, 3240947181, 1080041504, 3810524412, 2043195825
        DC32 3069008731, 3569248874, 2370227147, 1742323390, 1917532473
        DC32 2497595978, 2564049996, 2968016984, 2236272591, 3144405200
        DC32 3307925487, 1340451498, 3977706491, 2261074755, 2597801293
        DC32 1716859699, 294946181, 2328839493, 3910203897, 67502594
        DC32 4269899647, 2700103760, 2017737788, 632987551, 1273211048
        DC32 2733855057, 1576969123, 2160083008, 92966799, 1068339858
        DC32 566009245, 1883781176, 4043634165, 1675607228, 2009183926
        DC32 2943736538, 1113792801, 540020752, 3843751935, 4245615603
        DC32 3211645650, 2169294285, 403966988, 641012499, 3274697964
        DC32 3202441055, 899848087, 2295088196, 775493399, 2472002756
        DC32 1441965991, 4236410494, 2051489085, 3366741092, 3135724893
        DC32 841685273, 3868554099, 3231735904, 429425025, 2664517455
        DC32 2743065820, 1147544098, 1417554474, 1001099408, 193169544
        DC32 2362066502, 3341414126, 1809037496, 675025940, 2809781982
        DC32 3168951902, 371002123, 2910247899, 3678134496, 1683370546
        DC32 1951283770, 337512970, 2463844681, 201983494, 1215046692
        DC32 3101973596, 2673722050, 3178157011, 1139780780, 3299238498
        DC32 967348625, 832869781, 3543655652, 4069226873, 3576883175
        DC32 2336475336, 1851340599, 3669454189, 25988493, 2976175573
        DC32 2631028302, 1239460265, 3635702892, 2902087254, 4077384948
        DC32 3475368682, 3400492389, 4102978170, 1206496942, 270010376
        DC32 1876277946, 4035475576, 1248797989, 1550986798, 941890588
        DC32 1475454630, 1942467764, 2538718918, 3408128232, 2709315037
        DC32 3902567540, 1042358047, 2531085131, 1641856445, 226921355
        DC32 260409994, 3767562352, 2084716094, 1908716981, 3433719398
        DC32 2430093384, 100991747, 4144101110, 470945294, 3265487201
        DC32 1784624437, 2935576407, 1775286713, 395413126, 2572730817
        DC32 975641885, 666476190, 3644383713, 3943954680, 733190296, 573772049
        DC32 3535497577, 2842745305, 126455438, 866620564, 766942107
        DC32 1008868894, 361924487, 3374377449, 2269761230, 2868860245
        DC32 1350051880, 2776293343, 59739276, 1509466529, 159418761, 437718285
        DC32 1708834751, 3610371814, 2227585602, 3501746280, 2193834305
        DC32 699439513, 1517759789, 504434447, 2076946608, 2835108948
        DC32 1842789307, 742004246
//  212 #undef V
//  213 
//  214 #endif /* !MBEDTLS_AES_FEWER_TABLES */
//  215 
//  216 #undef FT
//  217 
//  218 /*
//  219  * Reverse S-box
//  220  */

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  221 static const unsigned char RSb[256] =
`RSb`:
        DATA8
        DC8 82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215
        DC8 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196
        DC8 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11
        DC8 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162
        DC8 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212
        DC8 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185
        DC8 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188
        DC8 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202
        DC8 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79
        DC8 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172
        DC8 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110
        DC8 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190
        DC8 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120
        DC8 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89
        DC8 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122
        DC8 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200
        DC8 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38
        DC8 225, 105, 20, 99, 85, 33, 12, 125
//  222 {
//  223     0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
//  224     0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
//  225     0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
//  226     0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
//  227     0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
//  228     0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
//  229     0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
//  230     0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
//  231     0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
//  232     0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
//  233     0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
//  234     0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
//  235     0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
//  236     0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
//  237     0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
//  238     0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
//  239     0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
//  240     0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
//  241     0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
//  242     0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
//  243     0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
//  244     0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
//  245     0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
//  246     0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
//  247     0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
//  248     0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
//  249     0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
//  250     0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
//  251     0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
//  252     0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
//  253     0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
//  254     0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
//  255 };
//  256 
//  257 /*
//  258  * Reverse tables
//  259  */
//  260 #define RT \ 
//  261 \ 
//  262     V(50,A7,F4,51), V(53,65,41,7E), V(C3,A4,17,1A), V(96,5E,27,3A), \ 
//  263     V(CB,6B,AB,3B), V(F1,45,9D,1F), V(AB,58,FA,AC), V(93,03,E3,4B), \ 
//  264     V(55,FA,30,20), V(F6,6D,76,AD), V(91,76,CC,88), V(25,4C,02,F5), \ 
//  265     V(FC,D7,E5,4F), V(D7,CB,2A,C5), V(80,44,35,26), V(8F,A3,62,B5), \ 
//  266     V(49,5A,B1,DE), V(67,1B,BA,25), V(98,0E,EA,45), V(E1,C0,FE,5D), \ 
//  267     V(02,75,2F,C3), V(12,F0,4C,81), V(A3,97,46,8D), V(C6,F9,D3,6B), \ 
//  268     V(E7,5F,8F,03), V(95,9C,92,15), V(EB,7A,6D,BF), V(DA,59,52,95), \ 
//  269     V(2D,83,BE,D4), V(D3,21,74,58), V(29,69,E0,49), V(44,C8,C9,8E), \ 
//  270     V(6A,89,C2,75), V(78,79,8E,F4), V(6B,3E,58,99), V(DD,71,B9,27), \ 
//  271     V(B6,4F,E1,BE), V(17,AD,88,F0), V(66,AC,20,C9), V(B4,3A,CE,7D), \ 
//  272     V(18,4A,DF,63), V(82,31,1A,E5), V(60,33,51,97), V(45,7F,53,62), \ 
//  273     V(E0,77,64,B1), V(84,AE,6B,BB), V(1C,A0,81,FE), V(94,2B,08,F9), \ 
//  274     V(58,68,48,70), V(19,FD,45,8F), V(87,6C,DE,94), V(B7,F8,7B,52), \ 
//  275     V(23,D3,73,AB), V(E2,02,4B,72), V(57,8F,1F,E3), V(2A,AB,55,66), \ 
//  276     V(07,28,EB,B2), V(03,C2,B5,2F), V(9A,7B,C5,86), V(A5,08,37,D3), \ 
//  277     V(F2,87,28,30), V(B2,A5,BF,23), V(BA,6A,03,02), V(5C,82,16,ED), \ 
//  278     V(2B,1C,CF,8A), V(92,B4,79,A7), V(F0,F2,07,F3), V(A1,E2,69,4E), \ 
//  279     V(CD,F4,DA,65), V(D5,BE,05,06), V(1F,62,34,D1), V(8A,FE,A6,C4), \ 
//  280     V(9D,53,2E,34), V(A0,55,F3,A2), V(32,E1,8A,05), V(75,EB,F6,A4), \ 
//  281     V(39,EC,83,0B), V(AA,EF,60,40), V(06,9F,71,5E), V(51,10,6E,BD), \ 
//  282     V(F9,8A,21,3E), V(3D,06,DD,96), V(AE,05,3E,DD), V(46,BD,E6,4D), \ 
//  283     V(B5,8D,54,91), V(05,5D,C4,71), V(6F,D4,06,04), V(FF,15,50,60), \ 
//  284     V(24,FB,98,19), V(97,E9,BD,D6), V(CC,43,40,89), V(77,9E,D9,67), \ 
//  285     V(BD,42,E8,B0), V(88,8B,89,07), V(38,5B,19,E7), V(DB,EE,C8,79), \ 
//  286     V(47,0A,7C,A1), V(E9,0F,42,7C), V(C9,1E,84,F8), V(00,00,00,00), \ 
//  287     V(83,86,80,09), V(48,ED,2B,32), V(AC,70,11,1E), V(4E,72,5A,6C), \ 
//  288     V(FB,FF,0E,FD), V(56,38,85,0F), V(1E,D5,AE,3D), V(27,39,2D,36), \ 
//  289     V(64,D9,0F,0A), V(21,A6,5C,68), V(D1,54,5B,9B), V(3A,2E,36,24), \ 
//  290     V(B1,67,0A,0C), V(0F,E7,57,93), V(D2,96,EE,B4), V(9E,91,9B,1B), \ 
//  291     V(4F,C5,C0,80), V(A2,20,DC,61), V(69,4B,77,5A), V(16,1A,12,1C), \ 
//  292     V(0A,BA,93,E2), V(E5,2A,A0,C0), V(43,E0,22,3C), V(1D,17,1B,12), \ 
//  293     V(0B,0D,09,0E), V(AD,C7,8B,F2), V(B9,A8,B6,2D), V(C8,A9,1E,14), \ 
//  294     V(85,19,F1,57), V(4C,07,75,AF), V(BB,DD,99,EE), V(FD,60,7F,A3), \ 
//  295     V(9F,26,01,F7), V(BC,F5,72,5C), V(C5,3B,66,44), V(34,7E,FB,5B), \ 
//  296     V(76,29,43,8B), V(DC,C6,23,CB), V(68,FC,ED,B6), V(63,F1,E4,B8), \ 
//  297     V(CA,DC,31,D7), V(10,85,63,42), V(40,22,97,13), V(20,11,C6,84), \ 
//  298     V(7D,24,4A,85), V(F8,3D,BB,D2), V(11,32,F9,AE), V(6D,A1,29,C7), \ 
//  299     V(4B,2F,9E,1D), V(F3,30,B2,DC), V(EC,52,86,0D), V(D0,E3,C1,77), \ 
//  300     V(6C,16,B3,2B), V(99,B9,70,A9), V(FA,48,94,11), V(22,64,E9,47), \ 
//  301     V(C4,8C,FC,A8), V(1A,3F,F0,A0), V(D8,2C,7D,56), V(EF,90,33,22), \ 
//  302     V(C7,4E,49,87), V(C1,D1,38,D9), V(FE,A2,CA,8C), V(36,0B,D4,98), \ 
//  303     V(CF,81,F5,A6), V(28,DE,7A,A5), V(26,8E,B7,DA), V(A4,BF,AD,3F), \ 
//  304     V(E4,9D,3A,2C), V(0D,92,78,50), V(9B,CC,5F,6A), V(62,46,7E,54), \ 
//  305     V(C2,13,8D,F6), V(E8,B8,D8,90), V(5E,F7,39,2E), V(F5,AF,C3,82), \ 
//  306     V(BE,80,5D,9F), V(7C,93,D0,69), V(A9,2D,D5,6F), V(B3,12,25,CF), \ 
//  307     V(3B,99,AC,C8), V(A7,7D,18,10), V(6E,63,9C,E8), V(7B,BB,3B,DB), \ 
//  308     V(09,78,26,CD), V(F4,18,59,6E), V(01,B7,9A,EC), V(A8,9A,4F,83), \ 
//  309     V(65,6E,95,E6), V(7E,E6,FF,AA), V(08,CF,BC,21), V(E6,E8,15,EF), \ 
//  310     V(D9,9B,E7,BA), V(CE,36,6F,4A), V(D4,09,9F,EA), V(D6,7C,B0,29), \ 
//  311     V(AF,B2,A4,31), V(31,23,3F,2A), V(30,94,A5,C6), V(C0,66,A2,35), \ 
//  312     V(37,BC,4E,74), V(A6,CA,82,FC), V(B0,D0,90,E0), V(15,D8,A7,33), \ 
//  313     V(4A,98,04,F1), V(F7,DA,EC,41), V(0E,50,CD,7F), V(2F,F6,91,17), \ 
//  314     V(8D,D6,4D,76), V(4D,B0,EF,43), V(54,4D,AA,CC), V(DF,04,96,E4), \ 
//  315     V(E3,B5,D1,9E), V(1B,88,6A,4C), V(B8,1F,2C,C1), V(7F,51,65,46), \ 
//  316     V(04,EA,5E,9D), V(5D,35,8C,01), V(73,74,87,FA), V(2E,41,0B,FB), \ 
//  317     V(5A,1D,67,B3), V(52,D2,DB,92), V(33,56,10,E9), V(13,47,D6,6D), \ 
//  318     V(8C,61,D7,9A), V(7A,0C,A1,37), V(8E,14,F8,59), V(89,3C,13,EB), \ 
//  319     V(EE,27,A9,CE), V(35,C9,61,B7), V(ED,E5,1C,E1), V(3C,B1,47,7A), \ 
//  320     V(59,DF,D2,9C), V(3F,73,F2,55), V(79,CE,14,18), V(BF,37,C7,73), \ 
//  321     V(EA,CD,F7,53), V(5B,AA,FD,5F), V(14,6F,3D,DF), V(86,DB,44,78), \ 
//  322     V(81,F3,AF,CA), V(3E,C4,68,B9), V(2C,34,24,38), V(5F,40,A3,C2), \ 
//  323     V(72,C3,1D,16), V(0C,25,E2,BC), V(8B,49,3C,28), V(41,95,0D,FF), \ 
//  324     V(71,01,A8,39), V(DE,B3,0C,08), V(9C,E4,B4,D8), V(90,C1,56,64), \ 
//  325     V(61,84,CB,7B), V(70,B6,32,D5), V(74,5C,6C,48), V(42,57,B8,D0)
//  326 
//  327 #define V(a,b,c,d) 0x##a##b##c##d

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  328 static const uint32_t RT0[256] = { RT };
RT0:
        DATA32
        DC32 1353184337, 1399144830, 3282310938, 2522752826, 3412831035
        DC32 4047871263, 2874735276, 2466505547, 1442459680, 4134368941
        DC32 2440481928, 625738485, 4242007375, 3620416197, 2151953702
        DC32 2409849525, 1230680542, 1729870373, 2551114309, 3787521629
        DC32 41234371, 317738113, 2744600205, 3338261355, 3881799427
        DC32 2510066197, 3950669247, 3663286933, 763608788, 3542185048
        DC32 694804553, 1154009486, 1787413109, 2021232372, 1799248025
        DC32 3715217703, 3058688446, 397248752, 1722556617, 3023752829
        DC32 407560035, 2184256229, 1613975959, 1165972322, 3765920945
        DC32 2226023355, 480281086, 2485848313, 1483229296, 436028815
        DC32 2272059028, 3086515026, 601060267, 3791801202, 1468997603
        DC32 715871590, 120122290, 63092015, 2591802758, 2768779219, 4068943920
        DC32 2997206819, 3127509762, 1552029421, 723308426, 2461301159
        DC32 4042393587, 2715969870, 3455375973, 3586000134, 526529745
        DC32 2331944644, 2639474228, 2689987490, 853641733, 1978398372
        DC32 971801355, 2867814464, 111112542, 1360031421, 4186579262
        DC32 1023860118, 2919579357, 1186850381, 3045938321, 90031217
        DC32 1876166148, 4279586912, 620468249, 2548678102, 3426959497
        DC32 2006899047, 3175278768, 2290845959, 945494503, 3689859193
        DC32 1191869601, 3910091388, 3374220536, 0, 2206629897, 1223502642
        DC32 2893025566, 1316117100, 4227796733, 1446544655, 517320253
        DC32 658058550, 1691946762, 564550760, 3511966619, 976107044
        DC32 2976320012, 266819475, 3533106868, 2660342555, 1338359936
        DC32 2720062561, 1766553434, 370807324, 179999714, 3844776128
        DC32 1138762300, 488053522, 185403662, 2915535858, 3114841645
        DC32 3366526484, 2233069911, 1275557295, 3151862254, 4250959779
        DC32 2670068215, 3170202204, 3309004356, 880737115, 1982415755
        DC32 3703972811, 1761406390, 1676797112, 3403428311, 277177154
        DC32 1076008723, 538035844, 2099530373, 4164795346, 288553390
        DC32 1839278535, 1261411869, 4080055004, 3964831245, 3504587127
        DC32 1813426987, 2579067049, 4199060497, 577038663, 3297574056
        DC32 440397984, 3626794326, 4019204898, 3343796615, 3251714265
        DC32 4272081548, 906744984, 3481400742, 685669029, 646887386
        DC32 2764025151, 3835509292, 227702864, 2613862250, 1648787028
        DC32 3256061430, 3904428176, 1593260334, 4121936770, 3196083615
        DC32 2090061929, 2838353263, 3004310991, 999926984, 2809993232
        DC32 1852021992, 2075868123, 158869197, 4095236462, 28809964
        DC32 2828685187, 1701746150, 2129067946, 147831841, 3873969647
        DC32 3650873274, 3459673930, 3557400554, 3598495785, 2947720241
        DC32 824393514, 815048134, 3227951669, 935087732, 2798289660
        DC32 2966458592, 366520115, 1251476721, 4158319681, 240176511
        DC32 804688151, 2379631990, 1303441219, 1414376140, 3741619940
        DC32 3820343710, 461924940, 3089050817, 2136040774, 82468509
        DC32 1563790337, 1937016826, 776014843, 1511876531, 1389550482
        DC32 861278441, 323475053, 2355222426, 2047648055, 2383738969
        DC32 2302415851, 3995576782, 902390199, 3991215329, 1018251130
        DC32 1507840668, 1064563285, 2043548696, 3208103795, 3939366739
        DC32 1537932639, 342834655, 2262516856, 2180231114, 1053059257
        DC32 741614648, 1598071746, 1925389590, 203809468, 2336832552
        DC32 1100287487, 1895934009, 3736275976, 2632234200, 2428589668
        DC32 1636092795, 1890988757, 1952214088, 1113045200
//  329 #undef V
//  330 
//  331 #if !defined(MBEDTLS_AES_FEWER_TABLES)
//  332 
//  333 #define V(a,b,c,d) 0x##b##c##d##a

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  334 static const uint32_t RT1[256] = { RT };
RT1:
        DATA32
        DC32 2817806672, 1698790995, 2752977603, 1579629206, 1806384075
        DC32 1167925233, 1492823211, 65227667, 4197458005, 1836494326
        DC32 1993115793, 1275262245, 3622129660, 3408578007, 1144333952
        DC32 2741155215, 1521606217, 465184103, 250234264, 3237895649
        DC32 1966064386, 4031545618, 2537983395, 4191382470, 1603208167
        DC32 2626819477, 2054012907, 1498584538, 2210321453, 561273043
        DC32 1776306473, 3368652356, 2311222634, 2039411832, 1045993835
        DC32 1907959773, 1340194486, 2911432727, 2887829862, 986611124
        DC32 1256153880, 823846274, 860985184, 2136171077, 2003087840
        DC32 2926295940, 2692873756, 722008468, 1749577816, 4249194265
        DC32 1826526343, 4168831671, 3547573027, 38499042, 2401231703
        DC32 2874500650, 686535175, 3266653955, 2076542618, 137876389
        DC32 2267558130, 2780767154, 1778582202, 2182540636, 483363371
        DC32 3027871634, 4060607472, 3798552225, 4107953613, 3188000469
        DC32 1647628575, 4272342154, 1395537053, 1442030240, 3783918898
        DC32 3958809717, 3968011065, 4016062634, 2675006982, 275692881
        DC32 2317434617, 115185213, 88006062, 3185986886, 2371129781
        DC32 1573155077, 3557164143, 357589247, 4221049124, 3921532567
        DC32 1128303052, 2665047927, 1122545853, 2341013384, 1528424248
        DC32 4006115803, 175939911, 256015593, 512030921, 0, 2256537987
        DC32 3979031112, 1880170156, 1918528590, 4279172603, 948244310
        DC32 3584965918, 959264295, 3641641572, 2791073825, 1415289809
        DC32 775300154, 1728711857, 3881276175, 2532226258, 2442861470
        DC32 3317727311, 551313826, 1266113129, 437394454, 3130253834
        DC32 715178213, 3760340035, 387650077, 218697227, 3347837613
        DC32 2830511545, 2837320904, 435246981, 125153100, 3717852859
        DC32 1618977789, 637663135, 4117912764, 996558021, 2130402100
        DC32 692292470, 3324234716, 4243437160, 4058298467, 3694254026
        DC32 2237874704, 580326208, 298222624, 608863613, 1035719416, 855223825
        DC32 2703869805, 798891339, 817028339, 1384517100, 3821107152
        DC32 380840812, 3111168409, 1217663482, 1693009698, 2365368516
        DC32 1072734234, 746411736, 2419270383, 1313441735, 3510163905
        DC32 2731183358, 198481974, 2180359887, 3732579624, 2394413606
        DC32 3215802276, 2637835492, 2457358349, 3428805275, 1182684258
        DC32 328070850, 3101200616, 4147719774, 2948825845, 2153619390
        DC32 2479909244, 768962473, 304467891, 2578237499, 2098729127
        DC32 1671227502, 3141262203, 2015808777, 408514292, 3080383489
        DC32 2588902312, 1855317605, 3875515006, 3485212936, 3893751782
        DC32 2615655129, 913263310, 161475284, 2091919830, 2997105071
        DC32 591342129, 2493892144, 1721906624, 3159258167, 3397581990
        DC32 3499155632, 3634836245, 2550460746, 3672916471, 1355644686
        DC32 4136703791, 3595400845, 2968470349, 1303039060, 76997855
        DC32 3050413795, 2288667675, 523026872, 1365591679, 3932069124
        DC32 898367837, 1955068531, 1091304238, 493335386, 3537605202
        DC32 1443948851, 1205234963, 1641519756, 211892090, 351820174
        DC32 1007938441, 665439982, 3378624309, 3843875309, 2974251580
        DC32 3755121753, 1945261375, 3457423481, 935818175, 3455538154
        DC32 2868731739, 1866325780, 3678697606, 4088384129, 3295197502
        DC32 874788908, 1084473951, 3273463410, 635616268, 1228679307
        DC32 2500722497, 27801969, 3003910366, 3837057180, 3243664528
        DC32 2227927905, 3056784752, 1550600308, 1471729730
//  335 #undef V
//  336 
//  337 #define V(a,b,c,d) 0x##c##d##a##b

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  338 static const uint32_t RT2[256] = { RT };
RT2:
        DATA32
        DC32 4098969767, 1098797925, 387629988, 658151006, 2872822635
        DC32 2636116293, 4205620056, 3813380867, 807425530, 1991112301
        DC32 3431502198, 49620300, 3847224535, 717608907, 891715652, 1656065955
        DC32 2984135002, 3123013403, 3930429454, 4267565504, 801309301
        DC32 1283527408, 1183687575, 3547055865, 2399397727, 2450888092
        DC32 1841294202, 1385552473, 3201576323, 1951978273, 3762891113
        DC32 3381544136, 3262474889, 2398386297, 1486449470, 3106397553
        DC32 3787372111, 2297436077, 550069932, 3464344634, 3747813450
        DC32 451248689, 1368875059, 1398949247, 1689378935, 1807451310
        DC32 2180914336, 150574123, 1215322216, 1167006205, 3734275948
        DC32 2069018616, 1940595667, 1265820162, 534992783, 1432758955
        DC32 3954313000, 3039757250, 3313932923, 936617224, 674296455
        DC32 3206787749, 50510442, 384654466, 3481938716, 2041025204, 133427442
        DC32 1766760930, 3664104948, 84334014, 886120290, 2797898494, 775200083
        DC32 4087521365, 2315596513, 4137973227, 2198551020, 1614850799
        DC32 1901987487, 1857900816, 557775242, 3717610758, 1054715397
        DC32 3863824061, 1418835341, 3295741277, 100954068, 1348534037
        DC32 2551784699, 3184957417, 1082772547, 3647436702, 3903896898
        DC32 2298972299, 434583643, 3363429358, 2090944266, 1115482383
        DC32 2230896926, 0, 2148107142, 724715757, 287222896, 1517047410
        DC32 251526143, 2232374840, 2923241173, 758523705, 252339417
        DC32 1550328230, 1536938324, 908343854, 168604007, 1469255655
        DC32 4004827798, 2602278545, 3229634501, 3697386016, 2002413899
        DC32 303830554, 2481064634, 2696996138, 574374880, 454171927, 151915277
        DC32 2347937223, 3056449960, 504678569, 4049044761, 1974422535
        DC32 2582559709, 2141453664, 33005350, 1918680309, 1715782971
        DC32 4217058430, 1133213225, 600562886, 3988154620, 3837289457
        DC32 836225756, 1665273989, 2534621218, 3330547729, 1250262308
        DC32 3151165501, 4188934450, 700935585, 2652719919, 3000824624
        DC32 2249059410, 3245854947, 3005967382, 1890163129, 2484206152
        DC32 3913753188, 4238918796, 4037024319, 2102843436, 857927568
        DC32 1233635150, 953795025, 3398237858, 3566745099, 4121350017
        DC32 2057644254, 3084527246, 2906629311, 976020637, 2018512274
        DC32 1600822220, 2119459398, 2381758995, 3633375416, 959340279
        DC32 3280139695, 1570750080, 3496574099, 3580864813, 634368786
        DC32 2898803609, 403744637, 2632478307, 1004239803, 650971512
        DC32 1500443672, 2599158199, 1334028442, 2514904430, 4289363686
        DC32 3156281551, 368043752, 3887782299, 1867173430, 2682967049
        DC32 2955531900, 2754719666, 1059729699, 2781229204, 2721431654
        DC32 1316239292, 2197595850, 2430644432, 2805143000, 82922136
        DC32 3963746266, 3447656016, 2434215926, 1299615190, 4014165424
        DC32 2865517645, 2531581700, 3516851125, 1783372680, 750893087
        DC32 1699118929, 1587348714, 2348899637, 2281337716, 201010753
        DC32 1739807261, 3683799762, 283718486, 3597472583, 3617229921
        DC32 2704767500, 4166618644, 334203196, 2848910887, 1639396809
        DC32 484568549, 1199193265, 3533461983, 4065673075, 337148366
        DC32 3346251575, 4149471949, 4250885034, 1038029935, 1148749531
        DC32 2949284339, 1756970692, 607661108, 2747424576, 488010435
        DC32 3803974693, 1009290057, 234832277, 2822336769, 201907891
        DC32 3034094820, 1449431233, 3413860740, 852848822, 1816687708
        DC32 3100656215
//  339 #undef V
//  340 
//  341 #define V(a,b,c,d) 0x##d##a##b##c

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  342 static const uint32_t RT3[256] = { RT };
RT3:
        DATA32
        DC32 1364240372, 2119394625, 449029143, 982933031, 1003187115
        DC32 535905693, 2896910586, 1267925987, 542505520, 2918608246
        DC32 2291234508, 4112862210, 1341970405, 3319253802, 645940277
        DC32 3046089570, 3729349297, 627514298, 1167593194, 1575076094
        DC32 3271718191, 2165502028, 2376308550, 1808202195, 65494927
        DC32 362126482, 3219880557, 2514114898, 3559752638, 1490231668
        DC32 1227450848, 2386872521, 1969916354, 4101536142, 2573942360
        DC32 668823993, 3199619041, 4028083592, 3378949152, 2108963534
        DC32 1662536415, 3850514714, 2539664209, 1648721747, 2984277860
        DC32 3146034795, 4263288961, 4187237128, 1884842056, 2400845125
        DC32 2491903198, 1387788411, 2871251827, 1927414347, 3814166303
        DC32 1714072405, 2986813675, 788775605, 2258271173, 3550808119
        DC32 821200680, 598910399, 45771267, 3982262806, 2318081231, 2811409529
        DC32 4092654087, 1319232105, 1707996378, 114671109, 3508494900
        DC32 3297443494, 882725678, 2728416755, 87220618, 2759191542, 188345475
        DC32 1084944224, 1577492337, 3176206446, 1056541217, 2520581853
        DC32 3719169342, 1296481766, 2444594516, 1896177092, 74437638
        DC32 1627329872, 421854104, 3600279997, 2311865152, 1735892697
        DC32 2965193448, 126389129, 3879230233, 2044456648, 2705787516
        DC32 2095648578, 4173930116, 0, 159614592, 843640107, 514617361
        DC32 1817080410, 4261150478, 257308805, 1025430958, 908540205
        DC32 174381327, 1747035740, 2614187099, 607792694, 212952842
        DC32 2467293015, 3033700078, 463376795, 2152711616, 1638015196
        DC32 1516850039, 471210514, 3792353939, 3236244128, 1011081250
        DC32 303896347, 235605257, 4071475083, 767142070, 348694814, 1468340721
        DC32 2940995445, 4005289369, 2751291519, 4154402305, 1555887474
        DC32 1153776486, 1530167035, 2339776835, 3420243491, 3060333805
        DC32 3093557732, 3620396081, 1108378979, 322970263, 2216694214
        DC32 2239571018, 3539484091, 2920362745, 3345850665, 491466654
        DC32 3706925234, 233591430, 2010178497, 728503987, 2845423984
        DC32 301615252, 1193436393, 2831453436, 2686074864, 1457007741
        DC32 586125363, 2277985865, 3653357880, 2365498058, 2553678804
        DC32 2798617077, 2770919034, 3659959991, 1067761581, 753179962
        DC32 1343066744, 1788595295, 1415726718, 4139914125, 2431170776
        DC32 777975609, 2197139395, 2680062045, 1769771984, 1873358293
        DC32 3484619301, 3359349164, 279411992, 3899548572, 3682319163
        DC32 3439949862, 1861490777, 3959535514, 2208864847, 3865407125
        DC32 2860443391, 554225596, 4024887317, 3134823399, 1255028335
        DC32 3939764639, 701922480, 833598116, 707863359, 3325072549, 901801634
        DC32 1949809742, 4238789250, 3769684112, 857069735, 4048197636
        DC32 1106762476, 2131644621, 389019281, 1989006925, 1129165039
        DC32 3428076970, 3839820950, 2665723345, 1276872810, 3250069292
        DC32 1182749029, 2634345054, 22885772, 4201870471, 4214112523
        DC32 3009027431, 2454901467, 3912455696, 1829980118, 2592891351
        DC32 930745505, 1502483704, 3951639571, 3471714217, 3073755489
        DC32 3790464284, 2050797895, 2623135698, 1430221810, 410635796
        DC32 1941911495, 1407897079, 1599843069, 3742658365, 2022103876
        DC32 3397514159, 3107898472, 942421028, 3261022371, 376619805
        DC32 3154912738, 680216892, 4282488077, 963707304, 148812556
        DC32 3634160820, 1687208278, 2069988555, 3580933682, 1215585388
        DC32 3494008760
//  343 #undef V
//  344 
//  345 #endif /* !MBEDTLS_AES_FEWER_TABLES */
//  346 
//  347 #undef RT
//  348 
//  349 /*
//  350  * Round constants
//  351  */

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  352 static const uint32_t RCON[10] =
RCON:
        DATA32
        DC32 1, 2, 4, 8, 16, 32, 64, 128, 27, 54
//  353 {
//  354     0x00000001, 0x00000002, 0x00000004, 0x00000008,
//  355     0x00000010, 0x00000020, 0x00000040, 0x00000080,
//  356     0x0000001B, 0x00000036
//  357 };
//  358 
//  359 #else /* MBEDTLS_AES_ROM_TABLES */
//  360 
//  361 /*
//  362  * Forward S-box & tables
//  363  */
//  364 static unsigned char FSb[256];
//  365 static uint32_t FT0[256];
//  366 #if !defined(MBEDTLS_AES_FEWER_TABLES)
//  367 static uint32_t FT1[256];
//  368 static uint32_t FT2[256];
//  369 static uint32_t FT3[256];
//  370 #endif /* !MBEDTLS_AES_FEWER_TABLES */
//  371 
//  372 /*
//  373  * Reverse S-box & tables
//  374  */
//  375 static unsigned char RSb[256];
//  376 static uint32_t RT0[256];
//  377 #if !defined(MBEDTLS_AES_FEWER_TABLES)
//  378 static uint32_t RT1[256];
//  379 static uint32_t RT2[256];
//  380 static uint32_t RT3[256];
//  381 #endif /* !MBEDTLS_AES_FEWER_TABLES */
//  382 
//  383 /*
//  384  * Round constants
//  385  */
//  386 static uint32_t RCON[10];
//  387 
//  388 /*
//  389  * Tables generation code
//  390  */
//  391 #define ROTL8(x) ( ( x << 8 ) & 0xFFFFFFFF ) | ( x >> 24 )
//  392 #define XTIME(x) ( ( x << 1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) )
//  393 #define MUL(x,y) ( ( x && y ) ? pow[(log[x]+log[y]) % 255] : 0 )
//  394 
//  395 static int aes_init_done = 0;
//  396 
//  397 static void aes_gen_tables( void )
//  398 {
//  399     int i, x, y, z;
//  400     int pow[256];
//  401     int log[256];
//  402 
//  403     /*
//  404      * compute pow and log tables over GF(2^8)
//  405      */
//  406     for( i = 0, x = 1; i < 256; i++ )
//  407     {
//  408         pow[i] = x;
//  409         log[x] = i;
//  410         x = ( x ^ XTIME( x ) ) & 0xFF;
//  411     }
//  412 
//  413     /*
//  414      * calculate the round constants
//  415      */
//  416     for( i = 0, x = 1; i < 10; i++ )
//  417     {
//  418         RCON[i] = (uint32_t) x;
//  419         x = XTIME( x ) & 0xFF;
//  420     }
//  421 
//  422     /*
//  423      * generate the forward and reverse S-boxes
//  424      */
//  425     FSb[0x00] = 0x63;
//  426     RSb[0x63] = 0x00;
//  427 
//  428     for( i = 1; i < 256; i++ )
//  429     {
//  430         x = pow[255 - log[i]];
//  431 
//  432         y  = x; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
//  433         x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
//  434         x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
//  435         x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
//  436         x ^= y ^ 0x63;
//  437 
//  438         FSb[i] = (unsigned char) x;
//  439         RSb[x] = (unsigned char) i;
//  440     }
//  441 
//  442     /*
//  443      * generate the forward and reverse tables
//  444      */
//  445     for( i = 0; i < 256; i++ )
//  446     {
//  447         x = FSb[i];
//  448         y = XTIME( x ) & 0xFF;
//  449         z =  ( y ^ x ) & 0xFF;
//  450 
//  451         FT0[i] = ( (uint32_t) y       ) ^
//  452                  ( (uint32_t) x <<  8 ) ^
//  453                  ( (uint32_t) x << 16 ) ^
//  454                  ( (uint32_t) z << 24 );
//  455 
//  456 #if !defined(MBEDTLS_AES_FEWER_TABLES)
//  457         FT1[i] = ROTL8( FT0[i] );
//  458         FT2[i] = ROTL8( FT1[i] );
//  459         FT3[i] = ROTL8( FT2[i] );
//  460 #endif /* !MBEDTLS_AES_FEWER_TABLES */
//  461 
//  462         x = RSb[i];
//  463 
//  464         RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
//  465                  ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^
//  466                  ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^
//  467                  ( (uint32_t) MUL( 0x0B, x ) << 24 );
//  468 
//  469 #if !defined(MBEDTLS_AES_FEWER_TABLES)
//  470         RT1[i] = ROTL8( RT0[i] );
//  471         RT2[i] = ROTL8( RT1[i] );
//  472         RT3[i] = ROTL8( RT2[i] );
//  473 #endif /* !MBEDTLS_AES_FEWER_TABLES */
//  474     }
//  475 }
//  476 
//  477 #undef ROTL8
//  478 
//  479 #endif /* MBEDTLS_AES_ROM_TABLES */
//  480 
//  481 #if defined(MBEDTLS_AES_FEWER_TABLES)
//  482 
//  483 #define ROTL8(x)  ( (uint32_t)( ( x ) <<  8 ) + (uint32_t)( ( x ) >> 24 ) )
//  484 #define ROTL16(x) ( (uint32_t)( ( x ) << 16 ) + (uint32_t)( ( x ) >> 16 ) )
//  485 #define ROTL24(x) ( (uint32_t)( ( x ) << 24 ) + (uint32_t)( ( x ) >>  8 ) )
//  486 
//  487 #define AES_RT0(idx) RT0[idx]
//  488 #define AES_RT1(idx) ROTL8(  RT0[idx] )
//  489 #define AES_RT2(idx) ROTL16( RT0[idx] )
//  490 #define AES_RT3(idx) ROTL24( RT0[idx] )
//  491 
//  492 #define AES_FT0(idx) FT0[idx]
//  493 #define AES_FT1(idx) ROTL8(  FT0[idx] )
//  494 #define AES_FT2(idx) ROTL16( FT0[idx] )
//  495 #define AES_FT3(idx) ROTL24( FT0[idx] )
//  496 
//  497 #else /* MBEDTLS_AES_FEWER_TABLES */
//  498 
//  499 #define AES_RT0(idx) RT0[idx]
//  500 #define AES_RT1(idx) RT1[idx]
//  501 #define AES_RT2(idx) RT2[idx]
//  502 #define AES_RT3(idx) RT3[idx]
//  503 
//  504 #define AES_FT0(idx) FT0[idx]
//  505 #define AES_FT1(idx) FT1[idx]
//  506 #define AES_FT2(idx) FT2[idx]
//  507 #define AES_FT3(idx) FT3[idx]
//  508 
//  509 #endif /* MBEDTLS_AES_FEWER_TABLES */
//  510 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function mbedtls_aes_init
        THUMB
//  511 void mbedtls_aes_init( mbedtls_aes_context *ctx )
//  512 {
//  513     memset( ctx, 0, sizeof( mbedtls_aes_context ) );
mbedtls_aes_init:
        MOVS     R2,#+0
        MOV      R1,#+280
          CFI FunCall __aeabi_memset4
        B.W      __aeabi_memset4
//  514 }
          CFI EndBlock cfiBlock0
//  515 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function mbedtls_aes_free
        THUMB
//  516 void mbedtls_aes_free( mbedtls_aes_context *ctx )
//  517 {
//  518     if( ctx == NULL )
mbedtls_aes_free:
        CMP      R0,#+0
        BEQ.N    ??mbedtls_aes_free_0
//  519         return;
//  520 
//  521     mbedtls_platform_zeroize( ctx, sizeof( mbedtls_aes_context ) );
        MOV      R1,#+280
          CFI FunCall mbedtls_platform_zeroize
        B.W      mbedtls_platform_zeroize
??mbedtls_aes_free_0:
        BX       LR               ;; return
//  522 }
          CFI EndBlock cfiBlock1
//  523 
//  524 #if defined(MBEDTLS_CIPHER_MODE_XTS)
//  525 void mbedtls_aes_xts_init( mbedtls_aes_xts_context *ctx )
//  526 {
//  527     mbedtls_aes_init( &ctx->crypt );
//  528     mbedtls_aes_init( &ctx->tweak );
//  529 }
//  530 
//  531 void mbedtls_aes_xts_free( mbedtls_aes_xts_context *ctx )
//  532 {
//  533     mbedtls_aes_free( &ctx->crypt );
//  534     mbedtls_aes_free( &ctx->tweak );
//  535 }
//  536 #endif /* MBEDTLS_CIPHER_MODE_XTS */
//  537 
//  538 /*
//  539  * AES key schedule (encryption)
//  540  */
//  541 #if !defined(MBEDTLS_AES_SETKEY_ENC_ALT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function mbedtls_aes_setkey_enc
          CFI NoCalls
        THUMB
//  542 int mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key,
//  543                     unsigned int keybits )
//  544 {
mbedtls_aes_setkey_enc:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
//  545     unsigned int i;
//  546     uint32_t *RK;
//  547 
//  548 #if !defined(MBEDTLS_AES_ROM_TABLES)
//  549     if( aes_init_done == 0 )
//  550     {
//  551         aes_gen_tables();
//  552         aes_init_done = 1;
//  553 
//  554     }
//  555 #endif
//  556 
//  557     switch( keybits )
        MOV      R3,R2
        CMP      R3,#+128
        BEQ.N    ??mbedtls_aes_setkey_enc_0
        CMP      R3,#+192
        BEQ.N    ??mbedtls_aes_setkey_enc_1
        CMP      R3,#+256
        BEQ.N    ??mbedtls_aes_setkey_enc_2
        B.N      ??mbedtls_aes_setkey_enc_3
//  558     {
//  559         case 128: ctx->nr = 10; break;
??mbedtls_aes_setkey_enc_0:
        MOVS     R3,#+10
        STR      R3,[R0, #+0]
//  560         case 192: ctx->nr = 12; break;
//  561         case 256: ctx->nr = 14; break;
//  562         default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
//  563     }
//  564 
//  565 #if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)
//  566     if( aes_padlock_ace == -1 )
//  567         aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );
//  568 
//  569     if( aes_padlock_ace )
//  570         ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
//  571     else
//  572 #endif
//  573     ctx->rk = RK = ctx->buf;
??mbedtls_aes_setkey_enc_4:
        ADD      R3,R0,#+8
        STR      R3,[R0, #+4]
//  574 
//  575 #if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
//  576     if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
//  577         return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );
//  578 #endif
//  579 
//  580     for( i = 0; i < ( keybits >> 5 ); i++ )
        MOVS     R4,#+0
        B.N      ??mbedtls_aes_setkey_enc_5
??mbedtls_aes_setkey_enc_1:
        MOVS     R3,#+12
        STR      R3,[R0, #+0]
        B.N      ??mbedtls_aes_setkey_enc_4
??mbedtls_aes_setkey_enc_2:
        MOVS     R3,#+14
        STR      R3,[R0, #+0]
        B.N      ??mbedtls_aes_setkey_enc_4
??mbedtls_aes_setkey_enc_3:
        MVN      R0,#+31
        B.N      ??mbedtls_aes_setkey_enc_6
//  581     {
//  582         GET_UINT32_LE( RK[i], key, i << 2 );
??mbedtls_aes_setkey_enc_7:
        LDRB     R5,[R1, R4, LSL #+2]
        ADD      R6,R1,R4, LSL #+2
        LDRB     R6,[R6, #+1]
        ORR      R5,R5,R6, LSL #+8
        ADD      R6,R1,R4, LSL #+2
        LDRB     R6,[R6, #+2]
        ORR      R5,R5,R6, LSL #+16
        ADD      R6,R1,R4, LSL #+2
        LDRB     R6,[R6, #+3]
        ORR      R5,R5,R6, LSL #+24
        STR      R5,[R3, R4, LSL #+2]
//  583     }
        ADDS     R4,R4,#+1
??mbedtls_aes_setkey_enc_5:
        CMP      R4,R2, LSR #+5
        BCC.N    ??mbedtls_aes_setkey_enc_7
//  584 
//  585     switch( ctx->nr )
        LDR      R0,[R0, #+0]
        CMP      R0,#+10
        BEQ.N    ??mbedtls_aes_setkey_enc_8
        CMP      R0,#+12
        BEQ.N    ??mbedtls_aes_setkey_enc_9
        CMP      R0,#+14
        BEQ.N    ??mbedtls_aes_setkey_enc_10
        B.N      ??mbedtls_aes_setkey_enc_11
//  586     {
//  587         case 10:
//  588 
//  589             for( i = 0; i < 10; i++, RK += 4 )
??mbedtls_aes_setkey_enc_8:
        MOVS     R2,#+0
??mbedtls_aes_setkey_enc_12:
        CMP      R2,#+10
        BCS.W    ??mbedtls_aes_setkey_enc_11
//  590             {
//  591                 RK[4]  = RK[0] ^ RCON[i] ^
//  592                 ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
//  593                 ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
//  594                 ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
//  595                 ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
        LDR.W    R0,??DataTable4
        LDR      R1,[R3, #+0]
        LDR.W    R4,??DataTable4_1
        LDR      R4,[R4, R2, LSL #+2]
        EORS     R1,R4,R1
        LDR      R4,[R3, #+12]
        UBFX     R4,R4,#+8,#+8
        LDRB     R4,[R0, R4]
        EORS     R1,R4,R1
        LDR      R4,[R3, #+12]
        UBFX     R4,R4,#+16,#+8
        LDRB     R4,[R0, R4]
        EOR      R1,R1,R4, LSL #+8
        LDR      R4,[R3, #+12]
        LSRS     R4,R4,#+24
        LDRB     R4,[R0, R4]
        EOR      R1,R1,R4, LSL #+16
        LDRB     R4,[R3, #+12]
        LDRB     R0,[R0, R4]
        EOR      R1,R1,R0, LSL #+24
        STR      R1,[R3, #+16]
//  596 
//  597                 RK[5]  = RK[1] ^ RK[4];
        LDR      R0,[R3, #+4]
        LDR      R1,[R3, #+16]
        EORS     R0,R1,R0
        STR      R0,[R3, #+20]
//  598                 RK[6]  = RK[2] ^ RK[5];
        LDR      R0,[R3, #+8]
        LDR      R1,[R3, #+20]
        EORS     R0,R1,R0
        STR      R0,[R3, #+24]
//  599                 RK[7]  = RK[3] ^ RK[6];
        LDR      R0,[R3, #+12]
        LDR      R1,[R3, #+24]
        EORS     R0,R1,R0
        STR      R0,[R3, #+28]
//  600             }
        ADDS     R2,R2,#+1
        ADDS     R3,R3,#+16
        B.N      ??mbedtls_aes_setkey_enc_12
//  601             break;
//  602 
//  603         case 12:
//  604 
//  605             for( i = 0; i < 8; i++, RK += 6 )
??mbedtls_aes_setkey_enc_9:
        MOVS     R2,#+0
??mbedtls_aes_setkey_enc_13:
        CMP      R2,#+8
        BCS.W    ??mbedtls_aes_setkey_enc_11
//  606             {
//  607                 RK[6]  = RK[0] ^ RCON[i] ^
//  608                 ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
//  609                 ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
//  610                 ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
//  611                 ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
        LDR.W    R0,??DataTable4
        LDR      R1,[R3, #+0]
        LDR.W    R4,??DataTable4_1
        LDR      R4,[R4, R2, LSL #+2]
        EORS     R1,R4,R1
        LDR      R4,[R3, #+20]
        UBFX     R4,R4,#+8,#+8
        LDRB     R4,[R0, R4]
        EORS     R1,R4,R1
        LDR      R4,[R3, #+20]
        UBFX     R4,R4,#+16,#+8
        LDRB     R4,[R0, R4]
        EOR      R1,R1,R4, LSL #+8
        LDR      R4,[R3, #+20]
        LSRS     R4,R4,#+24
        LDRB     R4,[R0, R4]
        EOR      R1,R1,R4, LSL #+16
        LDRB     R4,[R3, #+20]
        LDRB     R0,[R0, R4]
        EOR      R1,R1,R0, LSL #+24
        STR      R1,[R3, #+24]
//  612 
//  613                 RK[7]  = RK[1] ^ RK[6];
        LDR      R0,[R3, #+4]
        LDR      R1,[R3, #+24]
        EORS     R0,R1,R0
        STR      R0,[R3, #+28]
//  614                 RK[8]  = RK[2] ^ RK[7];
        LDR      R0,[R3, #+8]
        LDR      R1,[R3, #+28]
        EORS     R0,R1,R0
        STR      R0,[R3, #+32]
//  615                 RK[9]  = RK[3] ^ RK[8];
        LDR      R0,[R3, #+12]
        LDR      R1,[R3, #+32]
        EORS     R0,R1,R0
        STR      R0,[R3, #+36]
//  616                 RK[10] = RK[4] ^ RK[9];
        LDR      R0,[R3, #+16]
        LDR      R1,[R3, #+36]
        EORS     R0,R1,R0
        STR      R0,[R3, #+40]
//  617                 RK[11] = RK[5] ^ RK[10];
        LDR      R0,[R3, #+20]
        LDR      R1,[R3, #+40]
        EORS     R0,R1,R0
        STR      R0,[R3, #+44]
//  618             }
        ADDS     R2,R2,#+1
        ADDS     R3,R3,#+24
        B.N      ??mbedtls_aes_setkey_enc_13
//  619             break;
//  620 
//  621         case 14:
//  622 
//  623             for( i = 0; i < 7; i++, RK += 8 )
??mbedtls_aes_setkey_enc_10:
        MOVS     R2,#+0
??mbedtls_aes_setkey_enc_14:
        CMP      R2,#+7
        BCS.N    ??mbedtls_aes_setkey_enc_11
//  624             {
//  625                 RK[8]  = RK[0] ^ RCON[i] ^
//  626                 ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
//  627                 ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
//  628                 ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
//  629                 ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
        LDR.W    R0,??DataTable4
        LDR      R1,[R3, #+0]
        LDR.W    R4,??DataTable4_1
        LDR      R4,[R4, R2, LSL #+2]
        EORS     R1,R4,R1
        LDR      R4,[R3, #+28]
        UBFX     R4,R4,#+8,#+8
        LDRB     R4,[R0, R4]
        EORS     R1,R4,R1
        LDR      R4,[R3, #+28]
        UBFX     R4,R4,#+16,#+8
        LDRB     R4,[R0, R4]
        EOR      R1,R1,R4, LSL #+8
        LDR      R4,[R3, #+28]
        LSRS     R4,R4,#+24
        LDRB     R4,[R0, R4]
        EOR      R1,R1,R4, LSL #+16
        LDRB     R4,[R3, #+28]
        LDRB     R4,[R0, R4]
        EOR      R1,R1,R4, LSL #+24
        STR      R1,[R3, #+32]
//  630 
//  631                 RK[9]  = RK[1] ^ RK[8];
        LDR      R1,[R3, #+4]
        LDR      R4,[R3, #+32]
        EORS     R1,R4,R1
        STR      R1,[R3, #+36]
//  632                 RK[10] = RK[2] ^ RK[9];
        LDR      R1,[R3, #+8]
        LDR      R4,[R3, #+36]
        EORS     R1,R4,R1
        STR      R1,[R3, #+40]
//  633                 RK[11] = RK[3] ^ RK[10];
        LDR      R1,[R3, #+12]
        LDR      R4,[R3, #+40]
        EORS     R1,R4,R1
        STR      R1,[R3, #+44]
//  634 
//  635                 RK[12] = RK[4] ^
//  636                 ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
//  637                 ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
//  638                 ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
//  639                 ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );
        LDR      R1,[R3, #+16]
        LDRB     R4,[R3, #+44]
        LDRB     R4,[R0, R4]
        EORS     R1,R4,R1
        LDR      R4,[R3, #+44]
        UBFX     R4,R4,#+8,#+8
        LDRB     R4,[R0, R4]
        EOR      R1,R1,R4, LSL #+8
        LDR      R4,[R3, #+44]
        UBFX     R4,R4,#+16,#+8
        LDRB     R4,[R0, R4]
        EOR      R1,R1,R4, LSL #+16
        LDR      R4,[R3, #+44]
        LSRS     R4,R4,#+24
        LDRB     R0,[R0, R4]
        EOR      R1,R1,R0, LSL #+24
        STR      R1,[R3, #+48]
//  640 
//  641                 RK[13] = RK[5] ^ RK[12];
        LDR      R0,[R3, #+20]
        LDR      R1,[R3, #+48]
        EORS     R0,R1,R0
        STR      R0,[R3, #+52]
//  642                 RK[14] = RK[6] ^ RK[13];
        LDR      R0,[R3, #+24]
        LDR      R1,[R3, #+52]
        EORS     R0,R1,R0
        STR      R0,[R3, #+56]
//  643                 RK[15] = RK[7] ^ RK[14];
        LDR      R0,[R3, #+28]
        LDR      R1,[R3, #+56]
        EORS     R0,R1,R0
        STR      R0,[R3, #+60]
//  644             }
        ADDS     R2,R2,#+1
        ADDS     R3,R3,#+32
        B.N      ??mbedtls_aes_setkey_enc_14
//  645             break;
//  646     }
//  647 
//  648     return( 0 );
??mbedtls_aes_setkey_enc_11:
        MOVS     R0,#+0
??mbedtls_aes_setkey_enc_6:
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
//  649 }
          CFI EndBlock cfiBlock2
//  650 #endif /* !MBEDTLS_AES_SETKEY_ENC_ALT */
//  651 
//  652 /*
//  653  * AES key schedule (decryption)
//  654  */
//  655 #if !defined(MBEDTLS_AES_SETKEY_DEC_ALT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function mbedtls_aes_setkey_dec
        THUMB
//  656 int mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,
//  657                     unsigned int keybits )
//  658 {
mbedtls_aes_setkey_dec:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        SUB      SP,SP,#+280
          CFI CFA R13+304
        MOV      R6,R0
        MOV      R4,R1
        MOV      R7,R2
//  659     int i, j, ret;
//  660     mbedtls_aes_context cty;
//  661     uint32_t *RK;
//  662     uint32_t *SK;
//  663 
//  664     mbedtls_aes_init( &cty );
        MOV      R0,SP
          CFI FunCall mbedtls_aes_init
        BL       mbedtls_aes_init
//  665 
//  666 #if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)
//  667     if( aes_padlock_ace == -1 )
//  668         aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );
//  669 
//  670     if( aes_padlock_ace )
//  671         ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
//  672     else
//  673 #endif
//  674     ctx->rk = RK = ctx->buf;
        ADD      R5,R6,#+8
        STR      R5,[R6, #+4]
//  675 
//  676     /* Also checks keybits */
//  677     if( ( ret = mbedtls_aes_setkey_enc( &cty, key, keybits ) ) != 0 )
        MOV      R2,R7
        MOV      R1,R4
        MOV      R0,SP
          CFI FunCall mbedtls_aes_setkey_enc
        BL       mbedtls_aes_setkey_enc
        MOVS     R4,R0
        BNE.N    ??mbedtls_aes_setkey_dec_0
//  678         goto exit;
//  679 
//  680     ctx->nr = cty.nr;
        LDR      R0,[SP, #+0]
        STR      R0,[R6, #+0]
//  681 
//  682 #if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
//  683     if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
//  684     {
//  685         mbedtls_aesni_inverse_key( (unsigned char *) ctx->rk,
//  686                            (const unsigned char *) cty.rk, ctx->nr );
//  687         goto exit;
//  688     }
//  689 #endif
//  690 
//  691     SK = cty.rk + cty.nr * 4;
        LDR      R0,[SP, #+4]
        LDR      R1,[SP, #+0]
        ADD      R1,R0,R1, LSL #+4
//  692 
//  693     *RK++ = *SK++;
        LDR      R0,[R1, #+0]
        STR      R0,[R5], #+4
//  694     *RK++ = *SK++;
        LDR      R0,[R1, #+4]
        STR      R0,[R5], #+4
//  695     *RK++ = *SK++;
        LDR      R0,[R1, #+8]
        STR      R0,[R5], #+4
//  696     *RK++ = *SK++;
        LDR      R0,[R1, #+12]
        STR      R0,[R5], #+4
//  697 
//  698     for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
        LDR      R0,[R6, #+0]
        SUBS     R0,R0,#+1
        SUB      R2,R1,#+16
        B.N      ??mbedtls_aes_setkey_dec_1
//  699     {
//  700         for( j = 0; j < 4; j++, SK++ )
//  701         {
//  702             *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
//  703                     AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
//  704                     AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
//  705                     AES_RT3( FSb[ ( *SK >> 24 ) & 0xFF ] );
??mbedtls_aes_setkey_dec_2:
        LDR.W    R1,??DataTable4
        LDR.W    R6,??DataTable4_2
        LDRB     R7,[R2, #+0]
        LDRB     R7,[R1, R7]
        LDR      R6,[R6, R7, LSL #+2]
        LDR.W    R7,??DataTable4_3
        LDR      R12,[R2, #+0]
        UBFX     R12,R12,#+8,#+8
        LDRB     R12,[R1, R12]
        LDR      R7,[R7, R12, LSL #+2]
        EORS     R6,R7,R6
        LDR.W    R7,??DataTable4_4
        LDR      R12,[R2, #+0]
        UBFX     R12,R12,#+16,#+8
        LDRB     R12,[R1, R12]
        LDR      R7,[R7, R12, LSL #+2]
        EORS     R6,R7,R6
        LDR.W    R7,??DataTable4_5
        LDR      R12,[R2, #+0]
        LSR      R12,R12,#+24
        LDRB     R1,[R1, R12]
        LDR      R1,[R7, R1, LSL #+2]
        EORS     R6,R1,R6
        STR      R6,[R5], #+4
//  706         }
        ADDS     R3,R3,#+1
        ADDS     R2,R2,#+4
??mbedtls_aes_setkey_dec_3:
        CMP      R3,#+4
        BLT.N    ??mbedtls_aes_setkey_dec_2
        SUBS     R0,R0,#+1
        SUBS     R2,R2,#+32
??mbedtls_aes_setkey_dec_1:
        CMP      R0,#+1
        BLT.N    ??mbedtls_aes_setkey_dec_4
        MOVS     R3,#+0
        B.N      ??mbedtls_aes_setkey_dec_3
//  707     }
//  708 
//  709     *RK++ = *SK++;
??mbedtls_aes_setkey_dec_4:
        LDR      R0,[R2, #+0]
        STR      R0,[R5, #+0]
//  710     *RK++ = *SK++;
        LDR      R0,[R2, #+4]
        STR      R0,[R5, #+4]
//  711     *RK++ = *SK++;
        LDR      R0,[R2, #+8]
        STR      R0,[R5, #+8]
//  712     *RK++ = *SK++;
        LDR      R0,[R2, #+12]
        STR      R0,[R5, #+12]
//  713 
//  714 exit:
//  715     mbedtls_aes_free( &cty );
??mbedtls_aes_setkey_dec_0:
        MOV      R0,SP
          CFI FunCall mbedtls_aes_free
        BL       mbedtls_aes_free
//  716 
//  717     return( ret );
        MOV      R0,R4
        ADD      SP,SP,#+284
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
//  718 }
          CFI EndBlock cfiBlock3
//  719 
//  720 #if defined(MBEDTLS_CIPHER_MODE_XTS)
//  721 static int mbedtls_aes_xts_decode_keys( const unsigned char *key,
//  722                                         unsigned int keybits,
//  723                                         const unsigned char **key1,
//  724                                         unsigned int *key1bits,
//  725                                         const unsigned char **key2,
//  726                                         unsigned int *key2bits )
//  727 {
//  728     const unsigned int half_keybits = keybits / 2;
//  729     const unsigned int half_keybytes = half_keybits / 8;
//  730 
//  731     switch( keybits )
//  732     {
//  733         case 256: break;
//  734         case 512: break;
//  735         default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
//  736     }
//  737 
//  738     *key1bits = half_keybits;
//  739     *key2bits = half_keybits;
//  740     *key1 = &key[0];
//  741     *key2 = &key[half_keybytes];
//  742 
//  743     return 0;
//  744 }
//  745 
//  746 int mbedtls_aes_xts_setkey_enc( mbedtls_aes_xts_context *ctx,
//  747                                 const unsigned char *key,
//  748                                 unsigned int keybits)
//  749 {
//  750     int ret;
//  751     const unsigned char *key1, *key2;
//  752     unsigned int key1bits, key2bits;
//  753 
//  754     ret = mbedtls_aes_xts_decode_keys( key, keybits, &key1, &key1bits,
//  755                                        &key2, &key2bits );
//  756     if( ret != 0 )
//  757         return( ret );
//  758 
//  759     /* Set the tweak key. Always set tweak key for the encryption mode. */
//  760     ret = mbedtls_aes_setkey_enc( &ctx->tweak, key2, key2bits );
//  761     if( ret != 0 )
//  762         return( ret );
//  763 
//  764     /* Set crypt key for encryption. */
//  765     return mbedtls_aes_setkey_enc( &ctx->crypt, key1, key1bits );
//  766 }
//  767 
//  768 int mbedtls_aes_xts_setkey_dec( mbedtls_aes_xts_context *ctx,
//  769                                 const unsigned char *key,
//  770                                 unsigned int keybits)
//  771 {
//  772     int ret;
//  773     const unsigned char *key1, *key2;
//  774     unsigned int key1bits, key2bits;
//  775 
//  776     ret = mbedtls_aes_xts_decode_keys( key, keybits, &key1, &key1bits,
//  777                                        &key2, &key2bits );
//  778     if( ret != 0 )
//  779         return( ret );
//  780 
//  781     /* Set the tweak key. Always set tweak key for encryption. */
//  782     ret = mbedtls_aes_setkey_enc( &ctx->tweak, key2, key2bits );
//  783     if( ret != 0 )
//  784         return( ret );
//  785 
//  786     /* Set crypt key for decryption. */
//  787     return mbedtls_aes_setkey_dec( &ctx->crypt, key1, key1bits );
//  788 }
//  789 #endif /* MBEDTLS_CIPHER_MODE_XTS */
//  790 
//  791 #endif /* !MBEDTLS_AES_SETKEY_DEC_ALT */
//  792 
//  793 #define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)         \ 
//  794 {                                                   \ 
//  795     X0 = *RK++ ^ AES_FT0( ( Y0       ) & 0xFF ) ^   \ 
//  796                  AES_FT1( ( Y1 >>  8 ) & 0xFF ) ^   \ 
//  797                  AES_FT2( ( Y2 >> 16 ) & 0xFF ) ^   \ 
//  798                  AES_FT3( ( Y3 >> 24 ) & 0xFF );    \ 
//  799                                                     \ 
//  800     X1 = *RK++ ^ AES_FT0( ( Y1       ) & 0xFF ) ^   \ 
//  801                  AES_FT1( ( Y2 >>  8 ) & 0xFF ) ^   \ 
//  802                  AES_FT2( ( Y3 >> 16 ) & 0xFF ) ^   \ 
//  803                  AES_FT3( ( Y0 >> 24 ) & 0xFF );    \ 
//  804                                                     \ 
//  805     X2 = *RK++ ^ AES_FT0( ( Y2       ) & 0xFF ) ^   \ 
//  806                  AES_FT1( ( Y3 >>  8 ) & 0xFF ) ^   \ 
//  807                  AES_FT2( ( Y0 >> 16 ) & 0xFF ) ^   \ 
//  808                  AES_FT3( ( Y1 >> 24 ) & 0xFF );    \ 
//  809                                                     \ 
//  810     X3 = *RK++ ^ AES_FT0( ( Y3       ) & 0xFF ) ^   \ 
//  811                  AES_FT1( ( Y0 >>  8 ) & 0xFF ) ^   \ 
//  812                  AES_FT2( ( Y1 >> 16 ) & 0xFF ) ^   \ 
//  813                  AES_FT3( ( Y2 >> 24 ) & 0xFF );    \ 
//  814 }
//  815 
//  816 #define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)         \ 
//  817 {                                                   \ 
//  818     X0 = *RK++ ^ AES_RT0( ( Y0       ) & 0xFF ) ^   \ 
//  819                  AES_RT1( ( Y3 >>  8 ) & 0xFF ) ^   \ 
//  820                  AES_RT2( ( Y2 >> 16 ) & 0xFF ) ^   \ 
//  821                  AES_RT3( ( Y1 >> 24 ) & 0xFF );    \ 
//  822                                                     \ 
//  823     X1 = *RK++ ^ AES_RT0( ( Y1       ) & 0xFF ) ^   \ 
//  824                  AES_RT1( ( Y0 >>  8 ) & 0xFF ) ^   \ 
//  825                  AES_RT2( ( Y3 >> 16 ) & 0xFF ) ^   \ 
//  826                  AES_RT3( ( Y2 >> 24 ) & 0xFF );    \ 
//  827                                                     \ 
//  828     X2 = *RK++ ^ AES_RT0( ( Y2       ) & 0xFF ) ^   \ 
//  829                  AES_RT1( ( Y1 >>  8 ) & 0xFF ) ^   \ 
//  830                  AES_RT2( ( Y0 >> 16 ) & 0xFF ) ^   \ 
//  831                  AES_RT3( ( Y3 >> 24 ) & 0xFF );    \ 
//  832                                                     \ 
//  833     X3 = *RK++ ^ AES_RT0( ( Y3       ) & 0xFF ) ^   \ 
//  834                  AES_RT1( ( Y2 >>  8 ) & 0xFF ) ^   \ 
//  835                  AES_RT2( ( Y1 >> 16 ) & 0xFF ) ^   \ 
//  836                  AES_RT3( ( Y0 >> 24 ) & 0xFF );    \ 
//  837 }
//  838 
//  839 /*
//  840  * AES-ECB block encryption
//  841  */
//  842 #if !defined(MBEDTLS_AES_ENCRYPT_ALT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function mbedtls_internal_aes_encrypt
          CFI NoCalls
        THUMB
//  843 int mbedtls_internal_aes_encrypt( mbedtls_aes_context *ctx,
//  844                                   const unsigned char input[16],
//  845                                   unsigned char output[16] )
//  846 {
mbedtls_internal_aes_encrypt:
        PUSH     {R2,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R2,R1
//  847     int i;
//  848     uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
//  849 
//  850     RK = ctx->rk;
        LDR      R1,[R0, #+4]
//  851 
//  852     GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
        LDRB     R6,[R2, #+0]
        LDRB     R3,[R2, #+1]
        ORR      R6,R6,R3, LSL #+8
        LDRB     R3,[R2, #+2]
        ORR      R6,R6,R3, LSL #+16
        LDRB     R3,[R2, #+3]
        ORR      R6,R6,R3, LSL #+24
        LDR      R3,[R1], #+4
        EORS     R6,R3,R6
//  853     GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
        LDRB     R5,[R2, #+4]
        LDRB     R3,[R2, #+5]
        ORR      R5,R5,R3, LSL #+8
        LDRB     R3,[R2, #+6]
        ORR      R5,R5,R3, LSL #+16
        LDRB     R3,[R2, #+7]
        ORR      R5,R5,R3, LSL #+24
        LDR      R3,[R1], #+4
        EORS     R5,R3,R5
//  854     GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
        LDRB     R3,[R2, #+8]
        LDRB     R4,[R2, #+9]
        ORR      R3,R3,R4, LSL #+8
        LDRB     R4,[R2, #+10]
        ORR      R3,R3,R4, LSL #+16
        LDRB     R4,[R2, #+11]
        ORR      R3,R3,R4, LSL #+24
        LDR      R4,[R1], #+4
        EORS     R3,R4,R3
//  855     GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
        LDRB     R10,[R2, #+12]
        LDRB     R4,[R2, #+13]
        ORR      R10,R10,R4, LSL #+8
        LDRB     R4,[R2, #+14]
        ORR      R10,R10,R4, LSL #+16
        LDRB     R2,[R2, #+15]
        ORR      R10,R10,R2, LSL #+24
        LDR      R2,[R1], #+4
        EOR      R10,R2,R10
//  856 
//  857     for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
        LDR      R4,[R0, #+0]
        ASRS     R4,R4,#+1
        SUBS     R4,R4,#+1
        MOV      R0,R1
        MOV      R1,R6
        MOV      R2,R5
        B.N      ??mbedtls_internal_aes_encrypt_0
//  858     {
//  859         AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
??mbedtls_internal_aes_encrypt_1:
        LDR.W    R5,??DataTable4_6
        LDR.W    R6,??DataTable4_7
        LDR.W    R7,??DataTable4_8
        LDR.W    R12,??DataTable4_9
        LDR      LR,[R0], #+4
        AND      R8,R1,#0xFF
        LDR      R8,[R12, R8, LSL #+2]
        EOR      LR,R8,LR
        UBFX     R8,R2,#+8,#+8
        LDR      R8,[R7, R8, LSL #+2]
        EOR      LR,R8,LR
        UBFX     R8,R3,#+16,#+8
        LDR      R8,[R6, R8, LSL #+2]
        EOR      LR,R8,LR
        MOV      R8,R10
        LSR      R8,R8,#+24
        LDR      R8,[R5, R8, LSL #+2]
        EOR      LR,R8,LR
        LDR      R8,[R0], #+4
        AND      R9,R2,#0xFF
        LDR      R9,[R12, R9, LSL #+2]
        EOR      R8,R9,R8
        UBFX     R9,R3,#+8,#+8
        LDR      R9,[R7, R9, LSL #+2]
        EOR      R8,R9,R8
        UBFX     R9,R10,#+16,#+8
        LDR      R9,[R6, R9, LSL #+2]
        EOR      R8,R9,R8
        MOV      R9,R1
        LSR      R9,R9,#+24
        LDR      R9,[R5, R9, LSL #+2]
        EOR      R8,R9,R8
        LDR      R9,[R0], #+4
        AND      R11,R3,#0xFF
        LDR      R11,[R12, R11, LSL #+2]
        EOR      R9,R11,R9
        UBFX     R11,R10,#+8,#+8
        LDR      R11,[R7, R11, LSL #+2]
        EOR      R9,R11,R9
        UBFX     R11,R1,#+16,#+8
        LDR      R11,[R6, R11, LSL #+2]
        EOR      R9,R11,R9
        MOV      R11,R2
        LSR      R11,R11,#+24
        LDR      R11,[R5, R11, LSL #+2]
        EOR      R9,R11,R9
        LDR      R11,[R0], #+4
        AND      R10,R10,#0xFF
        LDR      R10,[R12, R10, LSL #+2]
        EOR      R10,R10,R11
        UBFX     R1,R1,#+8,#+8
        LDR      R1,[R7, R1, LSL #+2]
        EOR      R10,R1,R10
        UBFX     R1,R2,#+16,#+8
        LDR      R1,[R6, R1, LSL #+2]
        EOR      R10,R1,R10
        LSRS     R3,R3,#+24
        LDR      R1,[R5, R3, LSL #+2]
        EOR      R10,R1,R10
//  860         AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
        LDR      R1,[R0], #+4
        AND      R2,LR,#0xFF
        LDR      R2,[R12, R2, LSL #+2]
        EORS     R1,R2,R1
        UBFX     R2,R8,#+8,#+8
        LDR      R2,[R7, R2, LSL #+2]
        EORS     R1,R2,R1
        UBFX     R2,R9,#+16,#+8
        LDR      R2,[R6, R2, LSL #+2]
        EORS     R1,R2,R1
        MOV      R2,R10
        LSRS     R2,R2,#+24
        LDR      R2,[R5, R2, LSL #+2]
        EORS     R1,R2,R1
        LDR      R2,[R0], #+4
        AND      R3,R8,#0xFF
        LDR      R3,[R12, R3, LSL #+2]
        EORS     R2,R3,R2
        UBFX     R3,R9,#+8,#+8
        LDR      R3,[R7, R3, LSL #+2]
        EORS     R2,R3,R2
        UBFX     R3,R10,#+16,#+8
        LDR      R3,[R6, R3, LSL #+2]
        EORS     R2,R3,R2
        MOV      R3,LR
        LSRS     R3,R3,#+24
        LDR      R3,[R5, R3, LSL #+2]
        EORS     R2,R3,R2
        LDR      R3,[R0], #+4
        AND      R11,R9,#0xFF
        LDR      R11,[R12, R11, LSL #+2]
        EOR      R3,R11,R3
        UBFX     R11,R10,#+8,#+8
        LDR      R11,[R7, R11, LSL #+2]
        EOR      R3,R11,R3
        UBFX     R11,LR,#+16,#+8
        LDR      R11,[R6, R11, LSL #+2]
        EOR      R3,R11,R3
        MOV      R11,R8
        LSR      R11,R11,#+24
        LDR      R11,[R5, R11, LSL #+2]
        EOR      R3,R11,R3
        LDR      R11,[R0], #+4
        AND      R10,R10,#0xFF
        LDR      R12,[R12, R10, LSL #+2]
        EOR      R11,R12,R11
        UBFX     R12,LR,#+8,#+8
        LDR      R7,[R7, R12, LSL #+2]
        MOV      R10,R11
        EOR      R10,R7,R10
        UBFX     R7,R8,#+16,#+8
        LDR      R6,[R6, R7, LSL #+2]
        EOR      R10,R6,R10
        LSR      R9,R9,#+24
        LDR      R5,[R5, R9, LSL #+2]
        EOR      R10,R5,R10
//  861     }
        SUBS     R4,R4,#+1
??mbedtls_internal_aes_encrypt_0:
        CMP      R4,#+1
        BGE.W    ??mbedtls_internal_aes_encrypt_1
        LDR      R5,[SP, #+0]
//  862 
//  863     AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
        LDR.W    R6,??DataTable4_6
        LDR.W    R7,??DataTable4_7
        LDR.W    R12,??DataTable4_8
        LDR.W    LR,??DataTable4_9
        LDR      R8,[R0, #+0]
        AND      R4,R1,#0xFF
        LDR      R4,[LR, R4, LSL #+2]
        EOR      R8,R4,R8
        UBFX     R4,R2,#+8,#+8
        LDR      R4,[R12, R4, LSL #+2]
        EOR      R8,R4,R8
        UBFX     R4,R3,#+16,#+8
        LDR      R4,[R7, R4, LSL #+2]
        EOR      R8,R4,R8
        MOV      R4,R10
        LSRS     R4,R4,#+24
        LDR      R4,[R6, R4, LSL #+2]
        EOR      R8,R4,R8
        LDR      R9,[R0, #+4]
        AND      R4,R2,#0xFF
        LDR      R4,[LR, R4, LSL #+2]
        EOR      R9,R4,R9
        UBFX     R4,R3,#+8,#+8
        LDR      R4,[R12, R4, LSL #+2]
        EOR      R9,R4,R9
        UBFX     R4,R10,#+16,#+8
        LDR      R4,[R7, R4, LSL #+2]
        EOR      R9,R4,R9
        MOV      R4,R1
        LSRS     R4,R4,#+24
        LDR      R4,[R6, R4, LSL #+2]
        EOR      R9,R4,R9
        LDR      R11,[R0, #+8]
        AND      R4,R3,#0xFF
        LDR      R4,[LR, R4, LSL #+2]
        EOR      R11,R4,R11
        UBFX     R4,R10,#+8,#+8
        LDR      R4,[R12, R4, LSL #+2]
        EOR      R11,R4,R11
        UBFX     R4,R1,#+16,#+8
        LDR      R4,[R7, R4, LSL #+2]
        EOR      R11,R4,R11
        MOV      R4,R2
        LSRS     R4,R4,#+24
        LDR      R4,[R6, R4, LSL #+2]
        EOR      R11,R4,R11
        LDR      R4,[R0, #+12]
        AND      R10,R10,#0xFF
        LDR      LR,[LR, R10, LSL #+2]
        EOR      R4,LR,R4
        UBFX     R1,R1,#+8,#+8
        LDR      R1,[R12, R1, LSL #+2]
        EORS     R4,R1,R4
        UBFX     R1,R2,#+16,#+8
        LDR      R1,[R7, R1, LSL #+2]
        EORS     R4,R1,R4
        LSRS     R3,R3,#+24
        LDR      R1,[R6, R3, LSL #+2]
        EORS     R4,R1,R4
//  864 
//  865     X0 = *RK++ ^ \ 
//  866             ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
//  867             ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
//  868             ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
//  869             ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
        LDR.W    R3,??DataTable4
        LDR      R2,[R0, #+16]
        AND      R1,R8,#0xFF
        LDRB     R1,[R3, R1]
        EORS     R2,R1,R2
        UBFX     R1,R9,#+8,#+8
        LDRB     R1,[R3, R1]
        EOR      R2,R2,R1, LSL #+8
        UBFX     R1,R11,#+16,#+8
        LDRB     R1,[R3, R1]
        EOR      R2,R2,R1, LSL #+16
        MOV      R1,R4
        LSRS     R1,R1,#+24
        LDRB     R1,[R3, R1]
        EOR      R2,R2,R1, LSL #+24
//  870 
//  871     X1 = *RK++ ^ \ 
//  872             ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
//  873             ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
//  874             ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
//  875             ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
        LDR      R6,[R0, #+20]
        AND      R1,R9,#0xFF
        LDRB     R1,[R3, R1]
        EORS     R6,R1,R6
        UBFX     R1,R11,#+8,#+8
        LDRB     R1,[R3, R1]
        EOR      R6,R6,R1, LSL #+8
        UBFX     R1,R4,#+16,#+8
        LDRB     R1,[R3, R1]
        EOR      R6,R6,R1, LSL #+16
        MOV      R1,R8
        LSRS     R1,R1,#+24
        LDRB     R1,[R3, R1]
        EOR      R6,R6,R1, LSL #+24
//  876 
//  877     X2 = *RK++ ^ \ 
//  878             ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
//  879             ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
//  880             ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
//  881             ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
        LDR      R7,[R0, #+24]
        AND      R1,R11,#0xFF
        LDRB     R1,[R3, R1]
        EORS     R7,R1,R7
        UBFX     R1,R4,#+8,#+8
        LDRB     R1,[R3, R1]
        EOR      R7,R7,R1, LSL #+8
        UBFX     R1,R8,#+16,#+8
        LDRB     R1,[R3, R1]
        EOR      R7,R7,R1, LSL #+16
        MOV      R1,R9
        LSRS     R1,R1,#+24
        LDRB     R1,[R3, R1]
        EOR      R7,R7,R1, LSL #+24
//  882 
//  883     X3 = *RK++ ^ \ 
//  884             ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
//  885             ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
//  886             ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
//  887             ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
        LDR      R1,[R0, #+28]
        AND      R4,R4,#0xFF
        LDRB     R0,[R3, R4]
        EORS     R1,R0,R1
        UBFX     R0,R8,#+8,#+8
        LDRB     R0,[R3, R0]
        EOR      R1,R1,R0, LSL #+8
        UBFX     R0,R9,#+16,#+8
        LDRB     R0,[R3, R0]
        EOR      R1,R1,R0, LSL #+16
        LSR      R11,R11,#+24
        LDRB     R0,[R3, R11]
        EOR      R1,R1,R0, LSL #+24
//  888 
//  889     PUT_UINT32_LE( X0, output,  0 );
        STRB     R2,[R5, #+0]
        MOV      R0,R2
        LSRS     R0,R0,#+8
        STRB     R0,[R5, #+1]
        MOV      R0,R2
        LSRS     R0,R0,#+16
        STRB     R0,[R5, #+2]
        LSRS     R2,R2,#+24
        STRB     R2,[R5, #+3]
//  890     PUT_UINT32_LE( X1, output,  4 );
        STRB     R6,[R5, #+4]
        MOV      R0,R6
        LSRS     R0,R0,#+8
        STRB     R0,[R5, #+5]
        MOV      R0,R6
        LSRS     R0,R0,#+16
        STRB     R0,[R5, #+6]
        LSRS     R6,R6,#+24
        STRB     R6,[R5, #+7]
//  891     PUT_UINT32_LE( X2, output,  8 );
        STRB     R7,[R5, #+8]
        MOV      R0,R7
        LSRS     R0,R0,#+8
        STRB     R0,[R5, #+9]
        MOV      R0,R7
        LSRS     R0,R0,#+16
        STRB     R0,[R5, #+10]
        LSRS     R7,R7,#+24
        STRB     R7,[R5, #+11]
//  892     PUT_UINT32_LE( X3, output, 12 );
        STRB     R1,[R5, #+12]
        MOV      R0,R1
        LSRS     R0,R0,#+8
        STRB     R0,[R5, #+13]
        MOV      R0,R1
        LSRS     R0,R0,#+16
        STRB     R0,[R5, #+14]
        LSRS     R1,R1,#+24
        STRB     R1,[R5, #+15]
//  893 
//  894     return( 0 );
        MOVS     R0,#+0
        POP      {R1,R4-R11,PC}   ;; return
//  895 }
          CFI EndBlock cfiBlock4
//  896 #endif /* !MBEDTLS_AES_ENCRYPT_ALT */
//  897 
//  898 #if !defined(MBEDTLS_DEPRECATED_REMOVED)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function mbedtls_aes_encrypt
          CFI FunCall mbedtls_internal_aes_encrypt
        THUMB
//  899 void mbedtls_aes_encrypt( mbedtls_aes_context *ctx,
//  900                           const unsigned char input[16],
//  901                           unsigned char output[16] )
//  902 {
//  903     mbedtls_internal_aes_encrypt( ctx, input, output );
mbedtls_aes_encrypt:
        B.N      mbedtls_internal_aes_encrypt
//  904 }
          CFI EndBlock cfiBlock5
//  905 #endif /* !MBEDTLS_DEPRECATED_REMOVED */
//  906 
//  907 /*
//  908  * AES-ECB block decryption
//  909  */
//  910 #if !defined(MBEDTLS_AES_DECRYPT_ALT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function mbedtls_internal_aes_decrypt
          CFI NoCalls
        THUMB
//  911 int mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,
//  912                                   const unsigned char input[16],
//  913                                   unsigned char output[16] )
//  914 {
mbedtls_internal_aes_decrypt:
        PUSH     {R2,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R2,R1
//  915     int i;
//  916     uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
//  917 
//  918     RK = ctx->rk;
        LDR      R1,[R0, #+4]
//  919 
//  920     GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
        LDRB     R6,[R2, #+0]
        LDRB     R3,[R2, #+1]
        ORR      R6,R6,R3, LSL #+8
        LDRB     R3,[R2, #+2]
        ORR      R6,R6,R3, LSL #+16
        LDRB     R3,[R2, #+3]
        ORR      R6,R6,R3, LSL #+24
        LDR      R3,[R1], #+4
        EORS     R6,R3,R6
//  921     GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
        LDRB     R5,[R2, #+4]
        LDRB     R3,[R2, #+5]
        ORR      R5,R5,R3, LSL #+8
        LDRB     R3,[R2, #+6]
        ORR      R5,R5,R3, LSL #+16
        LDRB     R3,[R2, #+7]
        ORR      R5,R5,R3, LSL #+24
        LDR      R3,[R1], #+4
        EORS     R5,R3,R5
//  922     GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
        LDRB     R3,[R2, #+8]
        LDRB     R4,[R2, #+9]
        ORR      R3,R3,R4, LSL #+8
        LDRB     R4,[R2, #+10]
        ORR      R3,R3,R4, LSL #+16
        LDRB     R4,[R2, #+11]
        ORR      R3,R3,R4, LSL #+24
        LDR      R4,[R1], #+4
        EORS     R3,R4,R3
//  923     GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
        LDRB     R10,[R2, #+12]
        LDRB     R4,[R2, #+13]
        ORR      R10,R10,R4, LSL #+8
        LDRB     R4,[R2, #+14]
        ORR      R10,R10,R4, LSL #+16
        LDRB     R2,[R2, #+15]
        ORR      R10,R10,R2, LSL #+24
        LDR      R2,[R1], #+4
        EOR      R10,R2,R10
//  924 
//  925     for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
        LDR      R4,[R0, #+0]
        ASRS     R4,R4,#+1
        SUBS     R4,R4,#+1
        MOV      R0,R1
        MOV      R1,R6
        MOV      R2,R5
        B.N      ??mbedtls_internal_aes_decrypt_0
//  926     {
//  927         AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
??mbedtls_internal_aes_decrypt_1:
        LDR.N    R5,??DataTable4_5
        LDR.N    R6,??DataTable4_4
        LDR.N    R7,??DataTable4_3
        LDR.W    R12,??DataTable4_2
        LDR      LR,[R0], #+4
        AND      R8,R1,#0xFF
        LDR      R8,[R12, R8, LSL #+2]
        EOR      LR,R8,LR
        UBFX     R8,R10,#+8,#+8
        LDR      R8,[R7, R8, LSL #+2]
        EOR      LR,R8,LR
        UBFX     R8,R3,#+16,#+8
        LDR      R8,[R6, R8, LSL #+2]
        EOR      LR,R8,LR
        MOV      R8,R2
        LSR      R8,R8,#+24
        LDR      R8,[R5, R8, LSL #+2]
        EOR      LR,R8,LR
        LDR      R8,[R0], #+4
        AND      R9,R2,#0xFF
        LDR      R9,[R12, R9, LSL #+2]
        EOR      R8,R9,R8
        UBFX     R9,R1,#+8,#+8
        LDR      R9,[R7, R9, LSL #+2]
        EOR      R8,R9,R8
        UBFX     R9,R10,#+16,#+8
        LDR      R9,[R6, R9, LSL #+2]
        EOR      R8,R9,R8
        MOV      R9,R3
        LSR      R9,R9,#+24
        LDR      R9,[R5, R9, LSL #+2]
        EOR      R8,R9,R8
        LDR      R9,[R0], #+4
        AND      R11,R3,#0xFF
        LDR      R11,[R12, R11, LSL #+2]
        EOR      R9,R11,R9
        UBFX     R11,R2,#+8,#+8
        LDR      R11,[R7, R11, LSL #+2]
        EOR      R9,R11,R9
        UBFX     R11,R1,#+16,#+8
        LDR      R11,[R6, R11, LSL #+2]
        EOR      R9,R11,R9
        MOV      R11,R10
        LSR      R11,R11,#+24
        LDR      R11,[R5, R11, LSL #+2]
        EOR      R9,R11,R9
        LDR      R11,[R0], #+4
        AND      R10,R10,#0xFF
        LDR      R10,[R12, R10, LSL #+2]
        EOR      R10,R10,R11
        UBFX     R3,R3,#+8,#+8
        LDR      R3,[R7, R3, LSL #+2]
        EOR      R10,R3,R10
        UBFX     R2,R2,#+16,#+8
        LDR      R2,[R6, R2, LSL #+2]
        EOR      R10,R2,R10
        LSRS     R1,R1,#+24
        LDR      R1,[R5, R1, LSL #+2]
        EOR      R10,R1,R10
//  928         AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
        LDR      R1,[R0], #+4
        AND      R2,LR,#0xFF
        LDR      R2,[R12, R2, LSL #+2]
        EORS     R1,R2,R1
        UBFX     R2,R10,#+8,#+8
        LDR      R2,[R7, R2, LSL #+2]
        EORS     R1,R2,R1
        UBFX     R2,R9,#+16,#+8
        LDR      R2,[R6, R2, LSL #+2]
        EORS     R1,R2,R1
        MOV      R2,R8
        LSRS     R2,R2,#+24
        LDR      R2,[R5, R2, LSL #+2]
        EORS     R1,R2,R1
        LDR      R2,[R0], #+4
        AND      R3,R8,#0xFF
        LDR      R3,[R12, R3, LSL #+2]
        EORS     R2,R3,R2
        UBFX     R3,LR,#+8,#+8
        LDR      R3,[R7, R3, LSL #+2]
        EORS     R2,R3,R2
        UBFX     R3,R10,#+16,#+8
        LDR      R3,[R6, R3, LSL #+2]
        EORS     R2,R3,R2
        MOV      R3,R9
        LSRS     R3,R3,#+24
        LDR      R3,[R5, R3, LSL #+2]
        EORS     R2,R3,R2
        LDR      R3,[R0], #+4
        AND      R11,R9,#0xFF
        LDR      R11,[R12, R11, LSL #+2]
        EOR      R3,R11,R3
        UBFX     R11,R8,#+8,#+8
        LDR      R11,[R7, R11, LSL #+2]
        EOR      R3,R11,R3
        UBFX     R11,LR,#+16,#+8
        LDR      R11,[R6, R11, LSL #+2]
        EOR      R3,R11,R3
        MOV      R11,R10
        LSR      R11,R11,#+24
        LDR      R11,[R5, R11, LSL #+2]
        EOR      R3,R11,R3
        LDR      R11,[R0], #+4
        AND      R10,R10,#0xFF
        LDR      R12,[R12, R10, LSL #+2]
        EOR      R11,R12,R11
        UBFX     R12,R9,#+8,#+8
        LDR      R7,[R7, R12, LSL #+2]
        MOV      R10,R11
        EOR      R10,R7,R10
        UBFX     R7,R8,#+16,#+8
        LDR      R6,[R6, R7, LSL #+2]
        EOR      R10,R6,R10
        LSR      LR,LR,#+24
        LDR      R5,[R5, LR, LSL #+2]
        EOR      R10,R5,R10
//  929     }
        SUBS     R4,R4,#+1
??mbedtls_internal_aes_decrypt_0:
        CMP      R4,#+1
        BGE.W    ??mbedtls_internal_aes_decrypt_1
        LDR      R5,[SP, #+0]
//  930 
//  931     AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
        LDR.N    R6,??DataTable4_5
        LDR.N    R7,??DataTable4_4
        LDR.W    R12,??DataTable4_3
        LDR.W    LR,??DataTable4_2
        LDR      R8,[R0, #+0]
        AND      R4,R1,#0xFF
        LDR      R4,[LR, R4, LSL #+2]
        EOR      R8,R4,R8
        UBFX     R4,R10,#+8,#+8
        LDR      R4,[R12, R4, LSL #+2]
        EOR      R8,R4,R8
        UBFX     R4,R3,#+16,#+8
        LDR      R4,[R7, R4, LSL #+2]
        EOR      R8,R4,R8
        MOV      R4,R2
        LSRS     R4,R4,#+24
        LDR      R4,[R6, R4, LSL #+2]
        EOR      R8,R4,R8
        LDR      R9,[R0, #+4]
        AND      R4,R2,#0xFF
        LDR      R4,[LR, R4, LSL #+2]
        EOR      R9,R4,R9
        UBFX     R4,R1,#+8,#+8
        LDR      R4,[R12, R4, LSL #+2]
        EOR      R9,R4,R9
        UBFX     R4,R10,#+16,#+8
        LDR      R4,[R7, R4, LSL #+2]
        EOR      R9,R4,R9
        MOV      R4,R3
        LSRS     R4,R4,#+24
        LDR      R4,[R6, R4, LSL #+2]
        EOR      R9,R4,R9
        LDR      R11,[R0, #+8]
        AND      R4,R3,#0xFF
        LDR      R4,[LR, R4, LSL #+2]
        EOR      R11,R4,R11
        UBFX     R4,R2,#+8,#+8
        LDR      R4,[R12, R4, LSL #+2]
        EOR      R11,R4,R11
        UBFX     R4,R1,#+16,#+8
        LDR      R4,[R7, R4, LSL #+2]
        EOR      R11,R4,R11
        MOV      R4,R10
        LSRS     R4,R4,#+24
        LDR      R4,[R6, R4, LSL #+2]
        EOR      R11,R4,R11
        LDR      R4,[R0, #+12]
        AND      R10,R10,#0xFF
        LDR      LR,[LR, R10, LSL #+2]
        EOR      R4,LR,R4
        UBFX     R3,R3,#+8,#+8
        LDR      R3,[R12, R3, LSL #+2]
        EORS     R4,R3,R4
        UBFX     R2,R2,#+16,#+8
        LDR      R2,[R7, R2, LSL #+2]
        EORS     R4,R2,R4
        LSRS     R1,R1,#+24
        LDR      R1,[R6, R1, LSL #+2]
        EORS     R4,R1,R4
//  932 
//  933     X0 = *RK++ ^ \ 
//  934             ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
//  935             ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
//  936             ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
//  937             ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
        LDR.W    R3,??DataTable5_1
        LDR      R2,[R0, #+16]
        AND      R1,R8,#0xFF
        LDRB     R1,[R3, R1]
        EORS     R2,R1,R2
        UBFX     R1,R4,#+8,#+8
        LDRB     R1,[R3, R1]
        EOR      R2,R2,R1, LSL #+8
        UBFX     R1,R11,#+16,#+8
        LDRB     R1,[R3, R1]
        EOR      R2,R2,R1, LSL #+16
        MOV      R1,R9
        LSRS     R1,R1,#+24
        LDRB     R1,[R3, R1]
        EOR      R2,R2,R1, LSL #+24
//  938 
//  939     X1 = *RK++ ^ \ 
//  940             ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
//  941             ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
//  942             ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
//  943             ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
        LDR      R6,[R0, #+20]
        AND      R1,R9,#0xFF
        LDRB     R1,[R3, R1]
        EORS     R6,R1,R6
        UBFX     R1,R8,#+8,#+8
        LDRB     R1,[R3, R1]
        EOR      R6,R6,R1, LSL #+8
        UBFX     R1,R4,#+16,#+8
        LDRB     R1,[R3, R1]
        EOR      R6,R6,R1, LSL #+16
        MOV      R1,R11
        LSRS     R1,R1,#+24
        LDRB     R1,[R3, R1]
        EOR      R6,R6,R1, LSL #+24
//  944 
//  945     X2 = *RK++ ^ \ 
//  946             ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
//  947             ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
//  948             ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
//  949             ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
        LDR      R7,[R0, #+24]
        AND      R1,R11,#0xFF
        LDRB     R1,[R3, R1]
        EORS     R7,R1,R7
        UBFX     R1,R9,#+8,#+8
        LDRB     R1,[R3, R1]
        EOR      R7,R7,R1, LSL #+8
        UBFX     R1,R8,#+16,#+8
        LDRB     R1,[R3, R1]
        EOR      R7,R7,R1, LSL #+16
        MOV      R1,R4
        LSRS     R1,R1,#+24
        LDRB     R1,[R3, R1]
        EOR      R7,R7,R1, LSL #+24
//  950 
//  951     X3 = *RK++ ^ \ 
//  952             ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
//  953             ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
//  954             ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
//  955             ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
        LDR      R1,[R0, #+28]
        AND      R4,R4,#0xFF
        LDRB     R0,[R3, R4]
        EORS     R1,R0,R1
        UBFX     R0,R11,#+8,#+8
        LDRB     R0,[R3, R0]
        EOR      R1,R1,R0, LSL #+8
        UBFX     R0,R9,#+16,#+8
        LDRB     R0,[R3, R0]
        EOR      R1,R1,R0, LSL #+16
        LSR      R8,R8,#+24
        LDRB     R0,[R3, R8]
        EOR      R1,R1,R0, LSL #+24
//  956 
//  957     PUT_UINT32_LE( X0, output,  0 );
        STRB     R2,[R5, #+0]
        MOV      R0,R2
        LSRS     R0,R0,#+8
        STRB     R0,[R5, #+1]
        MOV      R0,R2
        LSRS     R0,R0,#+16
        STRB     R0,[R5, #+2]
        LSRS     R2,R2,#+24
        STRB     R2,[R5, #+3]
//  958     PUT_UINT32_LE( X1, output,  4 );
        STRB     R6,[R5, #+4]
        MOV      R0,R6
        LSRS     R0,R0,#+8
        STRB     R0,[R5, #+5]
        MOV      R0,R6
        LSRS     R0,R0,#+16
        STRB     R0,[R5, #+6]
        LSRS     R6,R6,#+24
        STRB     R6,[R5, #+7]
//  959     PUT_UINT32_LE( X2, output,  8 );
        STRB     R7,[R5, #+8]
        MOV      R0,R7
        LSRS     R0,R0,#+8
        STRB     R0,[R5, #+9]
        MOV      R0,R7
        LSRS     R0,R0,#+16
        STRB     R0,[R5, #+10]
        LSRS     R7,R7,#+24
        STRB     R7,[R5, #+11]
//  960     PUT_UINT32_LE( X3, output, 12 );
        STRB     R1,[R5, #+12]
        MOV      R0,R1
        LSRS     R0,R0,#+8
        STRB     R0,[R5, #+13]
        MOV      R0,R1
        LSRS     R0,R0,#+16
        STRB     R0,[R5, #+14]
        LSRS     R1,R1,#+24
        STRB     R1,[R5, #+15]
//  961 
//  962     return( 0 );
        MOVS     R0,#+0
        POP      {R1,R4-R11,PC}   ;; return
//  963 }
          CFI EndBlock cfiBlock6

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4:
        DATA32
        DC32     FSb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4_1:
        DATA32
        DC32     RCON

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4_2:
        DATA32
        DC32     RT0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4_3:
        DATA32
        DC32     RT1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4_4:
        DATA32
        DC32     RT2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4_5:
        DATA32
        DC32     RT3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4_6:
        DATA32
        DC32     FT3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4_7:
        DATA32
        DC32     FT2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4_8:
        DATA32
        DC32     FT1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4_9:
        DATA32
        DC32     FT0
//  964 #endif /* !MBEDTLS_AES_DECRYPT_ALT */
//  965 
//  966 #if !defined(MBEDTLS_DEPRECATED_REMOVED)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function mbedtls_aes_decrypt
          CFI FunCall mbedtls_internal_aes_decrypt
        THUMB
//  967 void mbedtls_aes_decrypt( mbedtls_aes_context *ctx,
//  968                           const unsigned char input[16],
//  969                           unsigned char output[16] )
//  970 {
//  971     mbedtls_internal_aes_decrypt( ctx, input, output );
mbedtls_aes_decrypt:
        B.N      mbedtls_internal_aes_decrypt
//  972 }
          CFI EndBlock cfiBlock7
//  973 #endif /* !MBEDTLS_DEPRECATED_REMOVED */
//  974 
//  975 /*
//  976  * AES-ECB block encryption/decryption
//  977  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function mbedtls_aes_crypt_ecb
        THUMB
//  978 int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,
//  979                     int mode,
//  980                     const unsigned char input[16],
//  981                     unsigned char output[16] )
//  982 {
mbedtls_aes_crypt_ecb:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
        MOV      R4,R2
        MOV      R2,R3
//  983 #if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
//  984     if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
//  985         return( mbedtls_aesni_crypt_ecb( ctx, mode, input, output ) );
//  986 #endif
//  987 
//  988 #if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)
//  989     if( aes_padlock_ace )
//  990     {
//  991         if( mbedtls_padlock_xcryptecb( ctx, mode, input, output ) == 0 )
//  992             return( 0 );
//  993 
//  994         // If padlock data misaligned, we just fall back to
//  995         // unaccelerated mode
//  996         //
//  997     }
//  998 #endif
//  999 
// 1000     if( mode == MBEDTLS_AES_ENCRYPT )
        CMP      R1,#+1
        MOV      R1,R4
        BNE.N    ??mbedtls_aes_crypt_ecb_0
// 1001         return( mbedtls_internal_aes_encrypt( ctx, input, output ) );
        POP      {R3,R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_internal_aes_encrypt
        B.W      mbedtls_internal_aes_encrypt
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 1002     else
// 1003         return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
??mbedtls_aes_crypt_ecb_0:
        POP      {R3,R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_internal_aes_decrypt
        B.N      mbedtls_internal_aes_decrypt
// 1004 }
          CFI EndBlock cfiBlock8
// 1005 
// 1006 #if defined(MBEDTLS_CIPHER_MODE_CBC)
// 1007 /*
// 1008  * AES-CBC buffer encryption/decryption
// 1009  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function mbedtls_aes_crypt_cbc
        THUMB
// 1010 int mbedtls_aes_crypt_cbc( mbedtls_aes_context *ctx,
// 1011                     int mode,
// 1012                     size_t length,
// 1013                     unsigned char iv[16],
// 1014                     const unsigned char *input,
// 1015                     unsigned char *output )
// 1016 {
mbedtls_aes_crypt_cbc:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOV      R8,R0
        MOV      R5,R1
        MOV      R4,R2
        MOV      R9,R3
// 1017     int i;
// 1018     unsigned char temp[16];
// 1019 
// 1020     if( length % 16 )
        TST      R4,#0xF
        BEQ.N    ??mbedtls_aes_crypt_cbc_0
// 1021         return( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
        MVN      R0,#+33
        B.N      ??mbedtls_aes_crypt_cbc_1
??mbedtls_aes_crypt_cbc_0:
        LDR      R6,[SP, #+48]
        LDR      R7,[SP, #+52]
// 1022 
// 1023 #if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)
// 1024     if( aes_padlock_ace )
// 1025     {
// 1026         if( mbedtls_padlock_xcryptcbc( ctx, mode, length, iv, input, output ) == 0 )
// 1027             return( 0 );
// 1028 
// 1029         // If padlock data misaligned, we just fall back to
// 1030         // unaccelerated mode
// 1031         //
// 1032     }
// 1033 #endif
// 1034 
// 1035     if( mode == MBEDTLS_AES_DECRYPT )
        CMP      R5,#+0
        BNE.N    ??mbedtls_aes_crypt_cbc_2
        CMP      R4,#+0
        B.N      ??mbedtls_aes_crypt_cbc_3
// 1036     {
// 1037         while( length > 0 )
// 1038         {
// 1039             memcpy( temp, input, 16 );
// 1040             mbedtls_aes_crypt_ecb( ctx, mode, input, output );
// 1041 
// 1042             for( i = 0; i < 16; i++ )
// 1043                 output[i] = (unsigned char)( output[i] ^ iv[i] );
??mbedtls_aes_crypt_cbc_4:
        LDRB     R1,[R7, R0]
        LDRB     R2,[R9, R0]
        EORS     R1,R2,R1
        STRB     R1,[R7, R0]
        ADDS     R0,R0,#+1
??mbedtls_aes_crypt_cbc_5:
        CMP      R0,#+16
        BLT.N    ??mbedtls_aes_crypt_cbc_4
// 1044 
// 1045             memcpy( iv, temp, 16 );
        MOVS     R2,#+16
        MOV      R1,SP
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1046 
// 1047             input  += 16;
        ADDS     R6,R6,#+16
// 1048             output += 16;
        ADDS     R7,R7,#+16
// 1049             length -= 16;
        SUBS     R4,R4,#+16
??mbedtls_aes_crypt_cbc_3:
        BEQ.N    ??mbedtls_aes_crypt_cbc_6
        MOVS     R2,#+16
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R3,R7
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R8
          CFI FunCall mbedtls_aes_crypt_ecb
        BL       mbedtls_aes_crypt_ecb
        MOVS     R0,#+0
        B.N      ??mbedtls_aes_crypt_cbc_5
// 1050         }
// 1051     }
// 1052     else
// 1053     {
// 1054         while( length > 0 )
// 1055         {
// 1056             for( i = 0; i < 16; i++ )
// 1057                 output[i] = (unsigned char)( input[i] ^ iv[i] );
??mbedtls_aes_crypt_cbc_7:
        LDRB     R1,[R6, R0]
        LDRB     R2,[R9, R0]
        EORS     R1,R2,R1
        STRB     R1,[R7, R0]
        ADDS     R0,R0,#+1
??mbedtls_aes_crypt_cbc_8:
        CMP      R0,#+16
        BLT.N    ??mbedtls_aes_crypt_cbc_7
// 1058 
// 1059             mbedtls_aes_crypt_ecb( ctx, mode, output, output );
        MOV      R3,R7
        MOV      R2,R7
        MOV      R1,R5
        MOV      R0,R8
          CFI FunCall mbedtls_aes_crypt_ecb
        BL       mbedtls_aes_crypt_ecb
// 1060             memcpy( iv, output, 16 );
        MOVS     R2,#+16
        MOV      R1,R7
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1061 
// 1062             input  += 16;
        ADDS     R6,R6,#+16
// 1063             output += 16;
        ADDS     R7,R7,#+16
// 1064             length -= 16;
        SUBS     R4,R4,#+16
??mbedtls_aes_crypt_cbc_2:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_crypt_cbc_6
        MOVS     R0,#+0
        B.N      ??mbedtls_aes_crypt_cbc_8
// 1065         }
// 1066     }
// 1067 
// 1068     return( 0 );
??mbedtls_aes_crypt_cbc_6:
        MOVS     R0,#+0
??mbedtls_aes_crypt_cbc_1:
        ADD      SP,SP,#+20
          CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
// 1069 }
          CFI EndBlock cfiBlock9
// 1070 #endif /* MBEDTLS_CIPHER_MODE_CBC */
// 1071 
// 1072 #if defined(MBEDTLS_CIPHER_MODE_XTS)
// 1073 
// 1074 /* Endianess with 64 bits values */
// 1075 #ifndef GET_UINT64_LE
// 1076 #define GET_UINT64_LE(n,b,i)                            \ 
// 1077 {                                                       \ 
// 1078     (n) = ( (uint64_t) (b)[(i) + 7] << 56 )             \ 
// 1079         | ( (uint64_t) (b)[(i) + 6] << 48 )             \ 
// 1080         | ( (uint64_t) (b)[(i) + 5] << 40 )             \ 
// 1081         | ( (uint64_t) (b)[(i) + 4] << 32 )             \ 
// 1082         | ( (uint64_t) (b)[(i) + 3] << 24 )             \ 
// 1083         | ( (uint64_t) (b)[(i) + 2] << 16 )             \ 
// 1084         | ( (uint64_t) (b)[(i) + 1] <<  8 )             \ 
// 1085         | ( (uint64_t) (b)[(i)    ]       );            \ 
// 1086 }
// 1087 #endif
// 1088 
// 1089 #ifndef PUT_UINT64_LE
// 1090 #define PUT_UINT64_LE(n,b,i)                            \ 
// 1091 {                                                       \ 
// 1092     (b)[(i) + 7] = (unsigned char) ( (n) >> 56 );       \ 
// 1093     (b)[(i) + 6] = (unsigned char) ( (n) >> 48 );       \ 
// 1094     (b)[(i) + 5] = (unsigned char) ( (n) >> 40 );       \ 
// 1095     (b)[(i) + 4] = (unsigned char) ( (n) >> 32 );       \ 
// 1096     (b)[(i) + 3] = (unsigned char) ( (n) >> 24 );       \ 
// 1097     (b)[(i) + 2] = (unsigned char) ( (n) >> 16 );       \ 
// 1098     (b)[(i) + 1] = (unsigned char) ( (n) >>  8 );       \ 
// 1099     (b)[(i)    ] = (unsigned char) ( (n)       );       \ 
// 1100 }
// 1101 #endif
// 1102 
// 1103 typedef unsigned char mbedtls_be128[16];
// 1104 
// 1105 /*
// 1106  * GF(2^128) multiplication function
// 1107  *
// 1108  * This function multiplies a field element by x in the polynomial field
// 1109  * representation. It uses 64-bit word operations to gain speed but compensates
// 1110  * for machine endianess and hence works correctly on both big and little
// 1111  * endian machines.
// 1112  */
// 1113 static void mbedtls_gf128mul_x_ble( unsigned char r[16],
// 1114                                     const unsigned char x[16] )
// 1115 {
// 1116     uint64_t a, b, ra, rb;
// 1117 
// 1118     GET_UINT64_LE( a, x, 0 );
// 1119     GET_UINT64_LE( b, x, 8 );
// 1120 
// 1121     ra = ( a << 1 )  ^ 0x0087 >> ( 8 - ( ( b >> 63 ) << 3 ) );
// 1122     rb = ( a >> 63 ) | ( b << 1 );
// 1123 
// 1124     PUT_UINT64_LE( ra, r, 0 );
// 1125     PUT_UINT64_LE( rb, r, 8 );
// 1126 }
// 1127 
// 1128 /*
// 1129  * AES-XTS buffer encryption/decryption
// 1130  */
// 1131 int mbedtls_aes_crypt_xts( mbedtls_aes_xts_context *ctx,
// 1132                            int mode,
// 1133                            size_t length,
// 1134                            const unsigned char data_unit[16],
// 1135                            const unsigned char *input,
// 1136                            unsigned char *output )
// 1137 {
// 1138     int ret;
// 1139     size_t blocks = length / 16;
// 1140     size_t leftover = length % 16;
// 1141     unsigned char tweak[16];
// 1142     unsigned char prev_tweak[16];
// 1143     unsigned char tmp[16];
// 1144 
// 1145     /* Sectors must be at least 16 bytes. */
// 1146     if( length < 16 )
// 1147         return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
// 1148 
// 1149     /* NIST SP 80-38E disallows data units larger than 2**20 blocks. */
// 1150     if( length > ( 1 << 20 ) * 16 )
// 1151         return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
// 1152 
// 1153     /* Compute the tweak. */
// 1154     ret = mbedtls_aes_crypt_ecb( &ctx->tweak, MBEDTLS_AES_ENCRYPT,
// 1155                                  data_unit, tweak );
// 1156     if( ret != 0 )
// 1157         return( ret );
// 1158 
// 1159     while( blocks-- )
// 1160     {
// 1161         size_t i;
// 1162 
// 1163         if( leftover && ( mode == MBEDTLS_AES_DECRYPT ) && blocks == 0 )
// 1164         {
// 1165             /* We are on the last block in a decrypt operation that has
// 1166              * leftover bytes, so we need to use the next tweak for this block,
// 1167              * and this tweak for the lefover bytes. Save the current tweak for
// 1168              * the leftovers and then update the current tweak for use on this,
// 1169              * the last full block. */
// 1170             memcpy( prev_tweak, tweak, sizeof( tweak ) );
// 1171             mbedtls_gf128mul_x_ble( tweak, tweak );
// 1172         }
// 1173 
// 1174         for( i = 0; i < 16; i++ )
// 1175             tmp[i] = input[i] ^ tweak[i];
// 1176 
// 1177         ret = mbedtls_aes_crypt_ecb( &ctx->crypt, mode, tmp, tmp );
// 1178         if( ret != 0 )
// 1179             return( ret );
// 1180 
// 1181         for( i = 0; i < 16; i++ )
// 1182             output[i] = tmp[i] ^ tweak[i];
// 1183 
// 1184         /* Update the tweak for the next block. */
// 1185         mbedtls_gf128mul_x_ble( tweak, tweak );
// 1186 
// 1187         output += 16;
// 1188         input += 16;
// 1189     }
// 1190 
// 1191     if( leftover )
// 1192     {
// 1193         /* If we are on the leftover bytes in a decrypt operation, we need to
// 1194          * use the previous tweak for these bytes (as saved in prev_tweak). */
// 1195         unsigned char *t = mode == MBEDTLS_AES_DECRYPT ? prev_tweak : tweak;
// 1196 
// 1197         /* We are now on the final part of the data unit, which doesn't divide
// 1198          * evenly by 16. It's time for ciphertext stealing. */
// 1199         size_t i;
// 1200         unsigned char *prev_output = output - 16;
// 1201 
// 1202         /* Copy ciphertext bytes from the previous block to our output for each
// 1203          * byte of cyphertext we won't steal. At the same time, copy the
// 1204          * remainder of the input for this final round (since the loop bounds
// 1205          * are the same). */
// 1206         for( i = 0; i < leftover; i++ )
// 1207         {
// 1208             output[i] = prev_output[i];
// 1209             tmp[i] = input[i] ^ t[i];
// 1210         }
// 1211 
// 1212         /* Copy ciphertext bytes from the previous block for input in this
// 1213          * round. */
// 1214         for( ; i < 16; i++ )
// 1215             tmp[i] = prev_output[i] ^ t[i];
// 1216 
// 1217         ret = mbedtls_aes_crypt_ecb( &ctx->crypt, mode, tmp, tmp );
// 1218         if( ret != 0 )
// 1219             return ret;
// 1220 
// 1221         /* Write the result back to the previous block, overriding the previous
// 1222          * output we copied. */
// 1223         for( i = 0; i < 16; i++ )
// 1224             prev_output[i] = tmp[i] ^ t[i];
// 1225     }
// 1226 
// 1227     return( 0 );
// 1228 }
// 1229 #endif /* MBEDTLS_CIPHER_MODE_XTS */
// 1230 
// 1231 #if defined(MBEDTLS_CIPHER_MODE_CFB)
// 1232 /*
// 1233  * AES-CFB128 buffer encryption/decryption
// 1234  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function mbedtls_aes_crypt_cfb128
        THUMB
// 1235 int mbedtls_aes_crypt_cfb128( mbedtls_aes_context *ctx,
// 1236                        int mode,
// 1237                        size_t length,
// 1238                        size_t *iv_off,
// 1239                        unsigned char iv[16],
// 1240                        const unsigned char *input,
// 1241                        unsigned char *output )
// 1242 {
mbedtls_aes_crypt_cfb128:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R6,R0
        MOV      R10,R2
        MOV      R5,R3
        LDR      R7,[SP, #+32]
        LDR      R8,[SP, #+36]
        LDR      R9,[SP, #+40]
// 1243     int c;
// 1244     size_t n = *iv_off;
        LDR      R4,[R5, #+0]
// 1245 
// 1246     if( mode == MBEDTLS_AES_DECRYPT )
        CMP      R1,#+0
        BNE.N    ??mbedtls_aes_crypt_cfb128_0
// 1247     {
// 1248         while( length-- )
??mbedtls_aes_crypt_cfb128_1:
        MOV      R0,R10
        SUB      R10,R0,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_aes_crypt_cfb128_2
// 1249         {
// 1250             if( n == 0 )
        CMP      R4,#+0
        BNE.N    ??mbedtls_aes_crypt_cfb128_3
// 1251                 mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
        MOV      R3,R7
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall mbedtls_aes_crypt_ecb
        BL       mbedtls_aes_crypt_ecb
// 1252 
// 1253             c = *input++;
??mbedtls_aes_crypt_cfb128_3:
        LDRB     R0,[R8], #+1
// 1254             *output++ = (unsigned char)( c ^ iv[n] );
        LDRB     R1,[R7, R4]
        EORS     R1,R1,R0
        STRB     R1,[R9], #+1
// 1255             iv[n] = (unsigned char) c;
        STRB     R0,[R7, R4]
// 1256 
// 1257             n = ( n + 1 ) & 0x0F;
        ADDS     R4,R4,#+1
        AND      R4,R4,#0xF
        B.N      ??mbedtls_aes_crypt_cfb128_1
// 1258         }
// 1259     }
// 1260     else
// 1261     {
// 1262         while( length-- )
// 1263         {
// 1264             if( n == 0 )
??mbedtls_aes_crypt_cfb128_4:
        CMP      R4,#+0
        BNE.N    ??mbedtls_aes_crypt_cfb128_5
// 1265                 mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
        MOV      R3,R7
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall mbedtls_aes_crypt_ecb
        BL       mbedtls_aes_crypt_ecb
// 1266 
// 1267             iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );
??mbedtls_aes_crypt_cfb128_5:
        LDRB     R0,[R7, R4]
        LDRB     R1,[R8], #+1
        EORS     R0,R1,R0
        STRB     R0,[R9], #+1
        STRB     R0,[R7, R4]
// 1268 
// 1269             n = ( n + 1 ) & 0x0F;
        ADDS     R4,R4,#+1
        AND      R4,R4,#0xF
// 1270         }
??mbedtls_aes_crypt_cfb128_0:
        MOV      R0,R10
        SUB      R10,R0,#+1
        CMP      R0,#+0
        BNE.N    ??mbedtls_aes_crypt_cfb128_4
// 1271     }
// 1272 
// 1273     *iv_off = n;
??mbedtls_aes_crypt_cfb128_2:
        STR      R4,[R5, #+0]
// 1274 
// 1275     return( 0 );
        MOVS     R0,#+0
        POP      {R4-R10,PC}      ;; return
// 1276 }
          CFI EndBlock cfiBlock10
// 1277 
// 1278 /*
// 1279  * AES-CFB8 buffer encryption/decryption
// 1280  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function mbedtls_aes_crypt_cfb8
        THUMB
// 1281 int mbedtls_aes_crypt_cfb8( mbedtls_aes_context *ctx,
// 1282                        int mode,
// 1283                        size_t length,
// 1284                        unsigned char iv[16],
// 1285                        const unsigned char *input,
// 1286                        unsigned char *output )
// 1287 {
mbedtls_aes_crypt_cfb8:
        PUSH     {R4-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+28
        SUB      SP,SP,#+20
          CFI CFA R13+48
        MOV      R7,R0
        MOV      R4,R1
        MOV      R8,R2
        MOV      R9,R3
        LDR      R5,[SP, #+48]
        LDR      R6,[SP, #+52]
        B.N      ??mbedtls_aes_crypt_cfb8_0
// 1288     unsigned char c;
// 1289     unsigned char ov[17];
// 1290 
// 1291     while( length-- )
// 1292     {
// 1293         memcpy( ov, iv, 16 );
??mbedtls_aes_crypt_cfb8_1:
        MOVS     R2,#+16
        MOV      R1,R9
        MOV      R0,SP
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1294         mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
        MOV      R3,R9
        MOV      R2,R9
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_aes_crypt_ecb
        BL       mbedtls_aes_crypt_ecb
// 1295 
// 1296         if( mode == MBEDTLS_AES_DECRYPT )
        CMP      R4,#+0
        BNE.N    ??mbedtls_aes_crypt_cfb8_2
// 1297             ov[16] = *input;
        LDRB     R0,[R5, #+0]
        STRB     R0,[SP, #+16]
// 1298 
// 1299         c = *output++ = (unsigned char)( iv[0] ^ *input++ );
??mbedtls_aes_crypt_cfb8_2:
        LDRB     R0,[R9, #+0]
        LDRB     R1,[R5], #+1
        EORS     R0,R1,R0
        STRB     R0,[R6], #+1
// 1300 
// 1301         if( mode == MBEDTLS_AES_ENCRYPT )
        CMP      R4,#+1
        BNE.N    ??mbedtls_aes_crypt_cfb8_3
// 1302             ov[16] = c;
        STRB     R0,[SP, #+16]
// 1303 
// 1304         memcpy( iv, ov + 1, 16 );
??mbedtls_aes_crypt_cfb8_3:
        MOVS     R2,#+16
        ADD      R1,SP,#+1
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1305     }
??mbedtls_aes_crypt_cfb8_0:
        MOV      R0,R8
        SUB      R8,R0,#+1
        CMP      R0,#+0
        BNE.N    ??mbedtls_aes_crypt_cfb8_1
// 1306 
// 1307     return( 0 );
        MOVS     R0,#+0
        ADD      SP,SP,#+20
          CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
// 1308 }
          CFI EndBlock cfiBlock11
// 1309 #endif /* MBEDTLS_CIPHER_MODE_CFB */
// 1310 
// 1311 #if defined(MBEDTLS_CIPHER_MODE_OFB)
// 1312 /*
// 1313  * AES-OFB (Output Feedback Mode) buffer encryption/decryption
// 1314  */
// 1315 int mbedtls_aes_crypt_ofb( mbedtls_aes_context *ctx,
// 1316                            size_t length,
// 1317                            size_t *iv_off,
// 1318                            unsigned char iv[16],
// 1319                            const unsigned char *input,
// 1320                            unsigned char *output )
// 1321 {
// 1322     int ret = 0;
// 1323     size_t n = *iv_off;
// 1324 
// 1325     while( length-- )
// 1326     {
// 1327         if( n == 0 )
// 1328         {
// 1329             ret = mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
// 1330             if( ret != 0 )
// 1331                 goto exit;
// 1332         }
// 1333         *output++ =  *input++ ^ iv[n];
// 1334 
// 1335         n = ( n + 1 ) & 0x0F;
// 1336     }
// 1337 
// 1338     *iv_off = n;
// 1339 
// 1340 exit:
// 1341     return( ret );
// 1342 }
// 1343 #endif /* MBEDTLS_CIPHER_MODE_OFB */
// 1344 
// 1345 #if defined(MBEDTLS_CIPHER_MODE_CTR)
// 1346 /*
// 1347  * AES-CTR buffer encryption/decryption
// 1348  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function mbedtls_aes_crypt_ctr
        THUMB
// 1349 int mbedtls_aes_crypt_ctr( mbedtls_aes_context *ctx,
// 1350                        size_t length,
// 1351                        size_t *nc_off,
// 1352                        unsigned char nonce_counter[16],
// 1353                        unsigned char stream_block[16],
// 1354                        const unsigned char *input,
// 1355                        unsigned char *output )
// 1356 {
mbedtls_aes_crypt_ctr:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
        MOV      R6,R1
        MOV      R7,R2
        MOV      R11,R3
        LDR      R8,[SP, #+40]
        LDR      R9,[SP, #+44]
        LDR      R10,[SP, #+48]
// 1357     int c, i;
// 1358     size_t n = *nc_off;
        LDR      R4,[R7, #+0]
// 1359 
// 1360     if ( n > 0x0F )
        CMP      R4,#+16
        BCC.N    ??mbedtls_aes_crypt_ctr_0
// 1361         return( MBEDTLS_ERR_AES_BAD_INPUT_DATA );
        MVN      R0,#+32
        B.N      ??mbedtls_aes_crypt_ctr_1
// 1362 
// 1363     while( length-- )
// 1364     {
// 1365         if( n == 0 ) {
// 1366             mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, nonce_counter, stream_block );
// 1367 
// 1368             for( i = 16; i > 0; i-- )
// 1369                 if( ++nonce_counter[i - 1] != 0 )
// 1370                     break;
// 1371         }
// 1372         c = *input++;
// 1373         *output++ = (unsigned char)( c ^ stream_block[n] );
// 1374 
// 1375         n = ( n + 1 ) & 0x0F;
// 1376     }
// 1377 
// 1378     *nc_off = n;
??mbedtls_aes_crypt_ctr_2:
        STR      R4,[R7, #+0]
// 1379 
// 1380     return( 0 );
        MOVS     R0,#+0
??mbedtls_aes_crypt_ctr_1:
        POP      {R1,R4-R11,PC}   ;; return
??mbedtls_aes_crypt_ctr_3:
        LDRB     R1,[R9], #+1
        LDRB     R0,[R8, R4]
        EORS     R1,R0,R1
        STRB     R1,[R10], #+1
        ADDS     R4,R4,#+1
        AND      R4,R4,#0xF
??mbedtls_aes_crypt_ctr_0:
        MOV      R0,R6
        SUBS     R6,R0,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_aes_crypt_ctr_2
        CMP      R4,#+0
        BNE.N    ??mbedtls_aes_crypt_ctr_3
        MOV      R3,R8
        MOV      R2,R11
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_aes_crypt_ecb
        BL       mbedtls_aes_crypt_ecb
        MOVS     R1,#+16
??mbedtls_aes_crypt_ctr_4:
        CMP      R1,#+1
        BLT.N    ??mbedtls_aes_crypt_ctr_3
        ADD      R0,R11,R1
        LDRB     R0,[R0, #-1]
        ADDS     R0,R0,#+1
        ADD      R2,R11,R1
        STRB     R0,[R2, #-1]
        ADD      R0,R11,R1
        LDRB     R0,[R0, #-1]
        CMP      R0,#+0
        BNE.N    ??mbedtls_aes_crypt_ctr_3
        SUBS     R1,R1,#+1
        B.N      ??mbedtls_aes_crypt_ctr_4
// 1381 }
          CFI EndBlock cfiBlock12
// 1382 #endif /* MBEDTLS_CIPHER_MODE_CTR */
// 1383 
// 1384 #endif /* !MBEDTLS_AES_ALT */
// 1385 
// 1386 #if defined(MBEDTLS_SELF_TEST)
// 1387 /*
// 1388  * AES test vectors from:
// 1389  *
// 1390  * http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip
// 1391  */

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1392 static const unsigned char aes_test_ecb_dec[3][16] =
aes_test_ecb_dec:
        DATA8
        DC8 68, 65, 106, 194, 209, 245, 60, 88, 51, 3, 145, 126, 107, 233, 235
        DC8 224, 72, 227, 30, 158, 37, 103, 24, 242, 146, 41, 49, 156, 25, 241
        DC8 91, 164, 5, 140, 207, 253, 187, 203, 56, 45, 31, 111, 86, 88, 93
        DC8 138, 74, 222
// 1393 {
// 1394     { 0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,
// 1395       0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0 },
// 1396     { 0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,
// 1397       0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4 },
// 1398     { 0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,
// 1399       0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE }
// 1400 };
// 1401 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1402 static const unsigned char aes_test_ecb_enc[3][16] =
aes_test_ecb_enc:
        DATA8
        DC8 195, 76, 5, 44, 192, 218, 141, 115, 69, 26, 254, 95, 3, 190, 41
        DC8 127, 243, 246, 117, 42, 232, 215, 131, 17, 56, 240, 65, 86, 6, 49
        DC8 177, 20, 139, 121, 238, 204, 147, 160, 238, 93, 255, 48, 180, 234
        DC8 33, 99, 109, 164
// 1403 {
// 1404     { 0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,
// 1405       0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F },
// 1406     { 0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,
// 1407       0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14 },
// 1408     { 0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,
// 1409       0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4 }
// 1410 };
// 1411 
// 1412 #if defined(MBEDTLS_CIPHER_MODE_CBC)

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1413 static const unsigned char aes_test_cbc_dec[3][16] =
aes_test_cbc_dec:
        DATA8
        DC8 250, 202, 55, 224, 176, 200, 83, 115, 223, 112, 110, 115, 247, 201
        DC8 175, 134, 93, 246, 120, 221, 23, 186, 78, 117, 182, 23, 104, 198
        DC8 173, 239, 124, 123, 72, 4, 225, 129, 143, 230, 41, 117, 25, 163
        DC8 232, 140, 87, 49, 4, 19
// 1414 {
// 1415     { 0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,
// 1416       0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86 },
// 1417     { 0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,
// 1418       0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B },
// 1419     { 0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,
// 1420       0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13 }
// 1421 };
// 1422 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1423 static const unsigned char aes_test_cbc_enc[3][16] =
aes_test_cbc_enc:
        DATA8
        DC8 138, 5, 252, 94, 9, 90, 244, 132, 138, 8, 211, 40, 211, 104, 142
        DC8 61, 123, 217, 102, 213, 58, 216, 193, 187, 133, 210, 173, 250, 232
        DC8 123, 177, 4, 254, 60, 83, 101, 62, 47, 69, 181, 111, 205, 136, 178
        DC8 204, 137, 143, 240
// 1424 {
// 1425     { 0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,
// 1426       0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D },
// 1427     { 0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,
// 1428       0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04 },
// 1429     { 0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,
// 1430       0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0 }
// 1431 };
// 1432 #endif /* MBEDTLS_CIPHER_MODE_CBC */
// 1433 
// 1434 #if defined(MBEDTLS_CIPHER_MODE_CFB)
// 1435 /*
// 1436  * AES-CFB128 test vectors from:
// 1437  *
// 1438  * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
// 1439  */

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1440 static const unsigned char aes_test_cfb128_key[3][32] =
aes_test_cfb128_key:
        DATA8
        DC8 43, 126, 21, 22, 40, 174, 210, 166, 171, 247, 21, 136, 9, 207, 79
        DC8 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 115, 176
        DC8 247, 218, 14, 100, 82, 200, 16, 243, 43, 128, 144, 121, 229, 98
        DC8 248, 234, 210, 82, 44, 107, 123, 0, 0, 0, 0, 0, 0, 0, 0, 96, 61
        DC8 235, 16, 21, 202, 113, 190, 43, 115, 174, 240, 133, 125, 119, 129
        DC8 31, 53, 44, 7, 59, 97, 8, 215, 45, 152, 16, 163, 9, 20, 223, 244
// 1441 {
// 1442     { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
// 1443       0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C },
// 1444     { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,
// 1445       0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,
// 1446       0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B },
// 1447     { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,
// 1448       0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,
// 1449       0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,
// 1450       0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 }
// 1451 };
// 1452 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1453 static const unsigned char aes_test_cfb128_iv[16] =
aes_test_cfb128_iv:
        DATA8
        DC8 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
// 1454 {
// 1455     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
// 1456     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
// 1457 };
// 1458 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1459 static const unsigned char aes_test_cfb128_pt[64] =
aes_test_cfb128_pt:
        DATA8
        DC8 107, 193, 190, 226, 46, 64, 159, 150, 233, 61, 126, 17, 115, 147
        DC8 23, 42, 174, 45, 138, 87, 30, 3, 172, 156, 158, 183, 111, 172, 69
        DC8 175, 142, 81, 48, 200, 28, 70, 163, 92, 228, 17, 229, 251, 193, 25
        DC8 26, 10, 82, 239, 246, 159, 36, 69, 223, 79, 155, 23, 173, 43, 65
        DC8 123, 230, 108, 55, 16
// 1460 {
// 1461     0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
// 1462     0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,
// 1463     0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
// 1464     0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,
// 1465     0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
// 1466     0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,
// 1467     0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,
// 1468     0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
// 1469 };
// 1470 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1471 static const unsigned char aes_test_cfb128_ct[3][64] =
aes_test_cfb128_ct:
        DATA8
        DC8 59, 63, 217, 46, 183, 45, 173, 32, 51, 52, 73, 248, 232, 60, 251
        DC8 74, 200, 166, 69, 55, 160, 179, 169, 63, 205, 227, 205, 173, 159
        DC8 28, 229, 139, 38, 117, 31, 103, 163, 203, 177, 64, 177, 128, 140
        DC8 241, 135, 164, 244, 223, 192, 75, 5, 53, 124, 93, 28, 14, 234, 196
        DC8 198, 111, 159, 247, 242, 230, 205, 200, 13, 111, 221, 241, 140, 171
        DC8 52, 194, 89, 9, 201, 154, 65, 116, 103, 206, 127, 127, 129, 23, 54
        DC8 33, 150, 26, 43, 112, 23, 29, 61, 122, 46, 30, 138, 29, 213, 155
        DC8 136, 177, 200, 230, 15, 237, 30, 250, 196, 201, 192, 95, 159, 156
        DC8 169, 131, 79, 160, 66, 174, 143, 186, 88, 75, 9, 255, 220, 126, 132
        DC8 191, 218, 121, 22, 75, 126, 205, 132, 134, 152, 93, 56, 96, 57, 255
        DC8 237, 20, 59, 40, 177, 200, 50, 17, 60, 99, 49, 229, 64, 123, 223
        DC8 16, 19, 36, 21, 229, 75, 146, 161, 62, 208, 168, 38, 122, 226, 249
        DC8 117, 163, 133, 116, 26, 185, 206, 248, 32, 49, 98, 61, 85, 177, 228
        DC8 113
// 1472 {
// 1473     { 0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,
// 1474       0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,
// 1475       0xC8, 0xA6, 0x45, 0x37, 0xA0, 0xB3, 0xA9, 0x3F,
// 1476       0xCD, 0xE3, 0xCD, 0xAD, 0x9F, 0x1C, 0xE5, 0x8B,
// 1477       0x26, 0x75, 0x1F, 0x67, 0xA3, 0xCB, 0xB1, 0x40,
// 1478       0xB1, 0x80, 0x8C, 0xF1, 0x87, 0xA4, 0xF4, 0xDF,
// 1479       0xC0, 0x4B, 0x05, 0x35, 0x7C, 0x5D, 0x1C, 0x0E,
// 1480       0xEA, 0xC4, 0xC6, 0x6F, 0x9F, 0xF7, 0xF2, 0xE6 },
// 1481     { 0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,
// 1482       0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,
// 1483       0x67, 0xCE, 0x7F, 0x7F, 0x81, 0x17, 0x36, 0x21,
// 1484       0x96, 0x1A, 0x2B, 0x70, 0x17, 0x1D, 0x3D, 0x7A,
// 1485       0x2E, 0x1E, 0x8A, 0x1D, 0xD5, 0x9B, 0x88, 0xB1,
// 1486       0xC8, 0xE6, 0x0F, 0xED, 0x1E, 0xFA, 0xC4, 0xC9,
// 1487       0xC0, 0x5F, 0x9F, 0x9C, 0xA9, 0x83, 0x4F, 0xA0,
// 1488       0x42, 0xAE, 0x8F, 0xBA, 0x58, 0x4B, 0x09, 0xFF },
// 1489     { 0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,
// 1490       0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,
// 1491       0x39, 0xFF, 0xED, 0x14, 0x3B, 0x28, 0xB1, 0xC8,
// 1492       0x32, 0x11, 0x3C, 0x63, 0x31, 0xE5, 0x40, 0x7B,
// 1493       0xDF, 0x10, 0x13, 0x24, 0x15, 0xE5, 0x4B, 0x92,
// 1494       0xA1, 0x3E, 0xD0, 0xA8, 0x26, 0x7A, 0xE2, 0xF9,
// 1495       0x75, 0xA3, 0x85, 0x74, 0x1A, 0xB9, 0xCE, 0xF8,
// 1496       0x20, 0x31, 0x62, 0x3D, 0x55, 0xB1, 0xE4, 0x71 }
// 1497 };
// 1498 #endif /* MBEDTLS_CIPHER_MODE_CFB */
// 1499 
// 1500 #if defined(MBEDTLS_CIPHER_MODE_OFB)
// 1501 /*
// 1502  * AES-OFB test vectors from:
// 1503  *
// 1504  * https://csrc.nist.gov/publications/detail/sp/800-38a/final
// 1505  */
// 1506 static const unsigned char aes_test_ofb_key[3][32] =
// 1507 {
// 1508     { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
// 1509       0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C },
// 1510     { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,
// 1511       0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,
// 1512       0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B },
// 1513     { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,
// 1514       0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,
// 1515       0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,
// 1516       0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 }
// 1517 };
// 1518 
// 1519 static const unsigned char aes_test_ofb_iv[16] =
// 1520 {
// 1521     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
// 1522     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
// 1523 };
// 1524 
// 1525 static const unsigned char aes_test_ofb_pt[64] =
// 1526 {
// 1527     0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
// 1528     0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,
// 1529     0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
// 1530     0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,
// 1531     0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
// 1532     0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,
// 1533     0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,
// 1534     0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
// 1535 };
// 1536 
// 1537 static const unsigned char aes_test_ofb_ct[3][64] =
// 1538 {
// 1539     { 0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,
// 1540       0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,
// 1541       0x77, 0x89, 0x50, 0x8d, 0x16, 0x91, 0x8f, 0x03,
// 1542       0xf5, 0x3c, 0x52, 0xda, 0xc5, 0x4e, 0xd8, 0x25,
// 1543       0x97, 0x40, 0x05, 0x1e, 0x9c, 0x5f, 0xec, 0xf6,
// 1544       0x43, 0x44, 0xf7, 0xa8, 0x22, 0x60, 0xed, 0xcc,
// 1545       0x30, 0x4c, 0x65, 0x28, 0xf6, 0x59, 0xc7, 0x78,
// 1546       0x66, 0xa5, 0x10, 0xd9, 0xc1, 0xd6, 0xae, 0x5e },
// 1547     { 0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,
// 1548       0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,
// 1549       0xfc, 0xc2, 0x8b, 0x8d, 0x4c, 0x63, 0x83, 0x7c,
// 1550       0x09, 0xe8, 0x17, 0x00, 0xc1, 0x10, 0x04, 0x01,
// 1551       0x8d, 0x9a, 0x9a, 0xea, 0xc0, 0xf6, 0x59, 0x6f,
// 1552       0x55, 0x9c, 0x6d, 0x4d, 0xaf, 0x59, 0xa5, 0xf2,
// 1553       0x6d, 0x9f, 0x20, 0x08, 0x57, 0xca, 0x6c, 0x3e,
// 1554       0x9c, 0xac, 0x52, 0x4b, 0xd9, 0xac, 0xc9, 0x2a },
// 1555     { 0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,
// 1556       0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,
// 1557       0x4f, 0xeb, 0xdc, 0x67, 0x40, 0xd2, 0x0b, 0x3a,
// 1558       0xc8, 0x8f, 0x6a, 0xd8, 0x2a, 0x4f, 0xb0, 0x8d,
// 1559       0x71, 0xab, 0x47, 0xa0, 0x86, 0xe8, 0x6e, 0xed,
// 1560       0xf3, 0x9d, 0x1c, 0x5b, 0xba, 0x97, 0xc4, 0x08,
// 1561       0x01, 0x26, 0x14, 0x1d, 0x67, 0xf3, 0x7b, 0xe8,
// 1562       0x53, 0x8f, 0x5a, 0x8b, 0xe7, 0x40, 0xe4, 0x84 }
// 1563 };
// 1564 #endif /* MBEDTLS_CIPHER_MODE_OFB */
// 1565 
// 1566 #if defined(MBEDTLS_CIPHER_MODE_CTR)
// 1567 /*
// 1568  * AES-CTR test vectors from:
// 1569  *
// 1570  * http://www.faqs.org/rfcs/rfc3686.html
// 1571  */
// 1572 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1573 static const unsigned char aes_test_ctr_key[3][16] =
aes_test_ctr_key:
        DATA8
        DC8 174, 104, 82, 248, 18, 16, 103, 204, 75, 247, 165, 118, 85, 119
        DC8 243, 158, 126, 36, 6, 120, 23, 250, 224, 215, 67, 214, 206, 31, 50
        DC8 83, 145, 99, 118, 145, 190, 3, 94, 80, 32, 168, 172, 110, 97, 133
        DC8 41, 249, 160, 220
// 1574 {
// 1575     { 0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
// 1576       0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E },
// 1577     { 0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7,
// 1578       0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63 },
// 1579     { 0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8,
// 1580       0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC }
// 1581 };
// 1582 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1583 static const unsigned char aes_test_ctr_nonce_counter[3][16] =
aes_test_ctr_nonce_counter:
        DATA8
        DC8 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 108, 182, 219
        DC8 192, 84, 59, 89, 218, 72, 217, 11, 0, 0, 0, 1, 0, 224, 1, 123, 39
        DC8 119, 127, 63, 74, 23, 134, 240, 0, 0, 0, 1
// 1584 {
// 1585     { 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
// 1586       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
// 1587     { 0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59,
// 1588       0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01 },
// 1589     { 0x00, 0xE0, 0x01, 0x7B, 0x27, 0x77, 0x7F, 0x3F,
// 1590       0x4A, 0x17, 0x86, 0xF0, 0x00, 0x00, 0x00, 0x01 }
// 1591 };
// 1592 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1593 static const unsigned char aes_test_ctr_pt[3][48] =
aes_test_ctr_pt:
        DATA8
        DC8 83, 105, 110, 103, 108, 101, 32, 98, 108, 111, 99, 107, 32, 109
        DC8 115, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
        DC8 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26
        DC8 27, 28, 29, 30, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18
        DC8 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
// 1594 {
// 1595     { 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,
// 1596       0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67 },
// 1597 
// 1598     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
// 1599       0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
// 1600       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
// 1601       0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F },
// 1602 
// 1603     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
// 1604       0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
// 1605       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
// 1606       0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
// 1607       0x20, 0x21, 0x22, 0x23 }
// 1608 };
// 1609 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1610 static const unsigned char aes_test_ctr_ct[3][48] =
aes_test_ctr_ct:
        DATA8
        DC8 228, 9, 93, 79, 183, 167, 179, 121, 45, 97, 117, 163, 38, 19, 17
        DC8 184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 4, 161, 6, 22, 138, 114, 217
        DC8 121, 13, 65, 238, 142, 218, 211, 136, 235, 46, 30, 252, 70, 218, 87
        DC8 200, 252, 230, 48, 223, 145, 65, 190, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 193, 207, 72, 168, 159, 47, 253, 217, 207, 70
        DC8 82, 233, 239, 219, 114, 215, 69, 64, 164, 43, 222, 109, 120, 54
        DC8 213, 154, 92, 234, 174, 243, 16, 83, 37, 178, 7, 47, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0
// 1611 {
// 1612     { 0xE4, 0x09, 0x5D, 0x4F, 0xB7, 0xA7, 0xB3, 0x79,
// 1613       0x2D, 0x61, 0x75, 0xA3, 0x26, 0x13, 0x11, 0xB8 },
// 1614     { 0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9,
// 1615       0x79, 0x0D, 0x41, 0xEE, 0x8E, 0xDA, 0xD3, 0x88,
// 1616       0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA, 0x57, 0xC8,
// 1617       0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28 },
// 1618     { 0xC1, 0xCF, 0x48, 0xA8, 0x9F, 0x2F, 0xFD, 0xD9,
// 1619       0xCF, 0x46, 0x52, 0xE9, 0xEF, 0xDB, 0x72, 0xD7,
// 1620       0x45, 0x40, 0xA4, 0x2B, 0xDE, 0x6D, 0x78, 0x36,
// 1621       0xD5, 0x9A, 0x5C, 0xEA, 0xAE, 0xF3, 0x10, 0x53,
// 1622       0x25, 0xB2, 0x07, 0x2F }
// 1623 };
// 1624 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// 1625 static const int aes_test_ctr_len[3] =
aes_test_ctr_len:
        DATA32
        DC32 16, 32, 36
// 1626     { 16, 32, 36 };
// 1627 #endif /* MBEDTLS_CIPHER_MODE_CTR */
// 1628 
// 1629 #if defined(MBEDTLS_CIPHER_MODE_XTS)
// 1630 /*
// 1631  * AES-XTS test vectors from:
// 1632  *
// 1633  * IEEE P1619/D16 Annex B
// 1634  * https://web.archive.org/web/20150629024421/http://grouper.ieee.org/groups/1619/email/pdf00086.pdf
// 1635  * (Archived from original at http://grouper.ieee.org/groups/1619/email/pdf00086.pdf)
// 1636  */
// 1637 static const unsigned char aes_test_xts_key[][32] =
// 1638 {
// 1639     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 1640       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 1641       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 1642       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
// 1643     { 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
// 1644       0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
// 1645       0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
// 1646       0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22 },
// 1647     { 0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8,
// 1648       0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0,
// 1649       0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
// 1650       0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22 },
// 1651 };
// 1652 
// 1653 static const unsigned char aes_test_xts_pt32[][32] =
// 1654 {
// 1655     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 1656       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 1657       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 1658       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
// 1659     { 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
// 1660       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
// 1661       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
// 1662       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44 },
// 1663     { 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
// 1664       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
// 1665       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
// 1666       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44 },
// 1667 };
// 1668 
// 1669 static const unsigned char aes_test_xts_ct32[][32] =
// 1670 {
// 1671     { 0x91, 0x7c, 0xf6, 0x9e, 0xbd, 0x68, 0xb2, 0xec,
// 1672       0x9b, 0x9f, 0xe9, 0xa3, 0xea, 0xdd, 0xa6, 0x92,
// 1673       0xcd, 0x43, 0xd2, 0xf5, 0x95, 0x98, 0xed, 0x85,
// 1674       0x8c, 0x02, 0xc2, 0x65, 0x2f, 0xbf, 0x92, 0x2e },
// 1675     { 0xc4, 0x54, 0x18, 0x5e, 0x6a, 0x16, 0x93, 0x6e,
// 1676       0x39, 0x33, 0x40, 0x38, 0xac, 0xef, 0x83, 0x8b,
// 1677       0xfb, 0x18, 0x6f, 0xff, 0x74, 0x80, 0xad, 0xc4,
// 1678       0x28, 0x93, 0x82, 0xec, 0xd6, 0xd3, 0x94, 0xf0 },
// 1679     { 0xaf, 0x85, 0x33, 0x6b, 0x59, 0x7a, 0xfc, 0x1a,
// 1680       0x90, 0x0b, 0x2e, 0xb2, 0x1e, 0xc9, 0x49, 0xd2,
// 1681       0x92, 0xdf, 0x4c, 0x04, 0x7e, 0x0b, 0x21, 0x53,
// 1682       0x21, 0x86, 0xa5, 0x97, 0x1a, 0x22, 0x7a, 0x89 },
// 1683 };
// 1684 
// 1685 static const unsigned char aes_test_xts_data_unit[][16] =
// 1686 {
// 1687    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 1688      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
// 1689    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
// 1690      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
// 1691    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
// 1692      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
// 1693 };
// 1694 
// 1695 #endif /* MBEDTLS_CIPHER_MODE_XTS */
// 1696 
// 1697 /*
// 1698  * Checkup routine
// 1699  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function mbedtls_aes_self_test
        THUMB
// 1700 int mbedtls_aes_self_test( int verbose )
// 1701 {
mbedtls_aes_self_test:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+472
          CFI CFA R13+496
        MOV      R4,R0
// 1702     int ret = 0, i, j, u, mode;
// 1703     unsigned int keybits;
// 1704     unsigned char key[32];
// 1705     unsigned char buf[64];
// 1706     const unsigned char *aes_tests;
// 1707 #if defined(MBEDTLS_CIPHER_MODE_CBC) || defined(MBEDTLS_CIPHER_MODE_CFB)
// 1708     unsigned char iv[16];
// 1709 #endif
// 1710 #if defined(MBEDTLS_CIPHER_MODE_CBC)
// 1711     unsigned char prv[16];
// 1712 #endif
// 1713 #if defined(MBEDTLS_CIPHER_MODE_CTR) || defined(MBEDTLS_CIPHER_MODE_CFB) || \ 
// 1714     defined(MBEDTLS_CIPHER_MODE_OFB)
// 1715     size_t offset;
// 1716 #endif
// 1717 #if defined(MBEDTLS_CIPHER_MODE_CTR) || defined(MBEDTLS_CIPHER_MODE_XTS)
// 1718     int len;
// 1719 #endif
// 1720 #if defined(MBEDTLS_CIPHER_MODE_CTR)
// 1721     unsigned char nonce_counter[16];
// 1722     unsigned char stream_block[16];
// 1723 #endif
// 1724     mbedtls_aes_context ctx;
// 1725 
// 1726     memset( key, 0, 32 );
        MOVS     R2,#+0
        MOVS     R1,#+32
        ADD      R0,SP,#+80
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 1727     mbedtls_aes_init( &ctx );
        ADD      R0,SP,#+192
          CFI FunCall mbedtls_aes_init
        BL       mbedtls_aes_init
// 1728 
// 1729     /*
// 1730      * ECB mode
// 1731      */
// 1732     for( i = 0; i < 6; i++ )
        MOV      R8,#+0
        B.N      ??mbedtls_aes_self_test_2
// 1733     {
// 1734         u = i >> 1;
// 1735         keybits = 128 + u * 64;
// 1736         mode = i & 1;
// 1737 
// 1738         if( verbose != 0 )
// 1739             mbedtls_printf( "  AES-ECB-%3d (%s): ", keybits,
// 1740                             ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
// 1741 
// 1742         memset( buf, 0, 16 );
// 1743 
// 1744         if( mode == MBEDTLS_AES_DECRYPT )
// 1745         {
// 1746             ret = mbedtls_aes_setkey_dec( &ctx, key, keybits );
// 1747             aes_tests = aes_test_ecb_dec[u];
// 1748         }
// 1749         else
// 1750         {
// 1751             ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );
// 1752             aes_tests = aes_test_ecb_enc[u];
// 1753         }
// 1754 
// 1755         /*
// 1756          * AES-192 and AES-256 is an optional feature that may be unavailable when
// 1757          * there is an alternative underlying implementation i.e. when
// 1758          * MBEDTLS_AES_ALT is defined.
// 1759          */
// 1760         if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE )
// 1761         {
// 1762             mbedtls_printf( "skipped\n\r" );
// 1763             continue;
// 1764         }
// 1765         else if( ret != 0 )
// 1766         {
// 1767             goto exit;
// 1768         }
// 1769 
// 1770         for( j = 0; j < 10000; j++ )
// 1771         {
// 1772             ret = mbedtls_aes_crypt_ecb( &ctx, mode, buf, buf );
??mbedtls_aes_self_test_3:
        ADD      R3,SP,#+112
        ADD      R2,SP,#+112
        MOV      R1,R6
        ADD      R0,SP,#+192
          CFI FunCall mbedtls_aes_crypt_ecb
        BL       mbedtls_aes_crypt_ecb
// 1773             if( ret != 0 )
        CMP      R0,#+0
        BNE.W    ??mbedtls_aes_self_test_4
// 1774                 goto exit;
// 1775         }
        ADDS     R5,R5,#+1
??mbedtls_aes_self_test_5:
        MOVW     R0,#+10000
        CMP      R5,R0
        BLT.N    ??mbedtls_aes_self_test_3
// 1776 
// 1777         if( memcmp( buf, aes_tests, 16 ) != 0 )
        MOVS     R2,#+16
        MOV      R1,R7
        ADD      R0,SP,#+112
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BNE.W    ??mbedtls_aes_self_test_6
// 1778         {
// 1779             ret = 1;
// 1780             goto exit;
// 1781         }
// 1782 
// 1783         if( verbose != 0 )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_7
// 1784             mbedtls_printf( "passed\n\r" );
        LDR.W    R0,??DataTable5_2
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
??mbedtls_aes_self_test_7:
        ADD      R8,R8,#+1
??mbedtls_aes_self_test_2:
        CMP      R8,#+6
        BGE.N    ??mbedtls_aes_self_test_8
        MOV      R7,R8
        ASRS     R7,R7,#+1
        LSLS     R5,R7,#+6
        ADDS     R5,R5,#+128
        AND      R6,R8,#0x1
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_9
        CMP      R6,#+0
        BNE.N    ??mbedtls_aes_self_test_10
        ADR.N    R2,??mbedtls_aes_self_test_0  ;; "dec"
        B.N      ??mbedtls_aes_self_test_11
??mbedtls_aes_self_test_10:
        ADR.N    R2,??mbedtls_aes_self_test_0+0x4  ;; "enc"
??mbedtls_aes_self_test_11:
        MOV      R1,R5
        LDR.W    R0,??DataTable5_3
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
??mbedtls_aes_self_test_9:
        MOVS     R2,#+0
        MOVS     R1,#+16
        ADD      R0,SP,#+112
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        CMP      R6,#+0
        MOV      R2,R5
        ADD      R1,SP,#+80
        ADD      R0,SP,#+192
        BNE.N    ??mbedtls_aes_self_test_12
          CFI FunCall mbedtls_aes_setkey_dec
        BL       mbedtls_aes_setkey_dec
        MOV      R5,R0
        LDR.W    R0,??DataTable5_4
        ADD      R7,R0,R7, LSL #+4
        B.N      ??mbedtls_aes_self_test_13
??mbedtls_aes_self_test_12:
          CFI FunCall mbedtls_aes_setkey_enc
        BL       mbedtls_aes_setkey_enc
        MOV      R5,R0
        LDR.N    R0,??DataTable5_5
        ADD      R7,R0,R7, LSL #+4
??mbedtls_aes_self_test_13:
        CMN      R5,#+35
        BNE.N    ??mbedtls_aes_self_test_14
        LDR.N    R0,??DataTable5_6
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
        B.N      ??mbedtls_aes_self_test_7
??mbedtls_aes_self_test_14:
        CMP      R5,#+0
        BNE.W    ??mbedtls_aes_self_test_15
        MOVS     R5,#+0
        B.N      ??mbedtls_aes_self_test_5
// 1785     }
// 1786 
// 1787     if( verbose != 0 )
??mbedtls_aes_self_test_8:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_16
// 1788         mbedtls_printf( "\n\r" );
        ADR.N    R0,??mbedtls_aes_self_test_1  ;; 0x0A, 0x0D, 0x00, 0x00
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
// 1789 
// 1790 #if defined(MBEDTLS_CIPHER_MODE_CBC)
// 1791     /*
// 1792      * CBC mode
// 1793      */
// 1794     for( i = 0; i < 6; i++ )
??mbedtls_aes_self_test_16:
        MOVS     R7,#+0
        B.N      ??mbedtls_aes_self_test_17
// 1795     {
// 1796         u = i >> 1;
// 1797         keybits = 128 + u * 64;
// 1798         mode = i & 1;
// 1799 
// 1800         if( verbose != 0 )
// 1801             mbedtls_printf( "  AES-CBC-%3d (%s): ", keybits,
// 1802                             ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
// 1803 
// 1804         memset( iv , 0, 16 );
// 1805         memset( prv, 0, 16 );
// 1806         memset( buf, 0, 16 );
// 1807 
// 1808         if( mode == MBEDTLS_AES_DECRYPT )
// 1809         {
// 1810             ret = mbedtls_aes_setkey_dec( &ctx, key, keybits );
// 1811             aes_tests = aes_test_cbc_dec[u];
// 1812         }
// 1813         else
// 1814         {
// 1815             ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );
// 1816             aes_tests = aes_test_cbc_enc[u];
// 1817         }
// 1818 
// 1819         /*
// 1820          * AES-192 or 256 is an optional feature that may be unavailable when
// 1821          * there is an alternative underlying implementation i.e. when
// 1822          * MBEDTLS_AES_ALT is defined.
// 1823          */
// 1824         if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE )
// 1825         {
// 1826             mbedtls_printf( "skipped\n\r" );
// 1827             continue;
// 1828         }
// 1829         else if( ret != 0 )
// 1830         {
// 1831             goto exit;
// 1832         }
// 1833 
// 1834         for( j = 0; j < 10000; j++ )
// 1835         {
// 1836             if( mode == MBEDTLS_AES_ENCRYPT )
??mbedtls_aes_self_test_18:
        CMP      R6,#+1
        BNE.N    ??mbedtls_aes_self_test_19
// 1837             {
// 1838                 unsigned char tmp[16];
// 1839 
// 1840                 memcpy( tmp, prv, 16 );
        MOVS     R2,#+16
        ADD      R1,SP,#+16
        ADD      R0,SP,#+176
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 1841                 memcpy( prv, buf, 16 );
        MOVS     R2,#+16
        ADD      R1,SP,#+112
        ADD      R0,SP,#+16
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 1842                 memcpy( buf, tmp, 16 );
        MOVS     R2,#+16
        ADD      R1,SP,#+176
        ADD      R0,SP,#+112
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 1843             }
// 1844 
// 1845             ret = mbedtls_aes_crypt_cbc( &ctx, mode, 16, iv, buf, buf );
??mbedtls_aes_self_test_19:
        ADD      R0,SP,#+112
        STR      R0,[SP, #+4]
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+32
        MOVS     R2,#+16
        MOV      R1,R6
        ADD      R0,SP,#+192
          CFI FunCall mbedtls_aes_crypt_cbc
        BL       mbedtls_aes_crypt_cbc
// 1846             if( ret != 0 )
        CMP      R0,#+0
        BNE.W    ??mbedtls_aes_self_test_4
// 1847                 goto exit;
// 1848 
// 1849         }
        ADDS     R5,R5,#+1
??mbedtls_aes_self_test_20:
        MOVW     R0,#+10000
        CMP      R5,R0
        BLT.N    ??mbedtls_aes_self_test_18
// 1850 
// 1851         if( memcmp( buf, aes_tests, 16 ) != 0 )
        MOVS     R2,#+16
        MOV      R1,R8
        ADD      R0,SP,#+112
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BNE.W    ??mbedtls_aes_self_test_6
// 1852         {
// 1853             ret = 1;
// 1854             goto exit;
// 1855         }
// 1856 
// 1857         if( verbose != 0 )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_21
// 1858             mbedtls_printf( "passed\n\r" );
        LDR.N    R0,??DataTable5_2
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
??mbedtls_aes_self_test_21:
        ADDS     R7,R7,#+1
??mbedtls_aes_self_test_17:
        CMP      R7,#+6
        BGE.N    ??mbedtls_aes_self_test_22
        MOV      R8,R7
        ASR      R8,R8,#+1
        LSL      R5,R8,#+6
        ADDS     R5,R5,#+128
        AND      R6,R7,#0x1
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_23
        CMP      R6,#+0
        BNE.N    ??mbedtls_aes_self_test_24
        ADR.N    R2,??mbedtls_aes_self_test_0  ;; "dec"
        B.N      ??mbedtls_aes_self_test_25
??mbedtls_aes_self_test_24:
        ADR.N    R2,??mbedtls_aes_self_test_0+0x4  ;; "enc"
??mbedtls_aes_self_test_25:
        MOV      R1,R5
        LDR.N    R0,??DataTable5_7
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
??mbedtls_aes_self_test_23:
        MOVS     R2,#+0
        MOVS     R1,#+16
        ADD      R0,SP,#+32
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOVS     R2,#+0
        MOVS     R1,#+16
        ADD      R0,SP,#+16
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOVS     R2,#+0
        MOVS     R1,#+16
        ADD      R0,SP,#+112
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        CMP      R6,#+0
        MOV      R2,R5
        ADD      R1,SP,#+80
        ADD      R0,SP,#+192
        BNE.N    ??mbedtls_aes_self_test_26
          CFI FunCall mbedtls_aes_setkey_dec
        BL       mbedtls_aes_setkey_dec
        MOV      R5,R0
        LDR.N    R0,??DataTable5_8
        ADD      R8,R0,R8, LSL #+4
        B.N      ??mbedtls_aes_self_test_27
??mbedtls_aes_self_test_26:
          CFI FunCall mbedtls_aes_setkey_enc
        BL       mbedtls_aes_setkey_enc
        MOV      R5,R0
        LDR.N    R0,??DataTable5_9
        ADD      R8,R0,R8, LSL #+4
??mbedtls_aes_self_test_27:
        CMN      R5,#+35
        BNE.N    ??mbedtls_aes_self_test_28
        LDR.N    R0,??DataTable5_6
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
        B.N      ??mbedtls_aes_self_test_21
??mbedtls_aes_self_test_28:
        CMP      R5,#+0
        BNE.W    ??mbedtls_aes_self_test_15
        MOVS     R5,#+0
        B.N      ??mbedtls_aes_self_test_20
// 1859     }
// 1860 
// 1861     if( verbose != 0 )
??mbedtls_aes_self_test_22:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_29
// 1862         mbedtls_printf( "\n" );
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
// 1863 #endif /* MBEDTLS_CIPHER_MODE_CBC */
// 1864 
// 1865 #if defined(MBEDTLS_CIPHER_MODE_CFB)
// 1866     /*
// 1867      * CFB128 mode
// 1868      */
// 1869     for( i = 0; i < 6; i++ )
??mbedtls_aes_self_test_29:
        MOV      R8,#+0
        B.N      ??mbedtls_aes_self_test_30
// 1870     {
// 1871         u = i >> 1;
// 1872         keybits = 128 + u * 64;
// 1873         mode = i & 1;
// 1874 
// 1875         if( verbose != 0 )
// 1876             mbedtls_printf( "  AES-CFB128-%3d (%s): ", keybits,
// 1877                             ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
// 1878 
// 1879         memcpy( iv,  aes_test_cfb128_iv, 16 );
// 1880         memcpy( key, aes_test_cfb128_key[u], keybits / 8 );
// 1881 
// 1882         offset = 0;
// 1883         ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );
// 1884         /*
// 1885          * AES-192 and 256 is an optional feature that may be unavailable when
// 1886          * there is an alternative underlying implementation i.e. when
// 1887          * MBEDTLS_AES_ALT is defined.
// 1888          */
// 1889         if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE )
// 1890         {
// 1891             mbedtls_printf( "skipped\n\r" );
// 1892             continue;
// 1893         }
// 1894         else if( ret != 0 )
// 1895         {
// 1896             goto exit;
// 1897         }
// 1898 
// 1899         if( mode == MBEDTLS_AES_DECRYPT )
// 1900         {
// 1901             memcpy( buf, aes_test_cfb128_ct[u], 64 );
// 1902             aes_tests = aes_test_cfb128_pt;
// 1903         }
// 1904         else
// 1905         {
// 1906             memcpy( buf, aes_test_cfb128_pt, 64 );
??mbedtls_aes_self_test_31:
        MOVS     R2,#+64
        LDR.N    R1,??DataTable5_10
        ADD      R0,SP,#+112
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 1907             aes_tests = aes_test_cfb128_ct[u];
        LDR.N    R0,??DataTable5_11
        ADD      R6,R0,R6, LSL #+6
        B.N      ??mbedtls_aes_self_test_32
// 1908         }
??mbedtls_aes_self_test_33:
        CMP      R0,#+0
        BNE.W    ??mbedtls_aes_self_test_4
        CMP      R5,#+0
        BNE.N    ??mbedtls_aes_self_test_31
        MOVS     R2,#+64
        LDR.N    R0,??DataTable5_11
        ADDS     R1,R0,R6, LSL #+6
        ADD      R0,SP,#+112
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR.N    R6,??DataTable5_10
// 1909 
// 1910         ret = mbedtls_aes_crypt_cfb128( &ctx, mode, 64, &offset, iv, buf, buf );
??mbedtls_aes_self_test_32:
        ADD      R0,SP,#+112
        STR      R0,[SP, #+8]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+32
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+12
        MOVS     R2,#+64
        MOV      R1,R5
        ADD      R0,SP,#+192
          CFI FunCall mbedtls_aes_crypt_cfb128
        BL       mbedtls_aes_crypt_cfb128
// 1911         if( ret != 0 )
        CMP      R0,#+0
        BNE.W    ??mbedtls_aes_self_test_4
// 1912             goto exit;
// 1913 
// 1914         if( memcmp( buf, aes_tests, 64 ) != 0 )
        MOVS     R2,#+64
        MOV      R1,R6
        ADD      R0,SP,#+112
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BNE.W    ??mbedtls_aes_self_test_6
// 1915         {
// 1916             ret = 1;
// 1917             goto exit;
// 1918         }
// 1919 
// 1920         if( verbose != 0 )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_34
// 1921             mbedtls_printf( "passed\n\r" );
        LDR.N    R0,??DataTable5_2
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
??mbedtls_aes_self_test_34:
        ADD      R8,R8,#+1
??mbedtls_aes_self_test_30:
        CMP      R8,#+6
        BGE.W    ??mbedtls_aes_self_test_35
        MOV      R6,R8
        ASRS     R6,R6,#+1
        LSLS     R7,R6,#+6
        ADDS     R7,R7,#+128
        AND      R5,R8,#0x1
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_36
        CMP      R5,#+0
        BNE.N    ??mbedtls_aes_self_test_37
        ADR.N    R2,??mbedtls_aes_self_test_0  ;; "dec"
        B.N      ??mbedtls_aes_self_test_38
??mbedtls_aes_self_test_37:
        ADR.N    R2,??mbedtls_aes_self_test_0+0x4  ;; "enc"
??mbedtls_aes_self_test_38:
        MOV      R1,R7
        LDR.N    R0,??DataTable5_12
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
??mbedtls_aes_self_test_36:
        MOVS     R2,#+16
        LDR.N    R1,??DataTable5_13
        ADD      R0,SP,#+32
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOV      R2,R7
        LSRS     R2,R2,#+3
        LDR.N    R0,??DataTable5_14
        ADD      R1,R0,R6, LSL #+5
        ADD      R0,SP,#+80
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        MOV      R2,R7
        ADD      R1,SP,#+80
        ADD      R0,SP,#+192
          CFI FunCall mbedtls_aes_setkey_enc
        BL       mbedtls_aes_setkey_enc
        CMN      R0,#+35
        BNE.N    ??mbedtls_aes_self_test_33
        LDR.N    R0,??DataTable5_6
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
        B.N      ??mbedtls_aes_self_test_34
// 1922     }
// 1923 
// 1924     if( verbose != 0 )
// 1925         mbedtls_printf( "\n\r" );
// 1926 #endif /* MBEDTLS_CIPHER_MODE_CFB */
// 1927 
// 1928 #if defined(MBEDTLS_CIPHER_MODE_OFB)
// 1929     /*
// 1930      * OFB mode
// 1931      */
// 1932     for( i = 0; i < 6; i++ )
// 1933     {
// 1934         u = i >> 1;
// 1935         keybits = 128 + u * 64;
// 1936         mode = i & 1;
// 1937 
// 1938         if( verbose != 0 )
// 1939             mbedtls_printf( "  AES-OFB-%3d (%s): ", keybits,
// 1940                             ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
// 1941 
// 1942         memcpy( iv,  aes_test_ofb_iv, 16 );
// 1943         memcpy( key, aes_test_ofb_key[u], keybits / 8 );
// 1944 
// 1945         offset = 0;
// 1946         ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );
// 1947         /*
// 1948          * AES-192 and 256 is an optional feature that may be unavailable when
// 1949          * there is an alternative underlying implementation i.e. when
// 1950          * MBEDTLS_AES_ALT is defined.
// 1951          */
// 1952         if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE )
// 1953         {
// 1954             mbedtls_printf( "skipped\n" );
// 1955             continue;
// 1956         }
// 1957         else if( ret != 0 )
// 1958         {
// 1959             goto exit;
// 1960         }
// 1961 
// 1962         if( mode == MBEDTLS_AES_DECRYPT )
// 1963         {
// 1964             memcpy( buf, aes_test_ofb_ct[u], 64 );
// 1965             aes_tests = aes_test_ofb_pt;
// 1966         }
// 1967         else
// 1968         {
// 1969             memcpy( buf, aes_test_ofb_pt, 64 );
// 1970             aes_tests = aes_test_ofb_ct[u];
// 1971         }
// 1972 
// 1973         ret = mbedtls_aes_crypt_ofb( &ctx, 64, &offset, iv, buf, buf );
// 1974         if( ret != 0 )
// 1975             goto exit;
// 1976 
// 1977         if( memcmp( buf, aes_tests, 64 ) != 0 )
// 1978         {
// 1979             ret = 1;
// 1980             goto exit;
// 1981         }
// 1982 
// 1983         if( verbose != 0 )
// 1984             mbedtls_printf( "passed\n" );
// 1985     }
// 1986 
// 1987     if( verbose != 0 )
// 1988         mbedtls_printf( "\n" );
// 1989 #endif /* MBEDTLS_CIPHER_MODE_OFB */
// 1990 
// 1991 #if defined(MBEDTLS_CIPHER_MODE_CTR)
// 1992     /*
// 1993      * CTR mode
// 1994      */
// 1995     for( i = 0; i < 6; i++ )
// 1996     {
// 1997         u = i >> 1;
// 1998         mode = i & 1;
// 1999 
// 2000         if( verbose != 0 )
// 2001             mbedtls_printf( "  AES-CTR-128 (%s): ",
// 2002                             ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
// 2003 
// 2004         memcpy( nonce_counter, aes_test_ctr_nonce_counter[u], 16 );
// 2005         memcpy( key, aes_test_ctr_key[u], 16 );
// 2006 
// 2007         offset = 0;
// 2008         if( ( ret = mbedtls_aes_setkey_enc( &ctx, key, 128 ) ) != 0 )
// 2009             goto exit;
// 2010 
// 2011         len = aes_test_ctr_len[u];
// 2012 
// 2013         if( mode == MBEDTLS_AES_DECRYPT )
// 2014         {
// 2015             memcpy( buf, aes_test_ctr_ct[u], len );
// 2016             aes_tests = aes_test_ctr_pt[u];
// 2017         }
// 2018         else
// 2019         {
// 2020             memcpy( buf, aes_test_ctr_pt[u], len );
??mbedtls_aes_self_test_39:
        MOVS     R5,#+48
        MOV      R2,R8
        LDR.N    R0,??DataTable5_15
        MUL      R1,R5,R7
        ADD      R1,R0,R1
        ADD      R0,SP,#+112
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 2021             aes_tests = aes_test_ctr_ct[u];
        LDR.N    R0,??DataTable5_16
        MULS     R7,R5,R7
        ADDS     R5,R0,R7
// 2022         }
// 2023 
// 2024         ret = mbedtls_aes_crypt_ctr( &ctx, len, &offset, nonce_counter,
// 2025                                      stream_block, buf, buf );
??mbedtls_aes_self_test_40:
        ADD      R0,SP,#+112
        STR      R0,[SP, #+8]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+48
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+64
        ADD      R2,SP,#+12
        MOV      R1,R8
        ADD      R0,SP,#+192
          CFI FunCall mbedtls_aes_crypt_ctr
        BL       mbedtls_aes_crypt_ctr
// 2026         if( ret != 0 )
        CMP      R0,#+0
        BNE.N    ??mbedtls_aes_self_test_4
// 2027             goto exit;
// 2028 
// 2029         if( memcmp( buf, aes_tests, len ) != 0 )
        MOV      R2,R8
        MOV      R1,R5
        ADD      R0,SP,#+112
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BNE.N    ??mbedtls_aes_self_test_6
// 2030         {
// 2031             ret = 1;
// 2032             goto exit;
// 2033         }
// 2034 
// 2035         if( verbose != 0 )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_41
// 2036             mbedtls_printf( "passed\n\r" );
        LDR.N    R0,??DataTable5_2
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
??mbedtls_aes_self_test_41:
        ADDS     R6,R6,#+1
??mbedtls_aes_self_test_42:
        CMP      R6,#+6
        BGE.N    ??mbedtls_aes_self_test_43
        MOV      R7,R6
        ASRS     R7,R7,#+1
        AND      R5,R6,#0x1
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_44
        CMP      R5,#+0
        BNE.N    ??mbedtls_aes_self_test_45
        ADR.N    R1,??mbedtls_aes_self_test_0  ;; "dec"
        B.N      ??mbedtls_aes_self_test_46
??mbedtls_aes_self_test_45:
        ADR.N    R1,??mbedtls_aes_self_test_0+0x4  ;; "enc"
??mbedtls_aes_self_test_46:
        LDR.N    R0,??DataTable5_17
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
??mbedtls_aes_self_test_44:
        MOVS     R2,#+16
        LDR.N    R0,??DataTable5_18
        ADD      R1,R0,R7, LSL #+4
        ADD      R0,SP,#+64
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+16
        LDR.N    R0,??DataTable5_19
        ADD      R1,R0,R7, LSL #+4
        ADD      R0,SP,#+80
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        MOVS     R2,#+128
        ADD      R1,SP,#+80
        ADD      R0,SP,#+192
          CFI FunCall mbedtls_aes_setkey_enc
        BL       mbedtls_aes_setkey_enc
        CMP      R0,#+0
        BNE.N    ??mbedtls_aes_self_test_4
        LDR.N    R0,??DataTable5_20
        LDR      R8,[R0, R7, LSL #+2]
        CMP      R5,#+0
        BNE.N    ??mbedtls_aes_self_test_39
        MOVS     R5,#+48
        MOV      R2,R8
        LDR.N    R0,??DataTable5_16
        MUL      R1,R5,R7
        ADD      R1,R0,R1
        ADD      R0,SP,#+112
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR.N    R0,??DataTable5_15
        MULS     R7,R5,R7
        ADDS     R5,R0,R7
        B.N      ??mbedtls_aes_self_test_40
??mbedtls_aes_self_test_4:
        MOV      R5,R0
        B.N      ??mbedtls_aes_self_test_15
??mbedtls_aes_self_test_6:
        MOVS     R5,#+1
        B.N      ??mbedtls_aes_self_test_15
// 2037     }
??mbedtls_aes_self_test_35:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_47
        ADR.N    R0,??mbedtls_aes_self_test_1  ;; 0x0A, 0x0D, 0x00, 0x00
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
??mbedtls_aes_self_test_47:
        MOVS     R6,#+0
        B.N      ??mbedtls_aes_self_test_42
        DATA
??mbedtls_aes_self_test_0:
        DATA8
        DC8      "dec"
        DC8      "enc"
        THUMB
// 2038 
// 2039     if( verbose != 0 )
??mbedtls_aes_self_test_43:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_48
// 2040         mbedtls_printf( "\n\r" );
        ADR.N    R0,??mbedtls_aes_self_test_1  ;; 0x0A, 0x0D, 0x00, 0x00
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
// 2041 #endif /* MBEDTLS_CIPHER_MODE_CTR */
// 2042 
// 2043 #if defined(MBEDTLS_CIPHER_MODE_XTS)
// 2044     {
// 2045     static const int num_tests =
// 2046         sizeof(aes_test_xts_key) / sizeof(*aes_test_xts_key);
// 2047     mbedtls_aes_xts_context ctx_xts;
// 2048 
// 2049     /*
// 2050      * XTS mode
// 2051      */
// 2052     mbedtls_aes_xts_init( &ctx_xts );
// 2053 
// 2054     for( i = 0; i < num_tests << 1; i++ )
// 2055     {
// 2056         const unsigned char *data_unit;
// 2057         u = i >> 1;
// 2058         mode = i & 1;
// 2059 
// 2060         if( verbose != 0 )
// 2061             mbedtls_printf( "  AES-XTS-128 (%s): ",
// 2062                             ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
// 2063 
// 2064         memset( key, 0, sizeof( key ) );
// 2065         memcpy( key, aes_test_xts_key[u], 32 );
// 2066         data_unit = aes_test_xts_data_unit[u];
// 2067 
// 2068         len = sizeof( *aes_test_xts_ct32 );
// 2069 
// 2070         if( mode == MBEDTLS_AES_DECRYPT )
// 2071         {
// 2072             ret = mbedtls_aes_xts_setkey_dec( &ctx_xts, key, 256 );
// 2073             if( ret != 0)
// 2074                 goto exit;
// 2075             memcpy( buf, aes_test_xts_ct32[u], len );
// 2076             aes_tests = aes_test_xts_pt32[u];
// 2077         }
// 2078         else
// 2079         {
// 2080             ret = mbedtls_aes_xts_setkey_enc( &ctx_xts, key, 256 );
// 2081             if( ret != 0)
// 2082                 goto exit;
// 2083             memcpy( buf, aes_test_xts_pt32[u], len );
// 2084             aes_tests = aes_test_xts_ct32[u];
// 2085         }
// 2086 
// 2087 
// 2088         ret = mbedtls_aes_crypt_xts( &ctx_xts, mode, len, data_unit,
// 2089                                      buf, buf );
// 2090         if( ret != 0 )
// 2091             goto exit;
// 2092 
// 2093         if( memcmp( buf, aes_tests, len ) != 0 )
// 2094         {
// 2095             ret = 1;
// 2096             goto exit;
// 2097         }
// 2098 
// 2099         if( verbose != 0 )
// 2100             mbedtls_printf( "passed\n" );
// 2101     }
// 2102 
// 2103     if( verbose != 0 )
// 2104         mbedtls_printf( "\n" );
// 2105 
// 2106     mbedtls_aes_xts_free( &ctx_xts );
// 2107     }
// 2108 #endif /* MBEDTLS_CIPHER_MODE_XTS */
// 2109 
// 2110     ret = 0;
??mbedtls_aes_self_test_48:
        MOVS     R5,#+0
// 2111 
// 2112 exit:
// 2113     if( ret != 0 && verbose != 0 )
??mbedtls_aes_self_test_15:
        CMP      R5,#+0
        BEQ.N    ??mbedtls_aes_self_test_49
        CMP      R4,#+0
        BEQ.N    ??mbedtls_aes_self_test_49
// 2114         mbedtls_printf( "failed\n\r" );
        LDR.N    R0,??DataTable5_21
          CFI FunCall DbgConsole_Printf
        BL       DbgConsole_Printf
// 2115 
// 2116     mbedtls_aes_free( &ctx );
??mbedtls_aes_self_test_49:
        ADD      R0,SP,#+192
          CFI FunCall mbedtls_aes_free
        BL       mbedtls_aes_free
// 2117 
// 2118     return( ret );
        MOV      R0,R5
        ADD      SP,SP,#+472
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
        DATA
??mbedtls_aes_self_test_1:
        DATA8
        DC8      0x0A, 0x0D, 0x00, 0x00
// 2119 }
          CFI EndBlock cfiBlock13

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5:
        DATA8
        DC8      "\n",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_1:
        DATA32
        DC32     `RSb`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_2:
        DATA32
        DC32     ?_4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_3:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_4:
        DATA32
        DC32     aes_test_ecb_dec

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_5:
        DATA32
        DC32     aes_test_ecb_enc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_6:
        DATA32
        DC32     ?_3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_7:
        DATA32
        DC32     ?_6

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_8:
        DATA32
        DC32     aes_test_cbc_dec

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_9:
        DATA32
        DC32     aes_test_cbc_enc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_10:
        DATA32
        DC32     aes_test_cfb128_pt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_11:
        DATA32
        DC32     aes_test_cfb128_ct

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_12:
        DATA32
        DC32     ?_8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_13:
        DATA32
        DC32     aes_test_cfb128_iv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_14:
        DATA32
        DC32     aes_test_cfb128_key

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_15:
        DATA32
        DC32     aes_test_ctr_pt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_16:
        DATA32
        DC32     aes_test_ctr_ct

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_17:
        DATA32
        DC32     ?_9

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_18:
        DATA32
        DC32     aes_test_ctr_nonce_counter

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_19:
        DATA32
        DC32     aes_test_ctr_key

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_20:
        DATA32
        DC32     aes_test_ctr_len

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_21:
        DATA32
        DC32     ?_10

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
// 2120 
// 2121 #endif /* MBEDTLS_SELF_TEST */
// 2122 
// 2123 #endif /* MBEDTLS_AES_C */
// 
// 9 846 bytes in section .rodata
// 4 362 bytes in section .text
// 
// 4 362 bytes of CODE  memory
// 9 846 bytes of CONST memory
//
//Errors: none
//Warnings: none
