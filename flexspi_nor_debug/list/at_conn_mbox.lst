###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:47:58
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\at_conn_mbox.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW877B.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\atm\at_conn_mbox.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\at_conn_mbox.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\at_conn_mbox.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\atm\at_conn_mbox.c
      1          /*
      2           * Copyright (C) 2015-2019 Alibaba Group Holding Limited
      3           */
      4          
      5          #include "infra_types.h"
      6          #include "at_wrapper.h"
      7          
      8          #include "at_conn_mbox.h"
      9          
     10          typedef struct
     11          {
     12              void    *buffer;
     13              uint32_t length;
     14              uint32_t head;
     15              uint32_t tail;
     16              uint8_t  full;
     17          } at_ringbuf_t;
     18          
     19          #ifndef PLATFORM_HAS_DYNMEM
     20          static at_ringbuf_t ringbufs[AT_CONN_NUM] = {{NULL, 0, 0, 0, 0}};
     21          #endif
     22          

   \                                 In section .text, align 2, keep-with-next
     23          static at_ringbuf_t *alloc_ringbuf(void)
     24          {
     25          #ifdef PLATFORM_HAS_DYNMEM
     26              return HAL_Malloc(sizeof(at_ringbuf_t));
   \                     alloc_ringbuf: (+1)
   \        0x0   0x2014             MOVS     R0,#+20
   \        0x2   0x....'....        B.W      HAL_Malloc
     27          #else
     28              int i;
     29          
     30              for (i = 0; i < AT_CONN_NUM; i++) {
     31                  if (NULL == ringbufs[i].buffer) {
     32                      return &ringbufs[i];
     33                  }
     34              }
     35          
     36              return NULL;
     37          #endif
     38          }
     39          

   \                                 In section .text, align 2, keep-with-next
     40          static void free_ringbuf(at_ringbuf_t *ringbuf)
     41          {
     42              if (ringbuf) {
   \                     free_ringbuf: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??free_ringbuf_0
     43          #ifdef PLATFORM_HAS_DYNMEM
     44                  HAL_Free(ringbuf);
   \        0x4   0x....'....        B.W      HAL_Free
     45          #else
     46                  memset(ringbuf, 0, sizeof(at_ringbuf_t));
     47          #endif
     48             }
     49          }
   \                     ??free_ringbuf_0: (+1)
   \        0x8   0x4770             BX       LR               ;; return
     50          

   \                                 In section .text, align 2, keep-with-next
     51          static int at_ringbuf_available_read_space(at_ringbuf_t *ringbuf)
     52          {
   \                     at_ringbuf_available_read_space: (+1)
   \        0x0   0x4601             MOV      R1,R0
     53              if (ringbuf->full)
   \        0x2   0x7C08             LDRB     R0,[R1, #+16]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD001             BEQ.N    ??at_ringbuf_available_read_space_0
     54                  return ringbuf->length;
   \        0x8   0x6848             LDR      R0,[R1, #+4]
   \        0xA   0x4770             BX       LR
     55          
     56              if (ringbuf->head == ringbuf->tail) {
   \                     ??at_ringbuf_available_read_space_0: (+1)
   \        0xC   0x6888             LDR      R0,[R1, #+8]
   \        0xE   0x68CA             LDR      R2,[R1, #+12]
   \       0x10   0x4290             CMP      R0,R2
   \       0x12   0xD101             BNE.N    ??at_ringbuf_available_read_space_1
     57                  return 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x4770             BX       LR
     58              } else if (ringbuf->head < ringbuf->tail) {
   \                     ??at_ringbuf_available_read_space_1: (+1)
   \       0x18   0xD203             BCS.N    ??at_ringbuf_available_read_space_2
     59                  return ringbuf->tail - ringbuf->head;
   \       0x1A   0x4610             MOV      R0,R2
   \       0x1C   0x6889             LDR      R1,[R1, #+8]
   \       0x1E   0x1A40             SUBS     R0,R0,R1
   \       0x20   0x4770             BX       LR
     60              } else {
     61                  return ringbuf->length - (ringbuf->head - ringbuf->tail);
   \                     ??at_ringbuf_available_read_space_2: (+1)
   \       0x22   0x6848             LDR      R0,[R1, #+4]
   \       0x24   0x688A             LDR      R2,[R1, #+8]
   \       0x26   0x1A80             SUBS     R0,R0,R2
   \       0x28   0x68C9             LDR      R1,[R1, #+12]
   \       0x2A   0x1808             ADDS     R0,R1,R0
   \       0x2C   0x4770             BX       LR               ;; return
     62              }
     63          }
     64          

   \                                 In section .text, align 2, keep-with-next
     65          static int at_ringbuf_full(at_ringbuf_t *ringbuf)
     66          {
     67              return ringbuf->full;
   \                     at_ringbuf_full: (+1)
   \        0x0   0x7C00             LDRB     R0,[R0, #+16]
   \        0x2   0x4770             BX       LR               ;; return
     68          }
     69          

   \                                 In section .text, align 2, keep-with-next
     70          static int at_ringbuf_empty(at_ringbuf_t *ringbuf)
     71          {
   \                     at_ringbuf_empty: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     72              return (at_ringbuf_available_read_space(ringbuf) == 0);
   \        0x2   0x....'....        BL       at_ringbuf_available_read_space
   \        0x6   0x1E40             SUBS     R0,R0,#+1
   \        0x8   0x4180             SBCS     R0,R0,R0
   \        0xA   0x0FC0             LSRS     R0,R0,#+31
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
     73          }
     74          

   \                                 In section .text, align 2, keep-with-next
     75          static at_ringbuf_t *at_ringbuf_create(int length, void *buf)
     76          {
   \                     at_ringbuf_create: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
     77              at_ringbuf_t *ringbuf = NULL;
     78          
     79              if (length < 2 || NULL == buf) {
   \        0x6   0x2E02             CMP      R6,#+2
   \        0x8   0xDB01             BLT.N    ??at_ringbuf_create_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD104             BNE.N    ??at_ringbuf_create_1
     80                  HAL_Printf("Error: ringbuf len MUST exceed one!");
   \                     ??at_ringbuf_create_0: (+1)
   \        0xE   0x....             LDR.N    R0,??DataTable2
   \       0x10   0x....'....        BL       HAL_Printf
     81                  return NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD70             POP      {R4-R6,PC}
     82              }
     83          
     84              ringbuf = alloc_ringbuf();
   \                     ??at_ringbuf_create_1: (+1)
   \       0x18   0x....'....        BL       alloc_ringbuf
   \       0x1C   0x0004             MOVS     R4,R0
     85              if (ringbuf == NULL) {
   \       0x1E   0xD101             BNE.N    ??at_ringbuf_create_2
     86                  return NULL;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD70             POP      {R4-R6,PC}
     87              }
     88              memset(ringbuf, 0, sizeof(at_ringbuf_t));
   \                     ??at_ringbuf_create_2: (+1)
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x2114             MOVS     R1,#+20
   \       0x28   0x....'....        BL       __aeabi_memset4
     89          
     90              ringbuf->length = length;
   \       0x2C   0x6066             STR      R6,[R4, #+4]
     91              ringbuf->buffer = buf;
   \       0x2E   0x6025             STR      R5,[R4, #+0]
     92          
     93              return ringbuf;
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0xBD70             POP      {R4-R6,PC}       ;; return
     94          }
     95          

   \                                 In section .text, align 2, keep-with-next
     96          static void at_ringbuf_clear_all(at_ringbuf_t *ringbuf)
     97          {
     98              ringbuf->head = ringbuf->tail = 0;
   \                     at_ringbuf_clear_all: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x60C1             STR      R1,[R0, #+12]
   \        0x4   0x6081             STR      R1,[R0, #+8]
     99          }
   \        0x6   0x4770             BX       LR               ;; return
    100          

   \                                 In section .text, align 2, keep-with-next
    101          static void at_ringbuf_destroy(at_ringbuf_t *ringbuf)
    102          {
   \                     at_ringbuf_destroy: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    103              if (ringbuf) {
   \        0x4   0xD00B             BEQ.N    ??at_ringbuf_destroy_0
    104                  if (ringbuf->buffer) {
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ.N    ??at_ringbuf_destroy_1
    105                      at_ringbuf_clear_all(ringbuf);
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x....'....        BL       at_ringbuf_clear_all
    106          
    107                      ringbuf->buffer = NULL;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6020             STR      R0,[R4, #+0]
    108                  }
    109                  free_ringbuf(ringbuf);
   \                     ??at_ringbuf_destroy_1: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1C   0x....             B.N      free_ringbuf
    110              }
    111          }
   \                     ??at_ringbuf_destroy_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
    112          

   \                                 In section .text, align 2, keep-with-next
    113          static int at_ringbuf_write(at_ringbuf_t *ringbuf, void *data, int size)
    114          {
   \                     at_ringbuf_write: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    115              uint32_t next;
    116          
    117              if (ringbuf == NULL || data == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??at_ringbuf_write_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD102             BNE.N    ??at_ringbuf_write_1
    118                  return -1;
   \                     ??at_ringbuf_write_0: (+1)
   \       0x10   0xF04F 0x30FF      MOV      R0,#-1
   \       0x14   0xBD70             POP      {R4-R6,PC}
    119              }
    120          
    121              if (at_ringbuf_full(ringbuf)) {
   \                     ??at_ringbuf_write_1: (+1)
   \       0x16   0x....'....        BL       at_ringbuf_full
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD005             BEQ.N    ??at_ringbuf_write_2
    122                  HAL_Printf("ringbuf full!");
   \       0x1E   0x....             LDR.N    R0,??DataTable2_1
   \       0x20   0x....'....        BL       HAL_Printf
    123                  return -1;
   \       0x24   0xF04F 0x30FF      MOV      R0,#-1
   \       0x28   0xBD70             POP      {R4-R6,PC}
    124              }
    125          
    126              memcpy(&(((void **) ringbuf->buffer)[ringbuf->tail]), data, size);
   \                     ??at_ringbuf_write_2: (+1)
   \       0x2A   0x4632             MOV      R2,R6
   \       0x2C   0x4629             MOV      R1,R5
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68E3             LDR      R3,[R4, #+12]
   \       0x32   0xEB00 0x0083      ADD      R0,R0,R3, LSL #+2
   \       0x36   0x....'....        BL       __aeabi_memcpy
    127              next = (ringbuf->tail + 1) % (ringbuf->length);
   \       0x3A   0x68E1             LDR      R1,[R4, #+12]
   \       0x3C   0x1C49             ADDS     R1,R1,#+1
   \       0x3E   0x6862             LDR      R2,[R4, #+4]
   \       0x40   0xFBB1 0xF0F2      UDIV     R0,R1,R2
   \       0x44   0xFB02 0x1010      MLS      R0,R2,R0,R1
    128              if (next == ringbuf->head) {
   \       0x48   0x68A1             LDR      R1,[R4, #+8]
   \       0x4A   0x4288             CMP      R0,R1
   \       0x4C   0xD102             BNE.N    ??at_ringbuf_write_3
    129                  ringbuf->full = 1;
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0x7420             STRB     R0,[R4, #+16]
   \       0x52   0xE000             B.N      ??at_ringbuf_write_4
    130              } else {
    131                  ringbuf->tail = next;
   \                     ??at_ringbuf_write_3: (+1)
   \       0x54   0x60E0             STR      R0,[R4, #+12]
    132              }
    133          
    134              return 0;
   \                     ??at_ringbuf_write_4: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xBD70             POP      {R4-R6,PC}       ;; return
    135          }
    136          

   \                                 In section .text, align 2, keep-with-next
    137          static int at_ringbuf_read(at_ringbuf_t *ringbuf, void *target,
    138                                      unsigned int ms, unsigned int *size)
    139          {
   \                     at_ringbuf_read: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x461E             MOV      R6,R3
    140              *size = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x6030             STR      R0,[R6, #+0]
    141          
    142              if (ringbuf == NULL || target == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD006             BEQ.N    ??at_ringbuf_read_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD004             BEQ.N    ??at_ringbuf_read_0
    143                  return -1;
    144              }
    145          
    146              /* TODO: timeout handle */
    147              if (at_ringbuf_empty(ringbuf)) {
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       at_ringbuf_empty
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD002             BEQ.N    ??at_ringbuf_read_1
    148                  return -1;
   \                     ??at_ringbuf_read_0: (+1)
   \       0x1E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x22   0xBD70             POP      {R4-R6,PC}
    149              }
    150          
    151              memcpy(((void **)target), &((void **)ringbuf->buffer)[ringbuf->head], sizeof(void *));
   \                     ??at_ringbuf_read_1: (+1)
   \       0x24   0x2204             MOVS     R2,#+4
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x68A1             LDR      R1,[R4, #+8]
   \       0x2A   0xEB00 0x0181      ADD      R1,R0,R1, LSL #+2
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x....'....        BL       __aeabi_memcpy
    152              ((void **)ringbuf->buffer)[ringbuf->head] = NULL;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x68A2             LDR      R2,[R4, #+8]
   \       0x3A   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    153              *size = sizeof(void *);
   \       0x3E   0x2004             MOVS     R0,#+4
   \       0x40   0x6030             STR      R0,[R6, #+0]
    154              ringbuf->head = (ringbuf->head + 1) % (ringbuf->length);
   \       0x42   0x68A0             LDR      R0,[R4, #+8]
   \       0x44   0x1C40             ADDS     R0,R0,#+1
   \       0x46   0x6861             LDR      R1,[R4, #+4]
   \       0x48   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \       0x4C   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x50   0x60A0             STR      R0,[R4, #+8]
    155          
    156              if (ringbuf->full) {
   \       0x52   0x7C20             LDRB     R0,[R4, #+16]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD009             BEQ.N    ??at_ringbuf_read_2
    157                  ringbuf->full = 0;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x7420             STRB     R0,[R4, #+16]
    158                  ringbuf->tail = (ringbuf->tail + 1) % (ringbuf->length);
   \       0x5C   0x68E0             LDR      R0,[R4, #+12]
   \       0x5E   0x1C40             ADDS     R0,R0,#+1
   \       0x60   0x6861             LDR      R1,[R4, #+4]
   \       0x62   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \       0x66   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x6A   0x60E0             STR      R0,[R4, #+12]
    159              }
    160          
    161              return 0;
   \                     ??at_ringbuf_read_2: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xBD70             POP      {R4-R6,PC}       ;; return
    162          }
    163          
    164          /**********************public interface***********************/

   \                                 In section .text, align 2, keep-with-next
    165          int at_mbox_new(at_mbox_t *mb, int size, void *buf)
    166          {
   \                     at_mbox_new: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0x4611             MOV      R1,R2
    167              void *hdl = NULL;
    168          
    169              if (NULL == mb || NULL == buf) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??at_mbox_new_0
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD102             BNE.N    ??at_mbox_new_1
    170                  return  -1;
   \                     ??at_mbox_new_0: (+1)
   \       0x10   0xF04F 0x30FF      MOV      R0,#-1
   \       0x14   0xBD10             POP      {R4,PC}
    171              }
    172          
    173              hdl = at_ringbuf_create(size, buf);
   \                     ??at_mbox_new_1: (+1)
   \       0x16   0x....'....        BL       at_ringbuf_create
    174              if (hdl == NULL) {
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??at_mbox_new_2
    175                  return -1;
   \       0x1E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x22   0xBD10             POP      {R4,PC}
    176              }
    177              mb->hdl = hdl;
   \                     ??at_mbox_new_2: (+1)
   \       0x24   0x6020             STR      R0,[R4, #+0]
    178          
    179              return 0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD10             POP      {R4,PC}          ;; return
    180          }
    181          

   \                                 In section .text, align 2, keep-with-next
    182          void at_mbox_free(at_mbox_t *mb)
    183          {
    184              if ((mb != NULL)) {
   \                     at_mbox_free: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??at_mbox_free_0
    185                  at_ringbuf_destroy((at_ringbuf_t *)mb->hdl);
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x....             B.N      at_ringbuf_destroy
    186              }
    187          }
   \                     ??at_mbox_free_0: (+1)
   \        0x8   0x4770             BX       LR               ;; return
    188          

   \                                 In section .text, align 2, keep-with-next
    189          void at_mbox_post(at_mbox_t *mb, void *msg)
    190          {
   \                     at_mbox_post: (+1)
   \        0x0   0xB502             PUSH     {R1,LR}
    191              at_ringbuf_write((at_ringbuf_t *)mb->hdl, &msg, sizeof(void *));
   \        0x2   0x2204             MOVS     R2,#+4
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x....'....        BL       at_ringbuf_write
    192          }
   \        0xC   0xBD01             POP      {R0,PC}          ;; return
    193          

   \                                 In section .text, align 2, keep-with-next
    194          int at_mbox_trypost(at_mbox_t *mb, void *msg)
    195          {
   \                     at_mbox_trypost: (+1)
   \        0x0   0xB502             PUSH     {R1,LR}
    196              if (at_ringbuf_write((at_ringbuf_t *)mb->hdl,
    197                                   &msg, sizeof(void *)) != 0) {
   \        0x2   0x2204             MOVS     R2,#+4
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x....'....        BL       at_ringbuf_write
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD002             BEQ.N    ??at_mbox_trypost_0
    198                  return -1;
   \       0x10   0xF04F 0x30FF      MOV      R0,#-1
   \       0x14   0xBD02             POP      {R1,PC}
    199              } else {
    200                  return 0;
   \                     ??at_mbox_trypost_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xBD02             POP      {R1,PC}          ;; return
    201              }
    202          }
    203          

   \                                 In section .text, align 2, keep-with-next
    204          int at_mbox_valid(at_mbox_t *mbox)
    205          {
    206              if (mbox == NULL) {
   \                     at_mbox_valid: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??at_mbox_valid_0
    207                  return 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
    208              }
    209          
    210              if (mbox->hdl == NULL) {
   \                     ??at_mbox_valid_0: (+1)
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??at_mbox_valid_1
    211                  return 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR
    212              }
    213          
    214              return 1;
   \                     ??at_mbox_valid_1: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x4770             BX       LR               ;; return
    215          }
    216          

   \                                 In section .text, align 2, keep-with-next
    217          uint32_t at_mbox_fetch(at_mbox_t *mb, void **msg, uint32_t timeout)
    218          {
   \                     at_mbox_fetch: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4615             MOV      R5,R2
    219              uint32_t begin_ms, end_ms, elapsed_ms;
    220              uint32_t len;
    221              uint32_t ret;
    222          
    223              if (mb == NULL) {
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD102             BNE.N    ??at_mbox_fetch_0
    224                  return AT_MBOX_TIMEOUT;
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
   \       0x10   0xBDF2             POP      {R1,R4-R7,PC}
    225              }
    226          
    227              begin_ms = HAL_UptimeMs();
   \                     ??at_mbox_fetch_0: (+1)
   \       0x12   0x....'....        BL       HAL_UptimeMs
   \       0x16   0x4604             MOV      R4,R0
    228          
    229              if (timeout != 0UL) {
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD00E             BEQ.N    ??at_mbox_fetch_1
    230                  if (at_ringbuf_read((at_ringbuf_t *)mb->hdl, msg, timeout, &len) == 0) {
   \       0x1C   0x466B             MOV      R3,SP
   \       0x1E   0x462A             MOV      R2,R5
   \       0x20   0x4639             MOV      R1,R7
   \       0x22   0x6830             LDR      R0,[R6, #+0]
   \       0x24   0x....'....        BL       at_ringbuf_read
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD103             BNE.N    ??at_mbox_fetch_2
    231                      end_ms = HAL_UptimeMs();
   \       0x2C   0x....'....        BL       HAL_UptimeMs
    232                      elapsed_ms = end_ms - begin_ms;
    233                      ret = elapsed_ms;
   \       0x30   0x1B04             SUBS     R4,R0,R4
   \       0x32   0xE010             B.N      ??at_mbox_fetch_3
    234                  } else {
    235                      ret = AT_MBOX_TIMEOUT;
   \                     ??at_mbox_fetch_2: (+1)
   \       0x34   0xF04F 0x34FF      MOV      R4,#-1
   \       0x38   0xE00D             B.N      ??at_mbox_fetch_3
    236                  }
    237              } else {
    238                  while (at_ringbuf_read((at_ringbuf_t *)mb->hdl, msg, AT_MBOX_TIMEOUT, &len) != 0);
   \                     ??at_mbox_fetch_1: (+1)
   \       0x3A   0x466B             MOV      R3,SP
   \       0x3C   0xF04F 0x32FF      MOV      R2,#-1
   \       0x40   0x4639             MOV      R1,R7
   \       0x42   0x6830             LDR      R0,[R6, #+0]
   \       0x44   0x....'....        BL       at_ringbuf_read
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD1F6             BNE.N    ??at_mbox_fetch_1
    239                  end_ms = HAL_UptimeMs();
   \       0x4C   0x....'....        BL       HAL_UptimeMs
    240                  elapsed_ms = end_ms - begin_ms;
   \       0x50   0x1B04             SUBS     R4,R0,R4
    241          
    242                  if (elapsed_ms == 0UL) {
   \       0x52   0xD100             BNE.N    ??at_mbox_fetch_3
    243                      elapsed_ms = 1UL;
   \       0x54   0x2401             MOVS     R4,#+1
    244                  }
    245          
    246                  ret = elapsed_ms;
    247              }
    248          
    249              return ret;
   \                     ??at_mbox_fetch_3: (+1)
   \       0x56   0x4620             MOV      R0,R4
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    250          }
    251          

   \                                 In section .text, align 2, keep-with-next
    252          uint32_t at_mbox_tryfetch(at_mbox_t *mb, void **msg)
    253          {
   \                     at_mbox_tryfetch: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    254              uint32_t len;
    255          
    256              if (mb == NULL) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD102             BNE.N    ??at_mbox_tryfetch_0
    257                  return AT_MBOX_EMPTY;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD02             POP      {R1,PC}
    258              }
    259          
    260              if (at_ringbuf_read((at_ringbuf_t *)mb->hdl, msg, 0u, &len) != 0) {
   \                     ??at_mbox_tryfetch_0: (+1)
   \        0xC   0x466B             MOV      R3,SP
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x....'....        BL       at_ringbuf_read
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD002             BEQ.N    ??at_mbox_tryfetch_1
    261                  return AT_MBOX_EMPTY;
   \       0x1A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1E   0xBD02             POP      {R1,PC}
    262              } else {
    263                  return 0;
   \                     ??at_mbox_tryfetch_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD02             POP      {R1,PC}          ;; return
    264              }
    265          }
    266          

   \                                 In section .text, align 2, keep-with-next
    267          int at_mbox_empty(at_mbox_t *mb)
    268          {
    269              if (mb == NULL) {
   \                     at_mbox_empty: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD102             BNE.N    ??at_mbox_empty_0
    270                  return -1;
   \        0x4   0xF04F 0x30FF      MOV      R0,#-1
   \        0x8   0x4770             BX       LR
    271              }
    272          
    273              return at_ringbuf_empty((at_ringbuf_t *)mb->hdl);
   \                     ??at_mbox_empty_0: (+1)
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x....             B.N      at_ringbuf_empty
    274          }
    275          

   \                                 In section .text, align 2, keep-with-next
    276          void at_mbox_set_invalid(at_mbox_t *mb) 
    277          { 
    278              if (mb != NULL) { 
   \                     at_mbox_set_invalid: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??at_mbox_set_invalid_0
    279                  mb->hdl = NULL; 
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6001             STR      R1,[R0, #+0]
    280              }
    281          }
   \                     ??at_mbox_set_invalid_0: (+1)
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x45 0x72          DC8 "Error: ringbuf len MUST exceed one!"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x72    
   \              0x69 0x6E    
   \              0x67 0x62    
   \              0x75 0x66    
   \              0x20 0x6C    
   \              0x65 0x6E    
   \              0x20 0x4D    
   \              0x55 0x53    
   \              0x54 0x20    
   \              0x65 0x78    
   \              0x63 0x65    
   \              0x65 0x64    
   \              0x20 0x6F    
   \              0x6E 0x65    
   \              0x21 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x72 0x69          DC8 "ringbuf full!"
   \              0x6E 0x67    
   \              0x62 0x75    
   \              0x66 0x20    
   \              0x66 0x75    
   \              0x6C 0x6C    
   \              0x21 0x00    
   \        0xE   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   alloc_ringbuf
         0   -> HAL_Malloc
       0   at_mbox_empty
         0   -> at_ringbuf_empty
      24   at_mbox_fetch
        24   -> HAL_UptimeMs
        24   -> at_ringbuf_read
       0   at_mbox_free
         0   -> at_ringbuf_destroy
       8   at_mbox_new
         8   -> at_ringbuf_create
       8   at_mbox_post
         8   -> at_ringbuf_write
       0   at_mbox_set_invalid
       8   at_mbox_tryfetch
         8   -> at_ringbuf_read
       8   at_mbox_trypost
         8   -> at_ringbuf_write
       0   at_mbox_valid
       0   at_ringbuf_available_read_space
       0   at_ringbuf_clear_all
      16   at_ringbuf_create
        16   -> HAL_Printf
        16   -> __aeabi_memset4
        16   -> alloc_ringbuf
       8   at_ringbuf_destroy
         8   -> at_ringbuf_clear_all
         0   -> free_ringbuf
       8   at_ringbuf_empty
         8   -> at_ringbuf_available_read_space
       0   at_ringbuf_full
      16   at_ringbuf_read
        16   -> __aeabi_memcpy
        16   -> at_ringbuf_empty
      16   at_ringbuf_write
        16   -> HAL_Printf
        16   -> __aeabi_memcpy
        16   -> at_ringbuf_full
       0   free_ringbuf
         0   -> HAL_Free


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
      36  ?_0
      16  ?_1
       6  alloc_ringbuf
      14  at_mbox_empty
      90  at_mbox_fetch
      10  at_mbox_free
      42  at_mbox_new
      14  at_mbox_post
      10  at_mbox_set_invalid
      36  at_mbox_tryfetch
      26  at_mbox_trypost
      22  at_mbox_valid
      46  at_ringbuf_available_read_space
       8  at_ringbuf_clear_all
      52  at_ringbuf_create
      32  at_ringbuf_destroy
      14  at_ringbuf_empty
       4  at_ringbuf_full
     112  at_ringbuf_read
      90  at_ringbuf_write
      10  free_ringbuf

 
  52 bytes in section .rodata
 646 bytes in section .text
 
 646 bytes of CODE  memory
  52 bytes of CONST memory

Errors: none
Warnings: none
