###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:44
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\amazon-freertos\freertos\queue.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW3AA8.tmp
#        (C:\Development\smart_washing_machine_3080\amazon-freertos\freertos\queue.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\queue.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\queue.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\amazon-freertos\freertos\queue.c
      1          /*
      2           * FreeRTOS Kernel V10.2.0
      3           * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * http://www.FreeRTOS.org
     23           * http://aws.amazon.com/freertos
     24           *
     25           * 1 tab == 4 spaces!
     26           */
     27          
     28          #include <stdlib.h>
     29          #include <string.h>
     30          
     31          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     32          all the API functions to use the MPU wrappers.  That should only be done when
     33          task.h is included from an application file. */
     34          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     35          
     36          #include "FreeRTOS.h"
     37          #include "task.h"
     38          #include "queue.h"
     39          
     40          #if ( configUSE_CO_ROUTINES == 1 )
     41          	#include "croutine.h"
     42          #endif
     43          
     44          /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
     45          because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     46          for the header files above, but not in this file, in order to generate the
     47          correct privileged Vs unprivileged linkage and placement. */
     48          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
     49          
     50          
     51          /* Constants used with the cRxLock and cTxLock structure members. */
     52          #define queueUNLOCKED					( ( int8_t ) -1 )
     53          #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
     54          
     55          /* When the Queue_t structure is used to represent a base queue its pcHead and
     56          pcTail members are used as pointers into the queue storage area.  When the
     57          Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
     58          not necessary, and the pcHead pointer is set to NULL to indicate that the
     59          structure instead holds a pointer to the mutex holder (if any).  Map alternative
     60          names to the pcHead and structure member to ensure the readability of the code
     61          is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
     62          a union as their usage is mutually exclusive dependent on what the queue is
     63          being used for. */
     64          #define uxQueueType						pcHead
     65          #define queueQUEUE_IS_MUTEX				NULL
     66          
     67          typedef struct QueuePointers
     68          {
     69          	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
     70          	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
     71          } QueuePointers_t;
     72          
     73          typedef struct SemaphoreData
     74          {
     75          	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
     76          	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
     77          } SemaphoreData_t;
     78          
     79          /* Semaphores do not actually store or copy data, so have an item size of
     80          zero. */
     81          #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
     82          #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
     83          
     84          #if( configUSE_PREEMPTION == 0 )
     85          	/* If the cooperative scheduler is being used then a yield should not be
     86          	performed just because a higher priority task has been woken. */
     87          	#define queueYIELD_IF_USING_PREEMPTION()
     88          #else
     89          	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
     90          #endif
     91          
     92          /*
     93           * Definition of the queue used by the scheduler.
     94           * Items are queued by copy, not reference.  See the following link for the
     95           * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
     96           */
     97          typedef struct QueueDefinition 		/* The old naming convention is used to prevent breaking kernel aware debuggers. */
     98          {
     99          	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
    100          	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
    101          
    102          	union
    103          	{
    104          		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
    105          		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaphore. */
    106          	} u;
    107          
    108          	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
    109          	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
    110          
    111          	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
    112          	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
    113          	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
    114          
    115          	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    116          	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    117          
    118          	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    119          		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
    120          	#endif
    121          
    122          	#if ( configUSE_QUEUE_SETS == 1 )
    123          		struct QueueDefinition *pxQueueSetContainer;
    124          	#endif
    125          
    126          	#if ( configUSE_TRACE_FACILITY == 1 )
    127          		UBaseType_t uxQueueNumber;
    128          		uint8_t ucQueueType;
    129          	#endif
    130          
    131          } xQUEUE;
    132          
    133          /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
    134          name below to enable the use of older kernel aware debuggers. */
    135          typedef xQUEUE Queue_t;
    136          
    137          /*-----------------------------------------------------------*/
    138          
    139          /*
    140           * The queue registry is just a means for kernel aware debuggers to locate
    141           * queue structures.  It has no other purpose so is an optional component.
    142           */
    143          #if ( configQUEUE_REGISTRY_SIZE > 0 )
    144          
    145          	/* The type stored within the queue registry array.  This allows a name
    146          	to be assigned to each queue making kernel aware debugging a little
    147          	more user friendly. */
    148          	typedef struct QUEUE_REGISTRY_ITEM
    149          	{
    150          		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    151          		QueueHandle_t xHandle;
    152          	} xQueueRegistryItem;
    153          
    154          	/* The old xQueueRegistryItem name is maintained above then typedefed to the
    155          	new xQueueRegistryItem name below to enable the use of older kernel aware
    156          	debuggers. */
    157          	typedef xQueueRegistryItem QueueRegistryItem_t;
    158          
    159          	/* The queue registry is simply an array of QueueRegistryItem_t structures.
    160          	The pcQueueName member of a structure being NULL is indicative of the
    161          	array position being vacant. */

   \                                 In section .bss, align 4
    162          	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
   \                     xQueueRegistry:
   \        0x0                      DS8 64
    163          
    164          #endif /* configQUEUE_REGISTRY_SIZE */
    165          
    166          /*
    167           * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
    168           * prevent an ISR from adding or removing items to the queue, but does prevent
    169           * an ISR from removing tasks from the queue event lists.  If an ISR finds a
    170           * queue is locked it will instead increment the appropriate queue lock count
    171           * to indicate that a task may require unblocking.  When the queue in unlocked
    172           * these lock counts are inspected, and the appropriate action taken.
    173           */
    174          static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
    175          
    176          /*
    177           * Uses a critical section to determine if there is any data in a queue.
    178           *
    179           * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
    180           */
    181          static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
    182          
    183          /*
    184           * Uses a critical section to determine if there is any space in a queue.
    185           *
    186           * @return pdTRUE if there is no space, otherwise pdFALSE;
    187           */
    188          static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
    189          
    190          /*
    191           * Copies an item into the queue, either at the front of the queue or the
    192           * back of the queue.
    193           */
    194          static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
    195          
    196          /*
    197           * Copies an item out of a queue.
    198           */
    199          static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
    200          
    201          #if ( configUSE_QUEUE_SETS == 1 )
    202          	/*
    203          	 * Checks to see if a queue is a member of a queue set, and if so, notifies
    204          	 * the queue set that the queue contains data.
    205          	 */
    206          	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
    207          #endif
    208          
    209          /*
    210           * Called after a Queue_t structure has been allocated either statically or
    211           * dynamically to fill in the structure's members.
    212           */
    213          static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
    214          
    215          /*
    216           * Mutexes are a special type of queue.  When a mutex is created, first the
    217           * queue is created, then prvInitialiseMutex() is called to configure the queue
    218           * as a mutex.
    219           */
    220          #if( configUSE_MUTEXES == 1 )
    221          	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
    222          #endif
    223          
    224          #if( configUSE_MUTEXES == 1 )
    225          	/*
    226          	 * If a task waiting for a mutex causes the mutex holder to inherit a
    227          	 * priority, but the waiting task times out, then the holder should
    228          	 * disinherit the priority - but only down to the highest priority of any
    229          	 * other tasks that are waiting for the same mutex.  This function returns
    230          	 * that priority.
    231          	 */
    232          	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
    233          #endif
    234          /*-----------------------------------------------------------*/
    235          
    236          /*
    237           * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
    238           * accessing the queue event lists.
    239           */
    240          #define prvLockQueue( pxQueue )								\
    241          	taskENTER_CRITICAL();									\
    242          	{														\
    243          		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
    244          		{													\
    245          			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
    246          		}													\
    247          		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
    248          		{													\
    249          			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
    250          		}													\
    251          	}														\
    252          	taskEXIT_CRITICAL()
    253          /*-----------------------------------------------------------*/
    254          

   \                                 In section .text, align 2, keep-with-next
    255          BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
    256          {
   \                     xQueueGenericReset: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    257          Queue_t * const pxQueue = xQueue;
    258          
    259          	configASSERT( pxQueue );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xQueueGenericReset_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericReset_1: (+1)
   \       0x18   0xE7FE             B.N      ??xQueueGenericReset_1
    260          
    261          	taskENTER_CRITICAL();
   \                     ??xQueueGenericReset_0: (+1)
   \       0x1A   0x....'....        BL       vPortEnterCritical
    262          	{
    263          		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x6BE2             LDR      R2,[R4, #+60]
   \       0x22   0x6C20             LDR      R0,[R4, #+64]
   \       0x24   0x4342             MULS     R2,R0,R2
   \       0x26   0x1888             ADDS     R0,R1,R2
   \       0x28   0x60A0             STR      R0,[R4, #+8]
    264          		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x63A0             STR      R0,[R4, #+56]
    265          		pxQueue->pcWriteTo = pxQueue->pcHead;
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6060             STR      R0,[R4, #+4]
    266          		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   \       0x32   0x6821             LDR      R1,[R4, #+0]
   \       0x34   0x6BE2             LDR      R2,[R4, #+60]
   \       0x36   0x1E52             SUBS     R2,R2,#+1
   \       0x38   0x6C20             LDR      R0,[R4, #+64]
   \       0x3A   0x4342             MULS     R2,R0,R2
   \       0x3C   0x1888             ADDS     R0,R1,R2
   \       0x3E   0x60E0             STR      R0,[R4, #+12]
    267          		pxQueue->cRxLock = queueUNLOCKED;
   \       0x40   0xF04F 0x30FF      MOV      R0,#-1
   \       0x44   0xF884 0x0044      STRB     R0,[R4, #+68]
    268          		pxQueue->cTxLock = queueUNLOCKED;
   \       0x48   0xF884 0x0045      STRB     R0,[R4, #+69]
    269          
    270          		if( xNewQueue == pdFALSE )
   \       0x4C   0x2D00             CMP      R5,#+0
   \       0x4E   0xD112             BNE.N    ??xQueueGenericReset_2
    271          		{
    272          			/* If there are tasks blocked waiting to read from the queue, then
    273          			the tasks will remain blocked as after this function exits the queue
    274          			will still be empty.  If there are tasks blocked waiting to write to
    275          			the queue, then one should be unblocked as after this function exits
    276          			it will be possible to write to it. */
    277          			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \       0x50   0x6920             LDR      R0,[R4, #+16]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD017             BEQ.N    ??xQueueGenericReset_3
    278          			{
    279          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \       0x56   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x5A   0x....'....        BL       xTaskRemoveFromEventList
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD011             BEQ.N    ??xQueueGenericReset_3
    280          				{
    281          					queueYIELD_IF_USING_PREEMPTION();
   \       0x62   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x66   0x....'....        LDR.W    R1,??DataTable6  ;; 0xe000ed04
   \       0x6A   0x6008             STR      R0,[R1, #+0]
   \       0x6C   0xF3BF 0x8F4F      DSB      SY
   \       0x70   0xF3BF 0x8F6F      ISB      SY
   \       0x74   0xE007             B.N      ??xQueueGenericReset_3
    282          				}
    283          				else
    284          				{
    285          					mtCOVERAGE_TEST_MARKER();
    286          				}
    287          			}
    288          			else
    289          			{
    290          				mtCOVERAGE_TEST_MARKER();
    291          			}
    292          		}
    293          		else
    294          		{
    295          			/* Ensure the event queues start in the correct state. */
    296          			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   \                     ??xQueueGenericReset_2: (+1)
   \       0x76   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x7A   0x....'....        BL       vListInitialise
    297          			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   \       0x7E   0xF104 0x0024      ADD      R0,R4,#+36
   \       0x82   0x....'....        BL       vListInitialise
    298          		}
    299          	}
    300          	taskEXIT_CRITICAL();
   \                     ??xQueueGenericReset_3: (+1)
   \       0x86   0x....'....        BL       vPortExitCritical
    301          
    302          	/* A value is returned for calling semantic consistency with previous
    303          	versions. */
    304          	return pdPASS;
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    305          }
    306          /*-----------------------------------------------------------*/
    307          
    308          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    309          
    310          	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
    311          	{
    312          	Queue_t *pxNewQueue;
    313          
    314          		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    315          
    316          		/* The StaticQueue_t structure and the queue storage area must be
    317          		supplied. */
    318          		configASSERT( pxStaticQueue != NULL );
    319          
    320          		/* A queue storage area should be provided if the item size is not 0, and
    321          		should not be provided if the item size is 0. */
    322          		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
    323          		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
    324          
    325          		#if( configASSERT_DEFINED == 1 )
    326          		{
    327          			/* Sanity check that the size of the structure used to declare a
    328          			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
    329          			the real queue and semaphore structures. */
    330          			volatile size_t xSize = sizeof( StaticQueue_t );
    331          			configASSERT( xSize == sizeof( Queue_t ) );
    332          			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
    333          		}
    334          		#endif /* configASSERT_DEFINED */
    335          
    336          		/* The address of a statically allocated queue was passed in, use it.
    337          		The address of a statically allocated storage area was also passed in
    338          		but is already set. */
    339          		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    340          
    341          		if( pxNewQueue != NULL )
    342          		{
    343          			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    344          			{
    345          				/* Queues can be allocated wither statically or dynamically, so
    346          				note this queue was allocated statically in case the queue is
    347          				later deleted. */
    348          				pxNewQueue->ucStaticallyAllocated = pdTRUE;
    349          			}
    350          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    351          
    352          			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    353          		}
    354          		else
    355          		{
    356          			traceQUEUE_CREATE_FAILED( ucQueueType );
    357          			mtCOVERAGE_TEST_MARKER();
    358          		}
    359          
    360          		return pxNewQueue;
    361          	}
    362          
    363          #endif /* configSUPPORT_STATIC_ALLOCATION */
    364          /*-----------------------------------------------------------*/
    365          
    366          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    367          

   \                                 In section .text, align 2, keep-with-next
    368          	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
    369          	{
   \                     xQueueGenericCreate: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4617             MOV      R7,R2
    370          	Queue_t *pxNewQueue;
    371          	size_t xQueueSizeInBytes;
    372          	uint8_t *pucQueueStorage;
    373          
    374          		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD107             BNE.N    ??xQueueGenericCreate_0
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x12   0xF3BF 0x8F4F      DSB      SY
   \       0x16   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericCreate_1: (+1)
   \       0x1A   0xE7FE             B.N      ??xQueueGenericCreate_1
    375          
    376          		if( uxItemSize == ( UBaseType_t ) 0 )
   \                     ??xQueueGenericCreate_0: (+1)
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD101             BNE.N    ??xQueueGenericCreate_2
    377          		{
    378          			/* There is not going to be a queue storage area. */
    379          			xQueueSizeInBytes = ( size_t ) 0;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xE001             B.N      ??xQueueGenericCreate_3
    380          		}
    381          		else
    382          		{
    383          			/* Allocate enough space to hold the maximum number of items that
    384          			can be in the queue at any time. */
    385          			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \                     ??xQueueGenericCreate_2: (+1)
   \       0x24   0xFB05 0xF006      MUL      R0,R5,R6
    386          		}
    387          
    388          		/* Allocate the queue and storage area.  Justification for MISRA
    389          		deviation as follows:  pvPortMalloc() always ensures returned memory
    390          		blocks are aligned per the requirements of the MCU stack.  In this case
    391          		pvPortMalloc() must return a pointer that is guaranteed to meet the
    392          		alignment requirements of the Queue_t structure - which in this case
    393          		is an int8_t *.  Therefore, whenever the stack alignment requirements
    394          		are greater than or equal to the pointer to char requirements the cast
    395          		is safe.  In other cases alignment requirements are not strict (one or
    396          		two bytes). */
    397          		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
   \                     ??xQueueGenericCreate_3: (+1)
   \       0x28   0x3050             ADDS     R0,R0,#+80
   \       0x2A   0x....'....        BL       pvPortMalloc
   \       0x2E   0x0004             MOVS     R4,R0
    398          
    399          		if( pxNewQueue != NULL )
   \       0x30   0xD007             BEQ.N    ??xQueueGenericCreate_4
    400          		{
    401          			/* Jump past the queue structure to find the location of the queue
    402          			storage area. */
    403          			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    404          			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    405          
    406          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    407          			{
    408          				/* Queues can be created either statically or dynamically, so
    409          				note this task was created dynamically in case it is later
    410          				deleted. */
    411          				pxNewQueue->ucStaticallyAllocated = pdFALSE;
    412          			}
    413          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    414          
    415          			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   \       0x32   0x9400             STR      R4,[SP, #+0]
   \       0x34   0x463B             MOV      R3,R7
   \       0x36   0xF104 0x0250      ADD      R2,R4,#+80
   \       0x3A   0x4629             MOV      R1,R5
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x....'....        BL       prvInitialiseNewQueue
    416          		}
    417          		else
    418          		{
    419          			traceQUEUE_CREATE_FAILED( ucQueueType );
    420          			mtCOVERAGE_TEST_MARKER();
    421          		}
    422          
    423          		return pxNewQueue;
   \                     ??xQueueGenericCreate_4: (+1)
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    424          	}
    425          
    426          #endif /* configSUPPORT_STATIC_ALLOCATION */
    427          /*-----------------------------------------------------------*/
    428          

   \                                 In section .text, align 2, keep-with-next
    429          static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
    430          {
   \                     prvInitialiseNewQueue: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x461C             MOV      R4,R3
   \        0x4   0x9D04             LDR      R5,[SP, #+16]
    431          	/* Remove compiler warnings about unused parameters should
    432          	configUSE_TRACE_FACILITY not be set to 1. */
    433          	( void ) ucQueueType;
    434          
    435          	if( uxItemSize == ( UBaseType_t ) 0 )
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??prvInitialiseNewQueue_0
    436          	{
    437          		/* No RAM was allocated for the queue storage area, but PC head cannot
    438          		be set to NULL because NULL is used as a key to say the queue is used as
    439          		a mutex.  Therefore just set pcHead to point to the queue as a benign
    440          		value that is known to be within the memory map. */
    441          		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   \        0xA   0x602D             STR      R5,[R5, #+0]
   \        0xC   0xE000             B.N      ??prvInitialiseNewQueue_1
    442          	}
    443          	else
    444          	{
    445          		/* Set the head to the start of the queue storage area. */
    446          		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   \                     ??prvInitialiseNewQueue_0: (+1)
   \        0xE   0x602A             STR      R2,[R5, #+0]
    447          	}
    448          
    449          	/* Initialise the queue members as described where the queue type is
    450          	defined. */
    451          	pxNewQueue->uxLength = uxQueueLength;
   \                     ??prvInitialiseNewQueue_1: (+1)
   \       0x10   0x63E8             STR      R0,[R5, #+60]
    452          	pxNewQueue->uxItemSize = uxItemSize;
   \       0x12   0x6429             STR      R1,[R5, #+64]
    453          	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x....'....        BL       xQueueGenericReset
    454          
    455          	#if ( configUSE_TRACE_FACILITY == 1 )
    456          	{
    457          		pxNewQueue->ucQueueType = ucQueueType;
   \       0x1C   0xF885 0x404C      STRB     R4,[R5, #+76]
    458          	}
    459          	#endif /* configUSE_TRACE_FACILITY */
    460          
    461          	#if( configUSE_QUEUE_SETS == 1 )
    462          	{
    463          		pxNewQueue->pxQueueSetContainer = NULL;
    464          	}
    465          	#endif /* configUSE_QUEUE_SETS */
    466          
    467          	traceQUEUE_CREATE( pxNewQueue );
    468          }
   \       0x20   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    469          /*-----------------------------------------------------------*/
    470          
    471          #if( configUSE_MUTEXES == 1 )
    472          

   \                                 In section .text, align 2, keep-with-next
    473          	static void prvInitialiseMutex( Queue_t *pxNewQueue )
    474          	{
    475          		if( pxNewQueue != NULL )
   \                     prvInitialiseMutex: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD006             BEQ.N    ??prvInitialiseMutex_0
    476          		{
    477          			/* The queue create function will set all the queue structure members
    478          			correctly for a generic queue, but this function is creating a
    479          			mutex.  Overwrite those members that need to be set differently -
    480          			in particular the information required for priority inheritance. */
    481          			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6081             STR      R1,[R0, #+8]
    482          			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   \        0x8   0x6001             STR      R1,[R0, #+0]
    483          
    484          			/* In case this is a recursive mutex. */
    485          			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
   \        0xA   0x60C1             STR      R1,[R0, #+12]
    486          
    487          			traceCREATE_MUTEX( pxNewQueue );
    488          
    489          			/* Start with the semaphore in the expected state. */
    490          			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   \        0xC   0x460B             MOV      R3,R1
   \        0xE   0x460A             MOV      R2,R1
   \       0x10   0x....             B.N      xQueueGenericSend
    491          		}
    492          		else
    493          		{
    494          			traceCREATE_MUTEX_FAILED();
    495          		}
    496          	}
   \                     ??prvInitialiseMutex_0: (+1)
   \       0x12   0x4770             BX       LR               ;; return
    497          
    498          #endif /* configUSE_MUTEXES */
    499          /*-----------------------------------------------------------*/
    500          
    501          #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    502          

   \                                 In section .text, align 2, keep-with-next
    503          	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    504          	{
   \                     xQueueCreateMutex: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4602             MOV      R2,R0
    505          	QueueHandle_t xNewQueue;
    506          	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    507          
    508          		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x....'....        BL       xQueueGenericCreate
   \        0xC   0x4604             MOV      R4,R0
    509          		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
   \        0xE   0x....'....        BL       prvInitialiseMutex
    510          
    511          		return xNewQueue;
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
    512          	}
    513          
    514          #endif /* configUSE_MUTEXES */
    515          /*-----------------------------------------------------------*/
    516          
    517          #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    518          
    519          	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
    520          	{
    521          	QueueHandle_t xNewQueue;
    522          	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    523          
    524          		/* Prevent compiler warnings about unused parameters if
    525          		configUSE_TRACE_FACILITY does not equal 1. */
    526          		( void ) ucQueueType;
    527          
    528          		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
    529          		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    530          
    531          		return xNewQueue;
    532          	}
    533          
    534          #endif /* configUSE_MUTEXES */
    535          /*-----------------------------------------------------------*/
    536          
    537          #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
    538          
    539          	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
    540          	{
    541          	TaskHandle_t pxReturn;
    542          	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
    543          
    544          		/* This function is called by xSemaphoreGetMutexHolder(), and should not
    545          		be called directly.  Note:  This is a good way of determining if the
    546          		calling task is the mutex holder, but not a good way of determining the
    547          		identity of the mutex holder, as the holder may change between the
    548          		following critical section exiting and the function returning. */
    549          		taskENTER_CRITICAL();
    550          		{
    551          			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
    552          			{
    553          				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
    554          			}
    555          			else
    556          			{
    557          				pxReturn = NULL;
    558          			}
    559          		}
    560          		taskEXIT_CRITICAL();
    561          
    562          		return pxReturn;
    563          	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
    564          
    565          #endif
    566          /*-----------------------------------------------------------*/
    567          
    568          #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
    569          
    570          	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
    571          	{
    572          	TaskHandle_t pxReturn;
    573          
    574          		configASSERT( xSemaphore );
    575          
    576          		/* Mutexes cannot be used in interrupt service routines, so the mutex
    577          		holder should not change in an ISR, and therefore a critical section is
    578          		not required here. */
    579          		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
    580          		{
    581          			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
    582          		}
    583          		else
    584          		{
    585          			pxReturn = NULL;
    586          		}
    587          
    588          		return pxReturn;
    589          	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
    590          
    591          #endif
    592          /*-----------------------------------------------------------*/
    593          
    594          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    595          

   \                                 In section .text, align 2, keep-with-next
    596          	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    597          	{
   \                     xQueueGiveMutexRecursive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    598          	BaseType_t xReturn;
    599          	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    600          
    601          		configASSERT( pxMutex );
   \        0x4   0xD107             BNE.N    ??xQueueGiveMutexRecursive_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGiveMutexRecursive_1: (+1)
   \       0x14   0xE7FE             B.N      ??xQueueGiveMutexRecursive_1
    602          
    603          		/* If this is the task that holds the mutex then xMutexHolder will not
    604          		change outside of this task.  If this task does not hold the mutex then
    605          		pxMutexHolder can never coincidentally equal the tasks handle, and as
    606          		this is the only condition we are interested in it does not matter if
    607          		pxMutexHolder is accessed simultaneously by another task.  Therefore no
    608          		mutual exclusion is required to test the pxMutexHolder variable. */
    609          		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
   \                     ??xQueueGiveMutexRecursive_0: (+1)
   \       0x16   0x....'....        BL       xTaskGetCurrentTaskHandle
   \       0x1A   0x68A1             LDR      R1,[R4, #+8]
   \       0x1C   0x4281             CMP      R1,R0
   \       0x1E   0xD10B             BNE.N    ??xQueueGiveMutexRecursive_2
    610          		{
    611          			traceGIVE_MUTEX_RECURSIVE( pxMutex );
    612          
    613          			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
    614          			the task handle, therefore no underflow check is required.  Also,
    615          			uxRecursiveCallCount is only modified by the mutex holder, and as
    616          			there can only be one, no mutual exclusion is required to modify the
    617          			uxRecursiveCallCount member. */
    618          			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
   \       0x20   0x68E0             LDR      R0,[R4, #+12]
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0x60E0             STR      R0,[R4, #+12]
    619          
    620          			/* Has the recursive call count unwound to 0? */
    621          			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
   \       0x26   0xD105             BNE.N    ??xQueueGiveMutexRecursive_3
    622          			{
    623          				/* Return the mutex.  This will automatically unblock any other
    624          				task that might be waiting to access the mutex. */
    625          				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x461A             MOV      R2,R3
   \       0x2C   0x4611             MOV      R1,R2
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       xQueueGenericSend
    626          			}
    627          			else
    628          			{
    629          				mtCOVERAGE_TEST_MARKER();
    630          			}
    631          
    632          			xReturn = pdPASS;
   \                     ??xQueueGiveMutexRecursive_3: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD10             POP      {R4,PC}
    633          		}
    634          		else
    635          		{
    636          			/* The mutex cannot be given because the calling task is not the
    637          			holder. */
    638          			xReturn = pdFAIL;
   \                     ??xQueueGiveMutexRecursive_2: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
    639          
    640          			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
    641          		}
    642          
    643          		return xReturn;
   \       0x3A   0xBD10             POP      {R4,PC}          ;; return
    644          	}
    645          
    646          #endif /* configUSE_RECURSIVE_MUTEXES */
    647          /*-----------------------------------------------------------*/
    648          
    649          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    650          

   \                                 In section .text, align 2, keep-with-next
    651          	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
    652          	{
   \                     xQueueTakeMutexRecursive: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    653          	BaseType_t xReturn;
    654          	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    655          
    656          		configASSERT( pxMutex );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xQueueTakeMutexRecursive_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueTakeMutexRecursive_1: (+1)
   \       0x18   0xE7FE             B.N      ??xQueueTakeMutexRecursive_1
    657          
    658          		/* Comments regarding mutual exclusion as per those within
    659          		xQueueGiveMutexRecursive(). */
    660          
    661          		traceTAKE_MUTEX_RECURSIVE( pxMutex );
    662          
    663          		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
   \                     ??xQueueTakeMutexRecursive_0: (+1)
   \       0x1A   0x....'....        BL       xTaskGetCurrentTaskHandle
   \       0x1E   0x68A1             LDR      R1,[R4, #+8]
   \       0x20   0x4281             CMP      R1,R0
   \       0x22   0xD104             BNE.N    ??xQueueTakeMutexRecursive_2
    664          		{
    665          			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
   \       0x24   0x68E0             LDR      R0,[R4, #+12]
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \       0x28   0x60E0             STR      R0,[R4, #+12]
    666          			xReturn = pdPASS;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
    667          		}
    668          		else
    669          		{
    670          			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
   \                     ??xQueueTakeMutexRecursive_2: (+1)
   \       0x2E   0x4629             MOV      R1,R5
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       xQueueSemaphoreTake
    671          
    672          			/* pdPASS will only be returned if the mutex was successfully
    673          			obtained.  The calling task may have entered the Blocked state
    674          			before reaching here. */
    675          			if( xReturn != pdFAIL )
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD002             BEQ.N    ??xQueueTakeMutexRecursive_3
    676          			{
    677          				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
   \       0x3A   0x68E1             LDR      R1,[R4, #+12]
   \       0x3C   0x1C49             ADDS     R1,R1,#+1
   \       0x3E   0x60E1             STR      R1,[R4, #+12]
    678          			}
    679          			else
    680          			{
    681          				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
    682          			}
    683          		}
    684          
    685          		return xReturn;
   \                     ??xQueueTakeMutexRecursive_3: (+1)
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    686          	}
    687          
    688          #endif /* configUSE_RECURSIVE_MUTEXES */
    689          /*-----------------------------------------------------------*/
    690          
    691          #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    692          
    693          	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
    694          	{
    695          	QueueHandle_t xHandle;
    696          
    697          		configASSERT( uxMaxCount != 0 );
    698          		configASSERT( uxInitialCount <= uxMaxCount );
    699          
    700          		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    701          
    702          		if( xHandle != NULL )
    703          		{
    704          			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    705          
    706          			traceCREATE_COUNTING_SEMAPHORE();
    707          		}
    708          		else
    709          		{
    710          			traceCREATE_COUNTING_SEMAPHORE_FAILED();
    711          		}
    712          
    713          		return xHandle;
    714          	}
    715          
    716          #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
    717          /*-----------------------------------------------------------*/
    718          
    719          #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    720          

   \                                 In section .text, align 2, keep-with-next
    721          	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
    722          	{
   \                     xQueueCreateCountingSemaphore: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    723          	QueueHandle_t xHandle;
    724          
    725          		configASSERT( uxMaxCount != 0 );
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD107             BNE.N    ??xQueueCreateCountingSemaphore_0
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueCreateCountingSemaphore_1: (+1)
   \       0x16   0xE7FE             B.N      ??xQueueCreateCountingSemaphore_1
    726          		configASSERT( uxInitialCount <= uxMaxCount );
   \                     ??xQueueCreateCountingSemaphore_0: (+1)
   \       0x18   0x42A0             CMP      R0,R4
   \       0x1A   0xD207             BCS.N    ??xQueueCreateCountingSemaphore_2
   \       0x1C   0x2020             MOVS     R0,#+32
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueCreateCountingSemaphore_3: (+1)
   \       0x2A   0xE7FE             B.N      ??xQueueCreateCountingSemaphore_3
    727          
    728          		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   \                     ??xQueueCreateCountingSemaphore_2: (+1)
   \       0x2C   0x2202             MOVS     R2,#+2
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x....'....        BL       xQueueGenericCreate
    729          
    730          		if( xHandle != NULL )
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD000             BEQ.N    ??xQueueCreateCountingSemaphore_4
    731          		{
    732          			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   \       0x38   0x6384             STR      R4,[R0, #+56]
    733          
    734          			traceCREATE_COUNTING_SEMAPHORE();
    735          		}
    736          		else
    737          		{
    738          			traceCREATE_COUNTING_SEMAPHORE_FAILED();
    739          		}
    740          
    741          		return xHandle;
   \                     ??xQueueCreateCountingSemaphore_4: (+1)
   \       0x3A   0xBD10             POP      {R4,PC}          ;; return
    742          	}
    743          
    744          #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
    745          /*-----------------------------------------------------------*/
    746          

   \                                 In section .text, align 2, keep-with-next
    747          BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
    748          {
   \                     xQueueGenericSend: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x461F             MOV      R7,R3
    749          BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   \        0x8   0x2400             MOVS     R4,#+0
    750          TimeOut_t xTimeOut;
    751          Queue_t * const pxQueue = xQueue;
    752          
    753          	configASSERT( pxQueue );
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD107             BNE.N    ??xQueueGenericSend_0
   \        0xE   0x2020             MOVS     R0,#+32
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xQueueGenericSend_1
    754          	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueGenericSend_0: (+1)
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD104             BNE.N    ??xQueueGenericSend_2
   \       0x22   0x6C28             LDR      R0,[R5, #+64]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x4180             SBCS     R0,R0,R0
   \       0x28   0x0FC0             LSRS     R0,R0,#+31
   \       0x2A   0xE000             B.N      ??xQueueGenericSend_3
   \                     ??xQueueGenericSend_2: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \                     ??xQueueGenericSend_3: (+1)
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??xQueueGenericSend_4
   \       0x32   0x2020             MOVS     R0,#+32
   \       0x34   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_5: (+1)
   \       0x40   0xE7FE             B.N      ??xQueueGenericSend_5
    755          	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   \                     ??xQueueGenericSend_4: (+1)
   \       0x42   0x2F02             CMP      R7,#+2
   \       0x44   0xD102             BNE.N    ??xQueueGenericSend_6
   \       0x46   0x6BE8             LDR      R0,[R5, #+60]
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD101             BNE.N    ??xQueueGenericSend_7
   \                     ??xQueueGenericSend_6: (+1)
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xE000             B.N      ??xQueueGenericSend_8
   \                     ??xQueueGenericSend_7: (+1)
   \       0x50   0x4620             MOV      R0,R4
   \                     ??xQueueGenericSend_8: (+1)
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD107             BNE.N    ??xQueueGenericSend_9
   \       0x56   0x2020             MOVS     R0,#+32
   \       0x58   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x5C   0xF3BF 0x8F4F      DSB      SY
   \       0x60   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_10: (+1)
   \       0x64   0xE7FE             B.N      ??xQueueGenericSend_10
    756          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    757          	{
    758          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueueGenericSend_9: (+1)
   \       0x66   0x....'....        BL       xTaskGetSchedulerState
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD104             BNE.N    ??xQueueGenericSend_11
   \       0x6E   0x9802             LDR      R0,[SP, #+8]
   \       0x70   0x1E40             SUBS     R0,R0,#+1
   \       0x72   0x4180             SBCS     R0,R0,R0
   \       0x74   0x0FC0             LSRS     R0,R0,#+31
   \       0x76   0xE000             B.N      ??xQueueGenericSend_12
   \                     ??xQueueGenericSend_11: (+1)
   \       0x78   0x2001             MOVS     R0,#+1
   \                     ??xQueueGenericSend_12: (+1)
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD11C             BNE.N    ??xQueueGenericSend_13
   \       0x7E   0x2020             MOVS     R0,#+32
   \       0x80   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x84   0xF3BF 0x8F4F      DSB      SY
   \       0x88   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_14: (+1)
   \       0x8C   0xE7FE             B.N      ??xQueueGenericSend_14
    759          	}
    760          	#endif
    761          
    762          
    763          	/*lint -save -e904 This function relaxes the coding standard somewhat to
    764          	allow return statements within the function itself.  This is done in the
    765          	interest of execution time efficiency. */
    766          	for( ;; )
    767          	{
    768          		taskENTER_CRITICAL();
    769          		{
    770          			/* Is there room on the queue now?  The running task must be the
    771          			highest priority task wanting to access the queue.  If the head item
    772          			in the queue is to be overwritten then it does not matter if the
    773          			queue is full. */
    774          			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    775          			{
    776          				traceQUEUE_SEND( pxQueue );
    777          
    778          				#if ( configUSE_QUEUE_SETS == 1 )
    779          				{
    780          				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    781          
    782          					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    783          
    784          					if( pxQueue->pxQueueSetContainer != NULL )
    785          					{
    786          						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
    787          						{
    788          							/* Do not notify the queue set as an existing item
    789          							was overwritten in the queue so the number of items
    790          							in the queue has not changed. */
    791          							mtCOVERAGE_TEST_MARKER();
    792          						}
    793          						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
    794          						{
    795          							/* The queue is a member of a queue set, and posting
    796          							to the queue set caused a higher priority task to
    797          							unblock. A context switch is required. */
    798          							queueYIELD_IF_USING_PREEMPTION();
    799          						}
    800          						else
    801          						{
    802          							mtCOVERAGE_TEST_MARKER();
    803          						}
    804          					}
    805          					else
    806          					{
    807          						/* If there was a task waiting for data to arrive on the
    808          						queue then unblock it now. */
    809          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    810          						{
    811          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    812          							{
    813          								/* The unblocked task has a priority higher than
    814          								our own so yield immediately.  Yes it is ok to
    815          								do this from within the critical section - the
    816          								kernel takes care of that. */
    817          								queueYIELD_IF_USING_PREEMPTION();
    818          							}
    819          							else
    820          							{
    821          								mtCOVERAGE_TEST_MARKER();
    822          							}
    823          						}
    824          						else if( xYieldRequired != pdFALSE )
    825          						{
    826          							/* This path is a special case that will only get
    827          							executed if the task was holding multiple mutexes
    828          							and the mutexes were given back in an order that is
    829          							different to that in which they were taken. */
    830          							queueYIELD_IF_USING_PREEMPTION();
    831          						}
    832          						else
    833          						{
    834          							mtCOVERAGE_TEST_MARKER();
    835          						}
    836          					}
    837          				}
    838          				#else /* configUSE_QUEUE_SETS */
    839          				{
    840          					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    841          
    842          					/* If there was a task waiting for data to arrive on the
    843          					queue then unblock it now. */
    844          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    845          					{
    846          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    847          						{
    848          							/* The unblocked task has a priority higher than
    849          							our own so yield immediately.  Yes it is ok to do
    850          							this from within the critical section - the kernel
    851          							takes care of that. */
    852          							queueYIELD_IF_USING_PREEMPTION();
    853          						}
    854          						else
    855          						{
    856          							mtCOVERAGE_TEST_MARKER();
    857          						}
    858          					}
    859          					else if( xYieldRequired != pdFALSE )
    860          					{
    861          						/* This path is a special case that will only get
    862          						executed if the task was holding multiple mutexes and
    863          						the mutexes were given back in an order that is
    864          						different to that in which they were taken. */
    865          						queueYIELD_IF_USING_PREEMPTION();
    866          					}
    867          					else
    868          					{
    869          						mtCOVERAGE_TEST_MARKER();
    870          					}
    871          				}
    872          				#endif /* configUSE_QUEUE_SETS */
    873          
    874          				taskEXIT_CRITICAL();
    875          				return pdPASS;
    876          			}
    877          			else
    878          			{
    879          				if( xTicksToWait == ( TickType_t ) 0 )
    880          				{
    881          					/* The queue was full and no block time is specified (or
    882          					the block time has expired) so leave now. */
    883          					taskEXIT_CRITICAL();
    884          
    885          					/* Return to the original privilege level before exiting
    886          					the function. */
    887          					traceQUEUE_SEND_FAILED( pxQueue );
    888          					return errQUEUE_FULL;
    889          				}
    890          				else if( xEntryTimeSet == pdFALSE )
    891          				{
    892          					/* The queue was full and a block time was specified so
    893          					configure the timeout structure. */
    894          					vTaskInternalSetTimeOutState( &xTimeOut );
    895          					xEntryTimeSet = pdTRUE;
    896          				}
    897          				else
    898          				{
    899          					/* Entry time was already set. */
    900          					mtCOVERAGE_TEST_MARKER();
    901          				}
    902          			}
    903          		}
    904          		taskEXIT_CRITICAL();
    905          
    906          		/* Interrupts and other tasks can send to and receive from the queue
    907          		now the critical section has been exited. */
    908          
    909          		vTaskSuspendAll();
    910          		prvLockQueue( pxQueue );
    911          
    912          		/* Update the timeout state to see if it has expired yet. */
    913          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    914          		{
    915          			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    916          			{
    917          				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
    918          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   \                     ??xQueueGenericSend_15: (+1)
   \       0x8E   0x9902             LDR      R1,[SP, #+8]
   \       0x90   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x94   0x....'....        BL       vTaskPlaceOnEventList
    919          
    920          				/* Unlocking the queue means queue events can effect the
    921          				event list.  It is possible that interrupts occurring now
    922          				remove this task from the event list again - but as the
    923          				scheduler is suspended the task will go onto the pending
    924          				ready last instead of the actual ready list. */
    925          				prvUnlockQueue( pxQueue );
   \       0x98   0x4628             MOV      R0,R5
   \       0x9A   0x....'....        BL       prvUnlockQueue
    926          
    927          				/* Resuming the scheduler will move tasks from the pending
    928          				ready list into the ready list - so it is feasible that this
    929          				task is already in a ready list before it yields - in which
    930          				case the yield will not cause a context switch unless there
    931          				is also a higher priority task in the pending ready list. */
    932          				if( xTaskResumeAll() == pdFALSE )
   \       0x9E   0x....'....        BL       xTaskResumeAll
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD108             BNE.N    ??xQueueGenericSend_13
    933          				{
    934          					portYIELD_WITHIN_API();
   \       0xA6   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xAA   0x....'....        LDR.W    R1,??DataTable6  ;; 0xe000ed04
   \       0xAE   0x6008             STR      R0,[R1, #+0]
   \       0xB0   0xF3BF 0x8F4F      DSB      SY
   \       0xB4   0xF3BF 0x8F6F      ISB      SY
    935          				}
    936          			}
   \                     ??xQueueGenericSend_13: (+1)
   \       0xB8   0x....'....        BL       vPortEnterCritical
   \       0xBC   0x6BA8             LDR      R0,[R5, #+56]
   \       0xBE   0x6BE9             LDR      R1,[R5, #+60]
   \       0xC0   0x4288             CMP      R0,R1
   \       0xC2   0xD346             BCC.N    ??xQueueGenericSend_16
   \       0xC4   0x2F02             CMP      R7,#+2
   \       0xC6   0xD044             BEQ.N    ??xQueueGenericSend_16
   \       0xC8   0x9802             LDR      R0,[SP, #+8]
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD03D             BEQ.N    ??xQueueGenericSend_17
   \       0xCE   0x2C00             CMP      R4,#+0
   \       0xD0   0xD103             BNE.N    ??xQueueGenericSend_18
   \       0xD2   0x4668             MOV      R0,SP
   \       0xD4   0x....'....        BL       vTaskInternalSetTimeOutState
   \       0xD8   0x2401             MOVS     R4,#+1
   \                     ??xQueueGenericSend_18: (+1)
   \       0xDA   0x....'....        BL       vPortExitCritical
   \       0xDE   0x....'....        BL       vTaskSuspendAll
   \       0xE2   0x....'....        BL       vPortEnterCritical
   \       0xE6   0xF995 0x0044      LDRSB    R0,[R5, #+68]
   \       0xEA   0xF110 0x0F01      CMN      R0,#+1
   \       0xEE   0xD102             BNE.N    ??xQueueGenericSend_19
   \       0xF0   0x2000             MOVS     R0,#+0
   \       0xF2   0xF885 0x0044      STRB     R0,[R5, #+68]
   \                     ??xQueueGenericSend_19: (+1)
   \       0xF6   0xF995 0x0045      LDRSB    R0,[R5, #+69]
   \       0xFA   0xF110 0x0F01      CMN      R0,#+1
   \       0xFE   0xD102             BNE.N    ??xQueueGenericSend_20
   \      0x100   0x2000             MOVS     R0,#+0
   \      0x102   0xF885 0x0045      STRB     R0,[R5, #+69]
   \                     ??xQueueGenericSend_20: (+1)
   \      0x106   0x....'....        BL       vPortExitCritical
   \      0x10A   0xA902             ADD      R1,SP,#+8
   \      0x10C   0x4668             MOV      R0,SP
   \      0x10E   0x....'....        BL       xTaskCheckForTimeOut
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0x4628             MOV      R0,R5
   \      0x116   0xD12B             BNE.N    ??xQueueGenericSend_21
   \      0x118   0x....'....        BL       prvIsQueueFull
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD1B6             BNE.N    ??xQueueGenericSend_15
    937          			else
    938          			{
    939          				/* Try again. */
    940          				prvUnlockQueue( pxQueue );
   \      0x120   0x4628             MOV      R0,R5
   \      0x122   0x....'....        BL       prvUnlockQueue
    941          				( void ) xTaskResumeAll();
   \      0x126   0x....'....        BL       xTaskResumeAll
   \      0x12A   0xE7C5             B.N      ??xQueueGenericSend_13
    942          			}
   \                     ??xQueueGenericSend_22: (+1)
   \      0x12C   0x2800             CMP      R0,#+0
   \      0x12E   0xD008             BEQ.N    ??xQueueGenericSend_23
   \                     ??xQueueGenericSend_24: (+1)
   \      0x130   0xF04F 0x5080      MOV      R0,#+268435456
   \      0x134   0x....'....        LDR.W    R1,??DataTable6  ;; 0xe000ed04
   \      0x138   0x6008             STR      R0,[R1, #+0]
   \      0x13A   0xF3BF 0x8F4F      DSB      SY
   \      0x13E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_23: (+1)
   \      0x142   0x....'....        BL       vPortExitCritical
   \      0x146   0x2001             MOVS     R0,#+1
   \      0x148   0xBDFE             POP      {R1-R7,PC}
   \                     ??xQueueGenericSend_17: (+1)
   \      0x14A   0x....'....        BL       vPortExitCritical
   \      0x14E   0x2000             MOVS     R0,#+0
   \      0x150   0xBDFE             POP      {R1-R7,PC}
   \                     ??xQueueGenericSend_16: (+1)
   \      0x152   0x463A             MOV      R2,R7
   \      0x154   0x4631             MOV      R1,R6
   \      0x156   0x4628             MOV      R0,R5
   \      0x158   0x....'....        BL       prvCopyDataToQueue
   \      0x15C   0x6A69             LDR      R1,[R5, #+36]
   \      0x15E   0x2900             CMP      R1,#+0
   \      0x160   0xD0E4             BEQ.N    ??xQueueGenericSend_22
   \      0x162   0xF105 0x0024      ADD      R0,R5,#+36
   \      0x166   0x....'....        BL       xTaskRemoveFromEventList
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD1E0             BNE.N    ??xQueueGenericSend_24
   \      0x16E   0xE7E8             B.N      ??xQueueGenericSend_23
    943          		}
    944          		else
    945          		{
    946          			/* The timeout has expired. */
    947          			prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericSend_21: (+1)
   \      0x170   0x....'....        BL       prvUnlockQueue
    948          			( void ) xTaskResumeAll();
   \      0x174   0x....'....        BL       xTaskResumeAll
    949          
    950          			traceQUEUE_SEND_FAILED( pxQueue );
    951          			return errQUEUE_FULL;
   \      0x178   0x2000             MOVS     R0,#+0
   \      0x17A   0xBDFE             POP      {R1-R7,PC}       ;; return
    952          		}
    953          	} /*lint -restore */
    954          }
    955          /*-----------------------------------------------------------*/
    956          

   \                                 In section .text, align 2, keep-with-next
    957          BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
    958          {
   \                     xQueueGenericSendFromISR: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461F             MOV      R7,R3
    959          BaseType_t xReturn;
    960          UBaseType_t uxSavedInterruptStatus;
    961          Queue_t * const pxQueue = xQueue;
    962          
    963          	configASSERT( pxQueue );
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD107             BNE.N    ??xQueueGenericSendFromISR_0
   \       0x10   0x2020             MOVS     R0,#+32
   \       0x12   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x16   0xF3BF 0x8F4F      DSB      SY
   \       0x1A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSendFromISR_1: (+1)
   \       0x1E   0xE7FE             B.N      ??xQueueGenericSendFromISR_1
    964          	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueGenericSendFromISR_0: (+1)
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xD104             BNE.N    ??xQueueGenericSendFromISR_2
   \       0x24   0x6C20             LDR      R0,[R4, #+64]
   \       0x26   0x1E40             SUBS     R0,R0,#+1
   \       0x28   0x4180             SBCS     R0,R0,R0
   \       0x2A   0x0FC0             LSRS     R0,R0,#+31
   \       0x2C   0xE000             B.N      ??xQueueGenericSendFromISR_3
   \                     ??xQueueGenericSendFromISR_2: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \                     ??xQueueGenericSendFromISR_3: (+1)
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD107             BNE.N    ??xQueueGenericSendFromISR_4
   \       0x34   0x2020             MOVS     R0,#+32
   \       0x36   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x3A   0xF3BF 0x8F4F      DSB      SY
   \       0x3E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSendFromISR_5: (+1)
   \       0x42   0xE7FE             B.N      ??xQueueGenericSendFromISR_5
    965          	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   \                     ??xQueueGenericSendFromISR_4: (+1)
   \       0x44   0x2F02             CMP      R7,#+2
   \       0x46   0xD102             BNE.N    ??xQueueGenericSendFromISR_6
   \       0x48   0x6BE0             LDR      R0,[R4, #+60]
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD101             BNE.N    ??xQueueGenericSendFromISR_7
   \                     ??xQueueGenericSendFromISR_6: (+1)
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0xE000             B.N      ??xQueueGenericSendFromISR_8
   \                     ??xQueueGenericSendFromISR_7: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericSendFromISR_8: (+1)
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD107             BNE.N    ??xQueueGenericSendFromISR_9
   \       0x58   0x2020             MOVS     R0,#+32
   \       0x5A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x5E   0xF3BF 0x8F4F      DSB      SY
   \       0x62   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSendFromISR_10: (+1)
   \       0x66   0xE7FE             B.N      ??xQueueGenericSendFromISR_10
    966          
    967          	/* RTOS ports that support interrupt nesting have the concept of a maximum
    968          	system call (or maximum API call) interrupt priority.  Interrupts that are
    969          	above the maximum system call priority are kept permanently enabled, even
    970          	when the RTOS kernel is in a critical section, but cannot make any calls to
    971          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
    972          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
    973          	failure if a FreeRTOS API function is called from an interrupt that has been
    974          	assigned a priority above the configured maximum system call priority.
    975          	Only FreeRTOS functions that end in FromISR can be called from interrupts
    976          	that have been assigned a priority at or (logically) below the maximum
    977          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
    978          	safe API to ensure interrupt entry is as fast and as simple as possible.
    979          	More information (albeit Cortex-M specific) is provided on the following
    980          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
    981          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xQueueGenericSendFromISR_9: (+1)
   \       0x68   0x....'....        BL       vPortValidateInterruptPriority
    982          
    983          	/* Similar to xQueueGenericSend, except without blocking if there is no room
    984          	in the queue.  Also don't directly wake a task that was blocked on a queue
    985          	read, instead return a flag to say whether a context switch is required or
    986          	not (i.e. has a task with a higher priority than us been woken by this
    987          	post). */
    988          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x6C   0xF3EF 0x8811      MRS      R8,BASEPRI
   \       0x70   0x2020             MOVS     R0,#+32
   \       0x72   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x76   0xF3BF 0x8F4F      DSB      SY
   \       0x7A   0xF3BF 0x8F6F      ISB      SY
    989          	{
    990          		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   \       0x7E   0x6BA0             LDR      R0,[R4, #+56]
   \       0x80   0x6BE1             LDR      R1,[R4, #+60]
   \       0x82   0x4288             CMP      R0,R1
   \       0x84   0xD301             BCC.N    ??xQueueGenericSendFromISR_11
   \       0x86   0x2F02             CMP      R7,#+2
   \       0x88   0xD11D             BNE.N    ??xQueueGenericSendFromISR_12
    991          		{
    992          			const int8_t cTxLock = pxQueue->cTxLock;
   \                     ??xQueueGenericSendFromISR_11: (+1)
   \       0x8A   0xF994 0x9045      LDRSB    R9,[R4, #+69]
    993          
    994          			traceQUEUE_SEND_FROM_ISR( pxQueue );
    995          
    996          			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
    997          			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
    998          			in a task disinheriting a priority and prvCopyDataToQueue() can be
    999          			called here even though the disinherit function does not check if
   1000          			the scheduler is suspended before accessing the ready lists. */
   1001          			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   \       0x8E   0x463A             MOV      R2,R7
   \       0x90   0x4631             MOV      R1,R6
   \       0x92   0x4620             MOV      R0,R4
   \       0x94   0x....'....        BL       prvCopyDataToQueue
   1002          
   1003          			/* The event list is not altered if the queue is locked.  This will
   1004          			be done when the queue is unlocked later. */
   1005          			if( cTxLock == queueUNLOCKED )
   \       0x98   0xF119 0x0F01      CMN      R9,#+1
   \       0x9C   0xD10D             BNE.N    ??xQueueGenericSendFromISR_13
   1006          			{
   1007          				#if ( configUSE_QUEUE_SETS == 1 )
   1008          				{
   1009          					if( pxQueue->pxQueueSetContainer != NULL )
   1010          					{
   1011          						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
   1012          						{
   1013          							/* The queue is a member of a queue set, and posting
   1014          							to the queue set caused a higher priority task to
   1015          							unblock.  A context switch is required. */
   1016          							if( pxHigherPriorityTaskWoken != NULL )
   1017          							{
   1018          								*pxHigherPriorityTaskWoken = pdTRUE;
   1019          							}
   1020          							else
   1021          							{
   1022          								mtCOVERAGE_TEST_MARKER();
   1023          							}
   1024          						}
   1025          						else
   1026          						{
   1027          							mtCOVERAGE_TEST_MARKER();
   1028          						}
   1029          					}
   1030          					else
   1031          					{
   1032          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1033          						{
   1034          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1035          							{
   1036          								/* The task waiting has a higher priority so
   1037          								record that a context switch is required. */
   1038          								if( pxHigherPriorityTaskWoken != NULL )
   1039          								{
   1040          									*pxHigherPriorityTaskWoken = pdTRUE;
   1041          								}
   1042          								else
   1043          								{
   1044          									mtCOVERAGE_TEST_MARKER();
   1045          								}
   1046          							}
   1047          							else
   1048          							{
   1049          								mtCOVERAGE_TEST_MARKER();
   1050          							}
   1051          						}
   1052          						else
   1053          						{
   1054          							mtCOVERAGE_TEST_MARKER();
   1055          						}
   1056          					}
   1057          				}
   1058          				#else /* configUSE_QUEUE_SETS */
   1059          				{
   1060          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \       0x9E   0x6A60             LDR      R0,[R4, #+36]
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD00E             BEQ.N    ??xQueueGenericSendFromISR_14
   1061          					{
   1062          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \       0xA4   0xF104 0x0024      ADD      R0,R4,#+36
   \       0xA8   0x....'....        BL       xTaskRemoveFromEventList
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD008             BEQ.N    ??xQueueGenericSendFromISR_14
   1063          						{
   1064          							/* The task waiting has a higher priority so record that a
   1065          							context	switch is required. */
   1066          							if( pxHigherPriorityTaskWoken != NULL )
   \       0xB0   0x2D00             CMP      R5,#+0
   \       0xB2   0xD006             BEQ.N    ??xQueueGenericSendFromISR_14
   1067          							{
   1068          								*pxHigherPriorityTaskWoken = pdTRUE;
   \       0xB4   0x2001             MOVS     R0,#+1
   \       0xB6   0x6028             STR      R0,[R5, #+0]
   \       0xB8   0xE003             B.N      ??xQueueGenericSendFromISR_14
   1069          							}
   1070          							else
   1071          							{
   1072          								mtCOVERAGE_TEST_MARKER();
   1073          							}
   1074          						}
   1075          						else
   1076          						{
   1077          							mtCOVERAGE_TEST_MARKER();
   1078          						}
   1079          					}
   1080          					else
   1081          					{
   1082          						mtCOVERAGE_TEST_MARKER();
   1083          					}
   1084          				}
   1085          				#endif /* configUSE_QUEUE_SETS */
   1086          			}
   1087          			else
   1088          			{
   1089          				/* Increment the lock count so the task that unlocks the queue
   1090          				knows that data was posted while it was locked. */
   1091          				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   \                     ??xQueueGenericSendFromISR_13: (+1)
   \       0xBA   0xF109 0x0901      ADD      R9,R9,#+1
   \       0xBE   0xF884 0x9045      STRB     R9,[R4, #+69]
   1092          			}
   1093          
   1094          			xReturn = pdPASS;
   \                     ??xQueueGenericSendFromISR_14: (+1)
   \       0xC2   0x2001             MOVS     R0,#+1
   \       0xC4   0xE000             B.N      ??xQueueGenericSendFromISR_15
   1095          		}
   1096          		else
   1097          		{
   1098          			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1099          			xReturn = errQUEUE_FULL;
   \                     ??xQueueGenericSendFromISR_12: (+1)
   \       0xC6   0x2000             MOVS     R0,#+0
   1100          		}
   1101          	}
   1102          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGenericSendFromISR_15: (+1)
   \       0xC8   0xF388 0x8811      MSR      BASEPRI,R8
   1103          
   1104          	return xReturn;
   \       0xCC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1105          }
   1106          /*-----------------------------------------------------------*/
   1107          

   \                                 In section .text, align 2, keep-with-next
   1108          BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
   1109          {
   \                     xQueueGiveFromISR: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1110          BaseType_t xReturn;
   1111          UBaseType_t uxSavedInterruptStatus;
   1112          Queue_t * const pxQueue = xQueue;
   1113          
   1114          	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
   1115          	item size is 0.  Don't directly wake a task that was blocked on a queue
   1116          	read, instead return a flag to say whether a context switch is required or
   1117          	not (i.e. has a task with a higher priority than us been woken by this
   1118          	post). */
   1119          
   1120          	configASSERT( pxQueue );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xQueueGiveFromISR_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGiveFromISR_1: (+1)
   \       0x18   0xE7FE             B.N      ??xQueueGiveFromISR_1
   1121          
   1122          	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
   1123          	if the item size is not 0. */
   1124          	configASSERT( pxQueue->uxItemSize == 0 );
   \                     ??xQueueGiveFromISR_0: (+1)
   \       0x1A   0x6C20             LDR      R0,[R4, #+64]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD007             BEQ.N    ??xQueueGiveFromISR_2
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x26   0xF3BF 0x8F4F      DSB      SY
   \       0x2A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGiveFromISR_3: (+1)
   \       0x2E   0xE7FE             B.N      ??xQueueGiveFromISR_3
   1125          
   1126          	/* Normally a mutex would not be given from an interrupt, especially if
   1127          	there is a mutex holder, as priority inheritance makes no sense for an
   1128          	interrupts, only tasks. */
   1129          	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
   \                     ??xQueueGiveFromISR_2: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD102             BNE.N    ??xQueueGiveFromISR_4
   \       0x36   0x68A0             LDR      R0,[R4, #+8]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD101             BNE.N    ??xQueueGiveFromISR_5
   \                     ??xQueueGiveFromISR_4: (+1)
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xE000             B.N      ??xQueueGiveFromISR_6
   \                     ??xQueueGiveFromISR_5: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??xQueueGiveFromISR_6: (+1)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD107             BNE.N    ??xQueueGiveFromISR_7
   \       0x46   0x2020             MOVS     R0,#+32
   \       0x48   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x4C   0xF3BF 0x8F4F      DSB      SY
   \       0x50   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGiveFromISR_8: (+1)
   \       0x54   0xE7FE             B.N      ??xQueueGiveFromISR_8
   1130          
   1131          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1132          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1133          	above the maximum system call priority are kept permanently enabled, even
   1134          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1135          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1136          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1137          	failure if a FreeRTOS API function is called from an interrupt that has been
   1138          	assigned a priority above the configured maximum system call priority.
   1139          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1140          	that have been assigned a priority at or (logically) below the maximum
   1141          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1142          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1143          	More information (albeit Cortex-M specific) is provided on the following
   1144          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1145          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xQueueGiveFromISR_7: (+1)
   \       0x56   0x....'....        BL       vPortValidateInterruptPriority
   1146          
   1147          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x5A   0xF3EF 0x8611      MRS      R6,BASEPRI
   \       0x5E   0x2020             MOVS     R0,#+32
   \       0x60   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x64   0xF3BF 0x8F4F      DSB      SY
   \       0x68   0xF3BF 0x8F6F      ISB      SY
   1148          	{
   1149          		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   \       0x6C   0x6BA0             LDR      R0,[R4, #+56]
   1150          
   1151          		/* When the queue is used to implement a semaphore no data is ever
   1152          		moved through the queue but it is still valid to see if the queue 'has
   1153          		space'. */
   1154          		if( uxMessagesWaiting < pxQueue->uxLength )
   \       0x6E   0x6BE1             LDR      R1,[R4, #+60]
   \       0x70   0x4288             CMP      R0,R1
   \       0x72   0xD219             BCS.N    ??xQueueGiveFromISR_9
   1155          		{
   1156          			const int8_t cTxLock = pxQueue->cTxLock;
   \       0x74   0xF994 0x1045      LDRSB    R1,[R4, #+69]
   1157          
   1158          			traceQUEUE_SEND_FROM_ISR( pxQueue );
   1159          
   1160          			/* A task can only have an inherited priority if it is a mutex
   1161          			holder - and if there is a mutex holder then the mutex cannot be
   1162          			given from an ISR.  As this is the ISR version of the function it
   1163          			can be assumed there is no mutex holder and no need to determine if
   1164          			priority disinheritance is needed.  Simply increase the count of
   1165          			messages (semaphores) available. */
   1166          			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   \       0x78   0x1C40             ADDS     R0,R0,#+1
   \       0x7A   0x63A0             STR      R0,[R4, #+56]
   1167          
   1168          			/* The event list is not altered if the queue is locked.  This will
   1169          			be done when the queue is unlocked later. */
   1170          			if( cTxLock == queueUNLOCKED )
   \       0x7C   0xF111 0x0F01      CMN      R1,#+1
   \       0x80   0xD10D             BNE.N    ??xQueueGiveFromISR_10
   1171          			{
   1172          				#if ( configUSE_QUEUE_SETS == 1 )
   1173          				{
   1174          					if( pxQueue->pxQueueSetContainer != NULL )
   1175          					{
   1176          						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
   1177          						{
   1178          							/* The semaphore is a member of a queue set, and
   1179          							posting	to the queue set caused a higher priority
   1180          							task to	unblock.  A context switch is required. */
   1181          							if( pxHigherPriorityTaskWoken != NULL )
   1182          							{
   1183          								*pxHigherPriorityTaskWoken = pdTRUE;
   1184          							}
   1185          							else
   1186          							{
   1187          								mtCOVERAGE_TEST_MARKER();
   1188          							}
   1189          						}
   1190          						else
   1191          						{
   1192          							mtCOVERAGE_TEST_MARKER();
   1193          						}
   1194          					}
   1195          					else
   1196          					{
   1197          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1198          						{
   1199          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1200          							{
   1201          								/* The task waiting has a higher priority so
   1202          								record that a context switch is required. */
   1203          								if( pxHigherPriorityTaskWoken != NULL )
   1204          								{
   1205          									*pxHigherPriorityTaskWoken = pdTRUE;
   1206          								}
   1207          								else
   1208          								{
   1209          									mtCOVERAGE_TEST_MARKER();
   1210          								}
   1211          							}
   1212          							else
   1213          							{
   1214          								mtCOVERAGE_TEST_MARKER();
   1215          							}
   1216          						}
   1217          						else
   1218          						{
   1219          							mtCOVERAGE_TEST_MARKER();
   1220          						}
   1221          					}
   1222          				}
   1223          				#else /* configUSE_QUEUE_SETS */
   1224          				{
   1225          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \       0x82   0x6A60             LDR      R0,[R4, #+36]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD00D             BEQ.N    ??xQueueGiveFromISR_11
   1226          					{
   1227          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \       0x88   0xF104 0x0024      ADD      R0,R4,#+36
   \       0x8C   0x....'....        BL       xTaskRemoveFromEventList
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD007             BEQ.N    ??xQueueGiveFromISR_11
   1228          						{
   1229          							/* The task waiting has a higher priority so record that a
   1230          							context	switch is required. */
   1231          							if( pxHigherPriorityTaskWoken != NULL )
   \       0x94   0x2D00             CMP      R5,#+0
   \       0x96   0xD005             BEQ.N    ??xQueueGiveFromISR_11
   1232          							{
   1233          								*pxHigherPriorityTaskWoken = pdTRUE;
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0x6028             STR      R0,[R5, #+0]
   \       0x9C   0xE002             B.N      ??xQueueGiveFromISR_11
   1234          							}
   1235          							else
   1236          							{
   1237          								mtCOVERAGE_TEST_MARKER();
   1238          							}
   1239          						}
   1240          						else
   1241          						{
   1242          							mtCOVERAGE_TEST_MARKER();
   1243          						}
   1244          					}
   1245          					else
   1246          					{
   1247          						mtCOVERAGE_TEST_MARKER();
   1248          					}
   1249          				}
   1250          				#endif /* configUSE_QUEUE_SETS */
   1251          			}
   1252          			else
   1253          			{
   1254          				/* Increment the lock count so the task that unlocks the queue
   1255          				knows that data was posted while it was locked. */
   1256          				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   \                     ??xQueueGiveFromISR_10: (+1)
   \       0x9E   0x1C49             ADDS     R1,R1,#+1
   \       0xA0   0xF884 0x1045      STRB     R1,[R4, #+69]
   1257          			}
   1258          
   1259          			xReturn = pdPASS;
   \                     ??xQueueGiveFromISR_11: (+1)
   \       0xA4   0x2001             MOVS     R0,#+1
   \       0xA6   0xE000             B.N      ??xQueueGiveFromISR_12
   1260          		}
   1261          		else
   1262          		{
   1263          			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1264          			xReturn = errQUEUE_FULL;
   \                     ??xQueueGiveFromISR_9: (+1)
   \       0xA8   0x2000             MOVS     R0,#+0
   1265          		}
   1266          	}
   1267          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGiveFromISR_12: (+1)
   \       0xAA   0xF386 0x8811      MSR      BASEPRI,R6
   1268          
   1269          	return xReturn;
   \       0xAE   0xBD70             POP      {R4-R6,PC}       ;; return
   1270          }
   1271          /*-----------------------------------------------------------*/
   1272          

   \                                 In section .text, align 2, keep-with-next
   1273          BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
   1274          {
   \                     xQueueReceive: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
   1275          BaseType_t xEntryTimeSet = pdFALSE;
   \        0x6   0x2400             MOVS     R4,#+0
   1276          TimeOut_t xTimeOut;
   1277          Queue_t * const pxQueue = xQueue;
   1278          
   1279          	/* Check the pointer is not NULL. */
   1280          	configASSERT( ( pxQueue ) );
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD107             BNE.N    ??xQueueReceive_0
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x12   0xF3BF 0x8F4F      DSB      SY
   \       0x16   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceive_1: (+1)
   \       0x1A   0xE7FE             B.N      ??xQueueReceive_1
   1281          
   1282          	/* The buffer into which data is received can only be NULL if the data size
   1283          	is zero (so no data is copied into the buffer. */
   1284          	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueReceive_0: (+1)
   \       0x1C   0x2F00             CMP      R7,#+0
   \       0x1E   0xD104             BNE.N    ??xQueueReceive_2
   \       0x20   0x6C30             LDR      R0,[R6, #+64]
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0x4180             SBCS     R0,R0,R0
   \       0x26   0x0FC0             LSRS     R0,R0,#+31
   \       0x28   0xE000             B.N      ??xQueueReceive_3
   \                     ??xQueueReceive_2: (+1)
   \       0x2A   0x2001             MOVS     R0,#+1
   \                     ??xQueueReceive_3: (+1)
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD107             BNE.N    ??xQueueReceive_4
   \       0x30   0x2020             MOVS     R0,#+32
   \       0x32   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x36   0xF3BF 0x8F4F      DSB      SY
   \       0x3A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceive_5: (+1)
   \       0x3E   0xE7FE             B.N      ??xQueueReceive_5
   1285          
   1286          	/* Cannot block if the scheduler is suspended. */
   1287          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1288          	{
   1289          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueueReceive_4: (+1)
   \       0x40   0x....'....        BL       xTaskGetSchedulerState
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD104             BNE.N    ??xQueueReceive_6
   \       0x48   0x9802             LDR      R0,[SP, #+8]
   \       0x4A   0x1E40             SUBS     R0,R0,#+1
   \       0x4C   0x4180             SBCS     R0,R0,R0
   \       0x4E   0x0FC0             LSRS     R0,R0,#+31
   \       0x50   0xE000             B.N      ??xQueueReceive_7
   \                     ??xQueueReceive_6: (+1)
   \       0x52   0x2001             MOVS     R0,#+1
   \                     ??xQueueReceive_7: (+1)
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD10C             BNE.N    ??xQueueReceive_8
   \       0x58   0x2020             MOVS     R0,#+32
   \       0x5A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x5E   0xF3BF 0x8F4F      DSB      SY
   \       0x62   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceive_9: (+1)
   \       0x66   0xE7FE             B.N      ??xQueueReceive_9
   1290          	}
   1291          	#endif
   1292          
   1293          
   1294          	/*lint -save -e904  This function relaxes the coding standard somewhat to
   1295          	allow return statements within the function itself.  This is done in the
   1296          	interest of execution time efficiency. */
   1297          	for( ;; )
   1298          	{
   1299          		taskENTER_CRITICAL();
   1300          		{
   1301          			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1302          
   1303          			/* Is there data in the queue now?  To be running the calling task
   1304          			must be the highest priority task wanting to access the queue. */
   1305          			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   1306          			{
   1307          				/* Data available, remove one item. */
   1308          				prvCopyDataFromQueue( pxQueue, pvBuffer );
   1309          				traceQUEUE_RECEIVE( pxQueue );
   1310          				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   1311          
   1312          				/* There is now space in the queue, were any tasks waiting to
   1313          				post to the queue?  If so, unblock the highest priority waiting
   1314          				task. */
   1315          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1316          				{
   1317          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1318          					{
   1319          						queueYIELD_IF_USING_PREEMPTION();
   1320          					}
   1321          					else
   1322          					{
   1323          						mtCOVERAGE_TEST_MARKER();
   1324          					}
   1325          				}
   1326          				else
   1327          				{
   1328          					mtCOVERAGE_TEST_MARKER();
   1329          				}
   1330          
   1331          				taskEXIT_CRITICAL();
   1332          				return pdPASS;
   1333          			}
   1334          			else
   1335          			{
   1336          				if( xTicksToWait == ( TickType_t ) 0 )
   1337          				{
   1338          					/* The queue was empty and no block time is specified (or
   1339          					the block time has expired) so leave now. */
   1340          					taskEXIT_CRITICAL();
   1341          					traceQUEUE_RECEIVE_FAILED( pxQueue );
   1342          					return errQUEUE_EMPTY;
   1343          				}
   1344          				else if( xEntryTimeSet == pdFALSE )
   1345          				{
   1346          					/* The queue was empty and a block time was specified so
   1347          					configure the timeout structure. */
   1348          					vTaskInternalSetTimeOutState( &xTimeOut );
   1349          					xEntryTimeSet = pdTRUE;
   1350          				}
   1351          				else
   1352          				{
   1353          					/* Entry time was already set. */
   1354          					mtCOVERAGE_TEST_MARKER();
   1355          				}
   1356          			}
   1357          		}
   1358          		taskEXIT_CRITICAL();
   1359          
   1360          		/* Interrupts and other tasks can send to and receive from the queue
   1361          		now the critical section has been exited. */
   1362          
   1363          		vTaskSuspendAll();
   1364          		prvLockQueue( pxQueue );
   1365          
   1366          		/* Update the timeout state to see if it has expired yet. */
   1367          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1368          		{
   1369          			/* The timeout has not expired.  If the queue is still empty place
   1370          			the task on the list of tasks waiting to receive from the queue. */
   1371          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1372          			{
   1373          				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   1374          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1375          				prvUnlockQueue( pxQueue );
   1376          				if( xTaskResumeAll() == pdFALSE )
   1377          				{
   1378          					portYIELD_WITHIN_API();
   1379          				}
   1380          				else
   1381          				{
   1382          					mtCOVERAGE_TEST_MARKER();
   1383          				}
   1384          			}
   1385          			else
   1386          			{
   1387          				/* The queue contains data again.  Loop back to try and read the
   1388          				data. */
   1389          				prvUnlockQueue( pxQueue );
   \                     ??xQueueReceive_10: (+1)
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0x....'....        BL       prvUnlockQueue
   1390          				( void ) xTaskResumeAll();
   \       0x6E   0x....'....        BL       xTaskResumeAll
   1391          			}
   \                     ??xQueueReceive_8: (+1)
   \       0x72   0x....'....        BL       vPortEnterCritical
   \       0x76   0x6BB5             LDR      R5,[R6, #+56]
   \       0x78   0x2D00             CMP      R5,#+0
   \       0x7A   0xD106             BNE.N    ??xQueueReceive_11
   \       0x7C   0x9802             LDR      R0,[SP, #+8]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD11F             BNE.N    ??xQueueReceive_12
   \       0x82   0x....'....        BL       vPortExitCritical
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0xBDFE             POP      {R1-R7,PC}
   \                     ??xQueueReceive_11: (+1)
   \       0x8A   0x4639             MOV      R1,R7
   \       0x8C   0x4630             MOV      R0,R6
   \       0x8E   0x....'....        BL       prvCopyDataFromQueue
   \       0x92   0x1E6D             SUBS     R5,R5,#+1
   \       0x94   0x63B5             STR      R5,[R6, #+56]
   \       0x96   0x6930             LDR      R0,[R6, #+16]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD00E             BEQ.N    ??xQueueReceive_13
   \       0x9C   0xF106 0x0010      ADD      R0,R6,#+16
   \       0xA0   0x....'....        BL       xTaskRemoveFromEventList
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD008             BEQ.N    ??xQueueReceive_13
   \       0xA8   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xAC   0x....'....        LDR.W    R1,??DataTable6  ;; 0xe000ed04
   \       0xB0   0x6008             STR      R0,[R1, #+0]
   \       0xB2   0xF3BF 0x8F4F      DSB      SY
   \       0xB6   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceive_13: (+1)
   \       0xBA   0x....'....        BL       vPortExitCritical
   \       0xBE   0x2001             MOVS     R0,#+1
   \       0xC0   0xBDFE             POP      {R1-R7,PC}
   \                     ??xQueueReceive_12: (+1)
   \       0xC2   0x2C00             CMP      R4,#+0
   \       0xC4   0xD103             BNE.N    ??xQueueReceive_14
   \       0xC6   0x4668             MOV      R0,SP
   \       0xC8   0x....'....        BL       vTaskInternalSetTimeOutState
   \       0xCC   0x2401             MOVS     R4,#+1
   \                     ??xQueueReceive_14: (+1)
   \       0xCE   0x....'....        BL       vPortExitCritical
   \       0xD2   0x....'....        BL       vTaskSuspendAll
   \       0xD6   0x....'....        BL       vPortEnterCritical
   \       0xDA   0xF996 0x0044      LDRSB    R0,[R6, #+68]
   \       0xDE   0xF110 0x0F01      CMN      R0,#+1
   \       0xE2   0xD102             BNE.N    ??xQueueReceive_15
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0xF886 0x0044      STRB     R0,[R6, #+68]
   \                     ??xQueueReceive_15: (+1)
   \       0xEA   0xF996 0x0045      LDRSB    R0,[R6, #+69]
   \       0xEE   0xF110 0x0F01      CMN      R0,#+1
   \       0xF2   0xD102             BNE.N    ??xQueueReceive_16
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0xF886 0x0045      STRB     R0,[R6, #+69]
   \                     ??xQueueReceive_16: (+1)
   \       0xFA   0x....'....        BL       vPortExitCritical
   \       0xFE   0xA902             ADD      R1,SP,#+8
   \      0x100   0x4668             MOV      R0,SP
   \      0x102   0x....'....        BL       xTaskCheckForTimeOut
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0x4630             MOV      R0,R6
   \      0x10A   0xD119             BNE.N    ??xQueueReceive_17
   \      0x10C   0x....'....        BL       prvIsQueueEmpty
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD0A9             BEQ.N    ??xQueueReceive_10
   \      0x114   0x9902             LDR      R1,[SP, #+8]
   \      0x116   0xF106 0x0024      ADD      R0,R6,#+36
   \      0x11A   0x....'....        BL       vTaskPlaceOnEventList
   \      0x11E   0x4630             MOV      R0,R6
   \      0x120   0x....'....        BL       prvUnlockQueue
   \      0x124   0x....'....        BL       xTaskResumeAll
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD1A2             BNE.N    ??xQueueReceive_8
   \      0x12C   0xF04F 0x5080      MOV      R0,#+268435456
   \      0x130   0x....'....        LDR.W    R1,??DataTable6  ;; 0xe000ed04
   \      0x134   0x6008             STR      R0,[R1, #+0]
   \      0x136   0xF3BF 0x8F4F      DSB      SY
   \      0x13A   0xF3BF 0x8F6F      ISB      SY
   \      0x13E   0xE798             B.N      ??xQueueReceive_8
   1392          		}
   1393          		else
   1394          		{
   1395          			/* Timed out.  If there is no data in the queue exit, otherwise loop
   1396          			back and attempt to read the data. */
   1397          			prvUnlockQueue( pxQueue );
   \                     ??xQueueReceive_17: (+1)
   \      0x140   0x....'....        BL       prvUnlockQueue
   1398          			( void ) xTaskResumeAll();
   \      0x144   0x....'....        BL       xTaskResumeAll
   1399          
   1400          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   \      0x148   0x4630             MOV      R0,R6
   \      0x14A   0x....'....        BL       prvIsQueueEmpty
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD08F             BEQ.N    ??xQueueReceive_8
   1401          			{
   1402          				traceQUEUE_RECEIVE_FAILED( pxQueue );
   1403          				return errQUEUE_EMPTY;
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0xBDFE             POP      {R1-R7,PC}       ;; return
   1404          			}
   1405          			else
   1406          			{
   1407          				mtCOVERAGE_TEST_MARKER();
   1408          			}
   1409          		}
   1410          	} /*lint -restore */
   1411          }
   1412          /*-----------------------------------------------------------*/
   1413          

   \                                 In section .text, align 2, keep-with-next
   1414          BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
   1415          {
   \                     xQueueSemaphoreTake: (+1)
   \        0x0   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x4606             MOV      R6,R0
   1416          BaseType_t xEntryTimeSet = pdFALSE;
   \        0x6   0x2400             MOVS     R4,#+0
   1417          TimeOut_t xTimeOut;
   1418          Queue_t * const pxQueue = xQueue;
   1419          void *pvBuffer = NULL;
   1420          (void)pvBuffer;
   1421          
   1422          #if( configUSE_MUTEXES == 1 )
   1423          	BaseType_t xInheritanceOccurred = pdFALSE;
   \        0x8   0x4625             MOV      R5,R4
   1424          #endif
   1425          
   1426          	/* Check the queue pointer is not NULL. */
   1427          	configASSERT( ( pxQueue ) );
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD107             BNE.N    ??xQueueSemaphoreTake_0
   \        0xE   0x2020             MOVS     R0,#+32
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xQueueSemaphoreTake_1
   1428          
   1429          	/* Check this really is a semaphore, in which case the item size will be
   1430          	0. */
   1431          	configASSERT( pxQueue->uxItemSize == 0 );
   \                     ??xQueueSemaphoreTake_0: (+1)
   \       0x1E   0x6C30             LDR      R0,[R6, #+64]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD007             BEQ.N    ??xQueueSemaphoreTake_2
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_3: (+1)
   \       0x32   0xE7FE             B.N      ??xQueueSemaphoreTake_3
   1432          
   1433          	/* Cannot block if the scheduler is suspended. */
   1434          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1435          	{
   1436          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueueSemaphoreTake_2: (+1)
   \       0x34   0x....'....        BL       xTaskGetSchedulerState
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD104             BNE.N    ??xQueueSemaphoreTake_4
   \       0x3C   0x9803             LDR      R0,[SP, #+12]
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \       0x40   0x4180             SBCS     R0,R0,R0
   \       0x42   0x0FC0             LSRS     R0,R0,#+31
   \       0x44   0xE000             B.N      ??xQueueSemaphoreTake_5
   \                     ??xQueueSemaphoreTake_4: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \                     ??xQueueSemaphoreTake_5: (+1)
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD10C             BNE.N    ??xQueueSemaphoreTake_6
   \       0x4C   0x2020             MOVS     R0,#+32
   \       0x4E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x52   0xF3BF 0x8F4F      DSB      SY
   \       0x56   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_7: (+1)
   \       0x5A   0xE7FE             B.N      ??xQueueSemaphoreTake_7
   1437          	}
   1438          	#endif
   1439          
   1440          
   1441          	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
   1442          	statements within the function itself.  This is done in the interest
   1443          	of execution time efficiency. */
   1444          	for( ;; )
   1445          	{
   1446          		taskENTER_CRITICAL();
   1447          		{
   1448          			/* Semaphores are queues with an item size of 0, and where the
   1449          			number of messages in the queue is the semaphore's count value. */
   1450          			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   1451          
   1452          			/* Is there data in the queue now?  To be running the calling task
   1453          			must be the highest priority task wanting to access the queue. */
   1454          			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   1455          			{
   1456          				traceQUEUE_RECEIVE( pxQueue );
   1457          
   1458          				/* Semaphores are queues with a data size of zero and where the
   1459          				messages waiting is the semaphore's count.  Reduce the count. */
   1460          				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   1461          
   1462          				#if ( configUSE_MUTEXES == 1 )
   1463          				{
   1464          					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1465          					{
   1466          						/* Record the information required to implement
   1467          						priority inheritance should it become necessary. */
   1468          						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
   1469          					}
   1470          					else
   1471          					{
   1472          						mtCOVERAGE_TEST_MARKER();
   1473          					}
   1474          				}
   1475          				#endif /* configUSE_MUTEXES */
   1476          
   1477          				/* Check to see if other tasks are blocked waiting to give the
   1478          				semaphore, and if so, unblock the highest priority such task. */
   1479          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1480          				{
   1481          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1482          					{
   1483          						queueYIELD_IF_USING_PREEMPTION();
   1484          					}
   1485          					else
   1486          					{
   1487          						mtCOVERAGE_TEST_MARKER();
   1488          					}
   1489          				}
   1490          				else
   1491          				{
   1492          					mtCOVERAGE_TEST_MARKER();
   1493          				}
   1494          
   1495          				taskEXIT_CRITICAL();
   1496          				return pdPASS;
   1497          			}
   1498          			else
   1499          			{
   1500          				if( xTicksToWait == ( TickType_t ) 0 )
   1501          				{
   1502          					/* For inheritance to have occurred there must have been an
   1503          					initial timeout, and an adjusted timeout cannot become 0, as
   1504          					if it were 0 the function would have exited. */
   1505          					#if( configUSE_MUTEXES == 1 )
   1506          					{
   1507          						configASSERT( xInheritanceOccurred == pdFALSE );
   1508          					}
   1509          					#endif /* configUSE_MUTEXES */
   1510          
   1511          					/* The semaphore count was 0 and no block time is specified
   1512          					(or the block time has expired) so exit now. */
   1513          					taskEXIT_CRITICAL();
   1514          					traceQUEUE_RECEIVE_FAILED( pxQueue );
   1515          					return errQUEUE_EMPTY;
   1516          				}
   1517          				else if( xEntryTimeSet == pdFALSE )
   1518          				{
   1519          					/* The semaphore count was 0 and a block time was specified
   1520          					so configure the timeout structure ready to block. */
   1521          					vTaskInternalSetTimeOutState( &xTimeOut );
   1522          					xEntryTimeSet = pdTRUE;
   1523          				}
   1524          				else
   1525          				{
   1526          					/* Entry time was already set. */
   1527          					mtCOVERAGE_TEST_MARKER();
   1528          				}
   1529          			}
   1530          		}
   1531          		taskEXIT_CRITICAL();
   1532          
   1533          		/* Interrupts and other tasks can give to and take from the semaphore
   1534          		now the critical section has been exited. */
   1535          
   1536          		vTaskSuspendAll();
   1537          		prvLockQueue( pxQueue );
   1538          
   1539          		/* Update the timeout state to see if it has expired yet. */
   1540          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1541          		{
   1542          			/* A block time is specified and not expired.  If the semaphore
   1543          			count is 0 then enter the Blocked state to wait for a semaphore to
   1544          			become available.  As semaphores are implemented with queues the
   1545          			queue being empty is equivalent to the semaphore count being 0. */
   1546          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1547          			{
   1548          				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   1549          
   1550          				#if ( configUSE_MUTEXES == 1 )
   1551          				{
   1552          					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1553          					{
   1554          						taskENTER_CRITICAL();
   1555          						{
   1556          							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
   1557          						}
   1558          						taskEXIT_CRITICAL();
   1559          					}
   1560          					else
   1561          					{
   1562          						mtCOVERAGE_TEST_MARKER();
   1563          					}
   1564          				}
   1565          				#endif
   1566          
   1567          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1568          				prvUnlockQueue( pxQueue );
   1569          				if( xTaskResumeAll() == pdFALSE )
   1570          				{
   1571          					portYIELD_WITHIN_API();
   1572          				}
   1573          				else
   1574          				{
   1575          					mtCOVERAGE_TEST_MARKER();
   1576          				}
   1577          			}
   1578          			else
   1579          			{
   1580          				/* There was no timeout and the semaphore count was not 0, so
   1581          				attempt to take the semaphore again. */
   1582          				prvUnlockQueue( pxQueue );
   \                     ??xQueueSemaphoreTake_8: (+1)
   \       0x5C   0x4630             MOV      R0,R6
   \       0x5E   0x....'....        BL       prvUnlockQueue
   1583          				( void ) xTaskResumeAll();
   \       0x62   0x....'....        BL       xTaskResumeAll
   1584          			}
   \                     ??xQueueSemaphoreTake_6: (+1)
   \       0x66   0x....'....        BL       vPortEnterCritical
   \       0x6A   0x6BB0             LDR      R0,[R6, #+56]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD10C             BNE.N    ??xQueueSemaphoreTake_9
   \       0x70   0x9803             LDR      R0,[SP, #+12]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD12B             BNE.N    ??xQueueSemaphoreTake_10
   \       0x76   0x2D00             CMP      R5,#+0
   \       0x78   0xD025             BEQ.N    ??xQueueSemaphoreTake_11
   \       0x7A   0x2020             MOVS     R0,#+32
   \       0x7C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x80   0xF3BF 0x8F4F      DSB      SY
   \       0x84   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_12: (+1)
   \       0x88   0xE7FE             B.N      ??xQueueSemaphoreTake_12
   \                     ??xQueueSemaphoreTake_9: (+1)
   \       0x8A   0x1E40             SUBS     R0,R0,#+1
   \       0x8C   0x63B0             STR      R0,[R6, #+56]
   \       0x8E   0x6830             LDR      R0,[R6, #+0]
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD102             BNE.N    ??xQueueSemaphoreTake_13
   \       0x94   0x....'....        BL       pvTaskIncrementMutexHeldCount
   \       0x98   0x60B0             STR      R0,[R6, #+8]
   \                     ??xQueueSemaphoreTake_13: (+1)
   \       0x9A   0x6930             LDR      R0,[R6, #+16]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD00E             BEQ.N    ??xQueueSemaphoreTake_14
   \       0xA0   0xF106 0x0010      ADD      R0,R6,#+16
   \       0xA4   0x....'....        BL       xTaskRemoveFromEventList
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD008             BEQ.N    ??xQueueSemaphoreTake_14
   \       0xAC   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xB0   0x....'....        LDR.W    R1,??DataTable6  ;; 0xe000ed04
   \       0xB4   0x6008             STR      R0,[R1, #+0]
   \       0xB6   0xF3BF 0x8F4F      DSB      SY
   \       0xBA   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_14: (+1)
   \       0xBE   0x....'....        BL       vPortExitCritical
   \       0xC2   0x2001             MOVS     R0,#+1
   \       0xC4   0xE065             B.N      ??xQueueSemaphoreTake_15
   \                     ??xQueueSemaphoreTake_11: (+1)
   \       0xC6   0x....'....        BL       vPortExitCritical
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0xE061             B.N      ??xQueueSemaphoreTake_15
   \                     ??xQueueSemaphoreTake_10: (+1)
   \       0xCE   0x2C00             CMP      R4,#+0
   \       0xD0   0xD103             BNE.N    ??xQueueSemaphoreTake_16
   \       0xD2   0x4668             MOV      R0,SP
   \       0xD4   0x....'....        BL       vTaskInternalSetTimeOutState
   \       0xD8   0x2401             MOVS     R4,#+1
   \                     ??xQueueSemaphoreTake_16: (+1)
   \       0xDA   0x....'....        BL       vPortExitCritical
   \       0xDE   0x....'....        BL       vTaskSuspendAll
   \       0xE2   0x....'....        BL       vPortEnterCritical
   \       0xE6   0xF996 0x0044      LDRSB    R0,[R6, #+68]
   \       0xEA   0xF110 0x0F01      CMN      R0,#+1
   \       0xEE   0xD102             BNE.N    ??xQueueSemaphoreTake_17
   \       0xF0   0x2000             MOVS     R0,#+0
   \       0xF2   0xF886 0x0044      STRB     R0,[R6, #+68]
   \                     ??xQueueSemaphoreTake_17: (+1)
   \       0xF6   0xF996 0x0045      LDRSB    R0,[R6, #+69]
   \       0xFA   0xF110 0x0F01      CMN      R0,#+1
   \       0xFE   0xD102             BNE.N    ??xQueueSemaphoreTake_18
   \      0x100   0x2000             MOVS     R0,#+0
   \      0x102   0xF886 0x0045      STRB     R0,[R6, #+69]
   \                     ??xQueueSemaphoreTake_18: (+1)
   \      0x106   0x....'....        BL       vPortExitCritical
   \      0x10A   0xA903             ADD      R1,SP,#+12
   \      0x10C   0x4668             MOV      R0,SP
   \      0x10E   0x....'....        BL       xTaskCheckForTimeOut
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0x4630             MOV      R0,R6
   \      0x116   0xD124             BNE.N    ??xQueueSemaphoreTake_19
   \      0x118   0x....'....        BL       prvIsQueueEmpty
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD09D             BEQ.N    ??xQueueSemaphoreTake_8
   \      0x120   0x6830             LDR      R0,[R6, #+0]
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xD107             BNE.N    ??xQueueSemaphoreTake_20
   \      0x126   0x....'....        BL       vPortEnterCritical
   \      0x12A   0x68B0             LDR      R0,[R6, #+8]
   \      0x12C   0x....'....        BL       xTaskPriorityInherit
   \      0x130   0x4605             MOV      R5,R0
   \      0x132   0x....'....        BL       vPortExitCritical
   \                     ??xQueueSemaphoreTake_20: (+1)
   \      0x136   0x9903             LDR      R1,[SP, #+12]
   \      0x138   0xF106 0x0024      ADD      R0,R6,#+36
   \      0x13C   0x....'....        BL       vTaskPlaceOnEventList
   \      0x140   0x4630             MOV      R0,R6
   \      0x142   0x....'....        BL       prvUnlockQueue
   \      0x146   0x....'....        BL       xTaskResumeAll
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD18B             BNE.N    ??xQueueSemaphoreTake_6
   \      0x14E   0xF04F 0x5080      MOV      R0,#+268435456
   \      0x152   0x....'....        LDR.W    R1,??DataTable6  ;; 0xe000ed04
   \      0x156   0x6008             STR      R0,[R1, #+0]
   \      0x158   0xF3BF 0x8F4F      DSB      SY
   \      0x15C   0xF3BF 0x8F6F      ISB      SY
   \      0x160   0xE781             B.N      ??xQueueSemaphoreTake_6
   1585          		}
   1586          		else
   1587          		{
   1588          			/* Timed out. */
   1589          			prvUnlockQueue( pxQueue );
   \                     ??xQueueSemaphoreTake_19: (+1)
   \      0x162   0x....'....        BL       prvUnlockQueue
   1590          			( void ) xTaskResumeAll();
   \      0x166   0x....'....        BL       xTaskResumeAll
   1591          
   1592          			/* If the semaphore count is 0 exit now as the timeout has
   1593          			expired.  Otherwise return to attempt to take the semaphore that is
   1594          			known to be available.  As semaphores are implemented by queues the
   1595          			queue being empty is equivalent to the semaphore count being 0. */
   1596          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   \      0x16A   0x4630             MOV      R0,R6
   \      0x16C   0x....'....        BL       prvIsQueueEmpty
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xF43F 0xAF78      BEQ.W    ??xQueueSemaphoreTake_6
   1597          			{
   1598          				#if ( configUSE_MUTEXES == 1 )
   1599          				{
   1600          					/* xInheritanceOccurred could only have be set if
   1601          					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
   1602          					test the mutex type again to check it is actually a mutex. */
   1603          					if( xInheritanceOccurred != pdFALSE )
   \      0x176   0x2D00             CMP      R5,#+0
   \      0x178   0xD00A             BEQ.N    ??xQueueSemaphoreTake_21
   1604          					{
   1605          						taskENTER_CRITICAL();
   \      0x17A   0x....'....        BL       vPortEnterCritical
   1606          						{
   1607          							UBaseType_t uxHighestWaitingPriority;
   1608          
   1609          							/* This task blocking on the mutex caused another
   1610          							task to inherit this task's priority.  Now this task
   1611          							has timed out the priority should be disinherited
   1612          							again, but only as low as the next highest priority
   1613          							task that is waiting for the same mutex. */
   1614          							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
   \      0x17E   0x4630             MOV      R0,R6
   \      0x180   0x....'....        BL       prvGetDisinheritPriorityAfterTimeout
   1615          							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
   \      0x184   0x4601             MOV      R1,R0
   \      0x186   0x68B0             LDR      R0,[R6, #+8]
   \      0x188   0x....'....        BL       vTaskPriorityDisinheritAfterTimeout
   1616          						}
   1617          						taskEXIT_CRITICAL();
   \      0x18C   0x....'....        BL       vPortExitCritical
   1618          					}
   1619          				}
   1620          				#endif /* configUSE_MUTEXES */
   1621          
   1622          				traceQUEUE_RECEIVE_FAILED( pxQueue );
   1623          				return errQUEUE_EMPTY;
   \                     ??xQueueSemaphoreTake_21: (+1)
   \      0x190   0x2000             MOVS     R0,#+0
   \                     ??xQueueSemaphoreTake_15: (+1)
   \      0x192   0xB004             ADD      SP,SP,#+16
   \      0x194   0xBD70             POP      {R4-R6,PC}       ;; return
   1624          			}
   1625          			else
   1626          			{
   1627          				mtCOVERAGE_TEST_MARKER();
   1628          			}
   1629          		}
   1630          	} /*lint -restore */
   1631          }
   1632          /*-----------------------------------------------------------*/
   1633          

   \                                 In section .text, align 2, keep-with-next
   1634          BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
   1635          {
   \                     xQueuePeek: (+1)
   \        0x0   0xB576             PUSH     {R1,R2,R4-R6,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   1636          BaseType_t xEntryTimeSet = pdFALSE;
   \        0x8   0x2400             MOVS     R4,#+0
   1637          TimeOut_t xTimeOut;
   1638          int8_t *pcOriginalReadPosition;
   1639          Queue_t * const pxQueue = xQueue;
   1640          
   1641          	/* Check the pointer is not NULL. */
   1642          	configASSERT( ( pxQueue ) );
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD107             BNE.N    ??xQueuePeek_0
   \        0xE   0x2020             MOVS     R0,#+32
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeek_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xQueuePeek_1
   1643          
   1644          	/* The buffer into which data is received can only be NULL if the data size
   1645          	is zero (so no data is copied into the buffer. */
   1646          	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueuePeek_0: (+1)
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD104             BNE.N    ??xQueuePeek_2
   \       0x22   0x6C28             LDR      R0,[R5, #+64]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x4180             SBCS     R0,R0,R0
   \       0x28   0x0FC0             LSRS     R0,R0,#+31
   \       0x2A   0xE000             B.N      ??xQueuePeek_3
   \                     ??xQueuePeek_2: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \                     ??xQueuePeek_3: (+1)
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??xQueuePeek_4
   \       0x32   0x2020             MOVS     R0,#+32
   \       0x34   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeek_5: (+1)
   \       0x40   0xE7FE             B.N      ??xQueuePeek_5
   1647          
   1648          	/* Cannot block if the scheduler is suspended. */
   1649          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1650          	{
   1651          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueuePeek_4: (+1)
   \       0x42   0x....'....        BL       xTaskGetSchedulerState
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD104             BNE.N    ??xQueuePeek_6
   \       0x4A   0x9803             LDR      R0,[SP, #+12]
   \       0x4C   0x1E40             SUBS     R0,R0,#+1
   \       0x4E   0x4180             SBCS     R0,R0,R0
   \       0x50   0x0FC0             LSRS     R0,R0,#+31
   \       0x52   0xE000             B.N      ??xQueuePeek_7
   \                     ??xQueuePeek_6: (+1)
   \       0x54   0x2001             MOVS     R0,#+1
   \                     ??xQueuePeek_7: (+1)
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD10C             BNE.N    ??xQueuePeek_8
   \       0x5A   0x2020             MOVS     R0,#+32
   \       0x5C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x60   0xF3BF 0x8F4F      DSB      SY
   \       0x64   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeek_9: (+1)
   \       0x68   0xE7FE             B.N      ??xQueuePeek_9
   1652          	}
   1653          	#endif
   1654          
   1655          
   1656          	/*lint -save -e904  This function relaxes the coding standard somewhat to
   1657          	allow return statements within the function itself.  This is done in the
   1658          	interest of execution time efficiency. */
   1659          	for( ;; )
   1660          	{
   1661          		taskENTER_CRITICAL();
   1662          		{
   1663          			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1664          
   1665          			/* Is there data in the queue now?  To be running the calling task
   1666          			must be the highest priority task wanting to access the queue. */
   1667          			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   1668          			{
   1669          				/* Remember the read position so it can be reset after the data
   1670          				is read from the queue as this function is only peeking the
   1671          				data, not removing it. */
   1672          				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
   1673          
   1674          				prvCopyDataFromQueue( pxQueue, pvBuffer );
   1675          				traceQUEUE_PEEK( pxQueue );
   1676          
   1677          				/* The data is not being removed, so reset the read pointer. */
   1678          				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
   1679          
   1680          				/* The data is being left in the queue, so see if there are
   1681          				any other tasks waiting for the data. */
   1682          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1683          				{
   1684          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1685          					{
   1686          						/* The task waiting has a higher priority than this task. */
   1687          						queueYIELD_IF_USING_PREEMPTION();
   1688          					}
   1689          					else
   1690          					{
   1691          						mtCOVERAGE_TEST_MARKER();
   1692          					}
   1693          				}
   1694          				else
   1695          				{
   1696          					mtCOVERAGE_TEST_MARKER();
   1697          				}
   1698          
   1699          				taskEXIT_CRITICAL();
   1700          				return pdPASS;
   1701          			}
   1702          			else
   1703          			{
   1704          				if( xTicksToWait == ( TickType_t ) 0 )
   1705          				{
   1706          					/* The queue was empty and no block time is specified (or
   1707          					the block time has expired) so leave now. */
   1708          					taskEXIT_CRITICAL();
   1709          					traceQUEUE_PEEK_FAILED( pxQueue );
   1710          					return errQUEUE_EMPTY;
   1711          				}
   1712          				else if( xEntryTimeSet == pdFALSE )
   1713          				{
   1714          					/* The queue was empty and a block time was specified so
   1715          					configure the timeout structure ready to enter the blocked
   1716          					state. */
   1717          					vTaskInternalSetTimeOutState( &xTimeOut );
   1718          					xEntryTimeSet = pdTRUE;
   1719          				}
   1720          				else
   1721          				{
   1722          					/* Entry time was already set. */
   1723          					mtCOVERAGE_TEST_MARKER();
   1724          				}
   1725          			}
   1726          		}
   1727          		taskEXIT_CRITICAL();
   1728          
   1729          		/* Interrupts and other tasks can send to and receive from the queue
   1730          		now the critical section has been exited. */
   1731          
   1732          		vTaskSuspendAll();
   1733          		prvLockQueue( pxQueue );
   1734          
   1735          		/* Update the timeout state to see if it has expired yet. */
   1736          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1737          		{
   1738          			/* Timeout has not expired yet, check to see if there is data in the
   1739          			queue now, and if not enter the Blocked state to wait for data. */
   1740          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1741          			{
   1742          				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
   1743          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1744          				prvUnlockQueue( pxQueue );
   1745          				if( xTaskResumeAll() == pdFALSE )
   1746          				{
   1747          					portYIELD_WITHIN_API();
   1748          				}
   1749          				else
   1750          				{
   1751          					mtCOVERAGE_TEST_MARKER();
   1752          				}
   1753          			}
   1754          			else
   1755          			{
   1756          				/* There is data in the queue now, so don't enter the blocked
   1757          				state, instead return to try and obtain the data. */
   1758          				prvUnlockQueue( pxQueue );
   \                     ??xQueuePeek_10: (+1)
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x....'....        BL       prvUnlockQueue
   1759          				( void ) xTaskResumeAll();
   \       0x70   0x....'....        BL       xTaskResumeAll
   1760          			}
   \                     ??xQueuePeek_8: (+1)
   \       0x74   0x....'....        BL       vPortEnterCritical
   \       0x78   0x6BA8             LDR      R0,[R5, #+56]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD106             BNE.N    ??xQueuePeek_11
   \       0x7E   0x9803             LDR      R0,[SP, #+12]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD11F             BNE.N    ??xQueuePeek_12
   \       0x84   0x....'....        BL       vPortExitCritical
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0xE064             B.N      ??xQueuePeek_13
   \                     ??xQueuePeek_11: (+1)
   \       0x8C   0x68EC             LDR      R4,[R5, #+12]
   \       0x8E   0x4631             MOV      R1,R6
   \       0x90   0x4628             MOV      R0,R5
   \       0x92   0x....'....        BL       prvCopyDataFromQueue
   \       0x96   0x60EC             STR      R4,[R5, #+12]
   \       0x98   0x6A68             LDR      R0,[R5, #+36]
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD00E             BEQ.N    ??xQueuePeek_14
   \       0x9E   0xF105 0x0024      ADD      R0,R5,#+36
   \       0xA2   0x....'....        BL       xTaskRemoveFromEventList
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD008             BEQ.N    ??xQueuePeek_14
   \       0xAA   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xAE   0x....'....        LDR.W    R1,??DataTable6  ;; 0xe000ed04
   \       0xB2   0x6008             STR      R0,[R1, #+0]
   \       0xB4   0xF3BF 0x8F4F      DSB      SY
   \       0xB8   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeek_14: (+1)
   \       0xBC   0x....'....        BL       vPortExitCritical
   \       0xC0   0x2001             MOVS     R0,#+1
   \       0xC2   0xE048             B.N      ??xQueuePeek_13
   \                     ??xQueuePeek_12: (+1)
   \       0xC4   0x2C00             CMP      R4,#+0
   \       0xC6   0xD103             BNE.N    ??xQueuePeek_15
   \       0xC8   0x4668             MOV      R0,SP
   \       0xCA   0x....'....        BL       vTaskInternalSetTimeOutState
   \       0xCE   0x2401             MOVS     R4,#+1
   \                     ??xQueuePeek_15: (+1)
   \       0xD0   0x....'....        BL       vPortExitCritical
   \       0xD4   0x....'....        BL       vTaskSuspendAll
   \       0xD8   0x....'....        BL       vPortEnterCritical
   \       0xDC   0xF995 0x0044      LDRSB    R0,[R5, #+68]
   \       0xE0   0xF110 0x0F01      CMN      R0,#+1
   \       0xE4   0xD102             BNE.N    ??xQueuePeek_16
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xF885 0x0044      STRB     R0,[R5, #+68]
   \                     ??xQueuePeek_16: (+1)
   \       0xEC   0xF995 0x0045      LDRSB    R0,[R5, #+69]
   \       0xF0   0xF110 0x0F01      CMN      R0,#+1
   \       0xF4   0xD102             BNE.N    ??xQueuePeek_17
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0xF885 0x0045      STRB     R0,[R5, #+69]
   \                     ??xQueuePeek_17: (+1)
   \       0xFC   0x....'....        BL       vPortExitCritical
   \      0x100   0xA903             ADD      R1,SP,#+12
   \      0x102   0x4668             MOV      R0,SP
   \      0x104   0x....'....        BL       xTaskCheckForTimeOut
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0x4628             MOV      R0,R5
   \      0x10C   0xD119             BNE.N    ??xQueuePeek_18
   \      0x10E   0x....'....        BL       prvIsQueueEmpty
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xD0A9             BEQ.N    ??xQueuePeek_10
   \      0x116   0x9903             LDR      R1,[SP, #+12]
   \      0x118   0xF105 0x0024      ADD      R0,R5,#+36
   \      0x11C   0x....'....        BL       vTaskPlaceOnEventList
   \      0x120   0x4628             MOV      R0,R5
   \      0x122   0x....'....        BL       prvUnlockQueue
   \      0x126   0x....'....        BL       xTaskResumeAll
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD1A2             BNE.N    ??xQueuePeek_8
   \      0x12E   0xF04F 0x5080      MOV      R0,#+268435456
   \      0x132   0x....'....        LDR.W    R1,??DataTable6  ;; 0xe000ed04
   \      0x136   0x6008             STR      R0,[R1, #+0]
   \      0x138   0xF3BF 0x8F4F      DSB      SY
   \      0x13C   0xF3BF 0x8F6F      ISB      SY
   \      0x140   0xE798             B.N      ??xQueuePeek_8
   1761          		}
   1762          		else
   1763          		{
   1764          			/* The timeout has expired.  If there is still no data in the queue
   1765          			exit, otherwise go back and try to read the data again. */
   1766          			prvUnlockQueue( pxQueue );
   \                     ??xQueuePeek_18: (+1)
   \      0x142   0x....'....        BL       prvUnlockQueue
   1767          			( void ) xTaskResumeAll();
   \      0x146   0x....'....        BL       xTaskResumeAll
   1768          
   1769          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   \      0x14A   0x4628             MOV      R0,R5
   \      0x14C   0x....'....        BL       prvIsQueueEmpty
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD08F             BEQ.N    ??xQueuePeek_8
   1770          			{
   1771          				traceQUEUE_PEEK_FAILED( pxQueue );
   1772          				return errQUEUE_EMPTY;
   \      0x154   0x2000             MOVS     R0,#+0
   \                     ??xQueuePeek_13: (+1)
   \      0x156   0xB004             ADD      SP,SP,#+16
   \      0x158   0xBD70             POP      {R4-R6,PC}       ;; return
   1773          			}
   1774          			else
   1775          			{
   1776          				mtCOVERAGE_TEST_MARKER();
   1777          			}
   1778          		}
   1779          	} /*lint -restore */
   1780          }
   1781          /*-----------------------------------------------------------*/
   1782          

   \                                 In section .text, align 2, keep-with-next
   1783          BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
   1784          {
   \                     xQueueReceiveFromISR: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   1785          BaseType_t xReturn;
   1786          UBaseType_t uxSavedInterruptStatus;
   1787          Queue_t * const pxQueue = xQueue;
   1788          
   1789          	configASSERT( pxQueue );
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD107             BNE.N    ??xQueueReceiveFromISR_0
   \        0xE   0x2020             MOVS     R0,#+32
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceiveFromISR_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xQueueReceiveFromISR_1
   1790          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueReceiveFromISR_0: (+1)
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD104             BNE.N    ??xQueueReceiveFromISR_2
   \       0x22   0x6C20             LDR      R0,[R4, #+64]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x4180             SBCS     R0,R0,R0
   \       0x28   0x0FC0             LSRS     R0,R0,#+31
   \       0x2A   0xE000             B.N      ??xQueueReceiveFromISR_3
   \                     ??xQueueReceiveFromISR_2: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \                     ??xQueueReceiveFromISR_3: (+1)
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??xQueueReceiveFromISR_4
   \       0x32   0x2020             MOVS     R0,#+32
   \       0x34   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceiveFromISR_5: (+1)
   \       0x40   0xE7FE             B.N      ??xQueueReceiveFromISR_5
   1791          
   1792          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1793          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1794          	above the maximum system call priority are kept permanently enabled, even
   1795          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1796          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1797          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1798          	failure if a FreeRTOS API function is called from an interrupt that has been
   1799          	assigned a priority above the configured maximum system call priority.
   1800          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1801          	that have been assigned a priority at or (logically) below the maximum
   1802          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1803          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1804          	More information (albeit Cortex-M specific) is provided on the following
   1805          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1806          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xQueueReceiveFromISR_4: (+1)
   \       0x42   0x....'....        BL       vPortValidateInterruptPriority
   1807          
   1808          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x46   0xF3EF 0x8811      MRS      R8,BASEPRI
   \       0x4A   0x2020             MOVS     R0,#+32
   \       0x4C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x50   0xF3BF 0x8F4F      DSB      SY
   \       0x54   0xF3BF 0x8F6F      ISB      SY
   1809          	{
   1810          		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   \       0x58   0x6BA7             LDR      R7,[R4, #+56]
   1811          
   1812          		/* Cannot block in an ISR, so check there is data available. */
   1813          		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   \       0x5A   0x2F00             CMP      R7,#+0
   \       0x5C   0xD01E             BEQ.N    ??xQueueReceiveFromISR_6
   1814          		{
   1815          			const int8_t cRxLock = pxQueue->cRxLock;
   \       0x5E   0xF994 0x9044      LDRSB    R9,[R4, #+68]
   1816          
   1817          			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
   1818          
   1819          			prvCopyDataFromQueue( pxQueue, pvBuffer );
   \       0x62   0x4631             MOV      R1,R6
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x....'....        BL       prvCopyDataFromQueue
   1820          			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   \       0x6A   0x1E7F             SUBS     R7,R7,#+1
   \       0x6C   0x63A7             STR      R7,[R4, #+56]
   1821          
   1822          			/* If the queue is locked the event list will not be modified.
   1823          			Instead update the lock count so the task that unlocks the queue
   1824          			will know that an ISR has removed data while the queue was
   1825          			locked. */
   1826          			if( cRxLock == queueUNLOCKED )
   \       0x6E   0xF119 0x0F01      CMN      R9,#+1
   \       0x72   0xD10D             BNE.N    ??xQueueReceiveFromISR_7
   1827          			{
   1828          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \       0x74   0x6920             LDR      R0,[R4, #+16]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD00E             BEQ.N    ??xQueueReceiveFromISR_8
   1829          				{
   1830          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \       0x7A   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x7E   0x....'....        BL       xTaskRemoveFromEventList
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD008             BEQ.N    ??xQueueReceiveFromISR_8
   1831          					{
   1832          						/* The task waiting has a higher priority than us so
   1833          						force a context switch. */
   1834          						if( pxHigherPriorityTaskWoken != NULL )
   \       0x86   0x2D00             CMP      R5,#+0
   \       0x88   0xD006             BEQ.N    ??xQueueReceiveFromISR_8
   1835          						{
   1836          							*pxHigherPriorityTaskWoken = pdTRUE;
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0x6028             STR      R0,[R5, #+0]
   \       0x8E   0xE003             B.N      ??xQueueReceiveFromISR_8
   1837          						}
   1838          						else
   1839          						{
   1840          							mtCOVERAGE_TEST_MARKER();
   1841          						}
   1842          					}
   1843          					else
   1844          					{
   1845          						mtCOVERAGE_TEST_MARKER();
   1846          					}
   1847          				}
   1848          				else
   1849          				{
   1850          					mtCOVERAGE_TEST_MARKER();
   1851          				}
   1852          			}
   1853          			else
   1854          			{
   1855          				/* Increment the lock count so the task that unlocks the queue
   1856          				knows that data was removed while it was locked. */
   1857          				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
   \                     ??xQueueReceiveFromISR_7: (+1)
   \       0x90   0xF109 0x0901      ADD      R9,R9,#+1
   \       0x94   0xF884 0x9044      STRB     R9,[R4, #+68]
   1858          			}
   1859          
   1860          			xReturn = pdPASS;
   \                     ??xQueueReceiveFromISR_8: (+1)
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0xE000             B.N      ??xQueueReceiveFromISR_9
   1861          		}
   1862          		else
   1863          		{
   1864          			xReturn = pdFAIL;
   \                     ??xQueueReceiveFromISR_6: (+1)
   \       0x9C   0x2000             MOVS     R0,#+0
   1865          			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
   1866          		}
   1867          	}
   1868          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueReceiveFromISR_9: (+1)
   \       0x9E   0xF388 0x8811      MSR      BASEPRI,R8
   1869          
   1870          	return xReturn;
   \       0xA2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1871          }
   1872          /*-----------------------------------------------------------*/
   1873          

   \                                 In section .text, align 2, keep-with-next
   1874          BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
   1875          {
   \                     xQueuePeekFromISR: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1876          BaseType_t xReturn;
   1877          UBaseType_t uxSavedInterruptStatus;
   1878          int8_t *pcOriginalReadPosition;
   1879          Queue_t * const pxQueue = xQueue;
   1880          
   1881          	configASSERT( pxQueue );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xQueuePeekFromISR_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeekFromISR_1: (+1)
   \       0x18   0xE7FE             B.N      ??xQueuePeekFromISR_1
   1882          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueuePeekFromISR_0: (+1)
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD104             BNE.N    ??xQueuePeekFromISR_2
   \       0x1E   0x6C20             LDR      R0,[R4, #+64]
   \       0x20   0x1E40             SUBS     R0,R0,#+1
   \       0x22   0x4180             SBCS     R0,R0,R0
   \       0x24   0x0FC0             LSRS     R0,R0,#+31
   \       0x26   0xE000             B.N      ??xQueuePeekFromISR_3
   \                     ??xQueuePeekFromISR_2: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \                     ??xQueuePeekFromISR_3: (+1)
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD107             BNE.N    ??xQueuePeekFromISR_4
   \       0x2E   0x2020             MOVS     R0,#+32
   \       0x30   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x34   0xF3BF 0x8F4F      DSB      SY
   \       0x38   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeekFromISR_5: (+1)
   \       0x3C   0xE7FE             B.N      ??xQueuePeekFromISR_5
   1883          	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
   \                     ??xQueuePeekFromISR_4: (+1)
   \       0x3E   0x6C20             LDR      R0,[R4, #+64]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD107             BNE.N    ??xQueuePeekFromISR_6
   \       0x44   0x2020             MOVS     R0,#+32
   \       0x46   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x4A   0xF3BF 0x8F4F      DSB      SY
   \       0x4E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeekFromISR_7: (+1)
   \       0x52   0xE7FE             B.N      ??xQueuePeekFromISR_7
   1884          
   1885          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1886          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1887          	above the maximum system call priority are kept permanently enabled, even
   1888          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1889          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1890          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1891          	failure if a FreeRTOS API function is called from an interrupt that has been
   1892          	assigned a priority above the configured maximum system call priority.
   1893          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1894          	that have been assigned a priority at or (logically) below the maximum
   1895          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1896          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1897          	More information (albeit Cortex-M specific) is provided on the following
   1898          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1899          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xQueuePeekFromISR_6: (+1)
   \       0x54   0x....'....        BL       vPortValidateInterruptPriority
   1900          
   1901          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x58   0xF3EF 0x8611      MRS      R6,BASEPRI
   \       0x5C   0x2020             MOVS     R0,#+32
   \       0x5E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x62   0xF3BF 0x8F4F      DSB      SY
   \       0x66   0xF3BF 0x8F6F      ISB      SY
   1902          	{
   1903          		/* Cannot block in an ISR, so check there is data available. */
   1904          		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   \       0x6A   0x6BA0             LDR      R0,[R4, #+56]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD007             BEQ.N    ??xQueuePeekFromISR_8
   1905          		{
   1906          			traceQUEUE_PEEK_FROM_ISR( pxQueue );
   1907          
   1908          			/* Remember the read position so it can be reset as nothing is
   1909          			actually being removed from the queue. */
   1910          			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
   \       0x70   0x68E7             LDR      R7,[R4, #+12]
   1911          			prvCopyDataFromQueue( pxQueue, pvBuffer );
   \       0x72   0x4629             MOV      R1,R5
   \       0x74   0x4620             MOV      R0,R4
   \       0x76   0x....'....        BL       prvCopyDataFromQueue
   1912          			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
   \       0x7A   0x60E7             STR      R7,[R4, #+12]
   1913          
   1914          			xReturn = pdPASS;
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xE000             B.N      ??xQueuePeekFromISR_9
   1915          		}
   1916          		else
   1917          		{
   1918          			xReturn = pdFAIL;
   \                     ??xQueuePeekFromISR_8: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   1919          			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
   1920          		}
   1921          	}
   1922          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueuePeekFromISR_9: (+1)
   \       0x82   0xF386 0x8811      MSR      BASEPRI,R6
   1923          
   1924          	return xReturn;
   \       0x86   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1925          }
   1926          /*-----------------------------------------------------------*/
   1927          

   \                                 In section .text, align 2, keep-with-next
   1928          UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
   1929          {
   \                     uxQueueMessagesWaiting: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1930          UBaseType_t uxReturn;
   1931          
   1932          	configASSERT( xQueue );
   \        0x4   0xD107             BNE.N    ??uxQueueMessagesWaiting_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??uxQueueMessagesWaiting_1: (+1)
   \       0x14   0xE7FE             B.N      ??uxQueueMessagesWaiting_1
   1933          
   1934          	taskENTER_CRITICAL();
   \                     ??uxQueueMessagesWaiting_0: (+1)
   \       0x16   0x....'....        BL       vPortEnterCritical
   1935          	{
   1936          		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
   \       0x1A   0x6BA4             LDR      R4,[R4, #+56]
   1937          	}
   1938          	taskEXIT_CRITICAL();
   \       0x1C   0x....'....        BL       vPortExitCritical
   1939          
   1940          	return uxReturn;
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
   1941          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1942          /*-----------------------------------------------------------*/
   1943          

   \                                 In section .text, align 2, keep-with-next
   1944          UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
   1945          {
   \                     uxQueueSpacesAvailable: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1946          UBaseType_t uxReturn;
   1947          Queue_t * const pxQueue = xQueue;
   1948          
   1949          	configASSERT( pxQueue );
   \        0x4   0xD107             BNE.N    ??uxQueueSpacesAvailable_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??uxQueueSpacesAvailable_1: (+1)
   \       0x14   0xE7FE             B.N      ??uxQueueSpacesAvailable_1
   1950          
   1951          	taskENTER_CRITICAL();
   \                     ??uxQueueSpacesAvailable_0: (+1)
   \       0x16   0x....'....        BL       vPortEnterCritical
   1952          	{
   1953          		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
   \       0x1A   0x6BE0             LDR      R0,[R4, #+60]
   \       0x1C   0x6BA4             LDR      R4,[R4, #+56]
   \       0x1E   0x1B04             SUBS     R4,R0,R4
   1954          	}
   1955          	taskEXIT_CRITICAL();
   \       0x20   0x....'....        BL       vPortExitCritical
   1956          
   1957          	return uxReturn;
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0xBD10             POP      {R4,PC}          ;; return
   1958          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1959          /*-----------------------------------------------------------*/
   1960          

   \                                 In section .text, align 2, keep-with-next
   1961          UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
   1962          {
   1963          UBaseType_t uxReturn;
   1964          Queue_t * const pxQueue = xQueue;
   1965          
   1966          	configASSERT( pxQueue );
   \                     uxQueueMessagesWaitingFromISR: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??uxQueueMessagesWaitingFromISR_0
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??uxQueueMessagesWaitingFromISR_1: (+1)
   \       0x12   0xE7FE             B.N      ??uxQueueMessagesWaitingFromISR_1
   1967          	uxReturn = pxQueue->uxMessagesWaiting;
   \                     ??uxQueueMessagesWaitingFromISR_0: (+1)
   \       0x14   0x6B80             LDR      R0,[R0, #+56]
   1968          
   1969          	return uxReturn;
   \       0x16   0x4770             BX       LR               ;; return
   1970          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1971          /*-----------------------------------------------------------*/
   1972          

   \                                 In section .text, align 2, keep-with-next
   1973          void vQueueDelete( QueueHandle_t xQueue )
   1974          {
   \                     vQueueDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1975          Queue_t * const pxQueue = xQueue;
   1976          
   1977          	configASSERT( pxQueue );
   \        0x4   0xD107             BNE.N    ??vQueueDelete_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??vQueueDelete_1: (+1)
   \       0x14   0xE7FE             B.N      ??vQueueDelete_1
   1978          	traceQUEUE_DELETE( pxQueue );
   1979          
   1980          	#if ( configQUEUE_REGISTRY_SIZE > 0 )
   1981          	{
   1982          		vQueueUnregisterQueue( pxQueue );
   \                     ??vQueueDelete_0: (+1)
   \       0x16   0x....'....        BL       vQueueUnregisterQueue
   1983          	}
   1984          	#endif
   1985          
   1986          	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
   1987          	{
   1988          		/* The queue can only have been allocated dynamically - free it
   1989          		again. */
   1990          		vPortFree( pxQueue );
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x20   0x....'....        B.W      vPortFree
   1991          	}
   1992          	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
   1993          	{
   1994          		/* The queue could have been allocated statically or dynamically, so
   1995          		check before attempting to free the memory. */
   1996          		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
   1997          		{
   1998          			vPortFree( pxQueue );
   1999          		}
   2000          		else
   2001          		{
   2002          			mtCOVERAGE_TEST_MARKER();
   2003          		}
   2004          	}
   2005          	#else
   2006          	{
   2007          		/* The queue must have been statically allocated, so is not going to be
   2008          		deleted.  Avoid compiler warnings about the unused parameter. */
   2009          		( void ) pxQueue;
   2010          	}
   2011          	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
   2012          }
   2013          /*-----------------------------------------------------------*/
   2014          
   2015          #if ( configUSE_TRACE_FACILITY == 1 )
   2016          

   \                                 In section .text, align 2, keep-with-next
   2017          	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
   2018          	{
   2019          		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
   \                     uxQueueGetQueueNumber: (+1)
   \        0x0   0x6C80             LDR      R0,[R0, #+72]
   \        0x2   0x4770             BX       LR               ;; return
   2020          	}
   2021          
   2022          #endif /* configUSE_TRACE_FACILITY */
   2023          /*-----------------------------------------------------------*/
   2024          
   2025          #if ( configUSE_TRACE_FACILITY == 1 )
   2026          

   \                                 In section .text, align 2, keep-with-next
   2027          	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
   2028          	{
   2029          		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
   \                     vQueueSetQueueNumber: (+1)
   \        0x0   0x6481             STR      R1,[R0, #+72]
   2030          	}
   \        0x2   0x4770             BX       LR               ;; return
   2031          
   2032          #endif /* configUSE_TRACE_FACILITY */
   2033          /*-----------------------------------------------------------*/
   2034          
   2035          #if ( configUSE_TRACE_FACILITY == 1 )
   2036          

   \                                 In section .text, align 2, keep-with-next
   2037          	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
   2038          	{
   2039          		return ( ( Queue_t * ) xQueue )->ucQueueType;
   \                     ucQueueGetQueueType: (+1)
   \        0x0   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \        0x4   0x4770             BX       LR               ;; return
   2040          	}
   2041          
   2042          #endif /* configUSE_TRACE_FACILITY */
   2043          /*-----------------------------------------------------------*/
   2044          
   2045          #if( configUSE_MUTEXES == 1 )
   2046          

   \                                 In section .text, align 2, keep-with-next
   2047          	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
   2048          	{
   2049          	UBaseType_t uxHighestPriorityOfWaitingTasks;
   2050          
   2051          		/* If a task waiting for a mutex causes the mutex holder to inherit a
   2052          		priority, but the waiting task times out, then the holder should
   2053          		disinherit the priority - but only down to the highest priority of any
   2054          		other tasks that are waiting for the same mutex.  For this purpose,
   2055          		return the priority of the highest priority task that is waiting for the
   2056          		mutex. */
   2057          		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
   \                     prvGetDisinheritPriorityAfterTimeout: (+1)
   \        0x0   0x6A41             LDR      R1,[R0, #+36]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??prvGetDisinheritPriorityAfterTimeout_0
   2058          		{
   2059          			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   \        0x6   0x6B00             LDR      R0,[R0, #+48]
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0xF1C0 0x0005      RSB      R0,R0,#+5
   \        0xE   0x4770             BX       LR
   2060          		}
   2061          		else
   2062          		{
   2063          			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
   \                     ??prvGetDisinheritPriorityAfterTimeout_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   2064          		}
   2065          
   2066          		return uxHighestPriorityOfWaitingTasks;
   \       0x12   0x4770             BX       LR               ;; return
   2067          	}
   2068          
   2069          #endif /* configUSE_MUTEXES */
   2070          /*-----------------------------------------------------------*/
   2071          

   \                                 In section .text, align 2, keep-with-next
   2072          static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
   2073          {
   \                     prvCopyDataToQueue: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x4615             MOV      R5,R2
   2074          BaseType_t xReturn = pdFALSE;
   \        0x6   0x2700             MOVS     R7,#+0
   2075          UBaseType_t uxMessagesWaiting;
   2076          
   2077          	/* This function is called from a critical section. */
   2078          
   2079          	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   \        0x8   0x6BB4             LDR      R4,[R6, #+56]
   2080          
   2081          	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   \        0xA   0x6C30             LDR      R0,[R6, #+64]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD109             BNE.N    ??prvCopyDataToQueue_0
   2082          	{
   2083          		#if ( configUSE_MUTEXES == 1 )
   2084          		{
   2085          			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   \       0x10   0x6830             LDR      R0,[R6, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD12B             BNE.N    ??prvCopyDataToQueue_1
   2086          			{
   2087          				/* The mutex is no longer being held. */
   2088          				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
   \       0x16   0x68B0             LDR      R0,[R6, #+8]
   \       0x18   0x....'....        BL       xTaskPriorityDisinherit
   \       0x1C   0x4607             MOV      R7,R0
   2089          				pxQueue->u.xSemaphore.xMutexHolder = NULL;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60B0             STR      R0,[R6, #+8]
   \       0x22   0xE024             B.N      ??prvCopyDataToQueue_1
   2090          			}
   2091          			else
   2092          			{
   2093          				mtCOVERAGE_TEST_MARKER();
   2094          			}
   2095          		}
   2096          		#endif /* configUSE_MUTEXES */
   2097          	}
   2098          	else if( xPosition == queueSEND_TO_BACK )
   \                     ??prvCopyDataToQueue_0: (+1)
   \       0x24   0x2D00             CMP      R5,#+0
   \       0x26   0x4602             MOV      R2,R0
   \       0x28   0xD10C             BNE.N    ??prvCopyDataToQueue_2
   2099          	{
   2100          		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   \       0x2A   0x6870             LDR      R0,[R6, #+4]
   \       0x2C   0x....'....        BL       __aeabi_memcpy
   2101          		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   \       0x30   0x6870             LDR      R0,[R6, #+4]
   \       0x32   0x6C31             LDR      R1,[R6, #+64]
   \       0x34   0x4408             ADD      R0,R0,R1
   \       0x36   0x6070             STR      R0,[R6, #+4]
   2102          		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   \       0x38   0x68B1             LDR      R1,[R6, #+8]
   \       0x3A   0x4288             CMP      R0,R1
   \       0x3C   0xD317             BCC.N    ??prvCopyDataToQueue_1
   2103          		{
   2104          			pxQueue->pcWriteTo = pxQueue->pcHead;
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0x6070             STR      R0,[R6, #+4]
   \       0x42   0xE014             B.N      ??prvCopyDataToQueue_1
   2105          		}
   2106          		else
   2107          		{
   2108          			mtCOVERAGE_TEST_MARKER();
   2109          		}
   2110          	}
   2111          	else
   2112          	{
   2113          		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
   \                     ??prvCopyDataToQueue_2: (+1)
   \       0x44   0x68F0             LDR      R0,[R6, #+12]
   \       0x46   0x....'....        BL       __aeabi_memcpy
   2114          		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
   \       0x4A   0x68F0             LDR      R0,[R6, #+12]
   \       0x4C   0x6C31             LDR      R1,[R6, #+64]
   \       0x4E   0x4249             RSBS     R1,R1,#+0
   \       0x50   0x4408             ADD      R0,R0,R1
   \       0x52   0x60F0             STR      R0,[R6, #+12]
   2115          		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   \       0x54   0x6831             LDR      R1,[R6, #+0]
   \       0x56   0x4288             CMP      R0,R1
   \       0x58   0xD204             BCS.N    ??prvCopyDataToQueue_3
   2116          		{
   2117          			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
   \       0x5A   0x68B0             LDR      R0,[R6, #+8]
   \       0x5C   0x6C31             LDR      R1,[R6, #+64]
   \       0x5E   0x4249             RSBS     R1,R1,#+0
   \       0x60   0x4408             ADD      R0,R0,R1
   \       0x62   0x60F0             STR      R0,[R6, #+12]
   2118          		}
   2119          		else
   2120          		{
   2121          			mtCOVERAGE_TEST_MARKER();
   2122          		}
   2123          
   2124          		if( xPosition == queueOVERWRITE )
   \                     ??prvCopyDataToQueue_3: (+1)
   \       0x64   0x2D02             CMP      R5,#+2
   \       0x66   0xD102             BNE.N    ??prvCopyDataToQueue_1
   2125          		{
   2126          			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   \       0x68   0x2C00             CMP      R4,#+0
   \       0x6A   0xD000             BEQ.N    ??prvCopyDataToQueue_1
   2127          			{
   2128          				/* An item is not being added but overwritten, so subtract
   2129          				one from the recorded number of items in the queue so when
   2130          				one is added again below the number of recorded items remains
   2131          				correct. */
   2132          				--uxMessagesWaiting;
   \       0x6C   0x1E64             SUBS     R4,R4,#+1
   2133          			}
   2134          			else
   2135          			{
   2136          				mtCOVERAGE_TEST_MARKER();
   2137          			}
   2138          		}
   2139          		else
   2140          		{
   2141          			mtCOVERAGE_TEST_MARKER();
   2142          		}
   2143          	}
   2144          
   2145          	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   \                     ??prvCopyDataToQueue_1: (+1)
   \       0x6E   0x1C64             ADDS     R4,R4,#+1
   \       0x70   0x63B4             STR      R4,[R6, #+56]
   2146          
   2147          	return xReturn;
   \       0x72   0x4638             MOV      R0,R7
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2148          }
   2149          /*-----------------------------------------------------------*/
   2150          

   \                                 In section .text, align 2, keep-with-next
   2151          static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
   2152          {
   \                     prvCopyDataFromQueue: (+1)
   \        0x0   0x460B             MOV      R3,R1
   2153          	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   \        0x2   0x6C01             LDR      R1,[R0, #+64]
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD00D             BEQ.N    ??prvCopyDataFromQueue_0
   2154          	{
   2155          		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   \        0x8   0x68C1             LDR      R1,[R0, #+12]
   \        0xA   0x6C02             LDR      R2,[R0, #+64]
   \        0xC   0x4411             ADD      R1,R1,R2
   \        0xE   0x60C1             STR      R1,[R0, #+12]
   2156          		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   \       0x10   0x6882             LDR      R2,[R0, #+8]
   \       0x12   0x4291             CMP      R1,R2
   \       0x14   0xD301             BCC.N    ??prvCopyDataFromQueue_1
   2157          		{
   2158          			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x60C1             STR      R1,[R0, #+12]
   2159          		}
   2160          		else
   2161          		{
   2162          			mtCOVERAGE_TEST_MARKER();
   2163          		}
   2164          		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   \                     ??prvCopyDataFromQueue_1: (+1)
   \       0x1A   0x6C02             LDR      R2,[R0, #+64]
   \       0x1C   0x68C1             LDR      R1,[R0, #+12]
   \       0x1E   0x4618             MOV      R0,R3
   \       0x20   0x....'....        B.W      __aeabi_memcpy
   2165          	}
   2166          }
   \                     ??prvCopyDataFromQueue_0: (+1)
   \       0x24   0x4770             BX       LR               ;; return
   2167          /*-----------------------------------------------------------*/
   2168          

   \                                 In section .text, align 2, keep-with-next
   2169          static void prvUnlockQueue( Queue_t * const pxQueue )
   2170          {
   \                     prvUnlockQueue: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   2171          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
   2172          
   2173          	/* The lock counts contains the number of extra data items placed or
   2174          	removed from the queue while the queue was locked.  When a queue is
   2175          	locked items can be added or removed, but the event lists cannot be
   2176          	updated. */
   2177          	taskENTER_CRITICAL();
   \        0x4   0x....'....        BL       vPortEnterCritical
   2178          	{
   2179          		int8_t cTxLock = pxQueue->cTxLock;
   \        0x8   0xF994 0x5045      LDRSB    R5,[R4, #+69]
   2180          
   2181          		/* See if data was added to the queue while it was locked. */
   2182          		while( cTxLock > queueLOCKED_UNMODIFIED )
   \                     ??prvUnlockQueue_0: (+1)
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0xB240             SXTB     R0,R0
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xDB19             BLT.N    ??prvUnlockQueue_1
   2183          		{
   2184          			/* Data was posted while the queue was locked.  Are any tasks
   2185          			blocked waiting for data to become available? */
   2186          			#if ( configUSE_QUEUE_SETS == 1 )
   2187          			{
   2188          				if( pxQueue->pxQueueSetContainer != NULL )
   2189          				{
   2190          					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
   2191          					{
   2192          						/* The queue is a member of a queue set, and posting to
   2193          						the queue set caused a higher priority task to unblock.
   2194          						A context switch is required. */
   2195          						vTaskMissedYield();
   2196          					}
   2197          					else
   2198          					{
   2199          						mtCOVERAGE_TEST_MARKER();
   2200          					}
   2201          				}
   2202          				else
   2203          				{
   2204          					/* Tasks that are removed from the event list will get
   2205          					added to the pending ready list as the scheduler is still
   2206          					suspended. */
   2207          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2208          					{
   2209          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2210          						{
   2211          							/* The task waiting has a higher priority so record that a
   2212          							context	switch is required. */
   2213          							vTaskMissedYield();
   2214          						}
   2215          						else
   2216          						{
   2217          							mtCOVERAGE_TEST_MARKER();
   2218          						}
   2219          					}
   2220          					else
   2221          					{
   2222          						break;
   2223          					}
   2224          				}
   2225          			}
   2226          			#else /* configUSE_QUEUE_SETS */
   2227          			{
   2228          				/* Tasks that are removed from the event list will get added to
   2229          				the pending ready list as the scheduler is still suspended. */
   2230          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \       0x14   0x6A60             LDR      R0,[R4, #+36]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD016             BEQ.N    ??prvUnlockQueue_1
   2231          				{
   2232          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \       0x1A   0xF104 0x0024      ADD      R0,R4,#+36
   \       0x1E   0x....'....        BL       xTaskRemoveFromEventList
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD001             BEQ.N    ??prvUnlockQueue_2
   2233          					{
   2234          						/* The task waiting has a higher priority so record that
   2235          						a context switch is required. */
   2236          						vTaskMissedYield();
   \       0x26   0x....'....        BL       vTaskMissedYield
   2237          					}
   2238          					else
   2239          					{
   2240          						mtCOVERAGE_TEST_MARKER();
   2241          					}
   2242          				}
   2243          				else
   2244          				{
   2245          					break;
   2246          				}
   2247          			}
   2248          			#endif /* configUSE_QUEUE_SETS */
   2249          
   2250          			--cTxLock;
   \                     ??prvUnlockQueue_2: (+1)
   \       0x2A   0x1E6D             SUBS     R5,R5,#+1
   \       0x2C   0xE7EE             B.N      ??prvUnlockQueue_0
   2251          		}
   2252          
   2253          		pxQueue->cTxLock = queueUNLOCKED;
   2254          	}
   2255          	taskEXIT_CRITICAL();
   2256          
   2257          	/* Do the same for the Rx lock. */
   2258          	taskENTER_CRITICAL();
   2259          	{
   2260          		int8_t cRxLock = pxQueue->cRxLock;
   2261          
   2262          		while( cRxLock > queueLOCKED_UNMODIFIED )
   2263          		{
   2264          			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \                     ??prvUnlockQueue_3: (+1)
   \       0x2E   0x6920             LDR      R0,[R4, #+16]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD018             BEQ.N    ??prvUnlockQueue_4
   2265          			{
   2266          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \       0x34   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x38   0x....'....        BL       xTaskRemoveFromEventList
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD001             BEQ.N    ??prvUnlockQueue_5
   2267          				{
   2268          					vTaskMissedYield();
   \       0x40   0x....'....        BL       vTaskMissedYield
   2269          				}
   2270          				else
   2271          				{
   2272          					mtCOVERAGE_TEST_MARKER();
   2273          				}
   2274          
   2275          				--cRxLock;
   \                     ??prvUnlockQueue_5: (+1)
   \       0x44   0x1E76             SUBS     R6,R6,#+1
   \       0x46   0xE00A             B.N      ??prvUnlockQueue_6
   2276          			}
   2277          			else
   2278          			{
   2279          				break;
   2280          			}
   2281          		}
   \                     ??prvUnlockQueue_1: (+1)
   \       0x48   0xF04F 0x30FF      MOV      R0,#-1
   \       0x4C   0x4605             MOV      R5,R0
   \       0x4E   0xF884 0x5045      STRB     R5,[R4, #+69]
   \       0x52   0x....'....        BL       vPortExitCritical
   \       0x56   0x....'....        BL       vPortEnterCritical
   \       0x5A   0xF994 0x6044      LDRSB    R6,[R4, #+68]
   \                     ??prvUnlockQueue_6: (+1)
   \       0x5E   0x4630             MOV      R0,R6
   \       0x60   0xB240             SXTB     R0,R0
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0xDAE3             BGE.N    ??prvUnlockQueue_3
   2282          
   2283          		pxQueue->cRxLock = queueUNLOCKED;
   \                     ??prvUnlockQueue_4: (+1)
   \       0x66   0xF884 0x5044      STRB     R5,[R4, #+68]
   2284          	}
   2285          	taskEXIT_CRITICAL();
   \       0x6A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x6E   0x....'....        B.W      vPortExitCritical
   2286          }
   2287          /*-----------------------------------------------------------*/
   2288          

   \                                 In section .text, align 2, keep-with-next
   2289          static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
   2290          {
   \                     prvIsQueueEmpty: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2291          BaseType_t xReturn;
   2292          
   2293          	taskENTER_CRITICAL();
   \        0x4   0x....'....        BL       vPortEnterCritical
   2294          	{
   2295          		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   \        0x8   0x6BA0             LDR      R0,[R4, #+56]
   \        0xA   0x1E44             SUBS     R4,R0,#+1
   \        0xC   0x41A4             SBCS     R4,R4,R4
   \        0xE   0x0FE4             LSRS     R4,R4,#+31
   2296          		{
   2297          			xReturn = pdTRUE;
   2298          		}
   2299          		else
   2300          		{
   2301          			xReturn = pdFALSE;
   2302          		}
   2303          	}
   2304          	taskEXIT_CRITICAL();
   \       0x10   0x....'....        BL       vPortExitCritical
   2305          
   2306          	return xReturn;
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xBD10             POP      {R4,PC}          ;; return
   2307          }
   2308          /*-----------------------------------------------------------*/
   2309          

   \                                 In section .text, align 2, keep-with-next
   2310          BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
   2311          {
   2312          BaseType_t xReturn;
   2313          Queue_t * const pxQueue = xQueue;
   2314          
   2315          	configASSERT( pxQueue );
   \                     xQueueIsQueueEmptyFromISR: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??xQueueIsQueueEmptyFromISR_0
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueIsQueueEmptyFromISR_1: (+1)
   \       0x12   0xE7FE             B.N      ??xQueueIsQueueEmptyFromISR_1
   2316          	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   \                     ??xQueueIsQueueEmptyFromISR_0: (+1)
   \       0x14   0x6B80             LDR      R0,[R0, #+56]
   \       0x16   0x1E40             SUBS     R0,R0,#+1
   \       0x18   0x4180             SBCS     R0,R0,R0
   \       0x1A   0x0FC0             LSRS     R0,R0,#+31
   2317          	{
   2318          		xReturn = pdTRUE;
   2319          	}
   2320          	else
   2321          	{
   2322          		xReturn = pdFALSE;
   2323          	}
   2324          
   2325          	return xReturn;
   \       0x1C   0x4770             BX       LR               ;; return
   2326          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   2327          /*-----------------------------------------------------------*/
   2328          

   \                                 In section .text, align 2, keep-with-next
   2329          static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
   2330          {
   \                     prvIsQueueFull: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2331          BaseType_t xReturn;
   2332          
   2333          	taskENTER_CRITICAL();
   \        0x4   0x....'....        BL       vPortEnterCritical
   2334          	{
   2335          		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   \        0x8   0x6BA0             LDR      R0,[R4, #+56]
   \        0xA   0x6BE1             LDR      R1,[R4, #+60]
   \        0xC   0x4288             CMP      R0,R1
   \        0xE   0xD101             BNE.N    ??prvIsQueueFull_0
   2336          		{
   2337          			xReturn = pdTRUE;
   \       0x10   0x2401             MOVS     R4,#+1
   \       0x12   0xE000             B.N      ??prvIsQueueFull_1
   2338          		}
   2339          		else
   2340          		{
   2341          			xReturn = pdFALSE;
   \                     ??prvIsQueueFull_0: (+1)
   \       0x14   0x2400             MOVS     R4,#+0
   2342          		}
   2343          	}
   2344          	taskEXIT_CRITICAL();
   \                     ??prvIsQueueFull_1: (+1)
   \       0x16   0x....'....        BL       vPortExitCritical
   2345          
   2346          	return xReturn;
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
   2347          }
   2348          /*-----------------------------------------------------------*/
   2349          

   \                                 In section .text, align 2, keep-with-next
   2350          BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
   2351          {
   2352          BaseType_t xReturn;
   2353          Queue_t * const pxQueue = xQueue;
   2354          
   2355          	configASSERT( pxQueue );
   \                     xQueueIsQueueFullFromISR: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??xQueueIsQueueFullFromISR_0
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueIsQueueFullFromISR_1: (+1)
   \       0x12   0xE7FE             B.N      ??xQueueIsQueueFullFromISR_1
   2356          	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   \                     ??xQueueIsQueueFullFromISR_0: (+1)
   \       0x14   0x6B81             LDR      R1,[R0, #+56]
   \       0x16   0x6BC0             LDR      R0,[R0, #+60]
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0xD101             BNE.N    ??xQueueIsQueueFullFromISR_2
   2357          	{
   2358          		xReturn = pdTRUE;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x4770             BX       LR
   2359          	}
   2360          	else
   2361          	{
   2362          		xReturn = pdFALSE;
   \                     ??xQueueIsQueueFullFromISR_2: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   2363          	}
   2364          
   2365          	return xReturn;
   \       0x22   0x4770             BX       LR               ;; return
   2366          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   2367          /*-----------------------------------------------------------*/
   2368          
   2369          #if ( configUSE_CO_ROUTINES == 1 )
   2370          
   2371          	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
   2372          	{
   2373          	BaseType_t xReturn;
   2374          	Queue_t * const pxQueue = xQueue;
   2375          
   2376          		/* If the queue is already full we may have to block.  A critical section
   2377          		is required to prevent an interrupt removing something from the queue
   2378          		between the check to see if the queue is full and blocking on the queue. */
   2379          		portDISABLE_INTERRUPTS();
   2380          		{
   2381          			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   2382          			{
   2383          				/* The queue is full - do we want to block or just leave without
   2384          				posting? */
   2385          				if( xTicksToWait > ( TickType_t ) 0 )
   2386          				{
   2387          					/* As this is called from a coroutine we cannot block directly, but
   2388          					return indicating that we need to block. */
   2389          					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
   2390          					portENABLE_INTERRUPTS();
   2391          					return errQUEUE_BLOCKED;
   2392          				}
   2393          				else
   2394          				{
   2395          					portENABLE_INTERRUPTS();
   2396          					return errQUEUE_FULL;
   2397          				}
   2398          			}
   2399          		}
   2400          		portENABLE_INTERRUPTS();
   2401          
   2402          		portDISABLE_INTERRUPTS();
   2403          		{
   2404          			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   2405          			{
   2406          				/* There is room in the queue, copy the data into the queue. */
   2407          				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   2408          				xReturn = pdPASS;
   2409          
   2410          				/* Were any co-routines waiting for data to become available? */
   2411          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2412          				{
   2413          					/* In this instance the co-routine could be placed directly
   2414          					into the ready list as we are within a critical section.
   2415          					Instead the same pending ready list mechanism is used as if
   2416          					the event were caused from within an interrupt. */
   2417          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2418          					{
   2419          						/* The co-routine waiting has a higher priority so record
   2420          						that a yield might be appropriate. */
   2421          						xReturn = errQUEUE_YIELD;
   2422          					}
   2423          					else
   2424          					{
   2425          						mtCOVERAGE_TEST_MARKER();
   2426          					}
   2427          				}
   2428          				else
   2429          				{
   2430          					mtCOVERAGE_TEST_MARKER();
   2431          				}
   2432          			}
   2433          			else
   2434          			{
   2435          				xReturn = errQUEUE_FULL;
   2436          			}
   2437          		}
   2438          		portENABLE_INTERRUPTS();
   2439          
   2440          		return xReturn;
   2441          	}
   2442          
   2443          #endif /* configUSE_CO_ROUTINES */
   2444          /*-----------------------------------------------------------*/
   2445          
   2446          #if ( configUSE_CO_ROUTINES == 1 )
   2447          
   2448          	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
   2449          	{
   2450          	BaseType_t xReturn;
   2451          	Queue_t * const pxQueue = xQueue;
   2452          
   2453          		/* If the queue is already empty we may have to block.  A critical section
   2454          		is required to prevent an interrupt adding something to the queue
   2455          		between the check to see if the queue is empty and blocking on the queue. */
   2456          		portDISABLE_INTERRUPTS();
   2457          		{
   2458          			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   2459          			{
   2460          				/* There are no messages in the queue, do we want to block or just
   2461          				leave with nothing? */
   2462          				if( xTicksToWait > ( TickType_t ) 0 )
   2463          				{
   2464          					/* As this is a co-routine we cannot block directly, but return
   2465          					indicating that we need to block. */
   2466          					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
   2467          					portENABLE_INTERRUPTS();
   2468          					return errQUEUE_BLOCKED;
   2469          				}
   2470          				else
   2471          				{
   2472          					portENABLE_INTERRUPTS();
   2473          					return errQUEUE_FULL;
   2474          				}
   2475          			}
   2476          			else
   2477          			{
   2478          				mtCOVERAGE_TEST_MARKER();
   2479          			}
   2480          		}
   2481          		portENABLE_INTERRUPTS();
   2482          
   2483          		portDISABLE_INTERRUPTS();
   2484          		{
   2485          			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   2486          			{
   2487          				/* Data is available from the queue. */
   2488          				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
   2489          				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
   2490          				{
   2491          					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   2492          				}
   2493          				else
   2494          				{
   2495          					mtCOVERAGE_TEST_MARKER();
   2496          				}
   2497          				--( pxQueue->uxMessagesWaiting );
   2498          				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   2499          
   2500          				xReturn = pdPASS;
   2501          
   2502          				/* Were any co-routines waiting for space to become available? */
   2503          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2504          				{
   2505          					/* In this instance the co-routine could be placed directly
   2506          					into the ready list as we are within a critical section.
   2507          					Instead the same pending ready list mechanism is used as if
   2508          					the event were caused from within an interrupt. */
   2509          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2510          					{
   2511          						xReturn = errQUEUE_YIELD;
   2512          					}
   2513          					else
   2514          					{
   2515          						mtCOVERAGE_TEST_MARKER();
   2516          					}
   2517          				}
   2518          				else
   2519          				{
   2520          					mtCOVERAGE_TEST_MARKER();
   2521          				}
   2522          			}
   2523          			else
   2524          			{
   2525          				xReturn = pdFAIL;
   2526          			}
   2527          		}
   2528          		portENABLE_INTERRUPTS();
   2529          
   2530          		return xReturn;
   2531          	}
   2532          
   2533          #endif /* configUSE_CO_ROUTINES */
   2534          /*-----------------------------------------------------------*/
   2535          
   2536          #if ( configUSE_CO_ROUTINES == 1 )
   2537          
   2538          	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
   2539          	{
   2540          	Queue_t * const pxQueue = xQueue;
   2541          
   2542          		/* Cannot block within an ISR so if there is no space on the queue then
   2543          		exit without doing anything. */
   2544          		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   2545          		{
   2546          			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   2547          
   2548          			/* We only want to wake one co-routine per ISR, so check that a
   2549          			co-routine has not already been woken. */
   2550          			if( xCoRoutinePreviouslyWoken == pdFALSE )
   2551          			{
   2552          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2553          				{
   2554          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2555          					{
   2556          						return pdTRUE;
   2557          					}
   2558          					else
   2559          					{
   2560          						mtCOVERAGE_TEST_MARKER();
   2561          					}
   2562          				}
   2563          				else
   2564          				{
   2565          					mtCOVERAGE_TEST_MARKER();
   2566          				}
   2567          			}
   2568          			else
   2569          			{
   2570          				mtCOVERAGE_TEST_MARKER();
   2571          			}
   2572          		}
   2573          		else
   2574          		{
   2575          			mtCOVERAGE_TEST_MARKER();
   2576          		}
   2577          
   2578          		return xCoRoutinePreviouslyWoken;
   2579          	}
   2580          
   2581          #endif /* configUSE_CO_ROUTINES */
   2582          /*-----------------------------------------------------------*/
   2583          
   2584          #if ( configUSE_CO_ROUTINES == 1 )
   2585          
   2586          	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
   2587          	{
   2588          	BaseType_t xReturn;
   2589          	Queue_t * const pxQueue = xQueue;
   2590          
   2591          		/* We cannot block from an ISR, so check there is data available. If
   2592          		not then just leave without doing anything. */
   2593          		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   2594          		{
   2595          			/* Copy the data from the queue. */
   2596          			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
   2597          			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
   2598          			{
   2599          				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   2600          			}
   2601          			else
   2602          			{
   2603          				mtCOVERAGE_TEST_MARKER();
   2604          			}
   2605          			--( pxQueue->uxMessagesWaiting );
   2606          			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   2607          
   2608          			if( ( *pxCoRoutineWoken ) == pdFALSE )
   2609          			{
   2610          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2611          				{
   2612          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2613          					{
   2614          						*pxCoRoutineWoken = pdTRUE;
   2615          					}
   2616          					else
   2617          					{
   2618          						mtCOVERAGE_TEST_MARKER();
   2619          					}
   2620          				}
   2621          				else
   2622          				{
   2623          					mtCOVERAGE_TEST_MARKER();
   2624          				}
   2625          			}
   2626          			else
   2627          			{
   2628          				mtCOVERAGE_TEST_MARKER();
   2629          			}
   2630          
   2631          			xReturn = pdPASS;
   2632          		}
   2633          		else
   2634          		{
   2635          			xReturn = pdFAIL;
   2636          		}
   2637          
   2638          		return xReturn;
   2639          	}
   2640          
   2641          #endif /* configUSE_CO_ROUTINES */
   2642          /*-----------------------------------------------------------*/
   2643          
   2644          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2645          

   \                                 In section .text, align 2, keep-with-next
   2646          	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2647          	{
   \                     vQueueAddToRegistry: (+1)
   \        0x0   0xB410             PUSH     {R4}
   2648          	UBaseType_t ux;
   2649          
   2650          		/* See if there is an empty space in the registry.  A NULL name denotes
   2651          		a free slot. */
   2652          		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x....             LDR.N    R4,??DataTable7
   \        0x6   0xE000             B.N      ??vQueueAddToRegistry_0
   \                     ??vQueueAddToRegistry_1: (+1)
   \        0x8   0x1C5B             ADDS     R3,R3,#+1
   \                     ??vQueueAddToRegistry_0: (+1)
   \        0xA   0x2B08             CMP      R3,#+8
   \        0xC   0xD208             BCS.N    ??vQueueAddToRegistry_2
   2653          		{
   2654          			if( xQueueRegistry[ ux ].pcQueueName == NULL )
   \        0xE   0xF854 0x2033      LDR      R2,[R4, R3, LSL #+3]
   \       0x12   0x2A00             CMP      R2,#+0
   \       0x14   0xD1F8             BNE.N    ??vQueueAddToRegistry_1
   2655          			{
   2656          				/* Store the information on this queue. */
   2657          				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
   \       0x16   0xF844 0x1033      STR      R1,[R4, R3, LSL #+3]
   2658          				xQueueRegistry[ ux ].xHandle = xQueue;
   \       0x1A   0xEB04 0x01C3      ADD      R1,R4,R3, LSL #+3
   \       0x1E   0x6048             STR      R0,[R1, #+4]
   2659          
   2660          				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
   2661          				break;
   2662          			}
   2663          			else
   2664          			{
   2665          				mtCOVERAGE_TEST_MARKER();
   2666          			}
   2667          		}
   2668          	}
   \                     ??vQueueAddToRegistry_2: (+1)
   \       0x20   0xBC10             POP      {R4}
   \       0x22   0x4770             BX       LR               ;; return
   2669          
   2670          #endif /* configQUEUE_REGISTRY_SIZE */
   2671          /*-----------------------------------------------------------*/
   2672          
   2673          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2674          

   \                                 In section .text, align 2, keep-with-next
   2675          	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2676          	{
   \                     pcQueueGetName: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x4601             MOV      R1,R0
   2677          	UBaseType_t ux;
   2678          	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   \        0x4   0x2000             MOVS     R0,#+0
   2679          
   2680          		/* Note there is nothing here to protect against another task adding or
   2681          		removing entries from the registry while it is being searched. */
   2682          		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \        0x6   0x4602             MOV      R2,R0
   \        0x8   0x....             LDR.N    R3,??DataTable7
   \        0xA   0xE000             B.N      ??pcQueueGetName_0
   \                     ??pcQueueGetName_1: (+1)
   \        0xC   0x1C52             ADDS     R2,R2,#+1
   \                     ??pcQueueGetName_0: (+1)
   \        0xE   0x2A08             CMP      R2,#+8
   \       0x10   0xD206             BCS.N    ??pcQueueGetName_2
   2683          		{
   2684          			if( xQueueRegistry[ ux ].xHandle == xQueue )
   \       0x12   0xEB03 0x04C2      ADD      R4,R3,R2, LSL #+3
   \       0x16   0x6864             LDR      R4,[R4, #+4]
   \       0x18   0x428C             CMP      R4,R1
   \       0x1A   0xD1F7             BNE.N    ??pcQueueGetName_1
   2685          			{
   2686          				pcReturn = xQueueRegistry[ ux ].pcQueueName;
   \       0x1C   0xF853 0x0032      LDR      R0,[R3, R2, LSL #+3]
   2687          				break;
   2688          			}
   2689          			else
   2690          			{
   2691          				mtCOVERAGE_TEST_MARKER();
   2692          			}
   2693          		}
   2694          
   2695          		return pcReturn;
   \                     ??pcQueueGetName_2: (+1)
   \       0x20   0xBC10             POP      {R4}
   \       0x22   0x4770             BX       LR               ;; return
   2696          	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
   2697          
   2698          #endif /* configQUEUE_REGISTRY_SIZE */
   2699          /*-----------------------------------------------------------*/
   2700          
   2701          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2702          

   \                                 In section .text, align 2, keep-with-next
   2703          	void vQueueUnregisterQueue( QueueHandle_t xQueue )
   2704          	{
   2705          	UBaseType_t ux;
   2706          
   2707          		/* See if the handle of the queue being unregistered in actually in the
   2708          		registry. */
   2709          		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \                     vQueueUnregisterQueue: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             LDR.N    R2,??DataTable7
   \        0x4   0xE000             B.N      ??vQueueUnregisterQueue_0
   \                     ??vQueueUnregisterQueue_1: (+1)
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \                     ??vQueueUnregisterQueue_0: (+1)
   \        0x8   0x2908             CMP      R1,#+8
   \        0xA   0xD20A             BCS.N    ??vQueueUnregisterQueue_2
   2710          		{
   2711          			if( xQueueRegistry[ ux ].xHandle == xQueue )
   \        0xC   0xEB02 0x03C1      ADD      R3,R2,R1, LSL #+3
   \       0x10   0x685B             LDR      R3,[R3, #+4]
   \       0x12   0x4283             CMP      R3,R0
   \       0x14   0xD1F7             BNE.N    ??vQueueUnregisterQueue_1
   2712          			{
   2713          				/* Set the name to NULL to show that this slot if free again. */
   2714          				xQueueRegistry[ ux ].pcQueueName = NULL;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF842 0x0031      STR      R0,[R2, R1, LSL #+3]
   2715          
   2716          				/* Set the handle to NULL to ensure the same queue handle cannot
   2717          				appear in the registry twice if it is added, removed, then
   2718          				added again. */
   2719          				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
   \       0x1C   0xEB02 0x01C1      ADD      R1,R2,R1, LSL #+3
   \       0x20   0x6048             STR      R0,[R1, #+4]
   2720          				break;
   2721          			}
   2722          			else
   2723          			{
   2724          				mtCOVERAGE_TEST_MARKER();
   2725          			}
   2726          		}
   2727          
   2728          	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   \                     ??vQueueUnregisterQueue_2: (+1)
   \       0x22   0x4770             BX       LR               ;; return
   2729          
   2730          #endif /* configQUEUE_REGISTRY_SIZE */
   2731          /*-----------------------------------------------------------*/
   2732          
   2733          #if ( configUSE_TIMERS == 1 )
   2734          

   \                                 In section .text, align 2, keep-with-next
   2735          	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
   2736          	{
   \                     vQueueWaitForMessageRestricted: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   2737          	Queue_t * const pxQueue = xQueue;
   2738          
   2739          		/* This function should not be called by application code hence the
   2740          		'Restricted' in its name.  It is not part of the public API.  It is
   2741          		designed for use by kernel code, and has special calling requirements.
   2742          		It can result in vListInsert() being called on a list that can only
   2743          		possibly ever have one item in it, so the list will be fast, but even
   2744          		so it should be called with the scheduler locked and not from a critical
   2745          		section. */
   2746          
   2747          		/* Only do anything if there are no messages in the queue.  This function
   2748          		will not actually cause the task to block, just place it on a blocked
   2749          		list.  It will not block until the scheduler is unlocked - at which
   2750          		time a yield will be performed.  If an item is added to the queue while
   2751          		the queue is locked, and the calling task blocks on the queue, then the
   2752          		calling task will be immediately unblocked when the queue is unlocked. */
   2753          		prvLockQueue( pxQueue );
   \        0x8   0x....'....        BL       vPortEnterCritical
   \        0xC   0xF994 0x0044      LDRSB    R0,[R4, #+68]
   \       0x10   0xF110 0x0F01      CMN      R0,#+1
   \       0x14   0xD102             BNE.N    ??vQueueWaitForMessageRestricted_0
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF884 0x0044      STRB     R0,[R4, #+68]
   \                     ??vQueueWaitForMessageRestricted_0: (+1)
   \       0x1C   0xF994 0x0045      LDRSB    R0,[R4, #+69]
   \       0x20   0xF110 0x0F01      CMN      R0,#+1
   \       0x24   0xD102             BNE.N    ??vQueueWaitForMessageRestricted_1
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF884 0x0045      STRB     R0,[R4, #+69]
   \                     ??vQueueWaitForMessageRestricted_1: (+1)
   \       0x2C   0x....'....        BL       vPortExitCritical
   2754          		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   \       0x30   0x6BA0             LDR      R0,[R4, #+56]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD105             BNE.N    ??vQueueWaitForMessageRestricted_2
   2755          		{
   2756          			/* There is nothing in the queue, block for the specified period. */
   2757          			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
   \       0x36   0x4632             MOV      R2,R6
   \       0x38   0x4629             MOV      R1,R5
   \       0x3A   0xF104 0x0024      ADD      R0,R4,#+36
   \       0x3E   0x....'....        BL       vTaskPlaceOnEventListRestricted
   2758          		}
   2759          		else
   2760          		{
   2761          			mtCOVERAGE_TEST_MARKER();
   2762          		}
   2763          		prvUnlockQueue( pxQueue );
   \                     ??vQueueWaitForMessageRestricted_2: (+1)
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x48   0x....             B.N      prvUnlockQueue
   2764          	}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     xQueueRegistry
   2765          
   2766          #endif /* configUSE_TIMERS */
   2767          /*-----------------------------------------------------------*/
   2768          
   2769          #if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
   2770          
   2771          	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
   2772          	{
   2773          	QueueSetHandle_t pxQueue;
   2774          
   2775          		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
   2776          
   2777          		return pxQueue;
   2778          	}
   2779          
   2780          #endif /* configUSE_QUEUE_SETS */
   2781          /*-----------------------------------------------------------*/
   2782          
   2783          #if ( configUSE_QUEUE_SETS == 1 )
   2784          
   2785          	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
   2786          	{
   2787          	BaseType_t xReturn;
   2788          
   2789          		taskENTER_CRITICAL();
   2790          		{
   2791          			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
   2792          			{
   2793          				/* Cannot add a queue/semaphore to more than one queue set. */
   2794          				xReturn = pdFAIL;
   2795          			}
   2796          			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
   2797          			{
   2798          				/* Cannot add a queue/semaphore to a queue set if there are already
   2799          				items in the queue/semaphore. */
   2800          				xReturn = pdFAIL;
   2801          			}
   2802          			else
   2803          			{
   2804          				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
   2805          				xReturn = pdPASS;
   2806          			}
   2807          		}
   2808          		taskEXIT_CRITICAL();
   2809          
   2810          		return xReturn;
   2811          	}
   2812          
   2813          #endif /* configUSE_QUEUE_SETS */
   2814          /*-----------------------------------------------------------*/
   2815          
   2816          #if ( configUSE_QUEUE_SETS == 1 )
   2817          
   2818          	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
   2819          	{
   2820          	BaseType_t xReturn;
   2821          	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
   2822          
   2823          		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
   2824          		{
   2825          			/* The queue was not a member of the set. */
   2826          			xReturn = pdFAIL;
   2827          		}
   2828          		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
   2829          		{
   2830          			/* It is dangerous to remove a queue from a set when the queue is
   2831          			not empty because the queue set will still hold pending events for
   2832          			the queue. */
   2833          			xReturn = pdFAIL;
   2834          		}
   2835          		else
   2836          		{
   2837          			taskENTER_CRITICAL();
   2838          			{
   2839          				/* The queue is no longer contained in the set. */
   2840          				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
   2841          			}
   2842          			taskEXIT_CRITICAL();
   2843          			xReturn = pdPASS;
   2844          		}
   2845          
   2846          		return xReturn;
   2847          	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
   2848          
   2849          #endif /* configUSE_QUEUE_SETS */
   2850          /*-----------------------------------------------------------*/
   2851          
   2852          #if ( configUSE_QUEUE_SETS == 1 )
   2853          
   2854          	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
   2855          	{
   2856          	QueueSetMemberHandle_t xReturn = NULL;
   2857          
   2858          		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2859          		return xReturn;
   2860          	}
   2861          
   2862          #endif /* configUSE_QUEUE_SETS */
   2863          /*-----------------------------------------------------------*/
   2864          
   2865          #if ( configUSE_QUEUE_SETS == 1 )
   2866          
   2867          	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
   2868          	{
   2869          	QueueSetMemberHandle_t xReturn = NULL;
   2870          
   2871          		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2872          		return xReturn;
   2873          	}
   2874          
   2875          #endif /* configUSE_QUEUE_SETS */
   2876          /*-----------------------------------------------------------*/
   2877          
   2878          #if ( configUSE_QUEUE_SETS == 1 )
   2879          
   2880          	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
   2881          	{
   2882          	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
   2883          	BaseType_t xReturn = pdFALSE;
   2884          
   2885          		/* This function must be called form a critical section. */
   2886          
   2887          		configASSERT( pxQueueSetContainer );
   2888          		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
   2889          
   2890          		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
   2891          		{
   2892          			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
   2893          
   2894          			traceQUEUE_SEND( pxQueueSetContainer );
   2895          
   2896          			/* The data copied is the handle of the queue that contains data. */
   2897          			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
   2898          
   2899          			if( cTxLock == queueUNLOCKED )
   2900          			{
   2901          				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
   2902          				{
   2903          					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
   2904          					{
   2905          						/* The task waiting has a higher priority. */
   2906          						xReturn = pdTRUE;
   2907          					}
   2908          					else
   2909          					{
   2910          						mtCOVERAGE_TEST_MARKER();
   2911          					}
   2912          				}
   2913          				else
   2914          				{
   2915          					mtCOVERAGE_TEST_MARKER();
   2916          				}
   2917          			}
   2918          			else
   2919          			{
   2920          				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
   2921          			}
   2922          		}
   2923          		else
   2924          		{
   2925          			mtCOVERAGE_TEST_MARKER();
   2926          		}
   2927          
   2928          		return xReturn;
   2929          	}
   2930          
   2931          #endif /* configUSE_QUEUE_SETS */
   2932          
   2933          
   2934          
   2935          
   2936          
   2937          
   2938          
   2939          
   2940          
   2941          
   2942          
   2943          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   pcQueueGetName
       0   prvCopyDataFromQueue
         0   -> __aeabi_memcpy
      24   prvCopyDataToQueue
        24   -> __aeabi_memcpy
        24   -> xTaskPriorityDisinherit
       0   prvGetDisinheritPriorityAfterTimeout
       0   prvInitialiseMutex
         0   -> xQueueGenericSend
      16   prvInitialiseNewQueue
        16   -> xQueueGenericReset
       8   prvIsQueueEmpty
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   prvIsQueueFull
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      16   prvUnlockQueue
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
        16   -> vPortExitCritical
        16   -> vTaskMissedYield
        16   -> xTaskRemoveFromEventList
       0   ucQueueGetQueueType
       0   uxQueueGetQueueNumber
       8   uxQueueMessagesWaiting
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       0   uxQueueMessagesWaitingFromISR
       8   uxQueueSpacesAvailable
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       4   vQueueAddToRegistry
       8   vQueueDelete
         0   -> vPortFree
         8   -> vQueueUnregisterQueue
       0   vQueueSetQueueNumber
       0   vQueueUnregisterQueue
      16   vQueueWaitForMessageRestricted
         0   -> prvUnlockQueue
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskPlaceOnEventListRestricted
       8   xQueueCreateCountingSemaphore
         8   -> xQueueGenericCreate
       8   xQueueCreateMutex
         8   -> prvInitialiseMutex
         8   -> xQueueGenericCreate
      24   xQueueGenericCreate
        24   -> prvInitialiseNewQueue
        24   -> pvPortMalloc
      16   xQueueGenericReset
        16   -> vListInitialise
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> xTaskRemoveFromEventList
      32   xQueueGenericSend
        32   -> prvCopyDataToQueue
        32   -> prvIsQueueFull
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      32   xQueueGenericSendFromISR
        32   -> prvCopyDataToQueue
        32   -> vPortValidateInterruptPriority
        32   -> xTaskRemoveFromEventList
      16   xQueueGiveFromISR
        16   -> vPortValidateInterruptPriority
        16   -> xTaskRemoveFromEventList
       8   xQueueGiveMutexRecursive
         8   -> xQueueGenericSend
         8   -> xTaskGetCurrentTaskHandle
       0   xQueueIsQueueEmptyFromISR
       0   xQueueIsQueueFullFromISR
      32   xQueuePeek
        32   -> prvCopyDataFromQueue
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      24   xQueuePeekFromISR
        24   -> prvCopyDataFromQueue
        24   -> vPortValidateInterruptPriority
      32   xQueueReceive
        32   -> prvCopyDataFromQueue
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      32   xQueueReceiveFromISR
        32   -> prvCopyDataFromQueue
        32   -> vPortValidateInterruptPriority
        32   -> xTaskRemoveFromEventList
      32   xQueueSemaphoreTake
        32   -> prvGetDisinheritPriorityAfterTimeout
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> pvTaskIncrementMutexHeldCount
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskPriorityDisinheritAfterTimeout
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskPriorityInherit
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      16   xQueueTakeMutexRecursive
        16   -> xQueueSemaphoreTake
        16   -> xTaskGetCurrentTaskHandle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable7
      36  pcQueueGetName
      38  prvCopyDataFromQueue
     118  prvCopyDataToQueue
      20  prvGetDisinheritPriorityAfterTimeout
      20  prvInitialiseMutex
      34  prvInitialiseNewQueue
      24  prvIsQueueEmpty
      30  prvIsQueueFull
     114  prvUnlockQueue
       6  ucQueueGetQueueType
       4  uxQueueGetQueueNumber
      36  uxQueueMessagesWaiting
      24  uxQueueMessagesWaitingFromISR
      40  uxQueueSpacesAvailable
      36  vQueueAddToRegistry
      36  vQueueDelete
       4  vQueueSetQueueNumber
      36  vQueueUnregisterQueue
      74  vQueueWaitForMessageRestricted
      60  xQueueCreateCountingSemaphore
      22  xQueueCreateMutex
      70  xQueueGenericCreate
     142  xQueueGenericReset
     380  xQueueGenericSend
     208  xQueueGenericSendFromISR
     176  xQueueGiveFromISR
      60  xQueueGiveMutexRecursive
      30  xQueueIsQueueEmptyFromISR
      36  xQueueIsQueueFullFromISR
     346  xQueuePeek
     136  xQueuePeekFromISR
     342  xQueueReceive
     166  xQueueReceiveFromISR
      64  xQueueRegistry
     406  xQueueSemaphoreTake
      66  xQueueTakeMutexRecursive

 
    64 bytes in section .bss
 3 384 bytes in section .text
 
 3 384 bytes of CODE memory
    64 bytes of DATA memory

Errors: none
Warnings: none
