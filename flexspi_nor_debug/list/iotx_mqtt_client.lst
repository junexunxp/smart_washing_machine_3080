###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:31
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\iotx_mqtt_client.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW5BF.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\iotx_mqtt_client.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\iotx_mqtt_client.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\iotx_mqtt_client.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\iotx_mqtt_client.c
      1          /*
      2           * Copyright (C) 2015-2018 Alibaba Group Holding Limited
      3           */
      4          #include "mqtt_internal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __dlist_add(dlist_t *, dlist_t *, dlist_t *)
   \                     __dlist_add: (+1)
   \        0x0   0x6042             STR      R2,[R0, #+4]
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0x6048             STR      R0,[R1, #+4]
   \        0x6   0x6010             STR      R0,[R2, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void dlist_add_tail(dlist_t *, dlist_t *)
   \                     dlist_add_tail: (+1)
   \        0x0   0x460A             MOV      R2,R1
   \        0x2   0x6811             LDR      R1,[R2, #+0]
   \        0x4   0x....             B.N      __dlist_add

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void dlist_del(dlist_t *)
   \                     dlist_del: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x6840             LDR      R0,[R0, #+4]
   \        0x4   0x6048             STR      R0,[R1, #+4]
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void INIT_AOS_DLIST_HEAD(dlist_t *)
   \                     INIT_AOS_DLIST_HEAD: (+1)
   \        0x0   0x6040             STR      R0,[R0, #+4]
   \        0x2   0x6000             STR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int __dlist_entry_number(dlist_t *)
   \                     __dlist_entry_number: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xE001             B.N      ??__dlist_entry_number_0
   \                     ??__dlist_entry_number_1: (+1)
   \        0x8   0x461A             MOV      R2,R3
   \        0xA   0x1C40             ADDS     R0,R0,#+1
   \                     ??__dlist_entry_number_0: (+1)
   \        0xC   0x6853             LDR      R3,[R2, #+4]
   \        0xE   0x428B             CMP      R3,R1
   \       0x10   0xD1FA             BNE.N    ??__dlist_entry_number_1
   \       0x12   0x4770             BX       LR               ;; return
      5          
      6          #ifdef LOG_REPORT_TO_CLOUD
      7              #include "iotx_log_report.h"
      8          #endif

   \                                 In section .bss, align 4
      9          static int _in_yield_cb;
   \                     _in_yield_cb:
   \        0x0                      DS8 4
     10          
     11          #ifndef PLATFORM_HAS_DYNMEM
     12          iotx_mc_client_t g_iotx_mc_client[IOTX_MC_CLIENT_MAX_COUNT] = {0};
     13          #endif
     14          

   \                                 In section .text, align 2, keep-with-next
     15          static void iotx_mc_release(iotx_mc_client_t *pclient)
     16          {
     17          #ifdef PLATFORM_HAS_DYNMEM
     18              mqtt_free(pclient);
   \                     iotx_mc_release: (+1)
   \        0x0   0x....'....        B.W      HAL_Free
     19          #else
     20              memset(pclient, 0, sizeof(iotx_mc_client_t));
     21          #endif
     22          }
     23          
     24          #if !WITH_MQTT_ONLY_QOS0

   \                                 In section .text, align 2, keep-with-next
     25          static void iotx_mc_pub_wait_list_init(iotx_mc_client_t *pClient)
     26          {
     27          #ifdef PLATFORM_HAS_DYNMEM
     28              INIT_LIST_HEAD(&pClient->list_pub_wait_ack);
   \                     iotx_mc_pub_wait_list_init: (+1)
   \        0x0   0x30C0             ADDS     R0,R0,#+192
   \        0x2   0x....             B.N      INIT_AOS_DLIST_HEAD
     29          #else
     30              memset(pClient->list_pub_wait_ack, 0, sizeof(iotx_mc_pub_info_t) * IOTX_MC_PUBWAIT_LIST_MAX_LEN);
     31          #endif
     32          }
     33          

   \                                 In section .text, align 2, keep-with-next
     34          static void iotx_mc_pub_wait_list_deinit(iotx_mc_client_t *pClient)
     35          {
   \                     iotx_mc_pub_wait_list_deinit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
     36          #ifdef PLATFORM_HAS_DYNMEM
     37              iotx_mc_pub_info_t *node = NULL, *next_node = NULL;
     38              list_for_each_entry_safe(node, next_node, &pClient->list_pub_wait_ack, linked_list, iotx_mc_pub_info_t) {
   \        0x4   0xF8D4 0x00C4      LDR      R0,[R4, #+196]
   \        0x8   0xF1A0 0x0510      SUB      R5,R0,#+16
   \        0xC   0x6968             LDR      R0,[R5, #+20]
   \        0xE   0xF1A0 0x0610      SUB      R6,R0,#+16
   \       0x12   0xE008             B.N      ??iotx_mc_pub_wait_list_deinit_0
     39                  list_del(&node->linked_list);
   \                     ??iotx_mc_pub_wait_list_deinit_1: (+1)
   \       0x14   0x....'....        BL       dlist_del
     40                  mqtt_free(node);
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       HAL_Free
     41              }
   \       0x1E   0x4635             MOV      R5,R6
   \       0x20   0x6970             LDR      R0,[R6, #+20]
   \       0x22   0xF1A0 0x0610      SUB      R6,R0,#+16
   \                     ??iotx_mc_pub_wait_list_deinit_0: (+1)
   \       0x26   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x2A   0xF104 0x01C0      ADD      R1,R4,#+192
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD1F0             BNE.N    ??iotx_mc_pub_wait_list_deinit_1
     42          #else
     43              memset(pClient->list_pub_wait_ack, 0, sizeof(iotx_mc_pub_info_t) * IOTX_MC_PUBWAIT_LIST_MAX_LEN);
     44          #endif
     45          }
   \       0x32   0xBD70             POP      {R4-R6,PC}       ;; return
     46          #endif
     47          /* set MQTT connection parameter */

   \                                 In section .text, align 2, keep-with-next
     48          static int iotx_mc_set_connect_params(iotx_mc_client_t *pClient, MQTTPacket_connectData *pConnectParams)
     49          {
   \                     iotx_mc_set_connect_params: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
     50              if (NULL == pClient || NULL == pConnectParams) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??iotx_mc_set_connect_params_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD102             BNE.N    ??iotx_mc_set_connect_params_1
     51                  return NULL_VALUE_ERROR;
   \                     ??iotx_mc_set_connect_params_0: (+1)
   \        0xE   0xF06F 0x0001      MVN      R0,#+1
   \       0x12   0xBD70             POP      {R4-R6,PC}
     52              }
     53          
     54              memcpy(pClient->connect_data.struct_id, pConnectParams->struct_id, 4);
   \                     ??iotx_mc_set_connect_params_1: (+1)
   \       0x14   0x2204             MOVS     R2,#+4
   \       0x16   0xF104 0x0068      ADD      R0,R4,#+104
   \       0x1A   0x....'....        BL       __aeabi_memcpy4
     55              pClient->connect_data.struct_version = pConnectParams->struct_version;
   \       0x1E   0x6868             LDR      R0,[R5, #+4]
   \       0x20   0x66E0             STR      R0,[R4, #+108]
     56              pClient->connect_data.MQTTVersion = pConnectParams->MQTTVersion;
   \       0x22   0x7A28             LDRB     R0,[R5, #+8]
   \       0x24   0xF884 0x0070      STRB     R0,[R4, #+112]
     57              pClient->connect_data.clientID = pConnectParams->clientID;
   \       0x28   0xF104 0x0074      ADD      R0,R4,#+116
   \       0x2C   0xF105 0x010C      ADD      R1,R5,#+12
   \       0x30   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x34   0xE880 0x004C      STM      R0,{R2,R3,R6}
     58              pClient->connect_data.cleansession = pConnectParams->cleansession;
   \       0x38   0x7EA8             LDRB     R0,[R5, #+26]
   \       0x3A   0xF884 0x0082      STRB     R0,[R4, #+130]
     59              pClient->connect_data.willFlag = pConnectParams->willFlag;
   \       0x3E   0x7EE8             LDRB     R0,[R5, #+27]
   \       0x40   0xF884 0x0083      STRB     R0,[R4, #+131]
     60              pClient->connect_data.username = pConnectParams->username;
   \       0x44   0xF104 0x00A8      ADD      R0,R4,#+168
   \       0x48   0xF105 0x0140      ADD      R1,R5,#+64
   \       0x4C   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x50   0xE880 0x004C      STM      R0,{R2,R3,R6}
     61              pClient->connect_data.password = pConnectParams->password;
   \       0x54   0xF104 0x00B4      ADD      R0,R4,#+180
   \       0x58   0xF105 0x014C      ADD      R1,R5,#+76
   \       0x5C   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x60   0xE880 0x004C      STM      R0,{R2,R3,R6}
     62              memcpy(pClient->connect_data.will.struct_id, pConnectParams->will.struct_id, 4);
   \       0x64   0x2204             MOVS     R2,#+4
   \       0x66   0xF105 0x011C      ADD      R1,R5,#+28
   \       0x6A   0xF104 0x0084      ADD      R0,R4,#+132
   \       0x6E   0x....'....        BL       __aeabi_memcpy4
     63              pClient->connect_data.will.struct_version = pConnectParams->will.struct_version;
   \       0x72   0x6A28             LDR      R0,[R5, #+32]
   \       0x74   0xF8C4 0x0088      STR      R0,[R4, #+136]
     64              pClient->connect_data.will.topicName = pConnectParams->will.topicName;
   \       0x78   0xF104 0x008C      ADD      R0,R4,#+140
   \       0x7C   0xF105 0x0124      ADD      R1,R5,#+36
   \       0x80   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x84   0xE880 0x004C      STM      R0,{R2,R3,R6}
     65              pClient->connect_data.will.message = pConnectParams->will.message;
   \       0x88   0xF104 0x0098      ADD      R0,R4,#+152
   \       0x8C   0xF105 0x0130      ADD      R1,R5,#+48
   \       0x90   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x94   0xE880 0x004C      STM      R0,{R2,R3,R6}
     66              pClient->connect_data.will.qos = pConnectParams->will.qos;
   \       0x98   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x9C   0xF884 0x00A5      STRB     R0,[R4, #+165]
     67              pClient->connect_data.will.retained = pConnectParams->will.retained;
   \       0xA0   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0xA4   0xF884 0x00A4      STRB     R0,[R4, #+164]
     68          
     69              if (pConnectParams->keepAliveInterval < CONFIG_MQTT_KEEPALIVE_INTERVAL_MIN) {
   \       0xA8   0x8B28             LDRH     R0,[R5, #+24]
   \       0xAA   0x281E             CMP      R0,#+30
   \       0xAC   0xDA03             BGE.N    ??iotx_mc_set_connect_params_2
     70                  mqtt_warning("Input heartbeat interval(%d ms) < Allowed minimum(%d ms)",
     71                               (pConnectParams->keepAliveInterval * 1000),
     72                               (CONFIG_MQTT_KEEPALIVE_INTERVAL_MIN * 1000)
     73                              );
     74                  mqtt_warning("Reset heartbeat interval => %d Millisecond",
     75                               (CONFIG_MQTT_KEEPALIVE_INTERVAL * 1000)
     76                              );
     77                  pClient->connect_data.keepAliveInterval = CONFIG_MQTT_KEEPALIVE_INTERVAL;
   \       0xAE   0x203C             MOVS     R0,#+60
   \       0xB0   0xF8A4 0x0080      STRH     R0,[R4, #+128]
   \       0xB4   0xE007             B.N      ??iotx_mc_set_connect_params_3
     78              } else if (pConnectParams->keepAliveInterval > CONFIG_MQTT_KEEPALIVE_INTERVAL_MAX) {
   \                     ??iotx_mc_set_connect_params_2: (+1)
   \       0xB6   0x28B5             CMP      R0,#+181
   \       0xB8   0xDB03             BLT.N    ??iotx_mc_set_connect_params_4
     79                  mqtt_warning("Input heartbeat interval(%d ms) > Allowed maximum(%d ms)",
     80                               (pConnectParams->keepAliveInterval * 1000),
     81                               (CONFIG_MQTT_KEEPALIVE_INTERVAL_MAX * 1000)
     82                              );
     83                  mqtt_warning("Reset heartbeat interval => %d Millisecond",
     84                               (CONFIG_MQTT_KEEPALIVE_INTERVAL * 1000)
     85                              );
     86                  pClient->connect_data.keepAliveInterval = CONFIG_MQTT_KEEPALIVE_INTERVAL;
   \       0xBA   0x203C             MOVS     R0,#+60
   \       0xBC   0xF8A4 0x0080      STRH     R0,[R4, #+128]
   \       0xC0   0xE001             B.N      ??iotx_mc_set_connect_params_3
     87              } else {
     88                  pClient->connect_data.keepAliveInterval = pConnectParams->keepAliveInterval;
   \                     ??iotx_mc_set_connect_params_4: (+1)
   \       0xC2   0xF8A4 0x0080      STRH     R0,[R4, #+128]
     89              }
     90          
     91              return SUCCESS_RETURN;
   \                     ??iotx_mc_set_connect_params_3: (+1)
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0xBD70             POP      {R4-R6,PC}       ;; return
     92          }
     93          
     94          /* set state of MQTT client */

   \                                 In section .text, align 2, keep-with-next
     95          static void iotx_mc_set_client_state(iotx_mc_client_t *pClient, iotx_mc_state_t newState)
     96          {
   \                     iotx_mc_set_client_state: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
     97              HAL_MutexLock(pClient->lock_generic);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x....'....        BL       HAL_MutexLock
     98              pClient->client_state = newState;
   \        0xC   0xF884 0x505C      STRB     R5,[R4, #+92]
     99              HAL_MutexUnlock(pClient->lock_generic);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x16   0x....'....        B.W      HAL_MutexUnlock
    100          }
    101          

   \                                 In section .text, align 2, keep-with-next
    102          static iotx_mc_state_t iotx_mc_get_client_state(iotx_mc_client_t *pClient)
    103          {
   \                     iotx_mc_get_client_state: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    104              iotx_mc_state_t state;
    105              HAL_MutexLock(pClient->lock_generic);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x....'....        BL       HAL_MutexLock
    106              state = pClient->client_state;
   \        0xA   0xF894 0x505C      LDRB     R5,[R4, #+92]
    107              HAL_MutexUnlock(pClient->lock_generic);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       HAL_MutexUnlock
    108          
    109              return state;
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    110          }
    111          
    112          /* Initialize MQTT client */

   \                                 In section .text, align 2, keep-with-next
    113          static int iotx_mc_init(iotx_mc_client_t *pClient, iotx_mqtt_param_t *pInitParams)
    114          {
   \                     iotx_mc_init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB096             SUB      SP,SP,#+88
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
    115              int rc = FAIL_RETURN;
   \        0x8   0xF04F 0x34FF      MOV      R4,#-1
    116              iotx_mc_state_t mc_state = IOTX_MC_STATE_INVALID;
   \        0xC   0x2700             MOVS     R7,#+0
    117              MQTTPacket_connectData connectdata = MQTTPacket_connectData_initializer;
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x....'....        LDR.W    R1,??DataTable5
   \       0x14   0x2258             MOVS     R2,#+88
   \       0x16   0x....'....        BL       __aeabi_memcpy4
    118          
    119              if (pClient == NULL || pInitParams == NULL || pInitParams->write_buf_size == 0 || pInitParams->read_buf_size == 0) {
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD007             BEQ.N    ??iotx_mc_init_0
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD005             BEQ.N    ??iotx_mc_init_0
   \       0x22   0x6A70             LDR      R0,[R6, #+36]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD002             BEQ.N    ??iotx_mc_init_0
   \       0x28   0x6AB0             LDR      R0,[R6, #+40]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD102             BNE.N    ??iotx_mc_init_1
    120                  return NULL_VALUE_ERROR;
   \                     ??iotx_mc_init_0: (+1)
   \       0x2E   0xF06F 0x0001      MVN      R0,#+1
   \       0x32   0xE0B4             B.N      ??iotx_mc_init_2
    121              }
    122          
    123              pClient->lock_generic = HAL_MutexCreate();
   \                     ??iotx_mc_init_1: (+1)
   \       0x34   0x....'....        BL       HAL_MutexCreate
   \       0x38   0x6028             STR      R0,[R5, #+0]
    124              if (!pClient->lock_generic) {
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD101             BNE.N    ??iotx_mc_init_3
    125                  return FAIL_RETURN;
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0xE0AD             B.N      ??iotx_mc_init_2
    126              }
    127          
    128              pClient->lock_list_pub = HAL_MutexCreate();
   \                     ??iotx_mc_init_3: (+1)
   \       0x42   0x....'....        BL       HAL_MutexCreate
   \       0x46   0xF8C5 0x00D0      STR      R0,[R5, #+208]
    129              if (!pClient->lock_list_pub) {
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD06E             BEQ.N    ??iotx_mc_init_4
    130                  goto RETURN;
    131              }
    132          
    133              pClient->lock_yield = HAL_MutexCreate();
   \       0x4E   0x....'....        BL       HAL_MutexCreate
   \       0x52   0xF8C5 0x00DC      STR      R0,[R5, #+220]
    134              if (!pClient->lock_yield) {
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD068             BEQ.N    ??iotx_mc_init_4
    135                  goto RETURN;
    136              }
    137          
    138              pClient->lock_write_buf = HAL_MutexCreate();
   \       0x5A   0x....'....        BL       HAL_MutexCreate
   \       0x5E   0xF8C5 0x00D4      STR      R0,[R5, #+212]
    139              if (!pClient->lock_write_buf) {
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD062             BEQ.N    ??iotx_mc_init_4
    140                  goto RETURN;
    141              }
    142          
    143              pClient->lock_read_buf = HAL_MutexCreate();
   \       0x66   0x....'....        BL       HAL_MutexCreate
   \       0x6A   0xF8C5 0x00D8      STR      R0,[R5, #+216]
    144              if (!pClient->lock_read_buf) {
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD05C             BEQ.N    ??iotx_mc_init_4
    145                  goto RETURN;
    146              }
    147          
    148              connectdata.MQTTVersion = IOTX_MC_MQTT_VERSION;
   \       0x72   0x2004             MOVS     R0,#+4
   \       0x74   0xF88D 0x0008      STRB     R0,[SP, #+8]
    149              connectdata.keepAliveInterval = pInitParams->keepalive_interval_ms / 1000;
   \       0x78   0x6A30             LDR      R0,[R6, #+32]
   \       0x7A   0xF44F 0x717A      MOV      R1,#+1000
   \       0x7E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x82   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    150          
    151          
    152              connectdata.clientID.cstring = (char *)pInitParams->client_id;
   \       0x86   0x68B0             LDR      R0,[R6, #+8]
   \       0x88   0x9003             STR      R0,[SP, #+12]
    153              connectdata.username.cstring = (char *)pInitParams->username;
   \       0x8A   0x68F0             LDR      R0,[R6, #+12]
   \       0x8C   0x9010             STR      R0,[SP, #+64]
    154              connectdata.password.cstring = (char *)pInitParams->password;
   \       0x8E   0x6930             LDR      R0,[R6, #+16]
   \       0x90   0x9013             STR      R0,[SP, #+76]
    155              connectdata.cleansession = pInitParams->clean_session;
   \       0x92   0x7E30             LDRB     R0,[R6, #+24]
   \       0x94   0xF88D 0x001A      STRB     R0,[SP, #+26]
    156          
    157              if (pInitParams->request_timeout_ms < CONFIG_MQTT_REQ_TIMEOUT_MIN
    158                  || pInitParams->request_timeout_ms > CONFIG_MQTT_REQ_TIMEOUT_MAX) {
   \       0x98   0x69F0             LDR      R0,[R6, #+28]
   \       0x9A   0xF5A0 0x70FA      SUB      R0,R0,#+500
   \       0x9E   0xF241 0x1195      MOVW     R1,#+4501
   \       0xA2   0x4288             CMP      R0,R1
   \       0xA4   0xD303             BCC.N    ??iotx_mc_init_5
    159          
    160                  pClient->request_timeout_ms = CONFIG_MQTT_REQUEST_TIMEOUT;
   \       0xA6   0xF44F 0x60FA      MOV      R0,#+2000
   \       0xAA   0x60A8             STR      R0,[R5, #+8]
   \       0xAC   0xE001             B.N      ??iotx_mc_init_6
    161              } else {
    162                  pClient->request_timeout_ms = pInitParams->request_timeout_ms;
   \                     ??iotx_mc_init_5: (+1)
   \       0xAE   0x69F0             LDR      R0,[R6, #+28]
   \       0xB0   0x60A8             STR      R0,[R5, #+8]
    163              }
    164          
    165          #ifdef PLATFORM_HAS_DYNMEM
    166          #if !( WITH_MQTT_DYN_BUF)
    167              pClient->buf_send = mqtt_malloc(pInitParams->write_buf_size);
    168              if (pClient->buf_send == NULL) {
    169                  goto RETURN;
    170              }
    171              pClient->buf_size_send = pInitParams->write_buf_size;
    172          
    173              pClient->buf_read = mqtt_malloc(pInitParams->read_buf_size);
    174              if (pClient->buf_read == NULL) {
    175                  goto RETURN;
    176              }
    177              pClient->buf_size_read = pInitParams->read_buf_size;
    178          #else
    179              pClient->buf_size_send_max = pInitParams->write_buf_size;
   \                     ??iotx_mc_init_6: (+1)
   \       0xB2   0x6A70             LDR      R0,[R6, #+36]
   \       0xB4   0x6168             STR      R0,[R5, #+20]
    180              pClient->buf_size_read_max = pInitParams->read_buf_size;
   \       0xB6   0x6AB0             LDR      R0,[R6, #+40]
   \       0xB8   0x61A8             STR      R0,[R5, #+24]
    181          #endif
    182          #else
    183              pClient->buf_size_send = IOTX_MC_TX_MAX_LEN;
    184              pClient->buf_size_read = IOTX_MC_RX_MAX_LEN;
    185          #endif
    186          
    187              pClient->keepalive_probes = 0;
   \       0xBA   0x4638             MOV      R0,R7
   \       0xBC   0xF885 0x0020      STRB     R0,[R5, #+32]
    188          
    189              pClient->handle_event.h_fp = pInitParams->handle_event.h_fp;
   \       0xC0   0x6AF0             LDR      R0,[R6, #+44]
   \       0xC2   0xF8C5 0x00E0      STR      R0,[R5, #+224]
    190              pClient->handle_event.pcontext = pInitParams->handle_event.pcontext;
   \       0xC6   0x6B30             LDR      R0,[R6, #+48]
   \       0xC8   0xF8C5 0x00E4      STR      R0,[R5, #+228]
    191          
    192              /* Initialize reconnect parameter */
    193              pClient->reconnect_param.reconnect_time_interval_ms = IOTX_MC_RECONNECT_INTERVAL_MIN_MS;
   \       0xCC   0xF44F 0x707A      MOV      R0,#+1000
   \       0xD0   0x6668             STR      R0,[R5, #+100]
    194          #if !WITH_MQTT_ONLY_QOS0
    195              iotx_mc_pub_wait_list_init(pClient);
   \       0xD2   0x4628             MOV      R0,R5
   \       0xD4   0x....'....        BL       iotx_mc_pub_wait_list_init
    196          #endif
    197          
    198          #ifdef PLATFORM_HAS_DYNMEM
    199              INIT_LIST_HEAD(&pClient->list_sub_handle);
   \       0xD8   0xF105 0x002C      ADD      R0,R5,#+44
   \       0xDC   0x....'....        BL       INIT_AOS_DLIST_HEAD
    200              INIT_LIST_HEAD(&pClient->list_sub_sync_ack);
   \       0xE0   0xF105 0x00C8      ADD      R0,R5,#+200
   \       0xE4   0x....'....        BL       INIT_AOS_DLIST_HEAD
    201          #endif
    202              /* Initialize MQTT connect parameter */
    203              rc = iotx_mc_set_connect_params(pClient, &connectdata);
   \       0xE8   0x4669             MOV      R1,SP
   \       0xEA   0x4628             MOV      R0,R5
   \       0xEC   0x....'....        BL       iotx_mc_set_connect_params
   \       0xF0   0x0004             MOVS     R4,R0
    204              if (SUCCESS_RETURN != rc) {
   \       0xF2   0xD11B             BNE.N    ??iotx_mc_init_4
    205                  mc_state = IOTX_MC_STATE_INVALID;
    206                  goto RETURN;
    207              }
    208          
    209              iotx_time_init(&pClient->next_ping_time);
   \       0xF4   0xF105 0x0058      ADD      R0,R5,#+88
   \       0xF8   0x....'....        BL       iotx_time_init
    210              iotx_time_init(&pClient->reconnect_param.reconnect_next_time);
   \       0xFC   0xF105 0x0060      ADD      R0,R5,#+96
   \      0x100   0x....'....        BL       iotx_time_init
    211          
    212              memset(&pClient->ipstack, 0, sizeof(utils_network_t));
   \      0x104   0x463A             MOV      R2,R7
   \      0x106   0x2124             MOVS     R1,#+36
   \      0x108   0xF105 0x0034      ADD      R0,R5,#+52
   \      0x10C   0x....'....        BL       __aeabi_memset4
    213          
    214          #ifdef SUPPORT_TLS
    215              {
    216                  extern const char *iotx_ca_crt;
    217                  pInitParams->pub_key = iotx_ca_crt;
   \      0x110   0x....'....        LDR.W    R0,??DataTable5_1
   \      0x114   0x6800             LDR      R0,[R0, #+0]
   \      0x116   0x6170             STR      R0,[R6, #+20]
    218              }
    219          #endif
    220          
    221              rc = iotx_net_init(&pClient->ipstack, pInitParams->host, pInitParams->port, pInitParams->pub_key);
   \      0x118   0x4603             MOV      R3,R0
   \      0x11A   0x8832             LDRH     R2,[R6, #+0]
   \      0x11C   0x6871             LDR      R1,[R6, #+4]
   \      0x11E   0xF105 0x0034      ADD      R0,R5,#+52
   \      0x122   0x....'....        BL       iotx_net_init
   \      0x126   0x0004             MOVS     R4,R0
    222          
    223              if (SUCCESS_RETURN != rc) {
   \      0x128   0xD100             BNE.N    ??iotx_mc_init_4
    224                  mc_state = IOTX_MC_STATE_INVALID;
    225                  goto RETURN;
    226              }
    227          
    228              mc_state = IOTX_MC_STATE_INITIALIZED;
   \      0x12A   0x2701             MOVS     R7,#+1
    229              rc = SUCCESS_RETURN;
    230              mqtt_info("MQTT init success!");
    231          
    232          RETURN :
    233              iotx_mc_set_client_state(pClient, mc_state);
   \                     ??iotx_mc_init_4: (+1)
   \      0x12C   0x4639             MOV      R1,R7
   \      0x12E   0x4628             MOV      R0,R5
   \      0x130   0x....'....        BL       iotx_mc_set_client_state
    234              if (rc != SUCCESS_RETURN) {
   \      0x134   0x2C00             CMP      R4,#+0
   \      0x136   0xD031             BEQ.N    ??iotx_mc_init_7
    235          #ifdef PLATFORM_HAS_DYNMEM
    236                  if (pClient->buf_send != NULL) {
   \      0x138   0x6A68             LDR      R0,[R5, #+36]
   \      0x13A   0x2800             CMP      R0,#+0
   \      0x13C   0xD003             BEQ.N    ??iotx_mc_init_8
    237                      mqtt_free(pClient->buf_send);
   \      0x13E   0x....'....        BL       HAL_Free
   \      0x142   0x2000             MOVS     R0,#+0
   \      0x144   0x6268             STR      R0,[R5, #+36]
    238                      pClient->buf_send = NULL;
    239                  }
    240                  if (pClient->buf_read != NULL) {
   \                     ??iotx_mc_init_8: (+1)
   \      0x146   0x6AA8             LDR      R0,[R5, #+40]
   \      0x148   0x2800             CMP      R0,#+0
   \      0x14A   0xD003             BEQ.N    ??iotx_mc_init_9
    241                      mqtt_free(pClient->buf_read);
   \      0x14C   0x....'....        BL       HAL_Free
   \      0x150   0x2000             MOVS     R0,#+0
   \      0x152   0x62A8             STR      R0,[R5, #+40]
    242                      pClient->buf_read = NULL;
    243                  }
    244          #endif
    245                  if (pClient->lock_list_pub) {
   \                     ??iotx_mc_init_9: (+1)
   \      0x154   0xF8D5 0x00D0      LDR      R0,[R5, #+208]
   \      0x158   0x2800             CMP      R0,#+0
   \      0x15A   0xD004             BEQ.N    ??iotx_mc_init_10
    246                      HAL_MutexDestroy(pClient->lock_list_pub);
   \      0x15C   0x....'....        BL       HAL_MutexDestroy
    247                      pClient->lock_list_pub = NULL;
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0xF8C5 0x00D0      STR      R0,[R5, #+208]
    248                  }
    249                  if (pClient->lock_write_buf) {
   \                     ??iotx_mc_init_10: (+1)
   \      0x166   0xF8D5 0x00D4      LDR      R0,[R5, #+212]
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD004             BEQ.N    ??iotx_mc_init_11
    250                      HAL_MutexDestroy(pClient->lock_write_buf);
   \      0x16E   0x....'....        BL       HAL_MutexDestroy
    251                      pClient->lock_write_buf = NULL;
   \      0x172   0x2000             MOVS     R0,#+0
   \      0x174   0xF8C5 0x00D4      STR      R0,[R5, #+212]
    252                  }
    253                  if (pClient->lock_read_buf) {
   \                     ??iotx_mc_init_11: (+1)
   \      0x178   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \      0x17C   0x2800             CMP      R0,#+0
   \      0x17E   0xD004             BEQ.N    ??iotx_mc_init_12
    254                      HAL_MutexDestroy(pClient->lock_read_buf);
   \      0x180   0x....'....        BL       HAL_MutexDestroy
    255                      pClient->lock_read_buf = NULL;
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0xF8C5 0x00D8      STR      R0,[R5, #+216]
    256                  }
    257                  if (pClient->lock_yield) {
   \                     ??iotx_mc_init_12: (+1)
   \      0x18A   0xF8D5 0x00DC      LDR      R0,[R5, #+220]
   \      0x18E   0x2800             CMP      R0,#+0
   \      0x190   0xD004             BEQ.N    ??iotx_mc_init_7
    258                      HAL_MutexDestroy(pClient->lock_yield);
   \      0x192   0x....'....        BL       HAL_MutexDestroy
    259                      pClient->lock_yield = NULL;
   \      0x196   0x2000             MOVS     R0,#+0
   \      0x198   0xF8C5 0x00DC      STR      R0,[R5, #+220]
    260                  }
    261              }
    262          
    263              return rc;
   \                     ??iotx_mc_init_7: (+1)
   \      0x19C   0x4620             MOV      R0,R4
   \                     ??iotx_mc_init_2: (+1)
   \      0x19E   0xB017             ADD      SP,SP,#+92
   \      0x1A0   0xBDF0             POP      {R4-R7,PC}       ;; return
    264          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x4D 0x51          DC8 77, 81, 84, 67
   \              0x54 0x43    
   \        0x4   0x0000'0000        DC32 0
   \        0x8   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    
   \        0xC   0x0000'0000        DC32 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   \       0x18   0x001E             DC16 30
   \       0x1A   0x01 0x00          DC8 1, 0, 77, 81, 84, 87
   \              0x4D 0x51    
   \              0x54 0x57    
   \       0x20   0x0000'0000        DC32 0, 0H, 0, 0H, 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \       0x3C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x40   0x0000'0000        DC32 0H, 0, 0H, 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
    265          
    266          #ifdef PLATFORM_HAS_DYNMEM
    267              #if  WITH_MQTT_DYN_BUF
    268                  extern int MQTTPacket_len(int rem_len);
    269                  extern int MQTTSerialize_connectLength(MQTTPacket_connectData *options);
    270              #endif
    271          #endif
    272          

   \                                 In section .text, align 2, keep-with-next
    273          static int _get_connect_length(MQTTPacket_connectData *options)
    274          {
   \                     _get_connect_length: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    275          #ifdef PLATFORM_HAS_DYNMEM
    276          #if  WITH_MQTT_DYN_BUF
    277              return MQTTPacket_len(MQTTSerialize_connectLength(options));
   \        0x2   0x....'....        BL       MQTTSerialize_connectLength
   \        0x6   0xE8BD 0x4002      POP      {R1,LR}
   \        0xA   0x....'....        B.W      MQTTPacket_len
    278          #else
    279              return 0;
    280          #endif
    281          #else
    282              return 0;
    283          #endif
    284          }
    285          

   \                                 In section .text, align 2, keep-with-next
    286          static int _reset_send_buffer(iotx_mc_client_t *c)
    287          {
   \                     _reset_send_buffer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    288          #ifdef PLATFORM_HAS_DYNMEM
    289          #if  WITH_MQTT_DYN_BUF
    290              if (c == NULL || c->buf_send == NULL) {
   \        0x4   0xD002             BEQ.N    ??_reset_send_buffer_0
   \        0x6   0x6A60             LDR      R0,[R4, #+36]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD102             BNE.N    ??_reset_send_buffer_1
    291                  return FAIL_RETURN;
   \                     ??_reset_send_buffer_0: (+1)
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
   \       0x10   0xBD10             POP      {R4,PC}
    292              }
    293          
    294              mqtt_free(c->buf_send);
   \                     ??_reset_send_buffer_1: (+1)
   \       0x12   0x....'....        BL       HAL_Free
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x6260             STR      R0,[R4, #+36]
    295              c->buf_send = NULL;
    296              c->buf_size_send = 0;
   \       0x1A   0x6120             STR      R0,[R4, #+16]
    297              return 0;
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
    298          #else
    299              return 0;
    300          #endif
    301          #else
    302              return 0;
    303          #endif
    304          }
    305          

   \                                 In section .text, align 2, keep-with-next
    306          static int _reset_recv_buffer(iotx_mc_client_t *c)
    307          {
   \                     _reset_recv_buffer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    308          #ifdef PLATFORM_HAS_DYNMEM
    309          #if  WITH_MQTT_DYN_BUF
    310              if (c == NULL || c->buf_read == NULL) {
   \        0x4   0xD002             BEQ.N    ??_reset_recv_buffer_0
   \        0x6   0x6AA0             LDR      R0,[R4, #+40]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD102             BNE.N    ??_reset_recv_buffer_1
    311                  return FAIL_RETURN;
   \                     ??_reset_recv_buffer_0: (+1)
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
   \       0x10   0xBD10             POP      {R4,PC}
    312              }
    313          
    314              mqtt_free(c->buf_read);
   \                     ??_reset_recv_buffer_1: (+1)
   \       0x12   0x....'....        BL       HAL_Free
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x62A0             STR      R0,[R4, #+40]
    315              c->buf_read = NULL;
    316              c->buf_size_read = 0;
   \       0x1A   0x61E0             STR      R0,[R4, #+28]
    317              return 0;
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
    318          #else
    319              return 0;
    320          #endif
    321          #else
    322              return 0;
    323          #endif
    324          }
    325          

   \                                 In section .text, align 2, keep-with-next
    326          static int _alloc_send_buffer(iotx_mc_client_t *c, int len)
    327          {
   \                     _alloc_send_buffer: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    328          #ifdef PLATFORM_HAS_DYNMEM
    329          #if  WITH_MQTT_DYN_BUF
    330              int tmp_len;
    331          
    332              if (c == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??_alloc_send_buffer_0
    333                  return FAIL_RETURN;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
    334              }
    335          
    336              tmp_len = MQTT_DYNBUF_SEND_MARGIN + len;
   \                     ??_alloc_send_buffer_0: (+1)
   \       0x10   0x3540             ADDS     R5,R5,#+64
    337              if (tmp_len > c->buf_size_send_max) {
   \       0x12   0x6960             LDR      R0,[R4, #+20]
   \       0x14   0x42A8             CMP      R0,R5
   \       0x16   0xD200             BCS.N    ??_alloc_send_buffer_1
    338                  tmp_len = c->buf_size_send_max;
   \       0x18   0x4605             MOV      R5,R0
    339              }
    340              if (c->buf_send != NULL) {
   \                     ??_alloc_send_buffer_1: (+1)
   \       0x1A   0x6A60             LDR      R0,[R4, #+36]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD003             BEQ.N    ??_alloc_send_buffer_2
    341                  mqtt_warning("c->buf_send is not null,free it first!");
    342                  mqtt_free(c->buf_send);
   \       0x20   0x....'....        BL       HAL_Free
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6260             STR      R0,[R4, #+36]
    343              }
    344              c->buf_send = mqtt_malloc(tmp_len);
   \                     ??_alloc_send_buffer_2: (+1)
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       HAL_Malloc
   \       0x2E   0x6260             STR      R0,[R4, #+36]
    345              if (c->buf_send == NULL) {
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD102             BNE.N    ??_alloc_send_buffer_3
    346                  return ERROR_MALLOC;
   \       0x34   0x....'....        LDR.W    R0,??DataTable5_2  ;; 0xfffffc0a
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
    347              }
    348              memset(c->buf_send, 0, tmp_len);
   \                     ??_alloc_send_buffer_3: (+1)
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x4629             MOV      R1,R5
   \       0x3E   0x....'....        BL       __aeabi_memset
    349              c->buf_size_send = tmp_len;
   \       0x42   0x6125             STR      R5,[R4, #+16]
    350              return SUCCESS_RETURN;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    351          #else
    352              return 0;
    353          #endif
    354          #else
    355              return 0;
    356          #endif
    357          }
    358          

   \                                 In section .text, align 2, keep-with-next
    359          static int _alloc_recv_buffer(iotx_mc_client_t *c, int len)
    360          {
   \                     _alloc_recv_buffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    361          #ifdef PLATFORM_HAS_DYNMEM
    362          #if  WITH_MQTT_DYN_BUF
    363              int tmp_len;
    364          
    365              if (c == NULL) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD102             BNE.N    ??_alloc_recv_buffer_0
    366                  return FAIL_RETURN;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD70             POP      {R4-R6,PC}
    367              }
    368          
    369              tmp_len = MQTT_DYNBUF_RECV_MARGIN + len;
   \                     ??_alloc_recv_buffer_0: (+1)
   \       0x10   0x3608             ADDS     R6,R6,#+8
    370              if (tmp_len > c->buf_size_read_max) {
   \       0x12   0x69A8             LDR      R0,[R5, #+24]
   \       0x14   0x42B0             CMP      R0,R6
   \       0x16   0xD200             BCS.N    ??_alloc_recv_buffer_1
    371                  tmp_len = c->buf_size_read_max;
   \       0x18   0x4606             MOV      R6,R0
    372              }
    373              if (c->buf_read != NULL) { /* do realloc */
   \                     ??_alloc_recv_buffer_1: (+1)
   \       0x1A   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0xD016             BEQ.N    ??_alloc_recv_buffer_2
    374                  char *temp = mqtt_malloc(tmp_len);
   \       0x22   0x....'....        BL       HAL_Malloc
   \       0x26   0x0004             MOVS     R4,R0
    375                  if (temp == NULL) {
   \       0x28   0xD017             BEQ.N    ??_alloc_recv_buffer_3
    376                      mqtt_err("realloc err");
    377                      return ERROR_MALLOC;
    378                  }
    379                  memset(temp, 0, tmp_len);
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x4631             MOV      R1,R6
   \       0x2E   0x....'....        BL       __aeabi_memset
    380                  memcpy(temp, c->buf_read, c->buf_size_read < tmp_len ? c->buf_size_read : tmp_len);
   \       0x32   0x69EA             LDR      R2,[R5, #+28]
   \       0x34   0x42B2             CMP      R2,R6
   \       0x36   0xD900             BLS.N    ??_alloc_recv_buffer_4
   \       0x38   0x4632             MOV      R2,R6
   \                     ??_alloc_recv_buffer_4: (+1)
   \       0x3A   0x6AA9             LDR      R1,[R5, #+40]
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x....'....        BL       __aeabi_memcpy
    381                  mqtt_free(c->buf_read);
   \       0x42   0x6AA8             LDR      R0,[R5, #+40]
   \       0x44   0x....'....        BL       HAL_Free
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x62A8             STR      R0,[R5, #+40]
    382                  c->buf_read = temp;
   \       0x4C   0x62AC             STR      R4,[R5, #+40]
   \       0x4E   0xE00B             B.N      ??_alloc_recv_buffer_5
    383              } else {
    384                  c->buf_read = mqtt_malloc(tmp_len);
   \                     ??_alloc_recv_buffer_2: (+1)
   \       0x50   0x....'....        BL       HAL_Malloc
   \       0x54   0x62A8             STR      R0,[R5, #+40]
    385                  if (c->buf_read == NULL) {
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD102             BNE.N    ??_alloc_recv_buffer_6
    386                      mqtt_err("calloc err");
    387                      return ERROR_MALLOC;
   \                     ??_alloc_recv_buffer_3: (+1)
   \       0x5A   0x....'....        LDR.W    R0,??DataTable5_2  ;; 0xfffffc0a
   \       0x5E   0xBD70             POP      {R4-R6,PC}
    388                  }
    389                  memset(c->buf_read, 0, tmp_len);
   \                     ??_alloc_recv_buffer_6: (+1)
   \       0x60   0x2200             MOVS     R2,#+0
   \       0x62   0x4631             MOV      R1,R6
   \       0x64   0x....'....        BL       __aeabi_memset
    390              }
    391              c->buf_size_read = tmp_len;
   \                     ??_alloc_recv_buffer_5: (+1)
   \       0x68   0x61EE             STR      R6,[R5, #+28]
    392              return SUCCESS_RETURN;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xBD70             POP      {R4-R6,PC}       ;; return
    393          #else
    394              return 0;
    395          #endif
    396          #else
    397              return 0;
    398          #endif
    399          }
    400          

   \                                 In section .text, align 2, keep-with-next
    401          static int iotx_mc_send_packet(iotx_mc_client_t *c, char *buf, int length, iotx_time_t *time)
    402          {
   \                     iotx_mc_send_packet: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x461D             MOV      R5,R3
    403              int rc = FAIL_RETURN;
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
    404              int sent = 0;
   \       0x10   0xF04F 0x0800      MOV      R8,#+0
    405              unsigned int left_t = 0;
    406          
    407              if (!c || !buf || !time) {
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD021             BEQ.N    ??iotx_mc_send_packet_0
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD01F             BEQ.N    ??iotx_mc_send_packet_0
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD01D             BEQ.N    ??iotx_mc_send_packet_0
    408                  return rc;
    409              }
    410          
    411              while (sent < length && !utils_time_is_expired(time)) {
   \                     ??iotx_mc_send_packet_1: (+1)
   \       0x20   0x45B8             CMP      R8,R7
   \       0x22   0xDA1D             BGE.N    ??iotx_mc_send_packet_2
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x....'....        BL       utils_time_is_expired
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD118             BNE.N    ??iotx_mc_send_packet_2
    412                  left_t = iotx_time_left(time);
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x....'....        BL       iotx_time_left
    413                  left_t = (left_t == 0) ? 1 : left_t;
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD100             BNE.N    ??iotx_mc_send_packet_3
   \       0x38   0x2001             MOVS     R0,#+1
    414                  rc = c->ipstack.write(&c->ipstack, &buf[sent], length - sent, left_t);
   \                     ??iotx_mc_send_packet_3: (+1)
   \       0x3A   0x4603             MOV      R3,R0
   \       0x3C   0xEBA7 0x0208      SUB      R2,R7,R8
   \       0x40   0xEB04 0x0108      ADD      R1,R4,R8
   \       0x44   0xF106 0x0034      ADD      R0,R6,#+52
   \       0x48   0xF8D6 0xC04C      LDR      R12,[R6, #+76]
   \       0x4C   0x47E0             BLX      R12
    415                  if (rc < 0) { /* there was an error writing the data */
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD406             BMI.N    ??iotx_mc_send_packet_2
    416                      break;
    417                  }
    418                  sent += rc;
   \       0x52   0x4440             ADD      R0,R0,R8
   \       0x54   0x4680             MOV      R8,R0
   \       0x56   0xE7E3             B.N      ??iotx_mc_send_packet_1
    419              }
    420          
    421              if (sent == length) {
    422                  rc = SUCCESS_RETURN;
    423              } else {
    424                  rc = MQTT_NETWORK_ERROR;
   \                     ??iotx_mc_send_packet_4: (+1)
   \       0x58   0xF06F 0x000D      MVN      R0,#+13
    425              }
    426              return rc;
   \                     ??iotx_mc_send_packet_0: (+1)
   \       0x5C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??iotx_mc_send_packet_2: (+1)
   \       0x60   0x45B8             CMP      R8,R7
   \       0x62   0xD1F9             BNE.N    ??iotx_mc_send_packet_4
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE7F9             B.N      ??iotx_mc_send_packet_0
    427          }
    428          

   \                                 In section .text, align 2, keep-with-next
    429          int MQTTConnect(iotx_mc_client_t *pClient)
    430          {
   \                     MQTTConnect: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    431              MQTTPacket_connectData *pConnectParams;
    432              iotx_time_t connectTimer;
    433              int len = 0;
    434          
    435              if (!pClient) {
   \        0x4   0xD102             BNE.N    ??MQTTConnect_0
    436                  return FAIL_RETURN;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
    437              }
    438          
    439              pConnectParams = &pClient->connect_data;
   \                     ??MQTTConnect_0: (+1)
   \        0xC   0xF104 0x0568      ADD      R5,R4,#+104
    440              HAL_MutexLock(pClient->lock_write_buf);
   \       0x10   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x14   0x....'....        BL       HAL_MutexLock
    441          
    442              len = _get_connect_length(pConnectParams);
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       _get_connect_length
   \       0x1E   0x4601             MOV      R1,R0
    443          
    444              if (_alloc_send_buffer(pClient, len) != SUCCESS_RETURN) {
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x....'....        BL       _alloc_send_buffer
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD006             BEQ.N    ??MQTTConnect_1
    445                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x2A   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x2E   0x....'....        BL       HAL_MutexUnlock
    446                  return FAIL_RETURN;
   \       0x32   0xF04F 0x30FF      MOV      R0,#-1
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
    447              }
    448          
    449              if ((len = MQTTSerialize_connect((unsigned char *)pClient->buf_send, pClient->buf_size_send, pConnectParams)) <= 0) {
   \                     ??MQTTConnect_1: (+1)
   \       0x38   0x462A             MOV      R2,R5
   \       0x3A   0x6921             LDR      R1,[R4, #+16]
   \       0x3C   0x6A60             LDR      R0,[R4, #+36]
   \       0x3E   0x....'....        BL       MQTTSerialize_connect
   \       0x42   0x4605             MOV      R5,R0
   \       0x44   0x2D01             CMP      R5,#+1
   \       0x46   0xDA09             BGE.N    ??MQTTConnect_2
    450                  mqtt_err("Serialize connect packet failed, len = %d", len);
    451                  _reset_send_buffer(pClient);
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x....'....        BL       _reset_send_buffer
    452                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x4E   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x52   0x....'....        BL       HAL_MutexUnlock
    453                  return MQTT_CONNECT_PACKET_ERROR;
   \       0x56   0xF06F 0x001D      MVN      R0,#+29
   \       0x5A   0xBD32             POP      {R1,R4,R5,PC}
    454              }
    455          
    456              /* send the connect packet */
    457              iotx_time_init(&connectTimer);
   \                     ??MQTTConnect_2: (+1)
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       iotx_time_init
    458              utils_time_countdown_ms(&connectTimer, pClient->request_timeout_ms);
   \       0x62   0x68A1             LDR      R1,[R4, #+8]
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x....'....        BL       utils_time_countdown_ms
    459              if ((iotx_mc_send_packet(pClient, pClient->buf_send, len, &connectTimer)) != SUCCESS_RETURN) {
   \       0x6A   0x466B             MOV      R3,SP
   \       0x6C   0x462A             MOV      R2,R5
   \       0x6E   0x6A61             LDR      R1,[R4, #+36]
   \       0x70   0x4620             MOV      R0,R4
   \       0x72   0x....'....        BL       iotx_mc_send_packet
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0xD008             BEQ.N    ??MQTTConnect_3
    460                  mqtt_err("send connect packet failed");
    461                  _reset_send_buffer(pClient);
   \       0x7C   0x....'....        BL       _reset_send_buffer
    462                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x80   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x84   0x....'....        BL       HAL_MutexUnlock
    463                  return MQTT_NETWORK_ERROR;
   \       0x88   0xF06F 0x000D      MVN      R0,#+13
   \       0x8C   0xBD32             POP      {R1,R4,R5,PC}
    464              }
    465              _reset_send_buffer(pClient);
   \                     ??MQTTConnect_3: (+1)
   \       0x8E   0x....'....        BL       _reset_send_buffer
    466              HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x92   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x96   0x....'....        BL       HAL_MutexUnlock
    467              return SUCCESS_RETURN;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    468          }
    469          

   \                                 In section .text, align 2, keep-with-next
    470          static int iotx_mc_decode_packet(iotx_mc_client_t *c, int *value, int timeout)
    471          {
   \                     iotx_mc_decode_packet: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4614             MOV      R4,R2
    472              char i;
    473              int multiplier = 1;
   \        0xA   0x2701             MOVS     R7,#+1
    474              int len = 0;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    475              const int MAX_NO_OF_REMAINING_LENGTH_BYTES = 4;
    476          
    477              if (!c || !value) {
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD02B             BEQ.N    ??iotx_mc_decode_packet_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD029             BEQ.N    ??iotx_mc_decode_packet_0
    478                  return FAIL_RETURN;
    479              }
    480          
    481              *value = 0;
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0x6028             STR      R0,[R5, #+0]
    482              do {
    483                  int rc = MQTTPACKET_READ_ERROR;
    484          
    485                  if (++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
   \                     ??iotx_mc_decode_packet_1: (+1)
   \       0x1C   0xF108 0x0801      ADD      R8,R8,#+1
   \       0x20   0xF1B8 0x0F05      CMP      R8,#+5
   \       0x24   0xDA22             BGE.N    ??iotx_mc_decode_packet_0
    486                      return MQTTPACKET_READ_ERROR; /* bad data */
    487                  }
    488          
    489                  rc = c->ipstack.read(&c->ipstack, &i, 1, timeout == 0 ? 1 : timeout);
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD101             BNE.N    ??iotx_mc_decode_packet_2
   \       0x2A   0x2301             MOVS     R3,#+1
   \       0x2C   0xE000             B.N      ??iotx_mc_decode_packet_3
   \                     ??iotx_mc_decode_packet_2: (+1)
   \       0x2E   0x4623             MOV      R3,R4
   \                     ??iotx_mc_decode_packet_3: (+1)
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0x4669             MOV      R1,SP
   \       0x34   0xF106 0x0034      ADD      R0,R6,#+52
   \       0x38   0xF8D6 0xC048      LDR      R12,[R6, #+72]
   \       0x3C   0x47E0             BLX      R12
    490                  if (rc == 0) {
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD014             BEQ.N    ??iotx_mc_decode_packet_0
    491                      return FAIL_RETURN;
    492                  } else if (rc != 1) {
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD10F             BNE.N    ??iotx_mc_decode_packet_4
    493                      return MQTT_NETWORK_ERROR;
    494                  }
    495          
    496                  *value += (i & 127) * multiplier;
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x4C   0xF001 0x017F      AND      R1,R1,#0x7F
   \       0x50   0xFB07 0x0001      MLA      R0,R7,R1,R0
   \       0x54   0x6028             STR      R0,[R5, #+0]
    497                  multiplier *= 128;
   \       0x56   0x01FF             LSLS     R7,R7,#+7
    498              } while ((i & 128) != 0);
   \       0x58   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x5C   0x0600             LSLS     R0,R0,#+24
   \       0x5E   0xD4DD             BMI.N    ??iotx_mc_decode_packet_1
    499          
    500              return len;
   \       0x60   0x4640             MOV      R0,R8
   \                     ??iotx_mc_decode_packet_5: (+1)
   \       0x62   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   \                     ??iotx_mc_decode_packet_4: (+1)
   \       0x66   0xF06F 0x000D      MVN      R0,#+13
   \       0x6A   0xE7FA             B.N      ??iotx_mc_decode_packet_5
   \                     ??iotx_mc_decode_packet_0: (+1)
   \       0x6C   0xF04F 0x30FF      MOV      R0,#-1
   \       0x70   0xE7F7             B.N      ??iotx_mc_decode_packet_5
    501          }
    502          

   \                                 In section .text, align 2, keep-with-next
    503          static int _handle_event(iotx_mqtt_event_handle_pt handle, iotx_mc_client_t *c, iotx_mqtt_event_msg_pt msg)
    504          {
   \                     _handle_event: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0003             MOVS     R3,R0
    505              if (handle == NULL || handle->h_fp == NULL) {
   \        0x4   0xD002             BEQ.N    ??_handle_event_0
   \        0x6   0x6818             LDR      R0,[R3, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD102             BNE.N    ??_handle_event_1
    506                  return FAIL_RETURN;
   \                     ??_handle_event_0: (+1)
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
   \       0x10   0xBD10             POP      {R4,PC}
    507              }
    508          
    509              _in_yield_cb = 1;
   \                     ??_handle_event_1: (+1)
   \       0x12   0x....             LDR.N    R4,??DataTable5_3
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x6020             STR      R0,[R4, #+0]
    510              handle->h_fp(handle->pcontext, c, msg);
   \       0x18   0x6858             LDR      R0,[R3, #+4]
   \       0x1A   0x681B             LDR      R3,[R3, #+0]
   \       0x1C   0x4798             BLX      R3
    511              _in_yield_cb = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6020             STR      R0,[R4, #+0]
    512              return 0;
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
    513          }
    514          

   \                                 In section .text, align 2, keep-with-next
    515          static int iotx_mc_read_packet(iotx_mc_client_t *c, iotx_time_t *timer, unsigned int *packet_type)
    516          {
   \                     iotx_mc_read_packet: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    517              MQTTHeader header = {0};
    518              int len = 0;
    519              int rem_len = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9000             STR      R0,[SP, #+0]
    520              int rc = 0;
    521              unsigned int left_t = 0;
    522          
    523              if (!c || !timer || !packet_type) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD003             BEQ.N    ??iotx_mc_read_packet_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD001             BEQ.N    ??iotx_mc_read_packet_0
   \       0x16   0x2E00             CMP      R6,#+0
   \       0x18   0xD102             BNE.N    ??iotx_mc_read_packet_1
    524                  return FAIL_RETURN;
   \                     ??iotx_mc_read_packet_0: (+1)
   \       0x1A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1E   0xE0DE             B.N      ??iotx_mc_read_packet_2
    525              }
    526              HAL_MutexLock(c->lock_read_buf);
   \                     ??iotx_mc_read_packet_1: (+1)
   \       0x20   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x24   0x....'....        BL       HAL_MutexLock
    527              rc = _alloc_recv_buffer(c, 0);
    528              if (rc < 0) {
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       _alloc_recv_buffer
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xF100 0x80B9      BMI.W    ??iotx_mc_read_packet_3
    529                  HAL_MutexUnlock(c->lock_read_buf);
    530                  return FAIL_RETURN;
    531              }
    532              /* 1. read the header byte.  This has the packet type in it */
    533              left_t = iotx_time_left(timer);
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x....'....        BL       iotx_time_left
   \       0x3C   0x0003             MOVS     R3,R0
    534              left_t = (left_t == 0) ? 1 : left_t;
   \       0x3E   0xD100             BNE.N    ??iotx_mc_read_packet_4
   \       0x40   0x2301             MOVS     R3,#+1
    535              rc = c->ipstack.read(&c->ipstack, c->buf_read, 1, left_t);
   \                     ??iotx_mc_read_packet_4: (+1)
   \       0x42   0x2201             MOVS     R2,#+1
   \       0x44   0x6AA1             LDR      R1,[R4, #+40]
   \       0x46   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x4A   0x6CA7             LDR      R7,[R4, #+72]
   \       0x4C   0x47B8             BLX      R7
    536              if (0 == rc) { /* timeout */
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD107             BNE.N    ??iotx_mc_read_packet_5
    537                  *packet_type = 0;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x6030             STR      R0,[R6, #+0]
    538                  HAL_MutexUnlock(c->lock_read_buf);
   \       0x56   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x5A   0x....'....        BL       HAL_MutexUnlock
    539                  return SUCCESS_RETURN;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xE0BD             B.N      ??iotx_mc_read_packet_2
    540              } else if (1 != rc) {
   \                     ??iotx_mc_read_packet_5: (+1)
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0xF040 0x8097      BNE.W    ??iotx_mc_read_packet_6
    541                  mqtt_err("mqtt read error, rc=%d", rc);
    542                  HAL_MutexUnlock(c->lock_read_buf);
    543                  return MQTT_NETWORK_ERROR;
    544              }
    545          
    546              len = 1;
    547          
    548              /* 2. read the remaining length.  This is variable in itself */
    549              left_t = iotx_time_left(timer);
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0x....'....        BL       iotx_time_left
    550              left_t = (left_t == 0) ? 1 : left_t;
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD100             BNE.N    ??iotx_mc_read_packet_7
   \       0x72   0x2001             MOVS     R0,#+1
    551              if ((rc = iotx_mc_decode_packet(c, &rem_len, left_t)) < 0) {
   \                     ??iotx_mc_read_packet_7: (+1)
   \       0x74   0x4602             MOV      R2,R0
   \       0x76   0x4669             MOV      R1,SP
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0x....'....        BL       iotx_mc_decode_packet
   \       0x7E   0x0007             MOVS     R7,R0
   \       0x80   0xD505             BPL.N    ??iotx_mc_read_packet_8
    552                  mqtt_err("decodePacket error,rc = %d", rc);
    553                  HAL_MutexUnlock(c->lock_read_buf);
   \       0x82   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x86   0x....'....        BL       HAL_MutexUnlock
    554                  return rc;
   \       0x8A   0x4638             MOV      R0,R7
   \       0x8C   0xE0A7             B.N      ??iotx_mc_read_packet_2
    555              }
    556          
    557              len += MQTTPacket_encode((unsigned char *)c->buf_read + 1,
    558                                       rem_len); /* put the original remaining length back into the buffer */
   \                     ??iotx_mc_read_packet_8: (+1)
   \       0x8E   0x9900             LDR      R1,[SP, #+0]
   \       0x90   0x6AA0             LDR      R0,[R4, #+40]
   \       0x92   0x1C40             ADDS     R0,R0,#+1
   \       0x94   0x....'....        BL       MQTTPacket_encode
   \       0x98   0x4680             MOV      R8,R0
   \       0x9A   0xF108 0x0801      ADD      R8,R8,#+1
    559          
    560              rc = _alloc_recv_buffer(c, rem_len + len);
    561              if (rc < 0) {
   \       0x9E   0x9900             LDR      R1,[SP, #+0]
   \       0xA0   0x4441             ADD      R1,R8,R1
   \       0xA2   0x4620             MOV      R0,R4
   \       0xA4   0x....'....        BL       _alloc_recv_buffer
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD47D             BMI.N    ??iotx_mc_read_packet_3
    562                  HAL_MutexUnlock(c->lock_read_buf);
    563                  return FAIL_RETURN;
    564              }
    565          
    566              /* Check if the received data length exceeds mqtt read buffer length */
    567              if ((rem_len > 0) && ((rem_len + len) > c->buf_size_read)) {
   \       0xAC   0x9800             LDR      R0,[SP, #+0]
   \       0xAE   0x2801             CMP      R0,#+1
   \       0xB0   0xDB5D             BLT.N    ??iotx_mc_read_packet_9
   \       0xB2   0x69E0             LDR      R0,[R4, #+28]
   \       0xB4   0x9900             LDR      R1,[SP, #+0]
   \       0xB6   0x4441             ADD      R1,R8,R1
   \       0xB8   0x4288             CMP      R0,R1
   \       0xBA   0xD258             BCS.N    ??iotx_mc_read_packet_9
    568                  int needReadLen;
    569                  int remainDataLen;
    570          #ifdef PLATFORM_HAS_DYNMEM
    571                  char *remainDataBuf;
    572          #else
    573                  char remainDataBuf[IOTX_MC_RX_MAX_LEN] = {0};
    574          #endif
    575                  mqtt_err("mqtt read buffer is too short, mqttReadBufLen : %u, remainDataLen : %d", c->buf_size_read, rem_len);
    576                  needReadLen = c->buf_size_read - len;
   \       0xBC   0x4607             MOV      R7,R0
   \       0xBE   0xEBA7 0x0708      SUB      R7,R7,R8
    577                  left_t = iotx_time_left(timer);
   \       0xC2   0x4628             MOV      R0,R5
   \       0xC4   0x....'....        BL       iotx_time_left
    578                  left_t = (left_t == 0) ? 1 : left_t;
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD100             BNE.N    ??iotx_mc_read_packet_10
   \       0xCC   0x2001             MOVS     R0,#+1
    579                  rc = c->ipstack.read(&c->ipstack, c->buf_read + len, needReadLen, left_t);
   \                     ??iotx_mc_read_packet_10: (+1)
   \       0xCE   0x4603             MOV      R3,R0
   \       0xD0   0x463A             MOV      R2,R7
   \       0xD2   0x6AA0             LDR      R0,[R4, #+40]
   \       0xD4   0xEB00 0x0108      ADD      R1,R0,R8
   \       0xD8   0xF104 0x0034      ADD      R0,R4,#+52
   \       0xDC   0x6CA6             LDR      R6,[R4, #+72]
   \       0xDE   0x47B0             BLX      R6
    580                  if (rc < 0) {
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD458             BMI.N    ??iotx_mc_read_packet_6
    581                      mqtt_err("mqtt read error");
    582                      HAL_MutexUnlock(c->lock_read_buf);
    583                      return MQTT_NETWORK_ERROR;
    584                  } else if (rc != needReadLen) {
   \       0xE4   0x42B8             CMP      R0,R7
   \       0xE6   0xD15F             BNE.N    ??iotx_mc_read_packet_3
    585                      mqtt_warning("mqtt read timeout");
    586                      HAL_MutexUnlock(c->lock_read_buf);
    587                      return FAIL_RETURN;
    588                  }
    589          
    590                  /* drop data whitch over the length of mqtt buffer */
    591                  remainDataLen = rem_len - needReadLen;
   \       0xE8   0x9800             LDR      R0,[SP, #+0]
   \       0xEA   0x1BC7             SUBS     R7,R0,R7
    592          #ifdef PLATFORM_HAS_DYNMEM
    593                  remainDataBuf = mqtt_malloc(remainDataLen + 1);
   \       0xEC   0x1C78             ADDS     R0,R7,#+1
   \       0xEE   0x....'....        BL       HAL_Malloc
   \       0xF2   0x0006             MOVS     R6,R0
    594                  if (!remainDataBuf) {
   \       0xF4   0xD058             BEQ.N    ??iotx_mc_read_packet_3
    595                      mqtt_err("allocate remain buffer failed");
    596                      HAL_MutexUnlock(c->lock_read_buf);
    597                      return FAIL_RETURN;
    598                  }
    599          #else
    600                  if (remainDataLen >= IOTX_MC_RX_MAX_LEN) {
    601                      mqtt_err("IOTX_MC_RX_MAX_LEN too short, remainDataLen: %d, IOTX_MC_RX_MAX_LEN: %d", remainDataLen, IOTX_MC_RX_MAX_LEN);
    602                      HAL_MutexUnlock(c->lock_read_buf);
    603                      return FAIL_RETURN;
    604                  }
    605          #endif
    606          
    607                  left_t = iotx_time_left(timer);
   \       0xF6   0x4628             MOV      R0,R5
   \       0xF8   0x....'....        BL       iotx_time_left
    608                  left_t = (left_t == 0) ? 1 : left_t;
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD100             BNE.N    ??iotx_mc_read_packet_11
   \      0x100   0x2001             MOVS     R0,#+1
    609                  rc = c->ipstack.read(&c->ipstack, remainDataBuf, remainDataLen, left_t);
   \                     ??iotx_mc_read_packet_11: (+1)
   \      0x102   0x4603             MOV      R3,R0
   \      0x104   0x463A             MOV      R2,R7
   \      0x106   0x4631             MOV      R1,R6
   \      0x108   0xF104 0x0034      ADD      R0,R4,#+52
   \      0x10C   0x6CA5             LDR      R5,[R4, #+72]
   \      0x10E   0x47A8             BLX      R5
    610                  if (rc < 0) {
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD509             BPL.N    ??iotx_mc_read_packet_12
    611                      mqtt_err("mqtt read error");
    612          #ifdef PLATFORM_HAS_DYNMEM
    613                      mqtt_free(remainDataBuf);
   \      0x114   0x4630             MOV      R0,R6
   \      0x116   0x....'....        BL       HAL_Free
    614                      remainDataBuf = NULL;
    615          #endif
    616                      HAL_MutexUnlock(c->lock_read_buf);
   \      0x11A   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x11E   0x....'....        BL       HAL_MutexUnlock
    617                      return MQTT_NETWORK_ERROR;
   \      0x122   0xF06F 0x000D      MVN      R0,#+13
   \      0x126   0xE05A             B.N      ??iotx_mc_read_packet_2
    618                  } else if (rc != remainDataLen) {
   \                     ??iotx_mc_read_packet_12: (+1)
   \      0x128   0x42B8             CMP      R0,R7
   \      0x12A   0x4630             MOV      R0,R6
   \      0x12C   0xD008             BEQ.N    ??iotx_mc_read_packet_13
    619                      mqtt_warning("mqtt read timeout");
    620          #ifdef PLATFORM_HAS_DYNMEM
    621                      mqtt_free(remainDataBuf);
   \      0x12E   0x....'....        BL       HAL_Free
    622                      remainDataBuf = NULL;
    623          #endif
    624                      HAL_MutexUnlock(c->lock_read_buf);
   \      0x132   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x136   0x....'....        BL       HAL_MutexUnlock
    625                      return FAIL_RETURN;
   \      0x13A   0xF04F 0x30FF      MOV      R0,#-1
   \      0x13E   0xE04E             B.N      ??iotx_mc_read_packet_2
    626                  }
    627          
    628          #ifdef PLATFORM_HAS_DYNMEM
    629                  mqtt_free(remainDataBuf);
   \                     ??iotx_mc_read_packet_13: (+1)
   \      0x140   0x....'....        BL       HAL_Free
    630                  remainDataBuf = NULL;
    631          #endif
    632                  HAL_MutexUnlock(c->lock_read_buf);
   \      0x144   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x148   0x....'....        BL       HAL_MutexUnlock
    633                  if (NULL != c->handle_event.h_fp) {
   \      0x14C   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD00A             BEQ.N    ??iotx_mc_read_packet_14
    634                      iotx_mqtt_event_msg_t msg;
    635          
    636                      msg.event_type = IOTX_MQTT_EVENT_BUFFER_OVERFLOW;
   \      0x154   0x200D             MOVS     R0,#+13
   \      0x156   0xF88D 0x0004      STRB     R0,[SP, #+4]
    637                      msg.msg = "mqtt read buffer is too short";
   \      0x15A   0x....             LDR.N    R0,??DataTable5_4
   \      0x15C   0x9002             STR      R0,[SP, #+8]
    638                      _handle_event(&c->handle_event, c, &msg);
   \      0x15E   0xAA01             ADD      R2,SP,#+4
   \      0x160   0x4621             MOV      R1,R4
   \      0x162   0xF104 0x00E0      ADD      R0,R4,#+224
   \      0x166   0x....'....        BL       _handle_event
    639                  }
    640          
    641                  return SUCCESS_RETURN;
   \                     ??iotx_mc_read_packet_14: (+1)
   \      0x16A   0x2000             MOVS     R0,#+0
   \      0x16C   0xE037             B.N      ??iotx_mc_read_packet_2
    642          
    643              }
    644          
    645              /* 3. read the rest of the buffer using a callback to supply the rest of the data */
    646              left_t = iotx_time_left(timer);
   \                     ??iotx_mc_read_packet_9: (+1)
   \      0x16E   0x4628             MOV      R0,R5
   \      0x170   0x....'....        BL       iotx_time_left
    647              left_t = (left_t == 0) ? 1 : left_t;
   \      0x174   0x2800             CMP      R0,#+0
   \      0x176   0xD100             BNE.N    ??iotx_mc_read_packet_15
   \      0x178   0x2001             MOVS     R0,#+1
    648          
    649              rc = c->ipstack.read(&c->ipstack, c->buf_read + len, rem_len, left_t);
   \                     ??iotx_mc_read_packet_15: (+1)
   \      0x17A   0x4603             MOV      R3,R0
   \      0x17C   0x9A00             LDR      R2,[SP, #+0]
   \      0x17E   0x6AA0             LDR      R0,[R4, #+40]
   \      0x180   0xEB00 0x0108      ADD      R1,R0,R8
   \      0x184   0xF104 0x0034      ADD      R0,R4,#+52
   \      0x188   0x6CA5             LDR      R5,[R4, #+72]
   \      0x18A   0x47A8             BLX      R5
    650              if (rem_len > 0) {
   \      0x18C   0x9900             LDR      R1,[SP, #+0]
   \      0x18E   0x2901             CMP      R1,#+1
   \      0x190   0xDB11             BLT.N    ??iotx_mc_read_packet_16
    651                  if (rc < 0) {
   \      0x192   0x2800             CMP      R0,#+0
   \      0x194   0xD506             BPL.N    ??iotx_mc_read_packet_17
    652                      mqtt_err("mqtt read error");
    653                      HAL_MutexUnlock(c->lock_read_buf);
   \                     ??iotx_mc_read_packet_6: (+1)
   \      0x196   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x19A   0x....'....        BL       HAL_MutexUnlock
    654                      return MQTT_NETWORK_ERROR;
   \      0x19E   0xF06F 0x000D      MVN      R0,#+13
   \      0x1A2   0xE01C             B.N      ??iotx_mc_read_packet_2
    655                  } else if (rc != rem_len) {
   \                     ??iotx_mc_read_packet_17: (+1)
   \      0x1A4   0x4288             CMP      R0,R1
   \      0x1A6   0xD006             BEQ.N    ??iotx_mc_read_packet_16
    656                      mqtt_warning("mqtt read timeout");
    657                      HAL_MutexUnlock(c->lock_read_buf);
   \                     ??iotx_mc_read_packet_3: (+1)
   \      0x1A8   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x1AC   0x....'....        BL       HAL_MutexUnlock
    658                      return FAIL_RETURN;
   \      0x1B0   0xF04F 0x30FF      MOV      R0,#-1
   \      0x1B4   0xE013             B.N      ??iotx_mc_read_packet_2
    659                  }
    660              }
    661          
    662              header.byte = c->buf_read[0];
    663              *packet_type = MQTT_HEADER_GET_TYPE(header.byte);
   \                     ??iotx_mc_read_packet_16: (+1)
   \      0x1B6   0x6AA0             LDR      R0,[R4, #+40]
   \      0x1B8   0x7800             LDRB     R0,[R0, #+0]
   \      0x1BA   0x0900             LSRS     R0,R0,#+4
   \      0x1BC   0x6030             STR      R0,[R6, #+0]
    664              if ((len + rem_len) < c->buf_size_read) {
   \      0x1BE   0x9800             LDR      R0,[SP, #+0]
   \      0x1C0   0x4440             ADD      R0,R0,R8
   \      0x1C2   0x69E1             LDR      R1,[R4, #+28]
   \      0x1C4   0x4288             CMP      R0,R1
   \      0x1C6   0xD205             BCS.N    ??iotx_mc_read_packet_18
    665                  c->buf_read[len + rem_len] = '\0';
   \      0x1C8   0x2100             MOVS     R1,#+0
   \      0x1CA   0x6AA2             LDR      R2,[R4, #+40]
   \      0x1CC   0x9800             LDR      R0,[SP, #+0]
   \      0x1CE   0x4480             ADD      R8,R0,R8
   \      0x1D0   0xF802 0x1008      STRB     R1,[R2, R8]
    666              }
    667              HAL_MutexUnlock(c->lock_read_buf);
   \                     ??iotx_mc_read_packet_18: (+1)
   \      0x1D4   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x1D8   0x....'....        BL       HAL_MutexUnlock
    668              return SUCCESS_RETURN;
   \      0x1DC   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_read_packet_2: (+1)
   \      0x1DE   0xB004             ADD      SP,SP,#+16
   \      0x1E0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    669          }
    670          

   \                                 In section .text, align 4, keep-with-next
    671          static int iotx_mc_handle_recv_CONNACK(iotx_mc_client_t *c)
    672          {
   \                     iotx_mc_handle_recv_CONNACK: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    673              int rc = SUCCESS_RETURN;
   \        0x2   0x2400             MOVS     R4,#+0
    674              unsigned char connack_rc = 255;
   \        0x4   0x21FF             MOVS     R1,#+255
   \        0x6   0xF88D 0x1000      STRB     R1,[SP, #+0]
    675              char sessionPresent = 0;
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0xF88D 0x1001      STRB     R1,[SP, #+1]
    676          
    677              if (!c) {
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??iotx_mc_handle_recv_CONNACK_1
    678                  return FAIL_RETURN;
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD16             POP      {R1,R2,R4,PC}
    679              }
    680          
    681              if (MQTTDeserialize_connack((unsigned char *)&sessionPresent, &connack_rc, (unsigned char *)c->buf_read,
    682                                          c->buf_size_read) != 1) {
   \                     ??iotx_mc_handle_recv_CONNACK_1: (+1)
   \       0x1A   0x69C3             LDR      R3,[R0, #+28]
   \       0x1C   0x6A82             LDR      R2,[R0, #+40]
   \       0x1E   0x4669             MOV      R1,SP
   \       0x20   0xF10D 0x0001      ADD      R0,SP,#+1
   \       0x24   0x....'....        BL       MQTTDeserialize_connack
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD002             BEQ.N    ??iotx_mc_handle_recv_CONNACK_2
    683                  mqtt_err("connect ack is error");
    684                  return MQTT_CONNECT_ACK_PACKET_ERROR;
   \       0x2C   0xF06F 0x001C      MVN      R0,#+28
   \       0x30   0xBD16             POP      {R1,R2,R4,PC}
    685              }
    686          
    687              switch (connack_rc) {
   \                     ??iotx_mc_handle_recv_CONNACK_2: (+1)
   \       0x32   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x36   0x2805             CMP      R0,#+5
   \       0x38   0xD813             BHI.N    ??iotx_mc_handle_recv_CONNACK_3
   \       0x3A   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??iotx_mc_handle_recv_CONNACK_0:
   \       0x3E   0x14 0x03          DC8      0x14,0x3,0x6,0x9
   \              0x06 0x09    
   \       0x42   0x0C 0x0F          DC8      0xC,0xF
    688                  case IOTX_MC_CONNECTION_ACCEPTED:
    689                      rc = SUCCESS_RETURN;
    690                      break;
    691                  case IOTX_MC_CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION:
    692                      rc = MQTT_CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_4: (+1)
   \       0x44   0xF06F 0x0425      MVN      R4,#+37
    693                      break;
   \       0x48   0xE00D             B.N      ??iotx_mc_handle_recv_CONNACK_5
    694                  case IOTX_MC_CONNECTION_REFUSED_IDENTIFIER_REJECTED:
    695                      rc = MQTT_CONNACK_IDENTIFIER_REJECTED_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_6: (+1)
   \       0x4A   0xF06F 0x0424      MVN      R4,#+36
    696                      break;
   \       0x4E   0xE00A             B.N      ??iotx_mc_handle_recv_CONNACK_5
    697                  case IOTX_MC_CONNECTION_REFUSED_SERVER_UNAVAILABLE:
    698                      rc = MQTT_CONNACK_SERVER_UNAVAILABLE_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_7: (+1)
   \       0x50   0xF06F 0x0423      MVN      R4,#+35
    699                      break;
   \       0x54   0xE007             B.N      ??iotx_mc_handle_recv_CONNACK_5
    700                  case IOTX_MC_CONNECTION_REFUSED_BAD_USERDATA:
    701                      rc = MQTT_CONNACK_BAD_USERDATA_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_8: (+1)
   \       0x56   0xF06F 0x0422      MVN      R4,#+34
    702                      break;
   \       0x5A   0xE004             B.N      ??iotx_mc_handle_recv_CONNACK_5
    703                  case IOTX_MC_CONNECTION_REFUSED_NOT_AUTHORIZED:
    704                      rc = MQTT_CONNACK_NOT_AUTHORIZED_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_9: (+1)
   \       0x5C   0xF06F 0x0421      MVN      R4,#+33
    705                      break;
   \       0x60   0xE001             B.N      ??iotx_mc_handle_recv_CONNACK_5
    706                  default:
    707                      rc = MQTT_CONNACK_UNKNOWN_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_3: (+1)
   \       0x62   0xF06F 0x0426      MVN      R4,#+38
    708                      break;
    709              }
    710          
    711              return rc;
   \                     ??iotx_mc_handle_recv_CONNACK_5: (+1)
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    712          }
    713          

   \                                 In section .text, align 2, keep-with-next
    714          static int iotx_mc_wait_CONNACK(iotx_mc_client_t *c)
    715          {
   \                     iotx_mc_wait_CONNACK: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
    716          #define WAIT_CONNACK_MAX (10)
    717              unsigned char wait_connack = 0;
   \        0x4   0x2600             MOVS     R6,#+0
    718              unsigned int packetType = 0;
   \        0x6   0x4630             MOV      R0,R6
   \        0x8   0x9001             STR      R0,[SP, #+4]
    719              int rc = 0;
    720              iotx_time_t timer;
    721          
    722              if (!c) {
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD102             BNE.N    ??iotx_mc_wait_CONNACK_0
    723                  return FAIL_RETURN;
   \        0xE   0xF04F 0x30FF      MOV      R0,#-1
   \       0x12   0xBD76             POP      {R1,R2,R4-R6,PC}
    724              }
    725          
    726              iotx_time_init(&timer);
   \                     ??iotx_mc_wait_CONNACK_0: (+1)
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x....'....        BL       iotx_time_init
    727              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x1A   0x68A9             LDR      R1,[R5, #+8]
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x....'....        BL       utils_time_countdown_ms
    728          
    729              do {
    730                  /* read the socket, see what work is due */
    731          
    732                  rc = iotx_mc_read_packet(c, &timer, &packetType);
   \                     ??iotx_mc_wait_CONNACK_1: (+1)
   \       0x22   0xAA01             ADD      R2,SP,#+4
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x....'....        BL       iotx_mc_read_packet
   \       0x2C   0x0004             MOVS     R4,R0
    733                  if (rc != SUCCESS_RETURN) {
   \       0x2E   0xD118             BNE.N    ??iotx_mc_wait_CONNACK_2
    734                      mqtt_err("readPacket error,result = %d", rc);
    735                      HAL_MutexLock(c->lock_read_buf);
    736                      _reset_recv_buffer(c);
    737                      HAL_MutexUnlock(c->lock_read_buf);
    738                      return rc;
    739                  }
    740          
    741                  if (++wait_connack > WAIT_CONNACK_MAX) {
   \       0x30   0x1C76             ADDS     R6,R6,#+1
   \       0x32   0x4630             MOV      R0,R6
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x280B             CMP      R0,#+11
   \       0x38   0xDA20             BGE.N    ??iotx_mc_wait_CONNACK_3
    742                      mqtt_err("wait connack timeout");
    743                      HAL_MutexLock(c->lock_read_buf);
    744                      _reset_recv_buffer(c);
    745                      HAL_MutexUnlock(c->lock_read_buf);
    746                      return MQTT_NETWORK_ERROR;
    747                  }
    748              } while (packetType != CONNACK);
   \       0x3A   0x9801             LDR      R0,[SP, #+4]
   \       0x3C   0x2802             CMP      R0,#+2
   \       0x3E   0xD1F0             BNE.N    ??iotx_mc_wait_CONNACK_1
    749              HAL_MutexLock(c->lock_read_buf);
   \       0x40   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x44   0x....'....        BL       HAL_MutexLock
    750          
    751              rc = iotx_mc_handle_recv_CONNACK(c);
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x....'....        BL       iotx_mc_handle_recv_CONNACK
   \       0x4E   0x4604             MOV      R4,R0
    752              _reset_recv_buffer(c);
   \       0x50   0x4628             MOV      R0,R5
   \       0x52   0x....'....        BL       _reset_recv_buffer
    753              HAL_MutexUnlock(c->lock_read_buf);
   \       0x56   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x5A   0x....'....        BL       HAL_MutexUnlock
    754          
    755              if (SUCCESS_RETURN != rc) {
    756                  mqtt_err("recvConnackProc error,result = %d", rc);
    757              }
    758          
    759              return rc;
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??iotx_mc_wait_CONNACK_2: (+1)
   \       0x62   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x66   0x....'....        BL       HAL_MutexLock
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x....'....        BL       _reset_recv_buffer
   \       0x70   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x74   0x....'....        BL       HAL_MutexUnlock
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??iotx_mc_wait_CONNACK_3: (+1)
   \       0x7C   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x80   0x....'....        BL       HAL_MutexLock
   \       0x84   0x4628             MOV      R0,R5
   \       0x86   0x....'....        BL       _reset_recv_buffer
   \       0x8A   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x8E   0x....'....        BL       HAL_MutexUnlock
   \       0x92   0xF06F 0x000D      MVN      R0,#+13
   \       0x96   0xBD76             POP      {R1,R2,R4-R6,PC}
    760          }
    761          

   \                                 In section .text, align 2, keep-with-next
    762          static int _mqtt_connect(void *client)
    763          {
   \                     _mqtt_connect: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
    764          #define RETRY_TIME_LIMIT    (8+1)
    765          #define RETRY_INTV_PERIOD   (2000)
    766              int rc = FAIL_RETURN;
    767              int try_count = 1;
   \        0x4   0x2601             MOVS     R6,#+1
    768              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
    769          
    770              if (NULL == pClient) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD121             BNE.N    ??_mqtt_connect_0
    771                  return NULL_VALUE_ERROR;
   \        0xA   0xF06F 0x0001      MVN      R0,#+1
   \        0xE   0xBD70             POP      {R4-R6,PC}
    772              }
    773          
    774              mqtt_info("connect params: MQTTVersion=%d, clientID=%s, keepAliveInterval=%d, username=%s",
    775                        pClient->connect_data.MQTTVersion,
    776                        pClient->connect_data.clientID.cstring,
    777                        pClient->connect_data.keepAliveInterval,
    778                        pClient->connect_data.username.cstring);
    779          
    780              /* Establish TCP or TLS connection */
    781              do {
    782                  rc = MQTTConnect(pClient);
    783          
    784                  if (rc != SUCCESS_RETURN) {
    785                      pClient->ipstack.disconnect(&pClient->ipstack);
   \                     ??_mqtt_connect_1: (+1)
   \       0x10   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x14   0x6D29             LDR      R1,[R5, #+80]
   \       0x16   0x4788             BLX      R1
    786                      mqtt_err("send connect packet failed, rc = %d", rc);
    787                      return rc;
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0xBD70             POP      {R4-R6,PC}
    788                  }
    789          
    790                  rc = iotx_mc_wait_CONNACK(pClient);
    791          
    792                  if (rc <= MQTT_CONNACK_NOT_AUTHORIZED_ERROR && rc >= MQTT_CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR) {
    793                      mqtt_err("received reject ACK from MQTT server! rc = %d", rc);
    794                      pClient->ipstack.disconnect(&pClient->ipstack);
   \                     ??_mqtt_connect_2: (+1)
   \       0x1C   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x20   0x6D29             LDR      R1,[R5, #+80]
   \       0x22   0x4788             BLX      R1
    795                      return MQTT_CONNECT_ERROR;
   \       0x24   0xF06F 0x0020      MVN      R0,#+32
   \       0x28   0xBD70             POP      {R4-R6,PC}
    796                  }
    797          
    798                  if (SUCCESS_RETURN != rc) {
    799                      mqtt_err("wait connect ACK timeout! rc = %d", rc);
    800                      mqtt_warning("tried [%d/%d] times CONN, waiting for %d ms...", try_count, RETRY_TIME_LIMIT - 1, RETRY_INTV_PERIOD);
    801          
    802                      HAL_SleepMs(RETRY_INTV_PERIOD);
    803          
    804                      pClient->ipstack.disconnect(&pClient->ipstack);
    805                      pClient->ipstack.connect(&pClient->ipstack);
    806                      continue;
    807                  } else {
    808                      break;
    809                  }
    810          
    811              } while (++try_count < RETRY_TIME_LIMIT);
    812          
    813              if (try_count == RETRY_TIME_LIMIT) {
    814                  return MQTT_CONNECT_ERROR;
    815              }
    816              pClient->keepalive_probes = 0;
   \                     ??_mqtt_connect_3: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xF885 0x0020      STRB     R0,[R5, #+32]
    817              iotx_mc_set_client_state(pClient, IOTX_MC_STATE_CONNECTED);
   \       0x30   0x2102             MOVS     R1,#+2
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0x....'....        BL       iotx_mc_set_client_state
    818          
    819              utils_time_countdown_ms(&pClient->next_ping_time, pClient->connect_data.keepAliveInterval * 1000);
   \       0x38   0xF8B5 0x1080      LDRH     R1,[R5, #+128]
   \       0x3C   0xF44F 0x707A      MOV      R0,#+1000
   \       0x40   0x4341             MULS     R1,R0,R1
   \       0x42   0xF105 0x0058      ADD      R0,R5,#+88
   \       0x46   0x....'....        BL       utils_time_countdown_ms
    820          
    821              mqtt_info("mqtt connect success!");
    822              return SUCCESS_RETURN;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??_mqtt_connect_0: (+1)
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0x....'....        BL       MQTTConnect
   \       0x54   0x0004             MOVS     R4,R0
   \       0x56   0xD1DB             BNE.N    ??_mqtt_connect_1
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       iotx_mc_wait_CONNACK
   \       0x5E   0xF100 0x0126      ADD      R1,R0,#+38
   \       0x62   0x2905             CMP      R1,#+5
   \       0x64   0xD3DA             BCC.N    ??_mqtt_connect_2
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD00E             BEQ.N    ??_mqtt_connect_4
   \       0x6A   0xF44F 0x60FA      MOV      R0,#+2000
   \       0x6E   0x....'....        BL       HAL_SleepMs
   \       0x72   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x76   0x6D29             LDR      R1,[R5, #+80]
   \       0x78   0x4788             BLX      R1
   \       0x7A   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x7E   0x6D69             LDR      R1,[R5, #+84]
   \       0x80   0x4788             BLX      R1
   \       0x82   0x1C76             ADDS     R6,R6,#+1
   \       0x84   0x2E09             CMP      R6,#+9
   \       0x86   0xDBE2             BLT.N    ??_mqtt_connect_0
   \                     ??_mqtt_connect_4: (+1)
   \       0x88   0x2E09             CMP      R6,#+9
   \       0x8A   0xD1CE             BNE.N    ??_mqtt_connect_3
   \       0x8C   0xF06F 0x0020      MVN      R0,#+32
   \       0x90   0xBD70             POP      {R4-R6,PC}
    823          }
    824          
    825          #if !WITH_MQTT_ONLY_QOS0

   \                                 In section .text, align 2, keep-with-next
    826          static int iotx_mc_push_pubInfo_to(iotx_mc_client_t *c, int len, unsigned short msgId, iotx_mc_pub_info_t **node)
    827          {
   \                     iotx_mc_push_pubInfo_to: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x461D             MOV      R5,R3
    828          #ifdef PLATFORM_HAS_DYNMEM
    829              int list_number;
    830              iotx_mc_pub_info_t *repubInfo;
    831          #else
    832              int idx;
    833          #endif
    834          
    835              if (!c || !node) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD001             BEQ.N    ??iotx_mc_push_pubInfo_to_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD102             BNE.N    ??iotx_mc_push_pubInfo_to_1
    836                  mqtt_err("the param of c is error!");
    837                  return FAIL_RETURN;
   \                     ??iotx_mc_push_pubInfo_to_0: (+1)
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xE034             B.N      ??iotx_mc_push_pubInfo_to_2
    838              }
    839          
    840              if ((len < 0) || (len > c->buf_size_send)) {
   \                     ??iotx_mc_push_pubInfo_to_1: (+1)
   \       0x1A   0x2F00             CMP      R7,#+0
   \       0x1C   0xD402             BMI.N    ??iotx_mc_push_pubInfo_to_3
   \       0x1E   0x6930             LDR      R0,[R6, #+16]
   \       0x20   0x42B8             CMP      R0,R7
   \       0x22   0xD202             BCS.N    ??iotx_mc_push_pubInfo_to_4
    841                  mqtt_err("the param of len is error!");
    842          #ifndef PLATFORM_HAS_DYNMEM
    843                  if (len >= c->buf_size_send) {
    844                      mqtt_err("IOTX_MC_TX_MAX_LEN is too short, len: %d, IOTX_MC_TX_MAX_LEN: %d", len, IOTX_MC_TX_MAX_LEN);
    845                  }
    846          #endif
    847                  return FAIL_RETURN;
   \                     ??iotx_mc_push_pubInfo_to_3: (+1)
   \       0x24   0xF04F 0x30FF      MOV      R0,#-1
   \       0x28   0xE02C             B.N      ??iotx_mc_push_pubInfo_to_2
    848              }
    849          
    850          #ifdef PLATFORM_HAS_DYNMEM
    851              list_number = list_entry_number(&c->list_pub_wait_ack);
    852          
    853              if (list_number >= IOTX_MC_REPUB_NUM_MAX) {
   \                     ??iotx_mc_push_pubInfo_to_4: (+1)
   \       0x2A   0xF106 0x00C0      ADD      R0,R6,#+192
   \       0x2E   0x....'....        BL       __dlist_entry_number
   \       0x32   0x2814             CMP      R0,#+20
   \       0x34   0xDB02             BLT.N    ??iotx_mc_push_pubInfo_to_5
    854                  mqtt_err("more than %u elements in republish list. List overflow!", list_number);
    855                  return FAIL_RETURN;
   \       0x36   0xF04F 0x30FF      MOV      R0,#-1
   \       0x3A   0xE023             B.N      ??iotx_mc_push_pubInfo_to_2
    856              }
    857          
    858              repubInfo = (iotx_mc_pub_info_t *)mqtt_malloc(sizeof(iotx_mc_pub_info_t) + len);
   \                     ??iotx_mc_push_pubInfo_to_5: (+1)
   \       0x3C   0xF107 0x0018      ADD      R0,R7,#+24
   \       0x40   0x....'....        BL       HAL_Malloc
   \       0x44   0x0004             MOVS     R4,R0
    859              if (NULL == repubInfo) {
   \       0x46   0xD102             BNE.N    ??iotx_mc_push_pubInfo_to_6
    860                  mqtt_err("run iotx_memory_malloc is error!");
    861                  return FAIL_RETURN;
   \       0x48   0xF04F 0x30FF      MOV      R0,#-1
   \       0x4C   0xE01A             B.N      ??iotx_mc_push_pubInfo_to_2
    862              }
    863          
    864              repubInfo->node_state = IOTX_MC_NODE_STATE_NORMANL;
   \                     ??iotx_mc_push_pubInfo_to_6: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x7120             STRB     R0,[R4, #+4]
    865              repubInfo->msg_id = msgId;
   \       0x52   0xF8A4 0x8006      STRH     R8,[R4, #+6]
    866              repubInfo->len = len;
   \       0x56   0x60A7             STR      R7,[R4, #+8]
    867              iotx_time_start(&repubInfo->pub_start_time);
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x....'....        BL       iotx_time_start
    868              repubInfo->buf = (unsigned char *)repubInfo + sizeof(iotx_mc_pub_info_t);
   \       0x5E   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x62   0x60E0             STR      R0,[R4, #+12]
    869          
    870              memcpy(repubInfo->buf, c->buf_send, len);
   \       0x64   0x463A             MOV      R2,R7
   \       0x66   0x6A71             LDR      R1,[R6, #+36]
   \       0x68   0x....'....        BL       __aeabi_memcpy
    871              INIT_LIST_HEAD(&repubInfo->linked_list);
   \       0x6C   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x70   0x....'....        BL       INIT_AOS_DLIST_HEAD
    872          
    873              list_add_tail(&repubInfo->linked_list, &c->list_pub_wait_ack);
   \       0x74   0xF106 0x01C0      ADD      R1,R6,#+192
   \       0x78   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x7C   0x....'....        BL       dlist_add_tail
    874          
    875              *node = repubInfo;
   \       0x80   0x602C             STR      R4,[R5, #+0]
    876              return SUCCESS_RETURN;
   \       0x82   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_push_pubInfo_to_2: (+1)
   \       0x84   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    877          #else
    878              for (idx = 0; idx < IOTX_MC_PUBWAIT_LIST_MAX_LEN; idx++) {
    879                  if (c->list_pub_wait_ack[idx].used == 0) {
    880                      c->list_pub_wait_ack[idx].node_state = IOTX_MC_NODE_STATE_NORMANL;
    881                      c->list_pub_wait_ack[idx].msg_id = msgId;
    882                      c->list_pub_wait_ack[idx].len = len;
    883                      iotx_time_start(&c->list_pub_wait_ack[idx].pub_start_time);
    884                      memcpy(c->list_pub_wait_ack[idx].buf, c->buf_send, len);
    885                      c->list_pub_wait_ack[idx].used = 1;
    886                      *node = &c->list_pub_wait_ack[idx];
    887                      return SUCCESS_RETURN;
    888                  }
    889              }
    890          
    891              mqtt_err("IOTX_MC_PUBWAIT_LIST_MAX_LEN is too short");
    892          
    893              return FAIL_RETURN;
    894          #endif
    895          }
    896          

   \                                 In section .text, align 2, keep-with-next
    897          static int iotx_mc_mask_pubInfo_from(iotx_mc_client_t *c, uint16_t msgId)
    898          {
   \                     iotx_mc_mask_pubInfo_from: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    899          #ifdef PLATFORM_HAS_DYNMEM
    900              iotx_mc_pub_info_t *node = NULL;
    901          
    902              if (!c) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??iotx_mc_mask_pubInfo_from_0
    903                  return FAIL_RETURN;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
    904              }
    905          
    906              HAL_MutexLock(c->lock_list_pub);
   \                     ??iotx_mc_mask_pubInfo_from_0: (+1)
   \       0x10   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x14   0x....'....        BL       HAL_MutexLock
    907              list_for_each_entry(node, &c->list_pub_wait_ack, linked_list, iotx_mc_pub_info_t) {
   \       0x18   0xF8D4 0x00C4      LDR      R0,[R4, #+196]
   \       0x1C   0x3810             SUBS     R0,R0,#+16
   \       0x1E   0xE007             B.N      ??iotx_mc_mask_pubInfo_from_1
    908                  if (node->msg_id == msgId) {
   \                     ??iotx_mc_mask_pubInfo_from_2: (+1)
   \       0x20   0x88C1             LDRH     R1,[R0, #+6]
   \       0x22   0x462A             MOV      R2,R5
   \       0x24   0x4291             CMP      R1,R2
   \       0x26   0xD101             BNE.N    ??iotx_mc_mask_pubInfo_from_3
    909                      node->node_state = IOTX_MC_NODE_STATE_INVALID; /* mark as invalid node */
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x7101             STRB     R1,[R0, #+4]
    910                  }
    911              }
   \                     ??iotx_mc_mask_pubInfo_from_3: (+1)
   \       0x2C   0x6940             LDR      R0,[R0, #+20]
   \       0x2E   0x3810             SUBS     R0,R0,#+16
   \                     ??iotx_mc_mask_pubInfo_from_1: (+1)
   \       0x30   0xF100 0x0110      ADD      R1,R0,#+16
   \       0x34   0xF104 0x02C0      ADD      R2,R4,#+192
   \       0x38   0x4291             CMP      R1,R2
   \       0x3A   0xD1F1             BNE.N    ??iotx_mc_mask_pubInfo_from_2
    912              HAL_MutexUnlock(c->lock_list_pub);
   \       0x3C   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x40   0x....'....        BL       HAL_MutexUnlock
    913          #else
    914              int idx;
    915          
    916              for (idx = 0; idx < IOTX_MC_PUBWAIT_LIST_MAX_LEN; idx++) {
    917                  if (c->list_pub_wait_ack[idx].used &&
    918                      c->list_pub_wait_ack[idx].msg_id == msgId) {
    919                      c->list_pub_wait_ack[idx].node_state = IOTX_MC_NODE_STATE_INVALID; /* mark as invalid node */
    920                  }
    921              }
    922          #endif
    923              return SUCCESS_RETURN;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    924          }
    925          

   \                                 In section .text, align 2, keep-with-next
    926          static int MQTTRePublish(iotx_mc_client_t *c, char *buf, int len)
    927          {
   \                     MQTTRePublish: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    928              iotx_time_t timer;
    929              iotx_time_init(&timer);
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x....'....        BL       iotx_time_init
    930              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \        0xE   0x68A1             LDR      R1,[R4, #+8]
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x....'....        BL       utils_time_countdown_ms
    931          
    932              HAL_MutexLock(c->lock_write_buf);
   \       0x16   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x1A   0x....'....        BL       HAL_MutexLock
    933          
    934              if (iotx_mc_send_packet(c, buf, len, &timer) != SUCCESS_RETURN) {
   \       0x1E   0x466B             MOV      R3,SP
   \       0x20   0x4632             MOV      R2,R6
   \       0x22   0x4629             MOV      R1,R5
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       iotx_mc_send_packet
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x30   0xD004             BEQ.N    ??MQTTRePublish_0
    935                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x32   0x....'....        BL       HAL_MutexUnlock
    936                  return MQTT_NETWORK_ERROR;
   \       0x36   0xF06F 0x000D      MVN      R0,#+13
   \       0x3A   0xBD76             POP      {R1,R2,R4-R6,PC}
    937              }
    938          
    939              HAL_MutexUnlock(c->lock_write_buf);
   \                     ??MQTTRePublish_0: (+1)
   \       0x3C   0x....'....        BL       HAL_MutexUnlock
    940              return SUCCESS_RETURN;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    941          }
    942          

   \                                 In section .text, align 2, keep-with-next
    943          static int MQTTPubInfoProc(iotx_mc_client_t *pClient)
    944          {
   \                     MQTTPubInfoProc: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    945              int rc = 0;
    946              iotx_mc_state_t state = IOTX_MC_STATE_INVALID;
    947          #ifdef PLATFORM_HAS_DYNMEM
    948              iotx_mc_pub_info_t *node = NULL, *next_node = NULL;
    949          #else
    950              int idx;
    951          #endif
    952          
    953              if (!pClient) {
   \        0x4   0xD102             BNE.N    ??MQTTPubInfoProc_0
    954                  return FAIL_RETURN;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBDF2             POP      {R1,R4-R7,PC}
    955              }
    956          
    957              HAL_MutexLock(pClient->lock_list_pub);
   \                     ??MQTTPubInfoProc_0: (+1)
   \        0xC   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x10   0x....'....        BL       HAL_MutexLock
    958          #ifdef PLATFORM_HAS_DYNMEM
    959              list_for_each_entry_safe(node, next_node, &pClient->list_pub_wait_ack, linked_list, iotx_mc_pub_info_t) {
   \       0x14   0xF8D4 0x00C4      LDR      R0,[R4, #+196]
   \       0x18   0xF1A0 0x0510      SUB      R5,R0,#+16
   \       0x1C   0x6968             LDR      R0,[R5, #+20]
   \       0x1E   0xF1A0 0x0610      SUB      R6,R0,#+16
   \       0x22   0xE00A             B.N      ??MQTTPubInfoProc_1
    960                  /* remove invalid node */
    961                  if (IOTX_MC_NODE_STATE_INVALID == node->node_state) {
    962                      list_del(&node->linked_list);
   \                     ??MQTTPubInfoProc_2: (+1)
   \       0x24   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x28   0x....'....        BL       dlist_del
    963                      mqtt_free(node);
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x....'....        BL       HAL_Free
    964                      continue;
    965                  }
   \                     ??MQTTPubInfoProc_3: (+1)
   \       0x32   0x4635             MOV      R5,R6
   \       0x34   0x6970             LDR      R0,[R6, #+20]
   \       0x36   0xF1A0 0x0610      SUB      R6,R0,#+16
   \                     ??MQTTPubInfoProc_1: (+1)
   \       0x3A   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x3E   0xF104 0x01C0      ADD      R1,R4,#+192
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xD01E             BEQ.N    ??MQTTPubInfoProc_4
   \       0x46   0x7928             LDRB     R0,[R5, #+4]
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD0EB             BEQ.N    ??MQTTPubInfoProc_2
    966          
    967                  state = iotx_mc_get_client_state(pClient);
    968                  if (state != IOTX_MC_STATE_CONNECTED) {
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x....'....        BL       iotx_mc_get_client_state
   \       0x52   0x2802             CMP      R0,#+2
   \       0x54   0xD1ED             BNE.N    ??MQTTPubInfoProc_3
    969                      continue;
    970                  }
    971          
    972                  /* check the request if timeout or not */
    973                  if (utils_time_spend(&node->pub_start_time) <= (pClient->request_timeout_ms * 2)) {
   \       0x56   0x4628             MOV      R0,R5
   \       0x58   0x....'....        BL       utils_time_spend
   \       0x5C   0x68A1             LDR      R1,[R4, #+8]
   \       0x5E   0x0049             LSLS     R1,R1,#+1
   \       0x60   0x4281             CMP      R1,R0
   \       0x62   0xD2E6             BCS.N    ??MQTTPubInfoProc_3
    974                      continue;
    975                  }
    976          
    977                  /* If wait ACK timeout, republish */
    978                  rc = MQTTRePublish(pClient, (char *)node->buf, node->len);
   \       0x64   0x68AA             LDR      R2,[R5, #+8]
   \       0x66   0x68E9             LDR      R1,[R5, #+12]
   \       0x68   0x4620             MOV      R0,R4
   \       0x6A   0x....'....        BL       MQTTRePublish
   \       0x6E   0x4607             MOV      R7,R0
    979                  iotx_time_start(&node->pub_start_time);
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x....'....        BL       iotx_time_start
    980          
    981                  if (MQTT_NETWORK_ERROR == rc) {
   \       0x76   0xF117 0x0F0E      CMN      R7,#+14
   \       0x7A   0xD1DA             BNE.N    ??MQTTPubInfoProc_3
    982                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED);
   \       0x7C   0x2103             MOVS     R1,#+3
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0x....'....        BL       iotx_mc_set_client_state
    983                      break;
    984                  }
    985              }
    986          #else
    987              for (idx = 0; idx < IOTX_MC_PUBWAIT_LIST_MAX_LEN; idx++) {
    988                  if (pClient->list_pub_wait_ack[idx].used == 0) {
    989                      continue;
    990                  }
    991          
    992                  if (IOTX_MC_NODE_STATE_INVALID == pClient->list_pub_wait_ack[idx].node_state) {
    993                      memset(&pClient->list_pub_wait_ack[idx], 0, sizeof(iotx_mc_pub_info_t));
    994                      continue;
    995                  }
    996          
    997                  state = iotx_mc_get_client_state(pClient);
    998                  if (state != IOTX_MC_STATE_CONNECTED) {
    999                      continue;
   1000                  }
   1001          
   1002                  /* check the request if timeout or not */
   1003                  if (utils_time_spend(&pClient->list_pub_wait_ack[idx].pub_start_time) <= (pClient->request_timeout_ms * 2)) {
   1004                      continue;
   1005                  }
   1006          
   1007                  /* If wait ACK timeout, republish */
   1008                  rc = MQTTRePublish(pClient, (char *)pClient->list_pub_wait_ack[idx].buf, pClient->list_pub_wait_ack[idx].len);
   1009                  iotx_time_start(&pClient->list_pub_wait_ack[idx].pub_start_time);
   1010          
   1011                  if (MQTT_NETWORK_ERROR == rc) {
   1012                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED);
   1013                      break;
   1014                  }
   1015              }
   1016          #endif
   1017              HAL_MutexUnlock(pClient->lock_list_pub);
   \                     ??MQTTPubInfoProc_4: (+1)
   \       0x84   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x88   0x....'....        BL       HAL_MutexUnlock
   1018          
   1019              return SUCCESS_RETURN;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1020          }
   1021          
   1022          /* handle PUBACK packet received from remote MQTT broker */

   \                                 In section .text, align 2, keep-with-next
   1023          static int iotx_mc_handle_recv_PUBACK(iotx_mc_client_t *c)
   1024          {
   \                     iotx_mc_handle_recv_PUBACK: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1025              unsigned short mypacketid;
   1026              unsigned char dup = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   1027              unsigned char type = 0;
   \        0x6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1028          
   1029              if (!c) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??iotx_mc_handle_recv_PUBACK_0
   1030                  return FAIL_RETURN;
   \        0xE   0xF04F 0x30FF      MOV      R0,#-1
   \       0x12   0xE024             B.N      ??iotx_mc_handle_recv_PUBACK_1
   1031              }
   1032          
   1033              if (MQTTDeserialize_ack(&type, &dup, &mypacketid, (unsigned char *)c->buf_read, c->buf_size_read) != 1) {
   \                     ??iotx_mc_handle_recv_PUBACK_0: (+1)
   \       0x14   0x69E0             LDR      R0,[R4, #+28]
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \       0x18   0x6AA3             LDR      R3,[R4, #+40]
   \       0x1A   0xF10D 0x0206      ADD      R2,SP,#+6
   \       0x1E   0xF10D 0x0105      ADD      R1,SP,#+5
   \       0x22   0xA801             ADD      R0,SP,#+4
   \       0x24   0x....'....        BL       MQTTDeserialize_ack
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD002             BEQ.N    ??iotx_mc_handle_recv_PUBACK_2
   1034                  return MQTT_PUBLISH_ACK_PACKET_ERROR;
   \       0x2C   0xF06F 0x0012      MVN      R0,#+18
   \       0x30   0xE015             B.N      ??iotx_mc_handle_recv_PUBACK_1
   1035              }
   1036          
   1037              (void)iotx_mc_mask_pubInfo_from(c, mypacketid);
   \                     ??iotx_mc_handle_recv_PUBACK_2: (+1)
   \       0x32   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x....'....        BL       iotx_mc_mask_pubInfo_from
   1038          
   1039              /* call callback function to notify that PUBLISH is successful */
   1040              if (NULL != c->handle_event.h_fp) {
   \       0x3C   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD00B             BEQ.N    ??iotx_mc_handle_recv_PUBACK_3
   1041                  iotx_mqtt_event_msg_t msg;
   1042                  msg.event_type = IOTX_MQTT_EVENT_PUBLISH_SUCCESS;
   \       0x44   0x2009             MOVS     R0,#+9
   \       0x46   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1043                  msg.msg = (void *)(uintptr_t)mypacketid;
   \       0x4A   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0x4E   0x9003             STR      R0,[SP, #+12]
   1044                  _handle_event(&c->handle_event, c, &msg);
   \       0x50   0xAA02             ADD      R2,SP,#+8
   \       0x52   0x4621             MOV      R1,R4
   \       0x54   0xF104 0x00E0      ADD      R0,R4,#+224
   \       0x58   0x....'....        BL       _handle_event
   1045              }
   1046          
   1047              return SUCCESS_RETURN;
   \                     ??iotx_mc_handle_recv_PUBACK_3: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_handle_recv_PUBACK_1: (+1)
   \       0x5E   0xB004             ADD      SP,SP,#+16
   \       0x60   0xBD10             POP      {R4,PC}          ;; return
   1048          }
   1049          #endif
   1050          

   \                                 In section .text, align 2, keep-with-next
   1051          static void _iotx_mqtt_event_handle_sub(void *pcontext, void *pclient, iotx_mqtt_event_msg_pt msg)
   1052          {
   \                     _iotx_mqtt_event_handle_sub: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   1053              iotx_mc_client_t *client;
   1054              uintptr_t packet_id;
   1055          #ifdef PLATFORM_HAS_DYNMEM
   1056              mqtt_sub_sync_node_t *node = NULL;
   1057              mqtt_sub_sync_node_t *next = NULL;
   1058          #else
   1059              int idx;
   1060          #endif
   1061          
   1062              if (pclient == NULL || msg == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD01E             BEQ.N    ??_iotx_mqtt_event_handle_sub_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD01C             BEQ.N    ??_iotx_mqtt_event_handle_sub_0
   1063                  return;
   1064              }
   1065          
   1066              client = (iotx_mc_client_t *)pclient;
   1067              packet_id = (uintptr_t) msg->msg;
   \        0xE   0x686E             LDR      R6,[R5, #+4]
   1068          
   1069              mqtt_debug("packet_id = %lu, event_type=%d", packet_id, msg->event_type);
   1070          
   1071              HAL_MutexLock(client->lock_generic);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x....'....        BL       HAL_MutexLock
   1072          #ifdef PLATFORM_HAS_DYNMEM
   1073              list_for_each_entry_safe(node, next, &client->list_sub_sync_ack, linked_list, mqtt_sub_sync_node_t) {
   \       0x16   0xF8D4 0x00CC      LDR      R0,[R4, #+204]
   \       0x1A   0x380C             SUBS     R0,R0,#+12
   \       0x1C   0x6901             LDR      R1,[R0, #+16]
   \       0x1E   0x390C             SUBS     R1,R1,#+12
   \       0x20   0xF104 0x03C8      ADD      R3,R4,#+200
   \       0x24   0xE007             B.N      ??_iotx_mqtt_event_handle_sub_1
   1074                  if (node->packet_id == packet_id) {
   \                     ??_iotx_mqtt_event_handle_sub_2: (+1)
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x42B2             CMP      R2,R6
   \       0x2A   0xD101             BNE.N    ??_iotx_mqtt_event_handle_sub_3
   1075                      node->ack_type = msg->event_type;
   \       0x2C   0x782A             LDRB     R2,[R5, #+0]
   \       0x2E   0x7102             STRB     R2,[R0, #+4]
   1076                  }
   1077              }
   \                     ??_iotx_mqtt_event_handle_sub_3: (+1)
   \       0x30   0x4608             MOV      R0,R1
   \       0x32   0x6909             LDR      R1,[R1, #+16]
   \       0x34   0x390C             SUBS     R1,R1,#+12
   \                     ??_iotx_mqtt_event_handle_sub_1: (+1)
   \       0x36   0xF100 0x020C      ADD      R2,R0,#+12
   \       0x3A   0x429A             CMP      R2,R3
   \       0x3C   0xD1F3             BNE.N    ??_iotx_mqtt_event_handle_sub_2
   1078          #else
   1079              for (idx = 0; idx < IOTX_MC_SUBSYNC_LIST_MAX_LEN; idx++) {
   1080                  if (client->list_sub_sync_ack[idx].used &&
   1081                      client->list_sub_sync_ack[idx].packet_id == packet_id) {
   1082                      client->list_sub_sync_ack[idx].ack_type = msg->event_type;
   1083                  }
   1084              }
   1085          #endif
   1086              HAL_MutexUnlock(client->lock_generic);
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x44   0x....'....        B.W      HAL_MutexUnlock
   \                     ??_iotx_mqtt_event_handle_sub_0: (+1)
   \       0x48   0xBD70             POP      {R4-R6,PC}       ;; return
   1087          }
   1088          

   \                                 In section .text, align 2, keep-with-next
   1089          static int iotx_mc_handle_recv_SUBACK(iotx_mc_client_t *c)
   1090          {
   \                     iotx_mc_handle_recv_SUBACK: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
   \        0x4   0x4604             MOV      R4,R0
   1091              unsigned short mypacketid;
   1092              iotx_mqtt_event_msg_t msg;
   1093              int i = 0, count = 0, fail_flag = -1, j = 0;
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0x4638             MOV      R0,R7
   \        0xA   0x9002             STR      R0,[SP, #+8]
   \        0xC   0xF04F 0x35FF      MOV      R5,#-1
   \       0x10   0x4606             MOV      R6,R0
   1094              int grantedQoS[MUTLI_SUBSCIRBE_MAX];
   1095              int rc;
   1096          
   1097              if (!c) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD101             BNE.N    ??iotx_mc_handle_recv_SUBACK_0
   1098                  return FAIL_RETURN;
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0xE035             B.N      ??iotx_mc_handle_recv_SUBACK_1
   1099              }
   1100          
   1101              rc = MQTTDeserialize_suback(&mypacketid, MUTLI_SUBSCIRBE_MAX, &count, grantedQoS, (unsigned char *)c->buf_read,
   1102                                          c->buf_size_read);
   1103          
   1104              if (rc < 0) {
   \                     ??iotx_mc_handle_recv_SUBACK_0: (+1)
   \       0x1A   0x69E0             LDR      R0,[R4, #+28]
   \       0x1C   0x9001             STR      R0,[SP, #+4]
   \       0x1E   0x6AA0             LDR      R0,[R4, #+40]
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0xAB06             ADD      R3,SP,#+24
   \       0x24   0xAA02             ADD      R2,SP,#+8
   \       0x26   0x2105             MOVS     R1,#+5
   \       0x28   0xA803             ADD      R0,SP,#+12
   \       0x2A   0x....'....        BL       MQTTDeserialize_suback
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD503             BPL.N    ??iotx_mc_handle_recv_SUBACK_2
   1105                  mqtt_err("Sub ack packet error, rc = MQTTDeserialize_suback() = %d", rc);
   1106                  return MQTT_SUBSCRIBE_ACK_PACKET_ERROR;
   \       0x32   0xF06F 0x0018      MVN      R0,#+24
   \       0x36   0xE026             B.N      ??iotx_mc_handle_recv_SUBACK_1
   1107              }
   1108          
   1109              mqtt_debug("%20s : %d", "Return Value", rc);
   1110              mqtt_debug("%20s : %d", "Packet ID", mypacketid);
   1111              mqtt_debug("%20s : %d", "Count", count);
   1112              for (i = 0; i < count; ++i) {
   \                     ??iotx_mc_handle_recv_SUBACK_3: (+1)
   \       0x38   0x1C7F             ADDS     R7,R7,#+1
   \                     ??iotx_mc_handle_recv_SUBACK_2: (+1)
   \       0x3A   0x9802             LDR      R0,[SP, #+8]
   \       0x3C   0x4287             CMP      R7,R0
   \       0x3E   0xDBFB             BLT.N    ??iotx_mc_handle_recv_SUBACK_3
   1113                  mqtt_debug("%16s[%02d] : %d", "Granted QoS", i, grantedQoS[i]);
   1114              }
   1115          
   1116              for (j = 0; j <  count; j++) {
   \                     ??iotx_mc_handle_recv_SUBACK_4: (+1)
   \       0x40   0x9802             LDR      R0,[SP, #+8]
   \       0x42   0x4286             CMP      R6,R0
   \       0x44   0xDA21             BGE.N    ??iotx_mc_handle_recv_SUBACK_5
   1117                  fail_flag = 0;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x4605             MOV      R5,R0
   1118                  /* In negative case, grantedQoS will be 0xFFFF FF80, which means -128 */
   1119                  if ((uint8_t)grantedQoS[j] == 0x80) {
   \       0x4A   0xA806             ADD      R0,SP,#+24
   \       0x4C   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x2880             CMP      R0,#+128
   \       0x54   0xD101             BNE.N    ??iotx_mc_handle_recv_SUBACK_6
   1120                      fail_flag = 1;
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x4605             MOV      R5,R0
   1121                      mqtt_err("MQTT SUBSCRIBE failed, ack code is 0x80");
   1122                  }
   1123              }
   \                     ??iotx_mc_handle_recv_SUBACK_6: (+1)
   \       0x5A   0x1C76             ADDS     R6,R6,#+1
   \       0x5C   0xE7F0             B.N      ??iotx_mc_handle_recv_SUBACK_4
   1124          
   1125              /* call callback function to notify that SUBSCRIBE is successful */
   1126              msg.msg = (void *)(uintptr_t)mypacketid;
   1127              if (fail_flag == 1) {
   1128                  msg.event_type = IOTX_MQTT_EVENT_SUBCRIBE_NACK;
   1129              } else {
   1130                  msg.event_type = IOTX_MQTT_EVENT_SUBCRIBE_SUCCESS;
   \                     ??iotx_mc_handle_recv_SUBACK_7: (+1)
   \       0x5E   0x2003             MOVS     R0,#+3
   \       0x60   0xF88D 0x0010      STRB     R0,[SP, #+16]
   1131              }
   1132          
   1133              _iotx_mqtt_event_handle_sub(c->handle_event.pcontext, c, &msg);
   \                     ??iotx_mc_handle_recv_SUBACK_8: (+1)
   \       0x64   0xAA04             ADD      R2,SP,#+16
   \       0x66   0x4621             MOV      R1,R4
   \       0x68   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \       0x6C   0x....'....        BL       _iotx_mqtt_event_handle_sub
   1134          
   1135              if (NULL != c->handle_event.h_fp) {
   \       0x70   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD005             BEQ.N    ??iotx_mc_handle_recv_SUBACK_9
   1136                  _handle_event(&c->handle_event, c, &msg);
   \       0x78   0xAA04             ADD      R2,SP,#+16
   \       0x7A   0x4621             MOV      R1,R4
   \       0x7C   0xF104 0x00E0      ADD      R0,R4,#+224
   \       0x80   0x....'....        BL       _handle_event
   1137              }
   1138          
   1139              return SUCCESS_RETURN;
   \                     ??iotx_mc_handle_recv_SUBACK_9: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_handle_recv_SUBACK_1: (+1)
   \       0x86   0xB00B             ADD      SP,SP,#+44
   \       0x88   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??iotx_mc_handle_recv_SUBACK_5: (+1)
   \       0x8A   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \       0x8E   0x9005             STR      R0,[SP, #+20]
   \       0x90   0x2D01             CMP      R5,#+1
   \       0x92   0xD1E4             BNE.N    ??iotx_mc_handle_recv_SUBACK_7
   \       0x94   0x2005             MOVS     R0,#+5
   \       0x96   0xF88D 0x0010      STRB     R0,[SP, #+16]
   \       0x9A   0xE7E3             B.N      ??iotx_mc_handle_recv_SUBACK_8
   1140          }
   1141          
   1142          #if WITH_MQTT_ZIP_TOPIC
   1143          #define MQTT_ZIP_PATH_DEFAULT_LEN (32)
   1144          
   1145          static int iotx_mc_get_zip_topic(const char *path, int len, char outbuf[], int outlen)
   1146          {
   1147              unsigned char comp_data[MQTT_ZIP_PATH_DEFAULT_LEN] = {0};
   1148              if (!path || !len || !outbuf || !outlen) {
   1149                  return -1;
   1150              }
   1151          
   1152              utils_sha256((unsigned char *)path, (size_t)len, comp_data);
   1153          
   1154              memcpy(outbuf, comp_data, outlen > MQTT_ZIP_PATH_DEFAULT_LEN ? MQTT_ZIP_PATH_DEFAULT_LEN : outlen);
   1155              return 0;
   1156          }
   1157          #endif
   1158          

   \                                 In section .text, align 2, keep-with-next
   1159          static char iotx_mc_is_topic_matched(char *topicFilter, MQTTString *topicName)
   1160          {
   \                     iotx_mc_is_topic_matched: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x460A             MOV      R2,R1
   1161              char *curf;
   1162              char *curn;
   1163              char *curn_end;
   1164          
   1165              if (!topicFilter || !topicName) {
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD001             BEQ.N    ??iotx_mc_is_topic_matched_0
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD101             BNE.N    ??iotx_mc_is_topic_matched_1
   1166                  return 0;
   \                     ??iotx_mc_is_topic_matched_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE02E             B.N      ??iotx_mc_is_topic_matched_2
   1167              }
   1168          
   1169              curf = topicFilter;
   1170              curn = topicName->lenstring.data;
   \                     ??iotx_mc_is_topic_matched_1: (+1)
   \       0x10   0x6891             LDR      R1,[R2, #+8]
   1171              curn_end = curn + topicName->lenstring.len;
   \       0x12   0x6852             LDR      R2,[R2, #+4]
   \       0x14   0x188B             ADDS     R3,R1,R2
   \       0x16   0xE004             B.N      ??iotx_mc_is_topic_matched_3
   1172          
   1173              while (*curf && curn < curn_end) {
   1174                  if (*curn == '/' && *curf != '/') {
   1175                      break;
   1176                  }
   1177          
   1178                  if (*curf != '+' && *curf != '#' && *curf != *curn) {
   1179                      break;
   1180                  }
   1181          
   1182                  if (*curf == '+') {
   1183                      /* skip until we meet the next separator, or end of string */
   1184                      char *nextpos = curn + 1;
   1185                      while (nextpos < curn_end && *nextpos != '/') {
   1186                          nextpos = ++curn + 1;
   1187                      }
   1188                  } else if (*curf == '#') {
   \                     ??iotx_mc_is_topic_matched_4: (+1)
   \       0x18   0x2A23             CMP      R2,#+35
   \       0x1A   0xD100             BNE.N    ??iotx_mc_is_topic_matched_5
   1189                      curn = curn_end - 1;    /* skip until end of string */
   \       0x1C   0x1E59             SUBS     R1,R3,#+1
   1190                  }
   1191                  curf++;
   \                     ??iotx_mc_is_topic_matched_5: (+1)
   \       0x1E   0x1C40             ADDS     R0,R0,#+1
   1192                  curn++;
   \       0x20   0x1C49             ADDS     R1,R1,#+1
   \                     ??iotx_mc_is_topic_matched_3: (+1)
   \       0x22   0x7802             LDRB     R2,[R0, #+0]
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0xD01A             BEQ.N    ??iotx_mc_is_topic_matched_6
   \       0x28   0x4299             CMP      R1,R3
   \       0x2A   0xD218             BCS.N    ??iotx_mc_is_topic_matched_6
   \       0x2C   0x780A             LDRB     R2,[R1, #+0]
   \       0x2E   0x2A2F             CMP      R2,#+47
   \       0x30   0xD102             BNE.N    ??iotx_mc_is_topic_matched_7
   \       0x32   0x7802             LDRB     R2,[R0, #+0]
   \       0x34   0x2A2F             CMP      R2,#+47
   \       0x36   0xD112             BNE.N    ??iotx_mc_is_topic_matched_6
   \                     ??iotx_mc_is_topic_matched_7: (+1)
   \       0x38   0x7802             LDRB     R2,[R0, #+0]
   \       0x3A   0x2A2B             CMP      R2,#+43
   \       0x3C   0xD004             BEQ.N    ??iotx_mc_is_topic_matched_8
   \       0x3E   0x2A23             CMP      R2,#+35
   \       0x40   0xD002             BEQ.N    ??iotx_mc_is_topic_matched_8
   \       0x42   0x780C             LDRB     R4,[R1, #+0]
   \       0x44   0x42A2             CMP      R2,R4
   \       0x46   0xD10A             BNE.N    ??iotx_mc_is_topic_matched_6
   \                     ??iotx_mc_is_topic_matched_8: (+1)
   \       0x48   0x2A2B             CMP      R2,#+43
   \       0x4A   0xD1E5             BNE.N    ??iotx_mc_is_topic_matched_4
   \       0x4C   0x1C4A             ADDS     R2,R1,#+1
   \                     ??iotx_mc_is_topic_matched_9: (+1)
   \       0x4E   0x429A             CMP      R2,R3
   \       0x50   0xD2E5             BCS.N    ??iotx_mc_is_topic_matched_5
   \       0x52   0x7812             LDRB     R2,[R2, #+0]
   \       0x54   0x2A2F             CMP      R2,#+47
   \       0x56   0xD0E2             BEQ.N    ??iotx_mc_is_topic_matched_5
   \       0x58   0x1C49             ADDS     R1,R1,#+1
   \       0x5A   0x1C4A             ADDS     R2,R1,#+1
   \       0x5C   0xE7F7             B.N      ??iotx_mc_is_topic_matched_9
   1193              }
   1194          
   1195              return (curn == curn_end) && (*curf == '\0');
   \                     ??iotx_mc_is_topic_matched_6: (+1)
   \       0x5E   0x4299             CMP      R1,R3
   \       0x60   0xD104             BNE.N    ??iotx_mc_is_topic_matched_10
   \       0x62   0x4610             MOV      R0,R2
   \       0x64   0x1E40             SUBS     R0,R0,#+1
   \       0x66   0x4180             SBCS     R0,R0,R0
   \       0x68   0x0FC0             LSRS     R0,R0,#+31
   \       0x6A   0xE000             B.N      ??iotx_mc_is_topic_matched_2
   \                     ??iotx_mc_is_topic_matched_10: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_is_topic_matched_2: (+1)
   \       0x6E   0xBC10             POP      {R4}
   \       0x70   0x4770             BX       LR               ;; return
   1196          }
   1197          

   \                                 In section .text, align 2, keep-with-next
   1198          static void iotx_mc_deliver_message(iotx_mc_client_t *c, MQTTString *topicName, iotx_mqtt_topic_info_pt topic_msg)
   1199          {
   \                     iotx_mc_deliver_message: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   1200              int flag_matched = 0;
   \        0xA   0x2700             MOVS     R7,#+0
   1201              MQTTString *compare_topic = NULL;
   1202          #ifdef PLATFORM_HAS_DYNMEM
   1203              iotx_mc_topic_handle_t *node = NULL;
   1204          #else
   1205              int idx = 0;
   1206          #endif
   1207          
   1208          #if WITH_MQTT_ZIP_TOPIC
   1209              MQTTString      md5_topic;
   1210              char            md5_topic_data[MQTT_ZIP_PATH_DEFAULT_LEN] = {0};
   1211              char           *net_topic;
   1212              uint32_t        net_topic_len;
   1213          #endif
   1214          
   1215              if (!c || !topicName || !topic_msg) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD04E             BEQ.N    ??iotx_mc_deliver_message_0
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD04C             BEQ.N    ??iotx_mc_deliver_message_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD04A             BEQ.N    ??iotx_mc_deliver_message_0
   1216                  return;
   1217              }
   1218          
   1219              topic_msg->ptopic = topicName->lenstring.data;
   \       0x18   0x68B0             LDR      R0,[R6, #+8]
   \       0x1A   0x60E8             STR      R0,[R5, #+12]
   1220              topic_msg->topic_len = topicName->lenstring.len;
   \       0x1C   0x6870             LDR      R0,[R6, #+4]
   \       0x1E   0x80E8             STRH     R0,[R5, #+6]
   1221          
   1222          #if WITH_MQTT_ZIP_TOPIC
   1223              if (topicName->cstring) {
   1224                  net_topic = topicName->cstring;
   1225                  net_topic_len = strlen(topicName->cstring);
   1226              } else {
   1227                  net_topic = topicName->lenstring.data;
   1228                  net_topic_len = topicName->lenstring.len;
   1229              }
   1230              md5_topic.cstring = NULL;
   1231              md5_topic.lenstring.data = md5_topic_data;
   1232              md5_topic.lenstring.len = MQTT_ZIP_PATH_DEFAULT_LEN;
   1233              iotx_mc_get_zip_topic(net_topic, net_topic_len, md5_topic_data, MQTT_ZIP_PATH_DEFAULT_LEN);
   1234              compare_topic = &md5_topic;
   1235          #else
   1236              compare_topic = topicName;
   1237          #endif
   1238          
   1239              /* we have to find the right message handler - indexed by topic */
   1240              HAL_MutexLock(c->lock_generic);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x....'....        BL       HAL_MutexLock
   1241          #ifdef PLATFORM_HAS_DYNMEM
   1242              list_for_each_entry(node, &c->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   \       0x26   0x6B20             LDR      R0,[R4, #+48]
   \       0x28   0xF1A0 0x0810      SUB      R8,R0,#+16
   \       0x2C   0xE026             B.N      ??iotx_mc_deliver_message_1
   1243                  if (MQTTPacket_equals(compare_topic, (char *)node->topic_filter)
   1244                      || iotx_mc_is_topic_matched((char *)node->topic_filter, topicName)) {
   \                     ??iotx_mc_deliver_message_2: (+1)
   \       0x2E   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \       0x32   0x4630             MOV      R0,R6
   \       0x34   0x....'....        BL       MQTTPacket_equals
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD106             BNE.N    ??iotx_mc_deliver_message_3
   \       0x3C   0x4631             MOV      R1,R6
   \       0x3E   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x42   0x....'....        BL       iotx_mc_is_topic_matched
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD014             BEQ.N    ??iotx_mc_deliver_message_4
   1245                      mqtt_debug("topic be matched");
   1246          
   1247                      HAL_MutexUnlock(c->lock_generic);
   \                     ??iotx_mc_deliver_message_3: (+1)
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x....'....        BL       HAL_MutexUnlock
   1248                      if (NULL != node->handle.h_fp) {
   \       0x50   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD00A             BEQ.N    ??iotx_mc_deliver_message_5
   1249                          iotx_mqtt_event_msg_t msg;
   1250                          msg.event_type = IOTX_MQTT_EVENT_PUBLISH_RECEIVED;
   \       0x58   0x200C             MOVS     R0,#+12
   \       0x5A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1251                          msg.msg = (void *)topic_msg;
   \       0x5E   0x9501             STR      R5,[SP, #+4]
   1252                          _handle_event(&node->handle, c, &msg);
   \       0x60   0x466A             MOV      R2,SP
   \       0x62   0x4621             MOV      R1,R4
   \       0x64   0xF108 0x0004      ADD      R0,R8,#+4
   \       0x68   0x....'....        BL       _handle_event
   1253                          flag_matched = 1;
   \       0x6C   0x2701             MOVS     R7,#+1
   1254                      }
   1255                      HAL_MutexLock(c->lock_generic);
   \                     ??iotx_mc_deliver_message_5: (+1)
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x....'....        BL       HAL_MutexLock
   1256                  }
   1257              }
   \                     ??iotx_mc_deliver_message_4: (+1)
   \       0x74   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x78   0xF1A0 0x0810      SUB      R8,R0,#+16
   \                     ??iotx_mc_deliver_message_1: (+1)
   \       0x7C   0xF108 0x0010      ADD      R0,R8,#+16
   \       0x80   0xF104 0x012C      ADD      R1,R4,#+44
   \       0x84   0x4288             CMP      R0,R1
   \       0x86   0xD1D2             BNE.N    ??iotx_mc_deliver_message_2
   1258          #else
   1259              for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   1260                  if ((c->list_sub_handle[idx].used == 1) &&
   1261                      (MQTTPacket_equals(compare_topic, (char *)c->list_sub_handle[idx].topic_filter)
   1262                       || iotx_mc_is_topic_matched((char *)c->list_sub_handle[idx].topic_filter, topicName))) {
   1263                      mqtt_debug("topic be matched");
   1264          
   1265                      HAL_MutexUnlock(c->lock_generic);
   1266                      if (NULL != c->list_sub_handle[idx].handle.h_fp) {
   1267                          iotx_mqtt_event_msg_t msg;
   1268                          msg.event_type = IOTX_MQTT_EVENT_PUBLISH_RECEIVED;
   1269                          msg.msg = (void *)topic_msg;
   1270                          _handle_event(&c->list_sub_handle[idx].handle, c, &msg);
   1271                          flag_matched = 1;
   1272                      }
   1273                      HAL_MutexLock(c->lock_generic);
   1274                  }
   1275              }
   1276          #endif
   1277              HAL_MutexUnlock(c->lock_generic);
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x....'....        BL       HAL_MutexUnlock
   1278          
   1279              if (0 == flag_matched) {
   \       0x8E   0x2F00             CMP      R7,#+0
   \       0x90   0xD10D             BNE.N    ??iotx_mc_deliver_message_0
   1280                  mqtt_info("NO matching any topic, call default handle function");
   1281          
   1282                  if (NULL != c->handle_event.h_fp) {
   \       0x92   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD009             BEQ.N    ??iotx_mc_deliver_message_0
   1283                      iotx_mqtt_event_msg_t msg;
   1284          
   1285                      msg.event_type = IOTX_MQTT_EVENT_PUBLISH_RECEIVED;
   \       0x9A   0x200C             MOVS     R0,#+12
   \       0x9C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1286                      msg.msg = topic_msg;
   \       0xA0   0x9501             STR      R5,[SP, #+4]
   1287                      _handle_event(&c->handle_event, c, &msg);
   \       0xA2   0x466A             MOV      R2,SP
   \       0xA4   0x4621             MOV      R1,R4
   \       0xA6   0xF104 0x00E0      ADD      R0,R4,#+224
   \       0xAA   0x....'....        BL       _handle_event
   1288                  }
   1289              }
   1290          }
   \                     ??iotx_mc_deliver_message_0: (+1)
   \       0xAE   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
   1291          

   \                                 In section .text, align 2, keep-with-next
   1292          static int MQTTPuback(iotx_mc_client_t *c, unsigned int msgId, enum msgTypes type)
   1293          {
   \                     MQTTPuback: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   1294              int rc = 0;
   1295              int len = 0;
   1296              iotx_time_t timer;
   1297          
   1298              if (!c) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD102             BNE.N    ??MQTTPuback_0
   1299                  return FAIL_RETURN;
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
   \       0x10   0xBD76             POP      {R1,R2,R4-R6,PC}
   1300              }
   1301          
   1302              iotx_time_init(&timer);
   \                     ??MQTTPuback_0: (+1)
   \       0x12   0xA801             ADD      R0,SP,#+4
   \       0x14   0x....'....        BL       iotx_time_init
   1303              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x18   0x68A1             LDR      R1,[R4, #+8]
   \       0x1A   0xA801             ADD      R0,SP,#+4
   \       0x1C   0x....'....        BL       utils_time_countdown_ms
   1304          
   1305              HAL_MutexLock(c->lock_write_buf);
   \       0x20   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x24   0x....'....        BL       HAL_MutexLock
   1306              if (type == PUBACK) {
   \       0x28   0x2E04             CMP      R6,#+4
   \       0x2A   0xD120             BNE.N    ??MQTTPuback_1
   1307          
   1308                  if (_alloc_send_buffer(c, 0) < 0) {
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       _alloc_send_buffer
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD506             BPL.N    ??MQTTPuback_2
   1309                      HAL_MutexUnlock(c->lock_write_buf);
   \       0x38   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x3C   0x....'....        BL       HAL_MutexUnlock
   1310                      return FAIL_RETURN;
   \       0x40   0xF04F 0x30FF      MOV      R0,#-1
   \       0x44   0xBD76             POP      {R1,R2,R4-R6,PC}
   1311                  }
   1312          
   1313                  len = MQTTSerialize_ack((unsigned char *)c->buf_send, c->buf_size_send, PUBACK, 0, msgId);
   \                     ??MQTTPuback_2: (+1)
   \       0x46   0xB2AD             UXTH     R5,R5
   \       0x48   0x9500             STR      R5,[SP, #+0]
   \       0x4A   0x2300             MOVS     R3,#+0
   \       0x4C   0x2204             MOVS     R2,#+4
   \       0x4E   0x6921             LDR      R1,[R4, #+16]
   \       0x50   0x6A60             LDR      R0,[R4, #+36]
   \       0x52   0x....'....        BL       MQTTSerialize_ack
   1314          #if WITH_MQTT_QOS2_PACKET
   1315              } else if (type == PUBREC) {
   1316                  if (_alloc_send_buffer(c, 0) < 0) {
   1317                      HAL_MutexUnlock(c->lock_write_buf);
   1318                      return FAIL_RETURN;
   1319                  }
   1320                  len = MQTTSerialize_ack((unsigned char *)c->buf_send, c->buf_size_send, PUBREC, 0, msgId);
   1321              } else if (type == PUBREL) {
   1322                  if (_alloc_send_buffer(c, 0) < 0) {
   1323                      HAL_MutexUnlock(c->lock_write_buf);
   1324                      return FAIL_RETURN;
   1325                  }
   1326                  len = MQTTSerialize_ack((unsigned char *)c->buf_send, c->buf_size_send, PUBREL, 0, msgId);
   1327          #endif  /* #if WITH_MQTT_QOS2_PACKET */
   1328              } else {
   1329                  HAL_MutexUnlock(c->lock_write_buf);
   1330                  return MQTT_PUBLISH_ACK_TYPE_ERROR;
   1331              }
   1332          
   1333              if (len <= 0) {
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xDA10             BGE.N    ??MQTTPuback_3
   1334                  _reset_send_buffer(c);
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x....'....        BL       _reset_send_buffer
   1335                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x60   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x64   0x....'....        BL       HAL_MutexUnlock
   1336                  return MQTT_PUBLISH_ACK_PACKET_ERROR;
   \       0x68   0xF06F 0x0012      MVN      R0,#+18
   \       0x6C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1337              }
   \                     ??MQTTPuback_1: (+1)
   \       0x6E   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x72   0x....'....        BL       HAL_MutexUnlock
   \       0x76   0xF06F 0x000C      MVN      R0,#+12
   \       0x7A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1338          
   1339              rc = iotx_mc_send_packet(c, c->buf_send, len, &timer);
   1340              if (rc != SUCCESS_RETURN) {
   \                     ??MQTTPuback_3: (+1)
   \       0x7C   0xAB01             ADD      R3,SP,#+4
   \       0x7E   0x4602             MOV      R2,R0
   \       0x80   0x6A61             LDR      R1,[R4, #+36]
   \       0x82   0x4620             MOV      R0,R4
   \       0x84   0x....'....        BL       iotx_mc_send_packet
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0x4620             MOV      R0,R4
   \       0x8C   0xD008             BEQ.N    ??MQTTPuback_4
   1341                  _reset_send_buffer(c);
   \       0x8E   0x....'....        BL       _reset_send_buffer
   1342                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x92   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x96   0x....'....        BL       HAL_MutexUnlock
   1343                  return MQTT_NETWORK_ERROR;
   \       0x9A   0xF06F 0x000D      MVN      R0,#+13
   \       0x9E   0xBD76             POP      {R1,R2,R4-R6,PC}
   1344              }
   1345          
   1346              _reset_send_buffer(c);
   \                     ??MQTTPuback_4: (+1)
   \       0xA0   0x....'....        BL       _reset_send_buffer
   1347              HAL_MutexUnlock(c->lock_write_buf);
   \       0xA4   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xA8   0x....'....        BL       HAL_MutexUnlock
   1348              return SUCCESS_RETURN;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1349          }
   1350          

   \                                 In section .text, align 2, keep-with-next
   1351          static int iotx_mc_handle_recv_PUBLISH(iotx_mc_client_t *c)
   1352          {
   \                     iotx_mc_handle_recv_PUBLISH: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB08F             SUB      SP,SP,#+60
   \        0x4   0x4604             MOV      R4,R0
   1353              int result = 0;
   1354              MQTTString topicName;
   1355              iotx_mqtt_topic_info_t topic_msg;
   1356              int qos = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9006             STR      R0,[SP, #+24]
   1357              uint32_t payload_len = 0;
   \        0xA   0x9005             STR      R0,[SP, #+20]
   1358          #ifdef INFRA_LOG_NETWORK_PAYLOAD
   1359              const char     *json_payload = NULL;
   1360          #endif
   1361          
   1362              if (!c) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD102             BNE.N    ??iotx_mc_handle_recv_PUBLISH_0
   1363                  return FAIL_RETURN;
   \       0x10   0xF04F 0x30FF      MOV      R0,#-1
   \       0x14   0xE044             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   1364              }
   1365          
   1366              memset(&topic_msg, 0x0, sizeof(iotx_mqtt_topic_info_t));
   \                     ??iotx_mc_handle_recv_PUBLISH_0: (+1)
   \       0x16   0x4602             MOV      R2,R0
   \       0x18   0x2114             MOVS     R1,#+20
   \       0x1A   0xA807             ADD      R0,SP,#+28
   \       0x1C   0x....'....        BL       __aeabi_memset4
   1367              memset(&topicName, 0x0, sizeof(MQTTString));
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x210C             MOVS     R1,#+12
   \       0x24   0xA80C             ADD      R0,SP,#+48
   \       0x26   0x....'....        BL       __aeabi_memset4
   1368          
   1369              if (1 != MQTTDeserialize_publish((unsigned char *)&topic_msg.dup,
   1370                                               (int *)&qos,
   1371                                               (unsigned char *)&topic_msg.retain,
   1372                                               (unsigned short *)&topic_msg.packet_id,
   1373                                               &topicName,
   1374                                               (unsigned char **)&topic_msg.payload,
   1375                                               (int *)&payload_len,
   1376                                               (unsigned char *)c->buf_read,
   1377                                               c->buf_size_read)) {
   \       0x2A   0x69E0             LDR      R0,[R4, #+28]
   \       0x2C   0x9004             STR      R0,[SP, #+16]
   \       0x2E   0x6AA0             LDR      R0,[R4, #+40]
   \       0x30   0x9003             STR      R0,[SP, #+12]
   \       0x32   0xA805             ADD      R0,SP,#+20
   \       0x34   0x9002             STR      R0,[SP, #+8]
   \       0x36   0xA80B             ADD      R0,SP,#+44
   \       0x38   0x9001             STR      R0,[SP, #+4]
   \       0x3A   0xA80C             ADD      R0,SP,#+48
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   \       0x3E   0xAB07             ADD      R3,SP,#+28
   \       0x40   0xAA08             ADD      R2,SP,#+32
   \       0x42   0xA906             ADD      R1,SP,#+24
   \       0x44   0xF10D 0x001F      ADD      R0,SP,#+31
   \       0x48   0x....'....        BL       MQTTDeserialize_publish
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD002             BEQ.N    ??iotx_mc_handle_recv_PUBLISH_2
   1378                  return MQTT_PUBLISH_PACKET_ERROR;
   \       0x50   0xF06F 0x0014      MVN      R0,#+20
   \       0x54   0xE024             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   1379              }
   1380              topic_msg.qos = (unsigned char)qos;
   \                     ??iotx_mc_handle_recv_PUBLISH_2: (+1)
   \       0x56   0x9806             LDR      R0,[SP, #+24]
   \       0x58   0xF88D 0x001E      STRB     R0,[SP, #+30]
   1381              topic_msg.payload_len = payload_len;
   \       0x5C   0x9805             LDR      R0,[SP, #+20]
   \       0x5E   0x9009             STR      R0,[SP, #+36]
   1382          
   1383          #ifdef INFRA_LOG_NETWORK_PAYLOAD
   1384          
   1385              json_payload = (const char *)topic_msg.payload;
   1386              mqtt_info("Downstream Topic: '%.*s'", topicName.lenstring.len, topicName.lenstring.data);
   1387              mqtt_info("Downstream Payload:");
   1388              iotx_facility_json_print(json_payload, LOG_INFO_LEVEL, '<');
   \       0x60   0x223C             MOVS     R2,#+60
   \       0x62   0x2104             MOVS     R1,#+4
   \       0x64   0x980B             LDR      R0,[SP, #+44]
   \       0x66   0x....'....        BL       iotx_facility_json_print
   1389          
   1390          #endif  /* #ifdef INFRA_LOG */
   1391          
   1392              mqtt_debug("%20s : %08d", "Packet Ident", topic_msg.packet_id);
   1393              mqtt_debug("%20s : %d", "Topic Length", topicName.lenstring.len);
   1394              mqtt_debug("%20s : %.*s",
   1395                         "Topic Name",
   1396                         topicName.lenstring.len,
   1397                         topicName.lenstring.data);
   1398              mqtt_debug("%20s : %u / %d", "Payload Len/Room",
   1399                         (unsigned int)topic_msg.payload_len,
   1400                         (int)(c->buf_read + c->buf_size_read - topic_msg.payload));
   1401              mqtt_debug("%20s : %lu", "Receive Buflen", c->buf_size_read);
   1402          
   1403          #if defined(INSPECT_MQTT_FLOW)
   1404              mqtt_debug("%20s : %p", "Payload Buffer", topic_msg.payload);
   1405              mqtt_debug("%20s : %p", "Receive Buffer", c->buf_read);
   1406          #ifdef INFRA_LOG
   1407              HEXDUMP_DEBUG(topic_msg.payload, topic_msg.payload_len);
   1408          #endif
   1409          #endif
   1410          #ifdef LOG_REPORT_TO_CLOUD
   1411              get_msgid(topicName.lenstring.data, 1);
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0x980E             LDR      R0,[SP, #+56]
   \       0x6E   0x....'....        BL       get_msgid
   1412          #endif
   1413          
   1414              topic_msg.ptopic = NULL;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x900A             STR      R0,[SP, #+40]
   1415              topic_msg.topic_len = 0;
   \       0x76   0xF8AD 0x0022      STRH     R0,[SP, #+34]
   1416          
   1417              mqtt_debug("delivering msg ...");
   1418          
   1419          #if WITH_MQTT_FLOW_CTRL
   1420              /* flowControl for specific topic */
   1421              static uint64_t time_prev = 0;
   1422              uint64_t time_curr = 0;
   1423              char *filterStr = "{\"method\":\"thing.service.property.set\"";
   1424              int filterLen = strlen(filterStr);
   1425          
   1426              if (0 == memcmp(topic_msg.payload, filterStr, filterLen)) {
   1427                  time_curr = HAL_UptimeMs();
   1428                  if (time_curr < time_prev) {
   1429                      time_curr = time_prev;
   1430                  }
   1431                  if ((time_curr - time_prev) <= (uint64_t)50) {
   1432                      mqtt_info("MQTT over threshould");
   1433                      return SUCCESS_RETURN;
   1434                  } else {
   1435                      time_prev = time_curr;
   1436                  }
   1437              }
   1438          #endif
   1439          
   1440              iotx_mc_deliver_message(c, &topicName, &topic_msg);
   \       0x7A   0xAA07             ADD      R2,SP,#+28
   \       0x7C   0xA90C             ADD      R1,SP,#+48
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0x....'....        BL       iotx_mc_deliver_message
   1441          
   1442              if (topic_msg.qos == IOTX_MQTT_QOS0) {
   \       0x84   0xF89D 0x001E      LDRB     R0,[SP, #+30]
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD101             BNE.N    ??iotx_mc_handle_recv_PUBLISH_3
   1443                  return SUCCESS_RETURN;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xE007             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   1444              } else if (topic_msg.qos == IOTX_MQTT_QOS1) {
   \                     ??iotx_mc_handle_recv_PUBLISH_3: (+1)
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD107             BNE.N    ??iotx_mc_handle_recv_PUBLISH_4
   1445                  result = MQTTPuback(c, topic_msg.packet_id, PUBACK);
   \       0x94   0x2204             MOVS     R2,#+4
   \       0x96   0xF8BD 0x101C      LDRH     R1,[SP, #+28]
   \       0x9A   0x4620             MOV      R0,R4
   \       0x9C   0x....'....        BL       MQTTPuback
   1446              } else if (topic_msg.qos == IOTX_MQTT_QOS2) {
   1447                  result = MQTTPuback(c, topic_msg.packet_id, PUBREC);
   1448              } else {
   1449                  mqtt_err("Invalid QOS, QOSvalue = %d", topic_msg.qos);
   1450                  return MQTT_PUBLISH_QOS_ERROR;
   1451              }
   1452          
   1453              return result;
   \                     ??iotx_mc_handle_recv_PUBLISH_1: (+1)
   \       0xA0   0xB010             ADD      SP,SP,#+64
   \       0xA2   0xBD10             POP      {R4,PC}          ;; return
   \                     ??iotx_mc_handle_recv_PUBLISH_4: (+1)
   \       0xA4   0x2802             CMP      R0,#+2
   \       0xA6   0xD106             BNE.N    ??iotx_mc_handle_recv_PUBLISH_5
   \       0xA8   0x2205             MOVS     R2,#+5
   \       0xAA   0xF8BD 0x101C      LDRH     R1,[SP, #+28]
   \       0xAE   0x4620             MOV      R0,R4
   \       0xB0   0x....'....        BL       MQTTPuback
   \       0xB4   0xE7F4             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   \                     ??iotx_mc_handle_recv_PUBLISH_5: (+1)
   \       0xB6   0xF06F 0x0013      MVN      R0,#+19
   \       0xBA   0xE7F1             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   1454          }
   1455          

   \                                 In section .text, align 2, keep-with-next
   1456          static int iotx_mc_handle_recv_UNSUBACK(iotx_mc_client_t *c)
   1457          {
   \                     iotx_mc_handle_recv_UNSUBACK: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1458              unsigned short mypacketid = 0;  /* should be the same as the packetid above */
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1459              if (!c) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??iotx_mc_handle_recv_UNSUBACK_0
   1460                  return FAIL_RETURN;
   \        0xE   0xF04F 0x30FF      MOV      R0,#-1
   \       0x12   0xE01A             B.N      ??iotx_mc_handle_recv_UNSUBACK_1
   1461              }
   1462          
   1463              if (MQTTDeserialize_unsuback(&mypacketid, (unsigned char *)c->buf_read, c->buf_size_read) != 1) {
   \                     ??iotx_mc_handle_recv_UNSUBACK_0: (+1)
   \       0x14   0x69E2             LDR      R2,[R4, #+28]
   \       0x16   0x6AA1             LDR      R1,[R4, #+40]
   \       0x18   0x4668             MOV      R0,SP
   \       0x1A   0x....'....        BL       MQTTDeserialize_unsuback
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD002             BEQ.N    ??iotx_mc_handle_recv_UNSUBACK_2
   1464                  return MQTT_UNSUBSCRIBE_ACK_PACKET_ERROR;
   \       0x22   0xF06F 0x000E      MVN      R0,#+14
   \       0x26   0xE010             B.N      ??iotx_mc_handle_recv_UNSUBACK_1
   1465              }
   1466          
   1467              if (NULL != c->handle_event.h_fp) {
   \                     ??iotx_mc_handle_recv_UNSUBACK_2: (+1)
   \       0x28   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD00B             BEQ.N    ??iotx_mc_handle_recv_UNSUBACK_3
   1468                  iotx_mqtt_event_msg_t msg;
   1469                  msg.event_type = IOTX_MQTT_EVENT_UNSUBCRIBE_SUCCESS;
   \       0x30   0x2006             MOVS     R0,#+6
   \       0x32   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1470                  msg.msg = (void *)(uintptr_t)mypacketid;
   \       0x36   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x3A   0x9002             STR      R0,[SP, #+8]
   1471                  _handle_event(&c->handle_event, c, &msg);
   \       0x3C   0xAA01             ADD      R2,SP,#+4
   \       0x3E   0x4621             MOV      R1,R4
   \       0x40   0xF104 0x00E0      ADD      R0,R4,#+224
   \       0x44   0x....'....        BL       _handle_event
   1472              }
   1473          
   1474              return SUCCESS_RETURN;
   \                     ??iotx_mc_handle_recv_UNSUBACK_3: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_handle_recv_UNSUBACK_1: (+1)
   \       0x4A   0xB004             ADD      SP,SP,#+16
   \       0x4C   0xBD10             POP      {R4,PC}          ;; return
   1475          }
   1476          

   \                                 In section .text, align 2, keep-with-next
   1477          static int iotx_mc_cycle(iotx_mc_client_t *c, iotx_time_t *timer)
   1478          {
   \                     iotx_mc_cycle: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1479              unsigned int packetType;
   1480              iotx_mc_state_t state;
   1481              int rc = SUCCESS_RETURN;
   1482          
   1483              if (!c) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??iotx_mc_cycle_0
   1484                  return FAIL_RETURN;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD76             POP      {R1,R2,R4-R6,PC}
   1485              }
   1486          
   1487              state = iotx_mc_get_client_state(c);
   1488              if (state != IOTX_MC_STATE_CONNECTED) {
   \                     ??iotx_mc_cycle_0: (+1)
   \       0x10   0x....'....        BL       iotx_mc_get_client_state
   \       0x14   0x2802             CMP      R0,#+2
   \       0x16   0xD002             BEQ.N    ??iotx_mc_cycle_1
   1489                  mqtt_debug("state = %d", state);
   1490                  return MQTT_STATE_ERROR;
   \       0x18   0xF06F 0x001A      MVN      R0,#+26
   \       0x1C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1491              }
   1492          
   1493              if (IOTX_MC_KEEPALIVE_PROBE_MAX < c->keepalive_probes) {
   \                     ??iotx_mc_cycle_1: (+1)
   \       0x1E   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x22   0x2803             CMP      R0,#+3
   \       0x24   0xDB06             BLT.N    ??iotx_mc_cycle_2
   1494                  iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x26   0x2103             MOVS     R1,#+3
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       iotx_mc_set_client_state
   1495                  c->keepalive_probes = 0;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF884 0x0020      STRB     R0,[R4, #+32]
   1496                  mqtt_debug("keepalive_probes more than %u, disconnected\n", IOTX_MC_KEEPALIVE_PROBE_MAX);
   1497              }
   1498          
   1499              /* read the socket, see what work is due */
   1500              rc = iotx_mc_read_packet(c, timer, &packetType);
   \                     ??iotx_mc_cycle_2: (+1)
   \       0x34   0x466A             MOV      R2,SP
   \       0x36   0x4629             MOV      R1,R5
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x....'....        BL       iotx_mc_read_packet
   \       0x3E   0x0005             MOVS     R5,R0
   1501              if (rc != SUCCESS_RETURN) {
   \       0x40   0xD014             BEQ.N    ??iotx_mc_cycle_3
   1502                  HAL_MutexLock(c->lock_read_buf);
   \       0x42   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x46   0x....'....        BL       HAL_MutexLock
   1503                  _reset_recv_buffer(c);
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x....'....        BL       _reset_recv_buffer
   1504                  HAL_MutexUnlock(c->lock_read_buf);
   \       0x50   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x54   0x....'....        BL       HAL_MutexUnlock
   1505                  if (rc == MQTT_NETWORK_ERROR) {
   \       0x58   0xF06F 0x060D      MVN      R6,#+13
   \       0x5C   0x42B5             CMP      R5,R6
   \       0x5E   0xD103             BNE.N    ??iotx_mc_cycle_4
   1506                      iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x60   0x2103             MOVS     R1,#+3
   \       0x62   0x4620             MOV      R0,R4
   \       0x64   0x....'....        BL       iotx_mc_set_client_state
   1507                  }
   1508                  mqtt_err("readPacket error,result = %d", rc);
   1509                  return MQTT_NETWORK_ERROR;
   \                     ??iotx_mc_cycle_4: (+1)
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1510              }
   1511          
   1512              if (MQTT_CPT_RESERVED == packetType) {
   \                     ??iotx_mc_cycle_3: (+1)
   \       0x6C   0x9800             LDR      R0,[SP, #+0]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD10C             BNE.N    ??iotx_mc_cycle_5
   1513                  /* mqtt_debug("wait data timeout"); */
   1514                  HAL_MutexLock(c->lock_read_buf);
   \       0x72   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x76   0x....'....        BL       HAL_MutexLock
   1515                  _reset_recv_buffer(c);
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0x....'....        BL       _reset_recv_buffer
   1516                  HAL_MutexUnlock(c->lock_read_buf);
   \       0x80   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x84   0x....'....        BL       HAL_MutexUnlock
   1517                  return SUCCESS_RETURN;
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1518              }
   1519          
   1520              /* clear ping mark when any data received from MQTT broker */
   1521              HAL_MutexLock(c->lock_generic);
   \                     ??iotx_mc_cycle_5: (+1)
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x....'....        BL       HAL_MutexLock
   1522              c->keepalive_probes = 0;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xF884 0x0020      STRB     R0,[R4, #+32]
   1523              HAL_MutexUnlock(c->lock_generic);
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0x....'....        BL       HAL_MutexUnlock
   1524              HAL_MutexLock(c->lock_read_buf);
   \       0x9E   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0xA2   0x....'....        BL       HAL_MutexLock
   1525              switch (packetType) {
   \       0xA6   0x9800             LDR      R0,[SP, #+0]
   \       0xA8   0x2802             CMP      R0,#+2
   \       0xAA   0xD00E             BEQ.N    ??iotx_mc_cycle_6
   \       0xAC   0x2803             CMP      R0,#+3
   \       0xAE   0xD01A             BEQ.N    ??iotx_mc_cycle_7
   \       0xB0   0x2804             CMP      R0,#+4
   \       0xB2   0xD006             BEQ.N    ??iotx_mc_cycle_8
   \       0xB4   0x2809             CMP      R0,#+9
   \       0xB6   0xD011             BEQ.N    ??iotx_mc_cycle_9
   \       0xB8   0x280B             CMP      R0,#+11
   \       0xBA   0xD019             BEQ.N    ??iotx_mc_cycle_10
   \       0xBC   0x280D             CMP      R0,#+13
   \       0xBE   0xD004             BEQ.N    ??iotx_mc_cycle_6
   \       0xC0   0xE01B             B.N      ??iotx_mc_cycle_11
   1526                  case CONNACK: {
   1527                      mqtt_debug("CONNACK");
   1528                      break;
   1529                  }
   1530          #if !WITH_MQTT_ONLY_QOS0
   1531                  case PUBACK: {
   1532                      mqtt_debug("PUBACK");
   1533                      rc = iotx_mc_handle_recv_PUBACK(c);
   \                     ??iotx_mc_cycle_8: (+1)
   \       0xC2   0x4620             MOV      R0,R4
   \       0xC4   0x....'....        BL       iotx_mc_handle_recv_PUBACK
   \       0xC8   0x4605             MOV      R5,R0
   1534                      if (SUCCESS_RETURN != rc) {
   1535                          mqtt_err("recvPubackProc error,result = %d", rc);
   1536                      }
   1537          
   1538                      break;
   1539                  }
   1540          #endif
   1541                  case SUBACK: {
   1542                      mqtt_debug("SUBACK");
   1543                      rc = iotx_mc_handle_recv_SUBACK(c);
   1544                      if (SUCCESS_RETURN != rc) {
   1545                          mqtt_err("recvSubAckProc error,result = %d", rc);
   1546                      }
   1547                      break;
   1548                  }
   1549                  case PUBLISH: {
   1550                      mqtt_debug("PUBLISH");
   1551                      /* HEXDUMP_DEBUG(c->buf_read, 32); */
   1552          
   1553                      rc = iotx_mc_handle_recv_PUBLISH(c);
   1554                      if (SUCCESS_RETURN != rc) {
   1555                          mqtt_err("recvPublishProc error,result = %d", rc);
   1556                      }
   1557                      break;
   1558                  }
   1559                  case UNSUBACK: {
   1560                      mqtt_debug("UNSUBACK");
   1561                      rc = iotx_mc_handle_recv_UNSUBACK(c);
   1562                      if (SUCCESS_RETURN != rc) {
   1563                          mqtt_err("recvUnsubAckProc error,result = %d", rc);
   1564                      }
   1565                      break;
   1566                  }
   1567                  case PINGRESP: {
   1568                      rc = SUCCESS_RETURN;
   1569                      mqtt_info("receive ping response!");
   1570                      break;
   1571                  }
   1572                  default:
   1573                      mqtt_err("INVALID TYPE");
   1574                      _reset_recv_buffer(c);
   1575                      HAL_MutexUnlock(c->lock_read_buf);
   1576                      return FAIL_RETURN;
   1577              }
   1578              _reset_recv_buffer(c);
   \                     ??iotx_mc_cycle_6: (+1)
   \       0xCA   0x4620             MOV      R0,R4
   \       0xCC   0x....'....        BL       _reset_recv_buffer
   1579              HAL_MutexUnlock(c->lock_read_buf);
   \       0xD0   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0xD4   0x....'....        BL       HAL_MutexUnlock
   1580              return rc;
   \       0xD8   0x4628             MOV      R0,R5
   \       0xDA   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??iotx_mc_cycle_9: (+1)
   \       0xDC   0x4620             MOV      R0,R4
   \       0xDE   0x....'....        BL       iotx_mc_handle_recv_SUBACK
   \       0xE2   0x4605             MOV      R5,R0
   \       0xE4   0xE7F1             B.N      ??iotx_mc_cycle_6
   \                     ??iotx_mc_cycle_7: (+1)
   \       0xE6   0x4620             MOV      R0,R4
   \       0xE8   0x....'....        BL       iotx_mc_handle_recv_PUBLISH
   \       0xEC   0x4605             MOV      R5,R0
   \       0xEE   0xE7EC             B.N      ??iotx_mc_cycle_6
   \                     ??iotx_mc_cycle_10: (+1)
   \       0xF0   0x4620             MOV      R0,R4
   \       0xF2   0x....'....        BL       iotx_mc_handle_recv_UNSUBACK
   \       0xF6   0x4605             MOV      R5,R0
   \       0xF8   0xE7E7             B.N      ??iotx_mc_cycle_6
   \                     ??iotx_mc_cycle_11: (+1)
   \       0xFA   0x4620             MOV      R0,R4
   \       0xFC   0x....'....        BL       _reset_recv_buffer
   \      0x100   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x104   0x....'....        BL       HAL_MutexUnlock
   \      0x108   0xF04F 0x30FF      MOV      R0,#-1
   \      0x10C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1581          }
   1582          

   \                                 In section .text, align 2, keep-with-next
   1583          void _mqtt_cycle(void *client)
   1584          {
   \                     _mqtt_cycle: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1585              int                 rc = SUCCESS_RETURN;
   1586              iotx_time_t         time;
   1587              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
   1588          
   1589              iotx_time_init(&time);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....'....        BL       iotx_time_init
   1590              utils_time_countdown_ms(&time, pClient->cycle_timeout_ms);
   \        0xA   0x68E1             LDR      R1,[R4, #+12]
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x....'....        BL       utils_time_countdown_ms
   1591          
   1592              do {
   1593                  unsigned int left_t;
   1594          
   1595                  if (SUCCESS_RETURN != rc) {
   1596                      mqtt_err("error occur rc=%d", rc);
   1597                  }
   1598          
   1599                  HAL_MutexLock(pClient->lock_yield);
   \                     ??_mqtt_cycle_0: (+1)
   \       0x12   0xF8D4 0x00DC      LDR      R0,[R4, #+220]
   \       0x16   0x....'....        BL       HAL_MutexLock
   1600          
   1601                  /* acquire package in cycle, such as PINGRESP or PUBLISH */
   1602                  rc = iotx_mc_cycle(pClient, &time);
   1603                  if (SUCCESS_RETURN == rc) {
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       iotx_mc_cycle
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD102             BNE.N    ??_mqtt_cycle_1
   1604          #ifndef ASYNC_PROTOCOL_STACK
   1605          #if !WITH_MQTT_ONLY_QOS0
   1606                      /* check list of wait publish ACK to remove node that is ACKED or timeout */
   1607                      MQTTPubInfoProc(pClient);
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       MQTTPubInfoProc
   1608          #endif
   1609          #endif
   1610                  }
   1611                  HAL_MutexUnlock(pClient->lock_yield);
   \                     ??_mqtt_cycle_1: (+1)
   \       0x2C   0xF8D4 0x00DC      LDR      R0,[R4, #+220]
   \       0x30   0x....'....        BL       HAL_MutexUnlock
   1612          
   1613                  left_t = iotx_time_left(&time);
   \       0x34   0x4668             MOV      R0,SP
   \       0x36   0x....'....        BL       iotx_time_left
   1614                  if (left_t < 10) {
   \       0x3A   0x280A             CMP      R0,#+10
   \       0x3C   0xD202             BCS.N    ??_mqtt_cycle_2
   1615                      HAL_SleepMs(left_t);
   \       0x3E   0x....'....        BL       HAL_SleepMs
   \       0x42   0xE002             B.N      ??_mqtt_cycle_3
   1616                  } else {
   1617                      HAL_SleepMs(10);
   \                     ??_mqtt_cycle_2: (+1)
   \       0x44   0x200A             MOVS     R0,#+10
   \       0x46   0x....'....        BL       HAL_SleepMs
   1618                  }
   1619              } while (!utils_time_is_expired(&time));
   \                     ??_mqtt_cycle_3: (+1)
   \       0x4A   0x4668             MOV      R0,SP
   \       0x4C   0x....'....        BL       utils_time_is_expired
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD0DE             BEQ.N    ??_mqtt_cycle_0
   1620          }
   \       0x54   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1621          

   \                                 In section .text, align 2, keep-with-next
   1622          static int MQTTKeepalive(iotx_mc_client_t *pClient)
   1623          {
   \                     MQTTKeepalive: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1624              int len = 0;
   1625              int rc = 0;
   1626              /* there is no ping outstanding - send ping packet */
   1627              iotx_time_t timer;
   1628          
   1629              if (!pClient) {
   \        0x4   0xD102             BNE.N    ??MQTTKeepalive_0
   1630                  return FAIL_RETURN;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD16             POP      {R1,R2,R4,PC}
   1631              }
   1632          
   1633              iotx_time_init(&timer);
   \                     ??MQTTKeepalive_0: (+1)
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x....'....        BL       iotx_time_init
   1634              utils_time_countdown_ms(&timer, 1000);
   \       0x12   0xF44F 0x717A      MOV      R1,#+1000
   \       0x16   0x4668             MOV      R0,SP
   \       0x18   0x....'....        BL       utils_time_countdown_ms
   1635          
   1636              HAL_MutexLock(pClient->lock_write_buf);
   \       0x1C   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x20   0x....'....        BL       HAL_MutexLock
   1637              rc = _alloc_send_buffer(pClient, 0);
   1638              if (rc < 0) {
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       _alloc_send_buffer
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD506             BPL.N    ??MQTTKeepalive_1
   1639                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x30   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x34   0x....'....        BL       HAL_MutexUnlock
   1640                  return FAIL_RETURN;
   \       0x38   0xF04F 0x30FF      MOV      R0,#-1
   \       0x3C   0xBD16             POP      {R1,R2,R4,PC}
   1641              }
   1642          
   1643              len = MQTTSerialize_pingreq((unsigned char *)pClient->buf_send, pClient->buf_size_send);
   \                     ??MQTTKeepalive_1: (+1)
   \       0x3E   0x6921             LDR      R1,[R4, #+16]
   \       0x40   0x6A60             LDR      R0,[R4, #+36]
   \       0x42   0x....'....        BL       MQTTSerialize_pingreq
   \       0x46   0x4602             MOV      R2,R0
   1644              mqtt_debug("len = MQTTSerialize_pingreq() = %d", len);
   1645          
   1646              if (len <= 0) {
   \       0x48   0x2A01             CMP      R2,#+1
   \       0x4A   0xDA09             BGE.N    ??MQTTKeepalive_2
   1647                  mqtt_err("Serialize ping request is error");
   1648                  _reset_send_buffer(pClient);
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x....'....        BL       _reset_send_buffer
   1649                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x52   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x56   0x....'....        BL       HAL_MutexUnlock
   1650                  return MQTT_PING_PACKET_ERROR;
   \       0x5A   0xF06F 0x001E      MVN      R0,#+30
   \       0x5E   0xBD16             POP      {R1,R2,R4,PC}
   1651              }
   1652          
   1653              rc = iotx_mc_send_packet(pClient, pClient->buf_send, len, &timer);
   1654              if (SUCCESS_RETURN != rc) {
   \                     ??MQTTKeepalive_2: (+1)
   \       0x60   0x466B             MOV      R3,SP
   \       0x62   0x6A61             LDR      R1,[R4, #+36]
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x....'....        BL       iotx_mc_send_packet
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0xD008             BEQ.N    ??MQTTKeepalive_3
   1655                  /* ping outstanding, then close socket unsubscribe topic and handle callback function */
   1656                  mqtt_err("ping outstanding is error,result = %d", rc);
   1657          
   1658                  _reset_send_buffer(pClient);
   \       0x70   0x....'....        BL       _reset_send_buffer
   1659                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x74   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x78   0x....'....        BL       HAL_MutexUnlock
   1660                  return MQTT_NETWORK_ERROR;
   \       0x7C   0xF06F 0x000D      MVN      R0,#+13
   \       0x80   0xBD16             POP      {R1,R2,R4,PC}
   1661              }
   1662              _reset_send_buffer(pClient);
   \                     ??MQTTKeepalive_3: (+1)
   \       0x82   0x....'....        BL       _reset_send_buffer
   1663              HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x86   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x8A   0x....'....        BL       HAL_MutexUnlock
   1664              return SUCCESS_RETURN;
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1665          }
   1666          

   \                                 In section .text, align 2, keep-with-next
   1667          static int iotx_mc_keepalive_sub(iotx_mc_client_t *pClient)
   1668          {
   \                     iotx_mc_keepalive_sub: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1669          
   1670              int rc = SUCCESS_RETURN;
   1671          
   1672              if (NULL == pClient) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_keepalive_sub_0
   1673                  return NULL_VALUE_ERROR;
   \        0x6   0xF06F 0x0001      MVN      R0,#+1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   1674              }
   1675          
   1676              /* if in disabled state, without having to send ping packets */
   1677              if (!wrapper_mqtt_check_state(pClient)) {
   \                     ??iotx_mc_keepalive_sub_0: (+1)
   \        0xC   0x....'....        BL       wrapper_mqtt_check_state
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD005             BEQ.N    ??iotx_mc_keepalive_sub_1
   1678                  return SUCCESS_RETURN;
   1679              }
   1680          
   1681              /* if there is no ping_timer timeout, then return success */
   1682              if (!utils_time_is_expired(&pClient->next_ping_time)) {
   \       0x14   0xF105 0x0058      ADD      R0,R5,#+88
   \       0x18   0x....'....        BL       utils_time_is_expired
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD101             BNE.N    ??iotx_mc_keepalive_sub_2
   1683                  return SUCCESS_RETURN;
   \                     ??iotx_mc_keepalive_sub_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
   1684              }
   1685          
   1686              /* update to next time sending MQTT keep-alive */
   1687              utils_time_countdown_ms(&pClient->next_ping_time, pClient->connect_data.keepAliveInterval * 1000);
   \                     ??iotx_mc_keepalive_sub_2: (+1)
   \       0x24   0xF8B5 0x1080      LDRH     R1,[R5, #+128]
   \       0x28   0xF44F 0x707A      MOV      R0,#+1000
   \       0x2C   0x4341             MULS     R1,R0,R1
   \       0x2E   0xF105 0x0058      ADD      R0,R5,#+88
   \       0x32   0x....'....        BL       utils_time_countdown_ms
   1688          
   1689              rc = MQTTKeepalive(pClient);
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x....'....        BL       MQTTKeepalive
   \       0x3C   0x0004             MOVS     R4,R0
   1690              if (SUCCESS_RETURN != rc) {
   \       0x3E   0xD008             BEQ.N    ??iotx_mc_keepalive_sub_3
   1691                  if (rc == MQTT_NETWORK_ERROR) {
   \       0x40   0xF114 0x0F0E      CMN      R4,#+14
   \       0x44   0xD103             BNE.N    ??iotx_mc_keepalive_sub_4
   1692                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED);
   \       0x46   0x2103             MOVS     R1,#+3
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x....'....        BL       iotx_mc_set_client_state
   1693                  }
   1694                  mqtt_err("ping outstanding is error,result = %d", rc);
   1695                  return rc;
   \                     ??iotx_mc_keepalive_sub_4: (+1)
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0xBD32             POP      {R1,R4,R5,PC}
   1696              }
   1697          
   1698              mqtt_info("send MQTT ping...");
   1699          
   1700              HAL_MutexLock(pClient->lock_generic);
   \                     ??iotx_mc_keepalive_sub_3: (+1)
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x....'....        BL       HAL_MutexLock
   1701              pClient->keepalive_probes++;
   \       0x58   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x5C   0x1C40             ADDS     R0,R0,#+1
   \       0x5E   0xF885 0x0020      STRB     R0,[R5, #+32]
   1702              HAL_MutexUnlock(pClient->lock_generic);
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x....'....        BL       HAL_MutexUnlock
   1703          
   1704              return SUCCESS_RETURN;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1705          }
   1706          

   \                                 In section .text, align 2, keep-with-next
   1707          static int iotx_mc_attempt_reconnect(iotx_mc_client_t *pClient)
   1708          {
   \                     iotx_mc_attempt_reconnect: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1709              int rc;
   1710              if (pClient == NULL) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_attempt_reconnect_0
   1711                  return NULL_VALUE_ERROR;
   \        0x6   0xF06F 0x0001      MVN      R0,#+1
   \        0xA   0xBD10             POP      {R4,PC}
   1712              }
   1713          
   1714              pClient->ipstack.disconnect(&pClient->ipstack);
   \                     ??iotx_mc_attempt_reconnect_0: (+1)
   \        0xC   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x10   0x6D21             LDR      R1,[R4, #+80]
   \       0x12   0x4788             BLX      R1
   1715          
   1716              mqtt_info("reconnect params: MQTTVersion=%d, clientID=%s, keepAliveInterval=%d, username=%s",
   1717                        pClient->connect_data.MQTTVersion,
   1718                        pClient->connect_data.clientID.cstring,
   1719                        pClient->connect_data.keepAliveInterval,
   1720                        pClient->connect_data.username.cstring);
   1721          
   1722              /* Ignoring return code. failures expected if network is disconnected */
   1723              rc = wrapper_mqtt_connect(pClient);
   1724          
   1725              if (SUCCESS_RETURN != rc && MQTT_CONNECT_BLOCK != rc) {
   1726                  mqtt_err("run iotx_mqtt_connect() error!");
   1727              }
   1728          
   1729              return rc;
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1A   0x....'....        B.W      wrapper_mqtt_connect
   1730          }
   1731          

   \                                 In section .text, align 2, keep-with-next
   1732          static int iotx_mc_handle_reconnect(iotx_mc_client_t *pClient)
   1733          {
   \                     iotx_mc_handle_reconnect: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1734              int             rc = FAIL_RETURN;
   1735              uint32_t        interval_ms = 0;
   1736          
   1737              if (NULL == pClient) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_handle_reconnect_0
   1738                  return NULL_VALUE_ERROR;
   \        0x6   0xF06F 0x0001      MVN      R0,#+1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   1739              }
   1740              mqtt_info("Waiting to reconnect...");
   1741              if (!utils_time_is_expired(&(pClient->reconnect_param.reconnect_next_time))) {
   \                     ??iotx_mc_handle_reconnect_0: (+1)
   \        0xC   0xF105 0x0060      ADD      R0,R5,#+96
   \       0x10   0x....'....        BL       utils_time_is_expired
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??iotx_mc_handle_reconnect_1
   1742                  /* Timer has not expired. Not time to attempt reconnect yet. Return attempting reconnect */
   1743                  HAL_SleepMs(100);
   \       0x18   0x2064             MOVS     R0,#+100
   \       0x1A   0x....'....        BL       HAL_SleepMs
   1744                  return FAIL_RETURN;
   \       0x1E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
   1745              }
   1746          
   1747              mqtt_info("start to reconnect");
   1748              /*
   1749                  rc = _conn_info_dynamic_reload(pClient);
   1750                  if (SUCCESS_RETURN != rc) {
   1751                      mqtt_err("update connect info err");
   1752                      return -1;
   1753                  }
   1754              */
   1755              rc = iotx_mc_attempt_reconnect(pClient);
   \                     ??iotx_mc_handle_reconnect_1: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x....'....        BL       iotx_mc_attempt_reconnect
   \       0x2A   0x0004             MOVS     R4,R0
   1756              if (SUCCESS_RETURN == rc) {
   \       0x2C   0xD105             BNE.N    ??iotx_mc_handle_reconnect_2
   1757                  iotx_mc_set_client_state(pClient, IOTX_MC_STATE_CONNECTED);
   \       0x2E   0x2102             MOVS     R1,#+2
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x....'....        BL       iotx_mc_set_client_state
   1758                  /*
   1759                          _conn_info_dynamic_reload_clear(pClient);
   1760                  */
   1761                  return SUCCESS_RETURN;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
   1762              } else if (MQTT_CONNECT_BLOCK == rc) {
   \                     ??iotx_mc_handle_reconnect_2: (+1)
   \       0x3A   0xF06F 0x002B      MVN      R0,#+43
   \       0x3E   0x4284             CMP      R4,R0
   \       0x40   0xD013             BEQ.N    ??iotx_mc_handle_reconnect_3
   1763                  return rc;
   1764              } else {
   1765                  /* if reconnect network failed, then increase currentReconnectWaitInterval */
   1766                  /* e.g. init currentReconnectWaitInterval=1s, reconnect failed, then 2s..4s..8s */
   1767                  if (IOTX_MC_RECONNECT_INTERVAL_MAX_MS > pClient->reconnect_param.reconnect_time_interval_ms) {
   \       0x42   0xF64E 0x2060      MOVW     R0,#+60000
   \       0x46   0x6E69             LDR      R1,[R5, #+100]
   \       0x48   0x4281             CMP      R1,R0
   \       0x4A   0xD202             BCS.N    ??iotx_mc_handle_reconnect_4
   1768                      pClient->reconnect_param.reconnect_time_interval_ms *= 2;
   \       0x4C   0x0049             LSLS     R1,R1,#+1
   \       0x4E   0x6669             STR      R1,[R5, #+100]
   \       0x50   0xE000             B.N      ??iotx_mc_handle_reconnect_5
   1769                  } else {
   1770                      pClient->reconnect_param.reconnect_time_interval_ms = IOTX_MC_RECONNECT_INTERVAL_MAX_MS;
   \                     ??iotx_mc_handle_reconnect_4: (+1)
   \       0x52   0x6668             STR      R0,[R5, #+100]
   1771                  }
   1772              }
   1773              /*
   1774                  _conn_info_dynamic_reload_clear(pClient);
   1775              */
   1776              interval_ms = pClient->reconnect_param.reconnect_time_interval_ms;
   \                     ??iotx_mc_handle_reconnect_5: (+1)
   \       0x54   0x6E69             LDR      R1,[R5, #+100]
   1777              if (IOTX_MC_RECONNECT_INTERVAL_MAX_MS < interval_ms) {
   \       0x56   0xF64E 0x2261      MOVW     R2,#+60001
   \       0x5A   0x4291             CMP      R1,R2
   \       0x5C   0xD300             BCC.N    ??iotx_mc_handle_reconnect_6
   1778                  interval_ms = IOTX_MC_RECONNECT_INTERVAL_MAX_MS;
   \       0x5E   0x4601             MOV      R1,R0
   1779              }
   1780              utils_time_countdown_ms(&(pClient->reconnect_param.reconnect_next_time), interval_ms);
   \                     ??iotx_mc_handle_reconnect_6: (+1)
   \       0x60   0xF105 0x0060      ADD      R0,R5,#+96
   \       0x64   0x....'....        BL       utils_time_countdown_ms
   1781          
   1782              mqtt_err("mqtt reconnect failed rc = %d", rc);
   1783          
   1784              return rc;
   \       0x68   0x4620             MOV      R0,R4
   \                     ??iotx_mc_handle_reconnect_3: (+1)
   \       0x6A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1785          }
   1786          

   \                                 In section .text, align 2, keep-with-next
   1787          static void iotx_mc_reconnect_callback(iotx_mc_client_t *pClient)
   1788          {
   \                     iotx_mc_reconnect_callback: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xF8D1 0x00E0      LDR      R0,[R1, #+224]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD100             BNE.N    ??iotx_mc_reconnect_callback_0
   \        0xA   0x4770             BX       LR
   \                     ??iotx_mc_reconnect_callback_0: (+1)
   \        0xC   0xB5E0             PUSH     {R5-R7,LR}
   1789          
   1790              /* handle callback function */
   1791              if (NULL != pClient->handle_event.h_fp) {
   1792                  iotx_mqtt_event_msg_t msg;
   1793                  msg.event_type = IOTX_MQTT_EVENT_RECONNECT;
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1794                  msg.msg = NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9001             STR      R0,[SP, #+4]
   1795          
   1796                  pClient->handle_event.h_fp(pClient->handle_event.pcontext,
   1797                                             pClient,
   1798                                             &msg);
   \       0x18   0x466A             MOV      R2,SP
   \       0x1A   0xF8D1 0x00E4      LDR      R0,[R1, #+228]
   \       0x1E   0xF8D1 0x30E0      LDR      R3,[R1, #+224]
   \       0x22   0x4798             BLX      R3
   1799              }
   1800          }
   \       0x24   0xBD07             POP      {R0-R2,PC}       ;; return
   1801          

   \                                 In section .text, align 2, keep-with-next
   1802          static void iotx_mc_disconnect_callback(iotx_mc_client_t *pClient)
   1803          {
   \                     iotx_mc_disconnect_callback: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xF8D1 0x00E0      LDR      R0,[R1, #+224]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD100             BNE.N    ??iotx_mc_disconnect_callback_0
   \        0xA   0x4770             BX       LR
   \                     ??iotx_mc_disconnect_callback_0: (+1)
   \        0xC   0xB5E0             PUSH     {R5-R7,LR}
   1804          
   1805              if (NULL != pClient->handle_event.h_fp) {
   1806                  iotx_mqtt_event_msg_t msg;
   1807                  msg.event_type = IOTX_MQTT_EVENT_DISCONNECT;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1808                  msg.msg = NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9001             STR      R0,[SP, #+4]
   1809          
   1810                  pClient->handle_event.h_fp(pClient->handle_event.pcontext,
   1811                                             pClient,
   1812                                             &msg);
   \       0x18   0x466A             MOV      R2,SP
   \       0x1A   0xF8D1 0x00E4      LDR      R0,[R1, #+228]
   \       0x1E   0xF8D1 0x30E0      LDR      R3,[R1, #+224]
   \       0x22   0x4798             BLX      R3
   1813              }
   1814          }
   \       0x24   0xBD07             POP      {R0-R2,PC}       ;; return
   1815          

   \                                 In section .text, align 2, keep-with-next
   1816          static void iotx_mc_keepalive(iotx_mc_client_t *pClient)
   1817          {
   \                     iotx_mc_keepalive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1818              int rc = 0;
   1819              iotx_mc_state_t currentState;
   1820          
   1821              if (!pClient) {
   \        0x4   0xD02B             BEQ.N    ??iotx_mc_keepalive_0
   1822                  return;
   1823              }
   1824          
   1825              /* Periodic sending ping packet to detect whether the network is connected */
   1826              iotx_mc_keepalive_sub(pClient);
   \        0x6   0x....'....        BL       iotx_mc_keepalive_sub
   1827          
   1828              currentState = iotx_mc_get_client_state(pClient);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x....'....        BL       iotx_mc_get_client_state
   1829              do {
   1830                  /* if Exceeds the maximum delay time, then return reconnect timeout */
   1831                  if (IOTX_MC_STATE_DISCONNECTED_RECONNECTING == currentState ||
   1832                      IOTX_MC_STATE_CONNECT_BLOCK == currentState) {
   \       0x10   0x2804             CMP      R0,#+4
   \       0x12   0xD001             BEQ.N    ??iotx_mc_keepalive_1
   \       0x14   0x2805             CMP      R0,#+5
   \       0x16   0xD10B             BNE.N    ??iotx_mc_keepalive_2
   1833                      /* Reconnection is successful, Resume regularly ping packets */
   1834                      rc = iotx_mc_handle_reconnect(pClient);
   1835                      if (SUCCESS_RETURN != rc) {
   \                     ??iotx_mc_keepalive_1: (+1)
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x....'....        BL       iotx_mc_handle_reconnect
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD11D             BNE.N    ??iotx_mc_keepalive_0
   1836                          mqtt_err("reconnect network fail, rc = %d", rc);
   1837                      } else if (MQTT_CONNECT_BLOCK == rc) {
   1838                          mqtt_debug("now using async protocol stack, wait network connected...");
   1839                      } else {
   1840                          mqtt_info("network is reconnected!");
   1841                          iotx_mc_reconnect_callback(pClient);
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x....'....        BL       iotx_mc_reconnect_callback
   1842                          pClient->reconnect_param.reconnect_time_interval_ms = IOTX_MC_RECONNECT_INTERVAL_MIN_MS;
   \       0x28   0xF44F 0x707A      MOV      R0,#+1000
   \       0x2C   0x6660             STR      R0,[R4, #+100]
   \       0x2E   0xBD10             POP      {R4,PC}
   1843                      }
   1844          
   1845                      break;
   1846                  }
   1847          
   1848                  /* If network suddenly interrupted, stop pinging packet, try to reconnect network immediately */
   1849                  if (IOTX_MC_STATE_DISCONNECTED == currentState) {
   \                     ??iotx_mc_keepalive_2: (+1)
   \       0x30   0x2803             CMP      R0,#+3
   \       0x32   0xD114             BNE.N    ??iotx_mc_keepalive_0
   1850                      mqtt_err("network is disconnected!");
   1851                      iotx_mc_disconnect_callback(pClient);
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       iotx_mc_disconnect_callback
   1852          
   1853                      pClient->reconnect_param.reconnect_time_interval_ms = IOTX_MC_RECONNECT_INTERVAL_MIN_MS;
   \       0x3A   0xF44F 0x707A      MOV      R0,#+1000
   \       0x3E   0x6660             STR      R0,[R4, #+100]
   1854                      utils_time_countdown_ms(&(pClient->reconnect_param.reconnect_next_time),
   1855                                              pClient->reconnect_param.reconnect_time_interval_ms);
   \       0x40   0x4601             MOV      R1,R0
   \       0x42   0xF104 0x0060      ADD      R0,R4,#+96
   \       0x46   0x....'....        BL       utils_time_countdown_ms
   1856          
   1857                      pClient->ipstack.disconnect(&pClient->ipstack);
   \       0x4A   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x4E   0x6D21             LDR      R1,[R4, #+80]
   \       0x50   0x4788             BLX      R1
   1858                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED_RECONNECTING);
   \       0x52   0x2104             MOVS     R1,#+4
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0xE8BD 0x4010      POP      {R4,LR}
   \       0x5A   0x....'....        B.W      iotx_mc_set_client_state
   1859                      break;
   1860                  }
   1861          
   1862              } while (0);
   1863          }
   \                     ??iotx_mc_keepalive_0: (+1)
   \       0x5E   0xBD10             POP      {R4,PC}          ;; return
   1864          

   \                                 In section .text, align 2, keep-with-next
   1865          static int iotx_mc_check_handle_is_identical_ex(iotx_mc_topic_handle_t *messageHandlers1,
   1866                  iotx_mc_topic_handle_t *messageHandler2)
   1867          {
   \                     iotx_mc_check_handle_is_identical_ex: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   1868              int topicNameLen = 0;
   1869          
   1870              if (!messageHandlers1 || !messageHandler2) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_ex_0
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??iotx_mc_check_handle_is_identical_ex_1
   1871                  return 1;
   \                     ??iotx_mc_check_handle_is_identical_ex_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xBD70             POP      {R4-R6,PC}
   1872              }
   1873          
   1874              if (!(messageHandlers1->topic_filter) || !(messageHandler2->topic_filter)) {
   \                     ??iotx_mc_check_handle_is_identical_ex_1: (+1)
   \       0x12   0x68E8             LDR      R0,[R5, #+12]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??iotx_mc_check_handle_is_identical_ex_2
   \       0x18   0x68E0             LDR      R0,[R4, #+12]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD101             BNE.N    ??iotx_mc_check_handle_is_identical_ex_3
   1875                  return 1;
   \                     ??iotx_mc_check_handle_is_identical_ex_2: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xBD70             POP      {R4-R6,PC}
   1876              }
   1877          
   1878          #if !(WITH_MQTT_ZIP_TOPIC)
   1879              topicNameLen = strlen(messageHandlers1->topic_filter);
   \                     ??iotx_mc_check_handle_is_identical_ex_3: (+1)
   \       0x22   0x68E8             LDR      R0,[R5, #+12]
   \       0x24   0x....'....        BL       strlen
   \       0x28   0x4606             MOV      R6,R0
   1880          
   1881              if (topicNameLen != strlen(messageHandler2->topic_filter)) {
   \       0x2A   0x68E0             LDR      R0,[R4, #+12]
   \       0x2C   0x....'....        BL       strlen
   \       0x30   0x4286             CMP      R6,R0
   \       0x32   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_ex_4
   1882                  return 1;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD70             POP      {R4-R6,PC}
   1883              }
   1884          
   1885              if (0 != strncmp(messageHandlers1->topic_filter, messageHandler2->topic_filter, topicNameLen)) {
   \                     ??iotx_mc_check_handle_is_identical_ex_4: (+1)
   \       0x38   0x4632             MOV      R2,R6
   \       0x3A   0x68E1             LDR      R1,[R4, #+12]
   \       0x3C   0x68E8             LDR      R0,[R5, #+12]
   \       0x3E   0x....'....        BL       strncmp
   \       0x42   0x1E40             SUBS     R0,R0,#+1
   \       0x44   0x4180             SBCS     R0,R0,R0
   \       0x46   0x43C0             MVNS     R0,R0
   \       0x48   0x0FC0             LSRS     R0,R0,#+31
   1886                  return 1;
   1887              }
   1888          #else
   1889          
   1890              if (messageHandlers1->topic_type != messageHandler2->topic_type) {
   1891                  return 1;
   1892              }
   1893          
   1894              if (messageHandlers1->topic_type == TOPIC_NAME_TYPE) {
   1895                  int i;
   1896                  for (i = 0; i < MQTT_ZIP_PATH_DEFAULT_LEN; i++) {
   1897                      if (messageHandler2->topic_filter[i] != messageHandlers1->topic_filter[i]) {
   1898                          return 1;
   1899                      }
   1900                  }
   1901              } else {
   1902                  topicNameLen = strlen(messageHandlers1->topic_filter);
   1903          
   1904                  if (topicNameLen != strlen(messageHandler2->topic_filter)) {
   1905                      return 1;
   1906                  }
   1907          
   1908                  if (0 != strncmp(messageHandlers1->topic_filter, messageHandler2->topic_filter, topicNameLen)) {
   1909                      return 1;
   1910                  }
   1911              }
   1912          #endif
   1913          
   1914              return 0;
   \       0x4A   0xBD70             POP      {R4-R6,PC}       ;; return
   1915          }
   1916          

   \                                 In section .text, align 2, keep-with-next
   1917          static int iotx_mc_check_handle_is_identical(iotx_mc_topic_handle_t *messageHandlers1,
   1918                  iotx_mc_topic_handle_t *messageHandler2)
   1919          {
   \                     iotx_mc_check_handle_is_identical: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1920              if (iotx_mc_check_handle_is_identical_ex(messageHandlers1, messageHandler2) != 0) {
   \        0x6   0x....'....        BL       iotx_mc_check_handle_is_identical_ex
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_0
   1921                  return 1;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
   1922              }
   1923          
   1924              if (messageHandlers1->handle.h_fp != messageHandler2->handle.h_fp) {
   \                     ??iotx_mc_check_handle_is_identical_0: (+1)
   \       0x12   0x6860             LDR      R0,[R4, #+4]
   \       0x14   0x6869             LDR      R1,[R5, #+4]
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_1
   1925                  return 1;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xBD32             POP      {R1,R4,R5,PC}
   1926              }
   1927          
   1928              /* context must be identical also */
   1929              if (messageHandlers1->handle.pcontext != messageHandler2->handle.pcontext) {
   \                     ??iotx_mc_check_handle_is_identical_1: (+1)
   \       0x1E   0x68A0             LDR      R0,[R4, #+8]
   \       0x20   0x68A9             LDR      R1,[R5, #+8]
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_2
   1930                  return 1;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}
   1931              }
   1932          
   1933              return 0;
   \                     ??iotx_mc_check_handle_is_identical_2: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1934          }
   1935          

   \                                 In section .text, align 2, keep-with-next
   1936          static int MQTTSubscribe(iotx_mc_client_t *c, const char *topicFilter, iotx_mqtt_qos_t qos, unsigned int msgId,
   1937                                   iotx_mqtt_event_handle_func_fpt messageHandler, void *pcontext)
   1938          {
   \                     MQTTSubscribe: (+1)
   \        0x0   0xE92D 0x43F6      PUSH     {R1,R2,R4-R9,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x461F             MOV      R7,R3
   1939              int                         len = 0;
   1940              iotx_time_t                 timer;
   1941              MQTTString                  topic = MQTTString_initializer;
   \        0xC   0xA804             ADD      R0,SP,#+16
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x460A             MOV      R2,R1
   \       0x12   0x460B             MOV      R3,R1
   \       0x14   0xE880 0x000E      STM      R0,{R1-R3}
   1942              /*iotx_mc_topic_handle_t handler = {topicFilter, {messageHandler, pcontext}};*/
   1943              iotx_mc_topic_handle_t     *handler = NULL;
   1944          #ifndef PLATFORM_HAS_DYNMEM
   1945              int idx = 0;
   1946          #endif
   1947          
   1948              if (!c || !topicFilter || !messageHandler) {
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD013             BEQ.N    ??MQTTSubscribe_0
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD011             BEQ.N    ??MQTTSubscribe_0
   \       0x20   0xF8DD 0x8040      LDR      R8,[SP, #+64]
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD00C             BEQ.N    ??MQTTSubscribe_0
   1949                  return FAIL_RETURN;
   1950              }
   1951          #if !( WITH_MQTT_DYN_BUF)
   1952              if (!c->buf_send) {
   1953                  return FAIL_RETURN;
   1954              }
   1955          #endif
   1956          
   1957              topic.cstring = (char *)topicFilter;
   \       0x2A   0x9604             STR      R6,[SP, #+16]
   1958              iotx_time_init(&timer);
   \       0x2C   0xA803             ADD      R0,SP,#+12
   \       0x2E   0x....'....        BL       iotx_time_init
   1959              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x32   0x68A1             LDR      R1,[R4, #+8]
   \       0x34   0xA803             ADD      R0,SP,#+12
   \       0x36   0x....'....        BL       utils_time_countdown_ms
   1960          
   1961          #ifdef PLATFORM_HAS_DYNMEM
   1962              handler = mqtt_malloc(sizeof(iotx_mc_topic_handle_t));
   \       0x3A   0x2018             MOVS     R0,#+24
   \       0x3C   0x....'....        BL       HAL_Malloc
   \       0x40   0x0005             MOVS     R5,R0
   1963              if (NULL == handler) {
   \       0x42   0xD102             BNE.N    ??MQTTSubscribe_1
   1964                  return FAIL_RETURN;
   \                     ??MQTTSubscribe_0: (+1)
   \       0x44   0xF04F 0x30FF      MOV      R0,#-1
   \       0x48   0xE0B7             B.N      ??MQTTSubscribe_2
   1965              }
   1966              memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   \                     ??MQTTSubscribe_1: (+1)
   \       0x4A   0x2200             MOVS     R2,#+0
   \       0x4C   0x2118             MOVS     R1,#+24
   \       0x4E   0x....'....        BL       __aeabi_memset4
   1967              INIT_LIST_HEAD(&handler->linked_list);
   \       0x52   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x56   0x....'....        BL       INIT_AOS_DLIST_HEAD
   1968          #else
   1969              for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   1970                  if (c->list_sub_handle[idx].used == 0) {
   1971                      handler = &c->list_sub_handle[idx];
   1972                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   1973                      c->list_sub_handle[idx].used = 1;
   1974                      break;
   1975                  }
   1976              }
   1977          
   1978              if (handler == NULL) {
   1979                  return MQTT_SUBHANDLE_LIST_LEN_TOO_SHORT;
   1980              }
   1981          #endif
   1982          
   1983          #if !(WITH_MQTT_ZIP_TOPIC)
   1984          #ifdef PLATFORM_HAS_DYNMEM
   1985              handler->topic_filter = mqtt_malloc(strlen(topicFilter) + 1);
   \       0x5A   0x4630             MOV      R0,R6
   \       0x5C   0x....'....        BL       strlen
   \       0x60   0x1C40             ADDS     R0,R0,#+1
   \       0x62   0x....'....        BL       HAL_Malloc
   \       0x66   0x60E8             STR      R0,[R5, #+12]
   1986              if (NULL == handler->topic_filter) {
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD105             BNE.N    ??MQTTSubscribe_3
   1987                  mqtt_free(handler);
   \       0x6C   0x4628             MOV      R0,R5
   \       0x6E   0x....'....        BL       HAL_Free
   1988                  return FAIL_RETURN;
   \       0x72   0xF04F 0x30FF      MOV      R0,#-1
   \       0x76   0xE0A0             B.N      ??MQTTSubscribe_2
   1989              }
   \                     ??MQTTSubscribe_3: (+1)
   \       0x78   0xF8DD 0x9044      LDR      R9,[SP, #+68]
   1990              memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);
   \       0x7C   0x4630             MOV      R0,R6
   \       0x7E   0x....'....        BL       strlen
   \       0x82   0x1C40             ADDS     R0,R0,#+1
   \       0x84   0x2200             MOVS     R2,#+0
   \       0x86   0x4601             MOV      R1,R0
   \       0x88   0x68E8             LDR      R0,[R5, #+12]
   \       0x8A   0x....'....        BL       __aeabi_memset
   1991          #else
   1992              if (strlen(topicFilter) >= CONFIG_MQTT_TOPIC_MAXLEN) {
   1993                  memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   1994                  return MQTT_TOPIC_LEN_TOO_SHORT;
   1995              }
   1996          
   1997              memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   1998          #endif
   1999              memcpy((char *)handler->topic_filter, topicFilter, strlen(topicFilter) + 1);
   \       0x8E   0x4630             MOV      R0,R6
   \       0x90   0x....'....        BL       strlen
   \       0x94   0x1C40             ADDS     R0,R0,#+1
   \       0x96   0x4602             MOV      R2,R0
   \       0x98   0x4631             MOV      R1,R6
   \       0x9A   0x68E8             LDR      R0,[R5, #+12]
   \       0x9C   0x....'....        BL       __aeabi_memcpy
   2000          #else
   2001              if (strstr(topicFilter, "/+") != NULL || strstr(topicFilter, "/#") != NULL) {
   2002          #ifdef PLATFORM_HAS_DYNMEM
   2003                  handler->topic_filter = mqtt_malloc(strlen(topicFilter) + 1);
   2004                  if (NULL == handler->topic_filter) {
   2005                      mqtt_free(handler);
   2006                      return FAIL_RETURN;
   2007                  }
   2008                  memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);
   2009          #else
   2010                  if (strlen(topicFilter) >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2011                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2012                      return MQTT_TOPIC_LEN_TOO_SHORT;
   2013                  }
   2014                  memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2015          #endif
   2016                  handler->topic_type = TOPIC_FILTER_TYPE;
   2017                  memcpy((char *)handler->topic_filter, topicFilter, strlen(topicFilter) + 1);
   2018              } else {
   2019          #ifdef PLATFORM_HAS_DYNMEM
   2020                  handler->topic_filter = mqtt_malloc(MQTT_ZIP_PATH_DEFAULT_LEN);
   2021                  if (NULL == handler->topic_filter) {
   2022                      mqtt_free(handler);
   2023                      return FAIL_RETURN;
   2024                  }
   2025                  memset((char *)handler->topic_filter, 0, MQTT_ZIP_PATH_DEFAULT_LEN);
   2026          #else
   2027                  if (MQTT_ZIP_PATH_DEFAULT_LEN >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2028                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2029                      return MQTT_TOPIC_LEN_TOO_SHORT;
   2030                  }
   2031                  memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2032          #endif
   2033                  handler->topic_type = TOPIC_NAME_TYPE;
   2034                  if (iotx_mc_get_zip_topic(topicFilter, strlen(topicFilter), (char *)handler->topic_filter,
   2035                                            MQTT_ZIP_PATH_DEFAULT_LEN) != 0) {
   2036          #ifdef PLATFORM_HAS_DYNMEM
   2037                      mqtt_free(handler->topic_filter);
   2038                      mqtt_free(handler);
   2039          #else
   2040                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2041          #endif
   2042                      return FAIL_RETURN;
   2043                  }
   2044              }
   2045          #endif
   2046              handler->handle.h_fp = messageHandler;
   \       0xA0   0xF8C5 0x8004      STR      R8,[R5, #+4]
   2047              handler->handle.pcontext = pcontext;
   \       0xA4   0xF8C5 0x9008      STR      R9,[R5, #+8]
   2048          
   2049          #ifdef SUB_PERSISTENCE_ENABLED
   2050              if (qos == IOTX_MQTT_QOS3_SUB_LOCAL) {
   2051                  uint8_t dup = 0;
   2052          #ifdef PLATFORM_HAS_DYNMEM
   2053                  iotx_mc_topic_handle_t *node;
   2054          #endif
   2055                  HAL_MutexLock(c->lock_generic);
   2056          #ifdef PLATFORM_HAS_DYNMEM
   2057          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2058          #if WITH_MQTT_ZIP_TOPIC
   2059                  HEXDUMP_DEBUG(handler->topic_filter, MQTT_ZIP_PATH_DEFAULT_LEN);
   2060          #else
   2061                  mqtt_warning("handler->topic: %s", handler->topic_filter);
   2062          #endif
   2063          #endif
   2064                  list_for_each_entry(node, &c->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   2065                      /* If subscribe the same topic and callback function, then ignore */
   2066          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2067          #if WITH_MQTT_ZIP_TOPIC
   2068                      HEXDUMP_DEBUG(node->topic_filter, MQTT_ZIP_PATH_DEFAULT_LEN);
   2069          #else
   2070                      mqtt_warning("node->topic: %s", node->topic_filter);
   2071          #endif
   2072          #endif
   2073                      if (0 == iotx_mc_check_handle_is_identical(node, handler)) {
   2074                          mqtt_warning("dup sub,topic = %s", topicFilter);
   2075                          dup = 1;
   2076                      }
   2077                  }
   2078          #else
   2079                  for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   2080                      /* If subscribe the same topic and callback function, then ignore */
   2081                      if (&c->list_sub_handle[idx] != handler &&
   2082                          0 == iotx_mc_check_handle_is_identical(&c->list_sub_handle[idx], handler)) {
   2083                          mqtt_warning("dup sub,topic = %s", topicFilter);
   2084                          dup = 1;
   2085                      }
   2086                  }
   2087          #endif
   2088                  if (dup == 0) {
   2089          #ifdef PLATFORM_HAS_DYNMEM
   2090                      list_add_tail(&handler->linked_list, &c->list_sub_handle);
   2091          #endif
   2092                  } else {
   2093          #ifdef PLATFORM_HAS_DYNMEM
   2094                      mqtt_free(handler->topic_filter);
   2095                      mqtt_free(handler);
   2096          #else
   2097                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2098          #endif
   2099                  }
   2100                  HAL_MutexUnlock(c->lock_generic);
   2101                  return SUCCESS_RETURN;
   2102              }
   2103          #endif
   2104          
   2105              HAL_MutexLock(c->lock_write_buf);
   \       0xA8   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xAC   0x....'....        BL       HAL_MutexLock
   2106          
   2107              if (_alloc_send_buffer(c, strlen(topicFilter)) < 0) {
   \       0xB0   0x4630             MOV      R0,R6
   \       0xB2   0x....'....        BL       strlen
   \       0xB6   0x4601             MOV      R1,R0
   \       0xB8   0x4620             MOV      R0,R4
   \       0xBA   0x....'....        BL       _alloc_send_buffer
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD50E             BPL.N    ??MQTTSubscribe_4
   2108                  HAL_MutexUnlock(c->lock_write_buf);
   \       0xC2   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xC6   0x....'....        BL       HAL_MutexUnlock
   2109          #ifdef PLATFORM_HAS_DYNMEM
   2110                  mqtt_free(handler->topic_filter);
   \       0xCA   0x68E8             LDR      R0,[R5, #+12]
   \       0xCC   0x....'....        BL       HAL_Free
   \       0xD0   0x2000             MOVS     R0,#+0
   \       0xD2   0x60E8             STR      R0,[R5, #+12]
   2111                  mqtt_free(handler);
   \       0xD4   0x4628             MOV      R0,R5
   \       0xD6   0x....'....        BL       HAL_Free
   2112          #else
   2113                  memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2114          #endif
   2115                  return FAIL_RETURN;
   \       0xDA   0xF04F 0x30FF      MOV      R0,#-1
   \       0xDE   0xE06C             B.N      ??MQTTSubscribe_2
   2116              }
   2117          
   2118              len = MQTTSerialize_subscribe((unsigned char *)c->buf_send, c->buf_size_send, 0, (unsigned short)msgId, 1, &topic,
   2119                                            (int *)&qos);
   \                     ??MQTTSubscribe_4: (+1)
   \       0xE0   0xA808             ADD      R0,SP,#+32
   \       0xE2   0x9002             STR      R0,[SP, #+8]
   \       0xE4   0xA804             ADD      R0,SP,#+16
   \       0xE6   0x9001             STR      R0,[SP, #+4]
   \       0xE8   0x2001             MOVS     R0,#+1
   \       0xEA   0x9000             STR      R0,[SP, #+0]
   \       0xEC   0x463B             MOV      R3,R7
   \       0xEE   0xB29B             UXTH     R3,R3
   \       0xF0   0x2200             MOVS     R2,#+0
   \       0xF2   0x6921             LDR      R1,[R4, #+16]
   \       0xF4   0x6A60             LDR      R0,[R4, #+36]
   \       0xF6   0x....'....        BL       MQTTSerialize_subscribe
   2120              if (len <= 0) {
   \       0xFA   0x2801             CMP      R0,#+1
   \       0xFC   0xDA11             BGE.N    ??MQTTSubscribe_5
   2121          #ifdef PLATFORM_HAS_DYNMEM
   2122                  mqtt_free(handler->topic_filter);
   \       0xFE   0x68E8             LDR      R0,[R5, #+12]
   \      0x100   0x....'....        BL       HAL_Free
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0x60E8             STR      R0,[R5, #+12]
   2123                  mqtt_free(handler);
   \      0x108   0x4628             MOV      R0,R5
   \      0x10A   0x....'....        BL       HAL_Free
   2124          #else
   2125                  memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2126          #endif
   2127                  _reset_send_buffer(c);
   \      0x10E   0x4620             MOV      R0,R4
   \      0x110   0x....'....        BL       _reset_send_buffer
   2128                  HAL_MutexUnlock(c->lock_write_buf);
   \      0x114   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x118   0x....'....        BL       HAL_MutexUnlock
   2129                  return MQTT_SUBSCRIBE_PACKET_ERROR;
   \      0x11C   0xF06F 0x0019      MVN      R0,#+25
   \      0x120   0xE04B             B.N      ??MQTTSubscribe_2
   2130              }
   2131          
   2132              mqtt_debug("%20s : %08d", "Packet Ident", msgId);
   2133              mqtt_debug("%20s : %s", "Topic", topicFilter);
   2134              mqtt_debug("%20s : %d", "QoS", (int)qos);
   2135              mqtt_debug("%20s : %d", "Packet Length", len);
   2136          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2137              HEXDUMP_DEBUG(c->buf_send, len);
   2138          #endif
   2139          
   2140              if ((iotx_mc_send_packet(c, c->buf_send, len, &timer)) != SUCCESS_RETURN) { /* send the subscribe packet */
   \                     ??MQTTSubscribe_5: (+1)
   \      0x122   0xAB03             ADD      R3,SP,#+12
   \      0x124   0x4602             MOV      R2,R0
   \      0x126   0x6A61             LDR      R1,[R4, #+36]
   \      0x128   0x4620             MOV      R0,R4
   \      0x12A   0x....'....        BL       iotx_mc_send_packet
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD011             BEQ.N    ??MQTTSubscribe_6
   2141                  /* If send failed, remove it */
   2142                  mqtt_err("run sendPacket error!");
   2143          #ifdef PLATFORM_HAS_DYNMEM
   2144                  mqtt_free(handler->topic_filter);
   \      0x132   0x68E8             LDR      R0,[R5, #+12]
   \      0x134   0x....'....        BL       HAL_Free
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0x60E8             STR      R0,[R5, #+12]
   2145                  mqtt_free(handler);
   \      0x13C   0x4628             MOV      R0,R5
   \      0x13E   0x....'....        BL       HAL_Free
   2146          #else
   2147                  memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2148          #endif
   2149                  _reset_send_buffer(c);
   \      0x142   0x4620             MOV      R0,R4
   \      0x144   0x....'....        BL       _reset_send_buffer
   2150                  HAL_MutexUnlock(c->lock_write_buf);
   \      0x148   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x14C   0x....'....        BL       HAL_MutexUnlock
   2151                  return MQTT_NETWORK_ERROR;
   \      0x150   0xF06F 0x000D      MVN      R0,#+13
   \      0x154   0xE031             B.N      ??MQTTSubscribe_2
   2152              }
   2153              _reset_send_buffer(c);
   \                     ??MQTTSubscribe_6: (+1)
   \      0x156   0x4620             MOV      R0,R4
   \      0x158   0x....'....        BL       _reset_send_buffer
   2154              HAL_MutexUnlock(c->lock_write_buf);
   \      0x15C   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x160   0x....'....        BL       HAL_MutexUnlock
   2155          
   2156              {
   2157                  uint8_t dup = 0;
   \      0x164   0x2600             MOVS     R6,#+0
   2158          #ifdef PLATFORM_HAS_DYNMEM
   2159                  iotx_mc_topic_handle_t *node;
   2160          #endif
   2161                  HAL_MutexLock(c->lock_generic);
   \      0x166   0x6820             LDR      R0,[R4, #+0]
   \      0x168   0x....'....        BL       HAL_MutexLock
   2162          #ifdef PLATFORM_HAS_DYNMEM
   2163          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2164          #if WITH_MQTT_ZIP_TOPIC
   2165                  HEXDUMP_DEBUG(handler->topic_filter, MQTT_ZIP_PATH_DEFAULT_LEN);
   2166          #else
   2167                  mqtt_warning("handler->topic: %s", handler->topic_filter);
   2168          #endif
   2169          #endif
   2170                  list_for_each_entry(node, &c->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   \      0x16C   0x6B20             LDR      R0,[R4, #+48]
   \      0x16E   0xF1A0 0x0710      SUB      R7,R0,#+16
   \      0x172   0xE009             B.N      ??MQTTSubscribe_7
   2171                      /* If subscribe the same topic and callback function, then ignore */
   2172          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2173          #if WITH_MQTT_ZIP_TOPIC
   2174                      HEXDUMP_DEBUG(node->topic_filter, MQTT_ZIP_PATH_DEFAULT_LEN);
   2175          #else
   2176                      mqtt_warning("node->topic: %s", node->topic_filter);
   2177          #endif
   2178          #endif
   2179                      if (0 == iotx_mc_check_handle_is_identical(node, handler)) {
   \                     ??MQTTSubscribe_8: (+1)
   \      0x174   0x4629             MOV      R1,R5
   \      0x176   0x4638             MOV      R0,R7
   \      0x178   0x....'....        BL       iotx_mc_check_handle_is_identical
   \      0x17C   0x2800             CMP      R0,#+0
   \      0x17E   0xD100             BNE.N    ??MQTTSubscribe_9
   2180                          mqtt_warning("dup sub,topic = %s", topicFilter);
   2181                          dup = 1;
   \      0x180   0x2601             MOVS     R6,#+1
   2182                      }
   2183                  }
   \                     ??MQTTSubscribe_9: (+1)
   \      0x182   0x6978             LDR      R0,[R7, #+20]
   \      0x184   0xF1A0 0x0710      SUB      R7,R0,#+16
   \                     ??MQTTSubscribe_7: (+1)
   \      0x188   0xF107 0x0010      ADD      R0,R7,#+16
   \      0x18C   0xF104 0x012C      ADD      R1,R4,#+44
   \      0x190   0x4288             CMP      R0,R1
   \      0x192   0xD1EF             BNE.N    ??MQTTSubscribe_8
   2184          #else
   2185                  for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   2186                      /* If subscribe the same topic and callback function, then ignore */
   2187                      if (&c->list_sub_handle[idx] != handler &&
   2188                          0 == iotx_mc_check_handle_is_identical(&c->list_sub_handle[idx], handler)) {
   2189                          mqtt_warning("dup sub,topic = %s", topicFilter);
   2190                          dup = 1;
   2191                      }
   2192                  }
   2193          #endif
   2194                  if (dup == 0) {
   \      0x194   0x2E00             CMP      R6,#+0
   \      0x196   0xD104             BNE.N    ??MQTTSubscribe_10
   2195          #ifdef PLATFORM_HAS_DYNMEM
   2196                      list_add_tail(&handler->linked_list, &c->list_sub_handle);
   \      0x198   0xF105 0x0010      ADD      R0,R5,#+16
   \      0x19C   0x....'....        BL       dlist_add_tail
   \      0x1A0   0xE007             B.N      ??MQTTSubscribe_11
   2197          #endif
   2198                  } else {
   2199          #ifdef PLATFORM_HAS_DYNMEM
   2200                      mqtt_free(handler->topic_filter);
   \                     ??MQTTSubscribe_10: (+1)
   \      0x1A2   0x68E8             LDR      R0,[R5, #+12]
   \      0x1A4   0x....'....        BL       HAL_Free
   \      0x1A8   0x2000             MOVS     R0,#+0
   \      0x1AA   0x60E8             STR      R0,[R5, #+12]
   2201                      mqtt_free(handler);
   \      0x1AC   0x4628             MOV      R0,R5
   \      0x1AE   0x....'....        BL       HAL_Free
   2202          #else
   2203                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2204          #endif
   2205                  }
   2206                  HAL_MutexUnlock(c->lock_generic);
   \                     ??MQTTSubscribe_11: (+1)
   \      0x1B2   0x6820             LDR      R0,[R4, #+0]
   \      0x1B4   0x....'....        BL       HAL_MutexUnlock
   2207              }
   2208          
   2209              return SUCCESS_RETURN;
   \      0x1B8   0x2000             MOVS     R0,#+0
   \                     ??MQTTSubscribe_2: (+1)
   \      0x1BA   0xB009             ADD      SP,SP,#+36
   \      0x1BC   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2210          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   2211          

   \                                 In section .text, align 2, keep-with-next
   2212          static int iotx_mc_get_next_packetid(iotx_mc_client_t *c)
   2213          {
   \                     iotx_mc_get_next_packetid: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2214              unsigned int id = 0;
   2215          
   2216              if (!c) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_get_next_packetid_0
   2217                  return FAIL_RETURN;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   2218              }
   2219          
   2220              HAL_MutexLock(c->lock_generic);
   \                     ??iotx_mc_get_next_packetid_0: (+1)
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x....'....        BL       HAL_MutexLock
   2221              c->packet_id = (c->packet_id == IOTX_MC_PACKET_ID_MAX) ? 1 : c->packet_id + 1;
   \       0x12   0x6860             LDR      R0,[R4, #+4]
   \       0x14   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xD101             BNE.N    ??iotx_mc_get_next_packetid_1
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE000             B.N      ??iotx_mc_get_next_packetid_2
   \                     ??iotx_mc_get_next_packetid_1: (+1)
   \       0x20   0x1C40             ADDS     R0,R0,#+1
   \                     ??iotx_mc_get_next_packetid_2: (+1)
   \       0x22   0x6060             STR      R0,[R4, #+4]
   2222              id = c->packet_id;
   \       0x24   0x4605             MOV      R5,R0
   2223              HAL_MutexUnlock(c->lock_generic);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x....'....        BL       HAL_MutexUnlock
   2224          
   2225              return id;
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2226          }
   2227          

   \                                 In section .text, align 2, keep-with-next
   2228          static int iotx_mc_check_rule(char *iterm, iotx_mc_topic_type_t type)
   2229          {
   \                     iotx_mc_check_rule: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   2230              int i = 0;
   \        0x6   0x2600             MOVS     R6,#+0
   2231              int len = 0;
   2232          
   2233              if (NULL == iterm) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD016             BEQ.N    ??iotx_mc_check_rule_0
   2234                  mqtt_err("iterm is NULL");
   2235                  return FAIL_RETURN;
   2236              }
   2237          
   2238              len = strlen(iterm);
   \        0xC   0x....'....        BL       strlen
   2239          
   2240              for (i = 0; i < len; i++) {
   \       0x10   0xE007             B.N      ??iotx_mc_check_rule_1
   2241                  if (TOPIC_FILTER_TYPE == type) {
   2242                      if ('+' == iterm[i] || '#' == iterm[i]) {
   2243                          if (1 != len) {
   2244                              mqtt_err("the character # and + is error");
   2245                              return FAIL_RETURN;
   2246                          }
   2247                      }
   2248                  } else {
   2249                      if ('+' == iterm[i] || '#' == iterm[i]) {
   \                     ??iotx_mc_check_rule_2: (+1)
   \       0x12   0x292B             CMP      R1,#+43
   \       0x14   0xD011             BEQ.N    ??iotx_mc_check_rule_0
   \       0x16   0x2923             CMP      R1,#+35
   \       0x18   0xD00F             BEQ.N    ??iotx_mc_check_rule_0
   2250                          mqtt_err("has character # and + is error");
   2251                          return FAIL_RETURN;
   2252                      }
   2253                  }
   2254          
   2255                  if (iterm[i] < 32 || iterm[i] >= 127) {
   \                     ??iotx_mc_check_rule_3: (+1)
   \       0x1A   0x3920             SUBS     R1,R1,#+32
   \       0x1C   0x295F             CMP      R1,#+95
   \       0x1E   0xD20C             BCS.N    ??iotx_mc_check_rule_0
   \       0x20   0x1C76             ADDS     R6,R6,#+1
   \                     ??iotx_mc_check_rule_1: (+1)
   \       0x22   0x4286             CMP      R6,R0
   \       0x24   0xDA0C             BGE.N    ??iotx_mc_check_rule_4
   \       0x26   0x4629             MOV      R1,R5
   \       0x28   0x2901             CMP      R1,#+1
   \       0x2A   0x5DA1             LDRB     R1,[R4, R6]
   \       0x2C   0xD1F1             BNE.N    ??iotx_mc_check_rule_2
   \       0x2E   0x292B             CMP      R1,#+43
   \       0x30   0xD001             BEQ.N    ??iotx_mc_check_rule_5
   \       0x32   0x2923             CMP      R1,#+35
   \       0x34   0xD1F1             BNE.N    ??iotx_mc_check_rule_3
   \                     ??iotx_mc_check_rule_5: (+1)
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD0EF             BEQ.N    ??iotx_mc_check_rule_3
   2256                      return FAIL_RETURN;
   \                     ??iotx_mc_check_rule_0: (+1)
   \       0x3A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x3E   0xBD70             POP      {R4-R6,PC}
   2257                  }
   2258              }
   2259              return SUCCESS_RETURN;
   \                     ??iotx_mc_check_rule_4: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD70             POP      {R4-R6,PC}       ;; return
   2260          }
   2261          

   \                                 In section .text, align 2, keep-with-next
   2262          static int iotx_mc_check_topic(const char *topicName, iotx_mc_topic_type_t type)
   2263          {
   \                     iotx_mc_check_topic: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB0A0             SUB      SP,SP,#+128
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   2264              int mask = 0;
   \        0x8   0x2600             MOVS     R6,#+0
   2265              char *delim = "/";
   \        0xA   0x....             ADR.N    R7,??DataTable7  ;; "/"
   2266              char *iterm = NULL;
   2267              char topicString[CONFIG_MQTT_TOPIC_MAXLEN];
   2268              if (NULL == topicName || '/' != topicName[0]) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD02B             BEQ.N    ??iotx_mc_check_topic_0
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x282F             CMP      R0,#+47
   \       0x14   0xD128             BNE.N    ??iotx_mc_check_topic_0
   2269                  return FAIL_RETURN;
   2270              }
   2271          
   2272              if (strlen(topicName) > CONFIG_MQTT_TOPIC_MAXLEN) {
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x....'....        BL       strlen
   \       0x1C   0x2881             CMP      R0,#+129
   \       0x1E   0xD223             BCS.N    ??iotx_mc_check_topic_0
   2273                  mqtt_err("len of topicName exceeds %d", CONFIG_MQTT_TOPIC_MAXLEN);
   2274                  return FAIL_RETURN;
   2275              }
   2276          
   2277              memset(topicString, 0x0, CONFIG_MQTT_TOPIC_MAXLEN);
   \       0x20   0x4632             MOV      R2,R6
   \       0x22   0x2180             MOVS     R1,#+128
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x....'....        BL       __aeabi_memset4
   2278              strncpy(topicString, topicName, CONFIG_MQTT_TOPIC_MAXLEN - 1);
   \       0x2A   0x227F             MOVS     R2,#+127
   \       0x2C   0x4621             MOV      R1,R4
   \       0x2E   0x4668             MOV      R0,SP
   \       0x30   0x....'....        BL       strncpy
   2279          
   2280              iterm = infra_strtok(topicString, delim);
   \       0x34   0x4639             MOV      R1,R7
   \       0x36   0x....'....        BL       infra_strtok
   2281          
   2282              if (SUCCESS_RETURN != iotx_mc_check_rule(iterm, type)) {
   \       0x3A   0x4629             MOV      R1,R5
   \       0x3C   0x....'....        BL       iotx_mc_check_rule
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD111             BNE.N    ??iotx_mc_check_topic_0
   \       0x44   0xE003             B.N      ??iotx_mc_check_topic_1
   2283                  mqtt_err("run iotx_check_rule error");
   2284                  return FAIL_RETURN;
   2285              }
   2286          
   2287              for (;;) {
   2288                  iterm = infra_strtok(NULL, delim);
   2289          
   2290                  if (iterm == NULL) {
   2291                      break;
   2292                  }
   2293          
   2294                  /* The character '#' is not in the last */
   2295                  if (1 == mask) {
   2296                      mqtt_err("the character # is error");
   2297                      return FAIL_RETURN;
   2298                  }
   2299          
   2300                  if (SUCCESS_RETURN != iotx_mc_check_rule(iterm, type)) {
   2301                      mqtt_err("run iotx_check_rule error");
   2302                      return FAIL_RETURN;
   2303                  }
   2304          
   2305                  if (iterm[0] == '#') {
   \                     ??iotx_mc_check_topic_2: (+1)
   \       0x46   0x7820             LDRB     R0,[R4, #+0]
   \       0x48   0x2823             CMP      R0,#+35
   \       0x4A   0xD100             BNE.N    ??iotx_mc_check_topic_1
   2306                      mask = 1;
   \       0x4C   0x2601             MOVS     R6,#+1
   2307                  }
   \                     ??iotx_mc_check_topic_1: (+1)
   \       0x4E   0x4639             MOV      R1,R7
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x....'....        BL       infra_strtok
   \       0x56   0x0004             MOVS     R4,R0
   \       0x58   0xD00A             BEQ.N    ??iotx_mc_check_topic_3
   \       0x5A   0x2E01             CMP      R6,#+1
   \       0x5C   0xD004             BEQ.N    ??iotx_mc_check_topic_0
   \       0x5E   0x4629             MOV      R1,R5
   \       0x60   0x....'....        BL       iotx_mc_check_rule
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD0EE             BEQ.N    ??iotx_mc_check_topic_2
   \                     ??iotx_mc_check_topic_0: (+1)
   \       0x68   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??iotx_mc_check_topic_4: (+1)
   \       0x6C   0xB021             ADD      SP,SP,#+132
   \       0x6E   0xBDF0             POP      {R4-R7,PC}       ;; return
   2308              }
   2309          
   2310              return SUCCESS_RETURN;
   \                     ??iotx_mc_check_topic_3: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xE7FB             B.N      ??iotx_mc_check_topic_4
   2311          }
   2312          

   \                                 In section .text, align 2, keep-with-next
   2313          static inline int _is_in_yield_cb()
   2314          {
   2315              return _in_yield_cb;
   \                     _is_in_yield_cb: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable8
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR               ;; return
   2316          }
   2317          

   \                                 In section .text, align 2, keep-with-next
   2318          static int MQTTUnsubscribe(iotx_mc_client_t *c, const char *topicFilter, unsigned int msgId)
   2319          {
   \                     MQTTUnsubscribe: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   2320              MQTTString cur_topic;
   2321              iotx_time_t timer;
   2322              MQTTString topic = MQTTString_initializer;
   \        0xA   0xA806             ADD      R0,SP,#+24
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x460A             MOV      R2,R1
   \       0x10   0x460B             MOV      R3,R1
   \       0x12   0xE880 0x000E      STM      R0,{R1-R3}
   2323              int len = 0;
   2324              /*iotx_mc_topic_handle_t handler = {topicFilter, {NULL, NULL}};*/
   2325              iotx_mc_topic_handle_t *handler = NULL;
   2326          #ifdef PLATFORM_HAS_DYNMEM
   2327              iotx_mc_topic_handle_t *node = NULL;
   2328              iotx_mc_topic_handle_t *next = NULL;
   2329          #else
   2330              int idx = 0;
   2331              iotx_mc_topic_handle_t s_handler;
   2332          #endif
   2333              if (!c || !topicFilter) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD00E             BEQ.N    ??MQTTUnsubscribe_0
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD00C             BEQ.N    ??MQTTUnsubscribe_0
   2334                  return FAIL_RETURN;
   2335              }
   2336          
   2337              topic.cstring = (char *)topicFilter;
   \       0x1E   0x9606             STR      R6,[SP, #+24]
   2338              iotx_time_init(&timer);
   \       0x20   0xA802             ADD      R0,SP,#+8
   \       0x22   0x....'....        BL       iotx_time_init
   2339              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x26   0x68A1             LDR      R1,[R4, #+8]
   \       0x28   0xA802             ADD      R0,SP,#+8
   \       0x2A   0x....'....        BL       utils_time_countdown_ms
   2340          
   2341          #ifdef PLATFORM_HAS_DYNMEM
   2342              handler = mqtt_malloc(sizeof(iotx_mc_topic_handle_t));
   \       0x2E   0x2018             MOVS     R0,#+24
   \       0x30   0x....'....        BL       HAL_Malloc
   \       0x34   0x0005             MOVS     R5,R0
   2343              if (NULL == handler) {
   \       0x36   0xD102             BNE.N    ??MQTTUnsubscribe_1
   2344                  return FAIL_RETURN;
   \                     ??MQTTUnsubscribe_0: (+1)
   \       0x38   0xF04F 0x30FF      MOV      R0,#-1
   \       0x3C   0xE0C1             B.N      ??MQTTUnsubscribe_2
   2345              }
   2346          #else
   2347              handler = &s_handler;
   2348          #endif
   2349          
   2350              memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   \                     ??MQTTUnsubscribe_1: (+1)
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x2118             MOVS     R1,#+24
   \       0x42   0x....'....        BL       __aeabi_memset4
   2351          
   2352          #if !(WITH_MQTT_ZIP_TOPIC)
   2353          #ifdef PLATFORM_HAS_DYNMEM
   2354              handler->topic_filter = mqtt_malloc(strlen(topicFilter) + 1);
   \       0x46   0x4630             MOV      R0,R6
   \       0x48   0x....'....        BL       strlen
   \       0x4C   0x1C40             ADDS     R0,R0,#+1
   \       0x4E   0x....'....        BL       HAL_Malloc
   \       0x52   0x60E8             STR      R0,[R5, #+12]
   2355              if (NULL == handler->topic_filter) {
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD105             BNE.N    ??MQTTUnsubscribe_3
   2356                  mqtt_free(handler);
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       HAL_Free
   2357                  return FAIL_RETURN;
   \       0x5E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x62   0xE0AE             B.N      ??MQTTUnsubscribe_2
   2358              }
   2359              memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);
   \                     ??MQTTUnsubscribe_3: (+1)
   \       0x64   0x4630             MOV      R0,R6
   \       0x66   0x....'....        BL       strlen
   \       0x6A   0x1C40             ADDS     R0,R0,#+1
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0x68E8             LDR      R0,[R5, #+12]
   \       0x72   0x....'....        BL       __aeabi_memset
   2360          #else
   2361              if (strlen(topicFilter) >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2362                  return MQTT_TOPIC_LEN_TOO_SHORT;
   2363              }
   2364              memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2365          #endif
   2366              memcpy((char *)handler->topic_filter, topicFilter, strlen(topicFilter) + 1);
   \       0x76   0x4630             MOV      R0,R6
   \       0x78   0x....'....        BL       strlen
   \       0x7C   0x1C40             ADDS     R0,R0,#+1
   \       0x7E   0x4602             MOV      R2,R0
   \       0x80   0x4631             MOV      R1,R6
   \       0x82   0x68E8             LDR      R0,[R5, #+12]
   \       0x84   0x....'....        BL       __aeabi_memcpy
   2367          #else
   2368              if (strstr(topicFilter, "/+") != NULL || strstr(topicFilter, "/#") != NULL) {
   2369          #ifdef PLATFORM_HAS_DYNMEM
   2370                  handler->topic_filter = mqtt_malloc(strlen(topicFilter) + 1);
   2371                  if (NULL == handler->topic_filter) {
   2372                      mqtt_free(handler);
   2373                      return FAIL_RETURN;
   2374                  }
   2375                  memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);
   2376          #else
   2377                  if (strlen(topicFilter) >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2378                      return MQTT_TOPIC_LEN_TOO_SHORT;
   2379                  }
   2380                  memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2381          #endif
   2382                  handler->topic_type = TOPIC_FILTER_TYPE;
   2383                  memcpy((char *)handler->topic_filter, topicFilter, strlen(topicFilter) + 1);
   2384              } else {
   2385          #ifdef PLATFORM_HAS_DYNMEM
   2386                  handler->topic_filter = mqtt_malloc(MQTT_ZIP_PATH_DEFAULT_LEN);
   2387                  if (NULL == handler->topic_filter) {
   2388                      mqtt_free(handler);
   2389                      return FAIL_RETURN;
   2390                  }
   2391                  memset((char *)handler->topic_filter, 0, MQTT_ZIP_PATH_DEFAULT_LEN);
   2392          #else
   2393                  if (MQTT_ZIP_PATH_DEFAULT_LEN >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2394                      return MQTT_TOPIC_LEN_TOO_SHORT;
   2395                  }
   2396                  memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2397          #endif
   2398                  handler->topic_type = TOPIC_NAME_TYPE;
   2399                  if (iotx_mc_get_zip_topic(topicFilter, strlen(topicFilter), (char *)handler->topic_filter,
   2400                                            MQTT_ZIP_PATH_DEFAULT_LEN) != 0) {
   2401          #ifdef PLATFORM_HAS_DYNMEM
   2402                      mqtt_free(handler->topic_filter);
   2403                      mqtt_free(handler);
   2404          #endif
   2405                      return FAIL_RETURN;
   2406                  }
   2407              }
   2408          #endif
   2409          
   2410              HAL_MutexLock(c->lock_write_buf);
   \       0x88   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x8C   0x....'....        BL       HAL_MutexLock
   2411          
   2412              if (_alloc_send_buffer(c, strlen(topicFilter)) < 0) {
   \       0x90   0x4630             MOV      R0,R6
   \       0x92   0x....'....        BL       strlen
   \       0x96   0x4601             MOV      R1,R0
   \       0x98   0x4620             MOV      R0,R4
   \       0x9A   0x....'....        BL       _alloc_send_buffer
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD50E             BPL.N    ??MQTTUnsubscribe_4
   2413                  HAL_MutexUnlock(c->lock_write_buf);
   \       0xA2   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xA6   0x....'....        BL       HAL_MutexUnlock
   2414          #ifdef PLATFORM_HAS_DYNMEM
   2415                  mqtt_free(handler->topic_filter);
   \       0xAA   0x68E8             LDR      R0,[R5, #+12]
   \       0xAC   0x....'....        BL       HAL_Free
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x60E8             STR      R0,[R5, #+12]
   2416                  mqtt_free(handler);
   \       0xB4   0x4628             MOV      R0,R5
   \       0xB6   0x....'....        BL       HAL_Free
   2417          #endif
   2418                  return FAIL_RETURN;
   \       0xBA   0xF04F 0x30FF      MOV      R0,#-1
   \       0xBE   0xE080             B.N      ??MQTTUnsubscribe_2
   2419              }
   2420          
   2421              if ((len = MQTTSerialize_unsubscribe((unsigned char *)c->buf_send, c->buf_size_send, 0, (unsigned short)msgId, 1,
   2422                                                   &topic)) <= 0) {
   \                     ??MQTTUnsubscribe_4: (+1)
   \       0xC0   0xA806             ADD      R0,SP,#+24
   \       0xC2   0x9001             STR      R0,[SP, #+4]
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0x9000             STR      R0,[SP, #+0]
   \       0xC8   0x463B             MOV      R3,R7
   \       0xCA   0xB29B             UXTH     R3,R3
   \       0xCC   0x2200             MOVS     R2,#+0
   \       0xCE   0x6921             LDR      R1,[R4, #+16]
   \       0xD0   0x6A60             LDR      R0,[R4, #+36]
   \       0xD2   0x....'....        BL       MQTTSerialize_unsubscribe
   \       0xD6   0x2801             CMP      R0,#+1
   \       0xD8   0xDA11             BGE.N    ??MQTTUnsubscribe_5
   2423          #ifdef PLATFORM_HAS_DYNMEM
   2424                  mqtt_free(handler->topic_filter);
   \       0xDA   0x68E8             LDR      R0,[R5, #+12]
   \       0xDC   0x....'....        BL       HAL_Free
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0x60E8             STR      R0,[R5, #+12]
   2425                  mqtt_free(handler);
   \       0xE4   0x4628             MOV      R0,R5
   \       0xE6   0x....'....        BL       HAL_Free
   2426          #endif
   2427                  _reset_send_buffer(c);
   \       0xEA   0x4620             MOV      R0,R4
   \       0xEC   0x....'....        BL       _reset_send_buffer
   2428                  HAL_MutexUnlock(c->lock_write_buf);
   \       0xF0   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xF4   0x....'....        BL       HAL_MutexUnlock
   2429                  return MQTT_UNSUBSCRIBE_PACKET_ERROR;
   \       0xF8   0xF06F 0x0015      MVN      R0,#+21
   \       0xFC   0xE061             B.N      ??MQTTUnsubscribe_2
   2430              }
   2431          
   2432              if ((iotx_mc_send_packet(c, c->buf_send, len, &timer)) != SUCCESS_RETURN) { /* send the subscribe packet */
   \                     ??MQTTUnsubscribe_5: (+1)
   \       0xFE   0xAB02             ADD      R3,SP,#+8
   \      0x100   0x4602             MOV      R2,R0
   \      0x102   0x6A61             LDR      R1,[R4, #+36]
   \      0x104   0x4620             MOV      R0,R4
   \      0x106   0x....'....        BL       iotx_mc_send_packet
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD011             BEQ.N    ??MQTTUnsubscribe_6
   2433          #ifdef PLATFORM_HAS_DYNMEM
   2434                  mqtt_free(handler->topic_filter);
   \      0x10E   0x68E8             LDR      R0,[R5, #+12]
   \      0x110   0x....'....        BL       HAL_Free
   \      0x114   0x2000             MOVS     R0,#+0
   \      0x116   0x60E8             STR      R0,[R5, #+12]
   2435                  mqtt_free(handler);
   \      0x118   0x4628             MOV      R0,R5
   \      0x11A   0x....'....        BL       HAL_Free
   2436          #endif
   2437                  _reset_send_buffer(c);
   \      0x11E   0x4620             MOV      R0,R4
   \      0x120   0x....'....        BL       _reset_send_buffer
   2438                  HAL_MutexUnlock(c->lock_write_buf);
   \      0x124   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x128   0x....'....        BL       HAL_MutexUnlock
   2439                  return MQTT_NETWORK_ERROR;
   \      0x12C   0xF06F 0x000D      MVN      R0,#+13
   \      0x130   0xE047             B.N      ??MQTTUnsubscribe_2
   2440              }
   2441          
   2442              cur_topic.cstring = NULL;
   \                     ??MQTTUnsubscribe_6: (+1)
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x9003             STR      R0,[SP, #+12]
   2443              cur_topic.lenstring.data = (char *)handler->topic_filter;
   \      0x136   0x68E8             LDR      R0,[R5, #+12]
   \      0x138   0x9005             STR      R0,[SP, #+20]
   2444          
   2445          #if !(WITH_MQTT_ZIP_TOPIC)
   2446              cur_topic.lenstring.len = strlen(handler->topic_filter) + 1;
   \      0x13A   0x68E8             LDR      R0,[R5, #+12]
   \      0x13C   0x....'....        BL       strlen
   \      0x140   0x1C40             ADDS     R0,R0,#+1
   \      0x142   0x9004             STR      R0,[SP, #+16]
   2447          #else
   2448              if (handler->topic_type == TOPIC_FILTER_TYPE) {
   2449                  cur_topic.lenstring.len = strlen(handler->topic_filter) + 1;
   2450              } else {
   2451                  cur_topic.lenstring.len = MQTT_ZIP_PATH_DEFAULT_LEN;
   2452              }
   2453          #endif
   2454              /* we have to find the right message handler - indexed by topic */
   2455              HAL_MutexLock(c->lock_generic);
   \      0x144   0x6820             LDR      R0,[R4, #+0]
   \      0x146   0x....'....        BL       HAL_MutexLock
   2456          #ifdef PLATFORM_HAS_DYNMEM
   2457              list_for_each_entry_safe(node, next, &c->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   \      0x14A   0x6B20             LDR      R0,[R4, #+48]
   \      0x14C   0xF1A0 0x0610      SUB      R6,R0,#+16
   \      0x150   0x6970             LDR      R0,[R6, #+20]
   \      0x152   0xF1A0 0x0710      SUB      R7,R0,#+16
   \      0x156   0xE01B             B.N      ??MQTTUnsubscribe_7
   2458                  if (MQTTPacket_equals(&cur_topic, (char *)node->topic_filter)
   2459                      || iotx_mc_is_topic_matched((char *)node->topic_filter, &cur_topic)) {
   \                     ??MQTTUnsubscribe_8: (+1)
   \      0x158   0x68F1             LDR      R1,[R6, #+12]
   \      0x15A   0xA803             ADD      R0,SP,#+12
   \      0x15C   0x....'....        BL       MQTTPacket_equals
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD105             BNE.N    ??MQTTUnsubscribe_9
   \      0x164   0xA903             ADD      R1,SP,#+12
   \      0x166   0x68F0             LDR      R0,[R6, #+12]
   \      0x168   0x....'....        BL       iotx_mc_is_topic_matched
   \      0x16C   0x2800             CMP      R0,#+0
   \      0x16E   0xD00B             BEQ.N    ??MQTTUnsubscribe_10
   2460                      mqtt_debug("topic be matched");
   2461                      list_del(&node->linked_list);
   \                     ??MQTTUnsubscribe_9: (+1)
   \      0x170   0xF106 0x0010      ADD      R0,R6,#+16
   \      0x174   0x....'....        BL       dlist_del
   2462                      mqtt_free(node->topic_filter);
   \      0x178   0x68F0             LDR      R0,[R6, #+12]
   \      0x17A   0x....'....        BL       HAL_Free
   \      0x17E   0x2000             MOVS     R0,#+0
   \      0x180   0x60F0             STR      R0,[R6, #+12]
   2463                      mqtt_free(node);
   \      0x182   0x4630             MOV      R0,R6
   \      0x184   0x....'....        BL       HAL_Free
   2464                  }
   2465              }
   \                     ??MQTTUnsubscribe_10: (+1)
   \      0x188   0x463E             MOV      R6,R7
   \      0x18A   0x6978             LDR      R0,[R7, #+20]
   \      0x18C   0xF1A0 0x0710      SUB      R7,R0,#+16
   \                     ??MQTTUnsubscribe_7: (+1)
   \      0x190   0xF106 0x0010      ADD      R0,R6,#+16
   \      0x194   0xF104 0x012C      ADD      R1,R4,#+44
   \      0x198   0x4288             CMP      R0,R1
   \      0x19A   0xD1DD             BNE.N    ??MQTTUnsubscribe_8
   2466              mqtt_free(handler->topic_filter);
   \      0x19C   0x68E8             LDR      R0,[R5, #+12]
   \      0x19E   0x....'....        BL       HAL_Free
   \      0x1A2   0x2000             MOVS     R0,#+0
   \      0x1A4   0x60E8             STR      R0,[R5, #+12]
   2467              mqtt_free(handler);
   \      0x1A6   0x4628             MOV      R0,R5
   \      0x1A8   0x....'....        BL       HAL_Free
   2468          #else
   2469              for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   2470                  if ((c->list_sub_handle[idx].used == 1) &&
   2471                      (MQTTPacket_equals(&cur_topic, (char *)c->list_sub_handle[idx].topic_filter) ||
   2472                       iotx_mc_is_topic_matched((char *)c->list_sub_handle[idx].topic_filter, &cur_topic))) {
   2473                      mqtt_debug("topic be matched");
   2474                      memset(&c->list_sub_handle[idx], 0, sizeof(iotx_mc_topic_handle_t));
   2475                  }
   2476              }
   2477          #endif
   2478              HAL_MutexUnlock(c->lock_generic);
   \      0x1AC   0x6820             LDR      R0,[R4, #+0]
   \      0x1AE   0x....'....        BL       HAL_MutexUnlock
   2479              _reset_send_buffer(c);
   \      0x1B2   0x4620             MOV      R0,R4
   \      0x1B4   0x....'....        BL       _reset_send_buffer
   2480              HAL_MutexUnlock(c->lock_write_buf);
   \      0x1B8   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x1BC   0x....'....        BL       HAL_MutexUnlock
   2481              return SUCCESS_RETURN;
   \      0x1C0   0x2000             MOVS     R0,#+0
   \                     ??MQTTUnsubscribe_2: (+1)
   \      0x1C2   0xB009             ADD      SP,SP,#+36
   \      0x1C4   0xBDF0             POP      {R4-R7,PC}       ;; return
   2482          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   2483          

   \                                 In section .text, align 2, keep-with-next
   2484          int MQTTPublish(iotx_mc_client_t *c, const char *topicName, iotx_mqtt_topic_info_pt topic_msg)
   2485          
   2486          {
   \                     MQTTPublish: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB08C             SUB      SP,SP,#+48
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   2487              iotx_time_t         timer;
   2488              MQTTString          topic = MQTTString_initializer;
   \        0xA   0xA809             ADD      R0,SP,#+36
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x460A             MOV      R2,R1
   \       0x10   0x460B             MOV      R3,R1
   \       0x12   0xE880 0x000E      STM      R0,{R1-R3}
   2489              int                 len = 0;
   2490          #if !WITH_MQTT_ONLY_QOS0
   2491              iotx_mc_pub_info_t  *node = NULL;
   \       0x16   0x4608             MOV      R0,R1
   \       0x18   0x9007             STR      R0,[SP, #+28]
   2492          #endif
   2493          #ifdef INFRA_LOG_NETWORK_PAYLOAD
   2494              const char     *json_payload = NULL;
   2495          #endif
   2496          
   2497              if (!c || !topicName || !topic_msg) {
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD003             BEQ.N    ??MQTTPublish_0
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD001             BEQ.N    ??MQTTPublish_0
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD102             BNE.N    ??MQTTPublish_1
   2498                  return FAIL_RETURN;
   \                     ??MQTTPublish_0: (+1)
   \       0x26   0xF04F 0x30FF      MOV      R0,#-1
   \       0x2A   0xE098             B.N      ??MQTTPublish_2
   2499              }
   2500          
   2501              topic.cstring = (char *)topicName;
   \                     ??MQTTPublish_1: (+1)
   \       0x2C   0x9609             STR      R6,[SP, #+36]
   2502              iotx_time_init(&timer);
   \       0x2E   0xA808             ADD      R0,SP,#+32
   \       0x30   0x....'....        BL       iotx_time_init
   2503              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x34   0x68A1             LDR      R1,[R4, #+8]
   \       0x36   0xA808             ADD      R0,SP,#+32
   \       0x38   0x....'....        BL       utils_time_countdown_ms
   2504          
   2505              HAL_MutexLock(c->lock_list_pub);
   \       0x3C   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x40   0x....'....        BL       HAL_MutexLock
   2506              HAL_MutexLock(c->lock_write_buf);
   \       0x44   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x48   0x....'....        BL       HAL_MutexLock
   2507          
   2508              if (_alloc_send_buffer(c, strlen(topicName) + topic_msg->payload_len) < 0) {
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x....'....        BL       strlen
   \       0x52   0x68A9             LDR      R1,[R5, #+8]
   \       0x54   0x1808             ADDS     R0,R1,R0
   \       0x56   0x4601             MOV      R1,R0
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x....'....        BL       _alloc_send_buffer
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD50A             BPL.N    ??MQTTPublish_3
   2509                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x62   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x66   0x....'....        BL       HAL_MutexUnlock
   2510                  HAL_MutexUnlock(c->lock_list_pub);
   \       0x6A   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x6E   0x....'....        BL       HAL_MutexUnlock
   2511                  return FAIL_RETURN;
   \       0x72   0xF04F 0x30FF      MOV      R0,#-1
   \       0x76   0xE072             B.N      ??MQTTPublish_2
   2512              }
   2513          
   2514              len = MQTTSerialize_publish((unsigned char *)c->buf_send,
   2515                                          c->buf_size_send,
   2516                                          0,
   2517                                          topic_msg->qos,
   2518                                          topic_msg->retain,
   2519                                          topic_msg->packet_id,
   2520                                          topic,
   2521                                          (unsigned char *)topic_msg->payload,
   2522                                          topic_msg->payload_len);
   \                     ??MQTTPublish_3: (+1)
   \       0x78   0x68A8             LDR      R0,[R5, #+8]
   \       0x7A   0x9006             STR      R0,[SP, #+24]
   \       0x7C   0x6928             LDR      R0,[R5, #+16]
   \       0x7E   0x9005             STR      R0,[SP, #+20]
   \       0x80   0xA809             ADD      R0,SP,#+36
   \       0x82   0xAA02             ADD      R2,SP,#+8
   \       0x84   0xC80A             LDM      R0!,{R1,R3}
   \       0x86   0xC20A             STM      R2!,{R1,R3}
   \       0x88   0x6803             LDR      R3,[R0, #+0]
   \       0x8A   0x6013             STR      R3,[R2, #+0]
   \       0x8C   0x8828             LDRH     R0,[R5, #+0]
   \       0x8E   0x9001             STR      R0,[SP, #+4]
   \       0x90   0x7928             LDRB     R0,[R5, #+4]
   \       0x92   0x9000             STR      R0,[SP, #+0]
   \       0x94   0x78AB             LDRB     R3,[R5, #+2]
   \       0x96   0x2200             MOVS     R2,#+0
   \       0x98   0x6921             LDR      R1,[R4, #+16]
   \       0x9A   0x6A60             LDR      R0,[R4, #+36]
   \       0x9C   0x....'....        BL       MQTTSerialize_publish
   \       0xA0   0x4606             MOV      R6,R0
   2523              if (len <= 0) {
   \       0xA2   0x2E01             CMP      R6,#+1
   \       0xA4   0xDA0D             BGE.N    ??MQTTPublish_4
   2524                  mqtt_err("MQTTSerialize_publish is error, len=%d, buf_size_send=%u, payloadlen=%u",
   2525                           len,
   2526                           c->buf_size_send,
   2527                           topic_msg->payload_len);
   2528                  _reset_send_buffer(c);
   \       0xA6   0x4620             MOV      R0,R4
   \       0xA8   0x....'....        BL       _reset_send_buffer
   2529                  HAL_MutexUnlock(c->lock_write_buf);
   \       0xAC   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xB0   0x....'....        BL       HAL_MutexUnlock
   2530                  HAL_MutexUnlock(c->lock_list_pub);
   \       0xB4   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0xB8   0x....'....        BL       HAL_MutexUnlock
   2531                  return MQTT_PUBLISH_PACKET_ERROR;
   \       0xBC   0xF06F 0x0014      MVN      R0,#+20
   \       0xC0   0xE04D             B.N      ??MQTTPublish_2
   2532              }
   2533          
   2534          #if !WITH_MQTT_ONLY_QOS0
   2535              node = NULL;
   \                     ??MQTTPublish_4: (+1)
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x9007             STR      R0,[SP, #+28]
   2536              /* If the QOS >1, push the information into list of wait publish ACK */
   2537              if (topic_msg->qos > IOTX_MQTT_QOS0) {
   \       0xC6   0x78A8             LDRB     R0,[R5, #+2]
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD015             BEQ.N    ??MQTTPublish_5
   2538                  /* push into list */
   2539                  if (SUCCESS_RETURN != iotx_mc_push_pubInfo_to(c, len, topic_msg->packet_id, &node)) {
   \       0xCC   0xAB07             ADD      R3,SP,#+28
   \       0xCE   0x882A             LDRH     R2,[R5, #+0]
   \       0xD0   0x4631             MOV      R1,R6
   \       0xD2   0x4620             MOV      R0,R4
   \       0xD4   0x....'....        BL       iotx_mc_push_pubInfo_to
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD00D             BEQ.N    ??MQTTPublish_5
   2540                      mqtt_err("push publish into to pubInfolist failed!");
   2541                      _reset_send_buffer(c);
   \       0xDC   0x4620             MOV      R0,R4
   \       0xDE   0x....'....        BL       _reset_send_buffer
   2542                      HAL_MutexUnlock(c->lock_write_buf);
   \       0xE2   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xE6   0x....'....        BL       HAL_MutexUnlock
   2543                      HAL_MutexUnlock(c->lock_list_pub);
   \       0xEA   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0xEE   0x....'....        BL       HAL_MutexUnlock
   2544                      return MQTT_PUSH_TO_LIST_ERROR;
   \       0xF2   0xF06F 0x0029      MVN      R0,#+41
   \       0xF6   0xE032             B.N      ??MQTTPublish_2
   2545                  }
   2546              }
   2547          #endif
   2548              /* send the publish packet */
   2549              if (iotx_mc_send_packet(c, c->buf_send, len, &timer) != SUCCESS_RETURN) {
   \                     ??MQTTPublish_5: (+1)
   \       0xF8   0xAB08             ADD      R3,SP,#+32
   \       0xFA   0x4632             MOV      R2,R6
   \       0xFC   0x6A61             LDR      R1,[R4, #+36]
   \       0xFE   0x4620             MOV      R0,R4
   \      0x100   0x....'....        BL       iotx_mc_send_packet
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD019             BEQ.N    ??MQTTPublish_6
   2550          #if !WITH_MQTT_ONLY_QOS0
   2551                  if (topic_msg->qos > IOTX_MQTT_QOS0) {
   \      0x108   0x78A8             LDRB     R0,[R5, #+2]
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD008             BEQ.N    ??MQTTPublish_7
   2552                      /* If not even successfully sent to IP stack, meaningless to wait QOS1 ack, give up waiting */
   2553          #ifdef PLATFORM_HAS_DYNMEM
   2554                      list_del(&node->linked_list);
   \      0x10E   0x9807             LDR      R0,[SP, #+28]
   \      0x110   0x3010             ADDS     R0,R0,#+16
   \      0x112   0x....'....        BL       dlist_del
   2555                      mqtt_free(node);
   \      0x116   0x9807             LDR      R0,[SP, #+28]
   \      0x118   0x....'....        BL       HAL_Free
   \      0x11C   0x2000             MOVS     R0,#+0
   \      0x11E   0x9007             STR      R0,[SP, #+28]
   2556          #else
   2557                      memset(node, 0, sizeof(iotx_mc_pub_info_t));
   2558          #endif
   2559                  }
   2560          #endif
   2561                  _reset_send_buffer(c);
   \                     ??MQTTPublish_7: (+1)
   \      0x120   0x4620             MOV      R0,R4
   \      0x122   0x....'....        BL       _reset_send_buffer
   2562                  HAL_MutexUnlock(c->lock_write_buf);
   \      0x126   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x12A   0x....'....        BL       HAL_MutexUnlock
   2563                  HAL_MutexUnlock(c->lock_list_pub);
   \      0x12E   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \      0x132   0x....'....        BL       HAL_MutexUnlock
   2564                  return MQTT_NETWORK_ERROR;
   \      0x136   0xF06F 0x000D      MVN      R0,#+13
   \      0x13A   0xE010             B.N      ??MQTTPublish_2
   2565              }
   2566          
   2567          #ifdef INFRA_LOG_NETWORK_PAYLOAD
   2568              json_payload = (const char *)topic_msg->payload;
   2569          
   2570              mqtt_info("Upstream Topic: '%s'", topicName);
   2571              mqtt_info("Upstream Payload:");
   2572              iotx_facility_json_print(json_payload, LOG_INFO_LEVEL, '>');
   \                     ??MQTTPublish_6: (+1)
   \      0x13C   0x223E             MOVS     R2,#+62
   \      0x13E   0x2104             MOVS     R1,#+4
   \      0x140   0x6928             LDR      R0,[R5, #+16]
   \      0x142   0x....'....        BL       iotx_facility_json_print
   2573          
   2574          #endif  /* #ifdef INFRA_LOG */
   2575          
   2576              _reset_send_buffer(c);
   \      0x146   0x4620             MOV      R0,R4
   \      0x148   0x....'....        BL       _reset_send_buffer
   2577              HAL_MutexUnlock(c->lock_write_buf);
   \      0x14C   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x150   0x....'....        BL       HAL_MutexUnlock
   2578              HAL_MutexUnlock(c->lock_list_pub);
   \      0x154   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \      0x158   0x....'....        BL       HAL_MutexUnlock
   2579          
   2580              return SUCCESS_RETURN;
   \      0x15C   0x2000             MOVS     R0,#+0
   \                     ??MQTTPublish_2: (+1)
   \      0x15E   0xB00C             ADD      SP,SP,#+48
   \      0x160   0xBD70             POP      {R4-R6,PC}       ;; return
   2581          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   2582          

   \                                 In section .text, align 2, keep-with-next
   2583          static int MQTTDisconnect(iotx_mc_client_t *c)
   2584          {
   \                     MQTTDisconnect: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   2585              int             rc = FAIL_RETURN;
   \        0x4   0xF04F 0x35FF      MOV      R5,#-1
   2586              int             len = 0;
   2587              iotx_time_t     timer;     /* we might wait for incomplete incoming publishes to complete */
   2588          
   2589              if (!c) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??MQTTDisconnect_0
   2590                  return FAIL_RETURN;
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0xBD76             POP      {R1,R2,R4-R6,PC}
   2591              }
   2592          
   2593              HAL_MutexLock(c->lock_write_buf);
   \                     ??MQTTDisconnect_0: (+1)
   \       0x10   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x14   0x....'....        BL       HAL_MutexLock
   2594          
   2595              if (_alloc_send_buffer(c, 0) < 0) {
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x....'....        BL       _alloc_send_buffer
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD505             BPL.N    ??MQTTDisconnect_1
   2596                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x24   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x28   0x....'....        BL       HAL_MutexUnlock
   2597                  return FAIL_RETURN;
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0xBD76             POP      {R1,R2,R4-R6,PC}
   2598              }
   2599          
   2600              len = MQTTSerialize_disconnect((unsigned char *)c->buf_send, c->buf_size_send);
   \                     ??MQTTDisconnect_1: (+1)
   \       0x30   0x6921             LDR      R1,[R4, #+16]
   \       0x32   0x6A60             LDR      R0,[R4, #+36]
   \       0x34   0x....'....        BL       MQTTSerialize_disconnect
   \       0x38   0x4606             MOV      R6,R0
   2601          
   2602              iotx_time_init(&timer);
   \       0x3A   0x4668             MOV      R0,SP
   \       0x3C   0x....'....        BL       iotx_time_init
   2603              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x40   0x68A1             LDR      R1,[R4, #+8]
   \       0x42   0x4668             MOV      R0,SP
   \       0x44   0x....'....        BL       utils_time_countdown_ms
   2604          
   2605              if (len > 0) {
   \       0x48   0x2E01             CMP      R6,#+1
   \       0x4A   0xDB06             BLT.N    ??MQTTDisconnect_2
   2606                  rc = iotx_mc_send_packet(c, c->buf_send, len, &timer);           /* send the disconnect packet */
   \       0x4C   0x466B             MOV      R3,SP
   \       0x4E   0x4632             MOV      R2,R6
   \       0x50   0x6A61             LDR      R1,[R4, #+36]
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x....'....        BL       iotx_mc_send_packet
   \       0x58   0x4605             MOV      R5,R0
   2607              }
   2608              _reset_send_buffer(c);
   \                     ??MQTTDisconnect_2: (+1)
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x....'....        BL       _reset_send_buffer
   2609              HAL_MutexUnlock(c->lock_write_buf);
   \       0x60   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x64   0x....'....        BL       HAL_MutexUnlock
   2610              return rc;
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   2611          }
   2612          

   \                                 In section .text, align 2, keep-with-next
   2613          static int iotx_mc_disconnect(iotx_mc_client_t *pClient)
   2614          {
   \                     iotx_mc_disconnect: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2615              int             rc = -1;
   2616          
   2617              if (NULL == pClient) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_disconnect_0
   2618                  return NULL_VALUE_ERROR;
   \        0x6   0xF06F 0x0001      MVN      R0,#+1
   \        0xA   0xBD10             POP      {R4,PC}
   2619              }
   2620          
   2621              if (wrapper_mqtt_check_state(pClient)) {
   \                     ??iotx_mc_disconnect_0: (+1)
   \        0xC   0x....'....        BL       wrapper_mqtt_check_state
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD002             BEQ.N    ??iotx_mc_disconnect_1
   2622                  rc = MQTTDisconnect(pClient);
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       MQTTDisconnect
   2623                  mqtt_debug("rc = MQTTDisconnect() = %d", rc);
   2624                  rc = rc;
   2625              }
   2626          
   2627              /* close tcp/ip socket or free tls resources */
   2628              pClient->ipstack.disconnect(&pClient->ipstack);
   \                     ??iotx_mc_disconnect_1: (+1)
   \       0x1A   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x1E   0x6D21             LDR      R1,[R4, #+80]
   \       0x20   0x4788             BLX      R1
   2629          
   2630              iotx_mc_set_client_state(pClient, IOTX_MC_STATE_INITIALIZED);
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       iotx_mc_set_client_state
   2631          
   2632              mqtt_info("mqtt disconnect!");
   2633              return SUCCESS_RETURN;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
   2634          }
   2635          
   2636          /************************  Public Interface ************************/

   \                                 In section .text, align 2, keep-with-next
   2637          void *wrapper_mqtt_init(iotx_mqtt_param_t *mqtt_params)
   2638          {
   \                     wrapper_mqtt_init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   2639              int err;
   2640              iotx_mc_client_t *pclient = NULL;
   2641          #ifndef PLATFORM_HAS_DYNMEM
   2642              int idx;
   2643          #endif
   2644          
   2645          #ifdef PLATFORM_HAS_DYNMEM
   2646              pclient = (iotx_mc_client_t *)mqtt_malloc(sizeof(iotx_mc_client_t));
   \        0x4   0x20E8             MOVS     R0,#+232
   \        0x6   0x....'....        BL       HAL_Malloc
   \        0xA   0x0004             MOVS     R4,R0
   2647              if (NULL == pclient) {
   \        0xC   0xD101             BNE.N    ??wrapper_mqtt_init_0
   2648                  mqtt_err("not enough memory.");
   2649                  return NULL;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
   2650              }
   2651              memset(pclient, 0, sizeof(iotx_mc_client_t));
   \                     ??wrapper_mqtt_init_0: (+1)
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x21E8             MOVS     R1,#+232
   \       0x16   0x....'....        BL       __aeabi_memset4
   2652          #else
   2653              for (idx = 0; idx < IOTX_MC_CLIENT_MAX_COUNT; idx++) {
   2654                  if (g_iotx_mc_client[idx].used == 0) {
   2655                      g_iotx_mc_client[idx].used = 1;
   2656                      pclient = &g_iotx_mc_client[idx];
   2657                      break;
   2658                  }
   2659              }
   2660          
   2661              if (NULL == pclient) {
   2662                  mqtt_err("IOTX_MC_CLIENT_MAX_COUNT too short: %d", IOTX_MC_CLIENT_MAX_COUNT);
   2663                  return NULL;
   2664              }
   2665          #endif
   2666          
   2667              err = iotx_mc_init(pclient, mqtt_params);
   2668          
   2669              if (SUCCESS_RETURN != err) {
   \       0x1A   0x4629             MOV      R1,R5
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       iotx_mc_init
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0xD002             BEQ.N    ??wrapper_mqtt_init_1
   2670                  mqtt_err("iotx_mc_init failed");
   2671                  iotx_mc_release(pclient);
   \       0x28   0x....'....        BL       iotx_mc_release
   2672                  return NULL;
   \       0x2C   0x2000             MOVS     R0,#+0
   2673              }
   2674          
   2675              return pclient;
   \                     ??wrapper_mqtt_init_1: (+1)
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2676          }
   2677          

   \                                 In section .text, align 2, keep-with-next
   2678          int wrapper_mqtt_connect(void *client)
   2679          {
   \                     wrapper_mqtt_connect: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   2680              int rc = FAIL_RETURN;
   2681              int retry_max = 3;
   2682              int retry_cnt = 1;
   \        0x4   0x2601             MOVS     R6,#+1
   2683              int retry_interval = 1000;
   2684              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
   2685          
   2686              if (NULL == pClient) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD10C             BNE.N    ??wrapper_mqtt_connect_0
   2687                  return NULL_VALUE_ERROR;
   \        0xA   0xF06F 0x0001      MVN      R0,#+1
   \        0xE   0xBD70             POP      {R4-R6,PC}
   2688              }
   2689          
   2690              /* Establish TCP or TLS connection */
   2691              do {
   2692                  mqtt_debug("calling TCP or TLS connect HAL for [%d/%d] iteration", retry_cnt, retry_max);
   2693          
   2694                  rc = pClient->ipstack.connect(&pClient->ipstack);
   2695                  if (SUCCESS_RETURN != rc) {
   2696                      pClient->ipstack.disconnect(&pClient->ipstack);
   2697                      mqtt_err("TCP or TLS Connection failed");
   2698          
   2699                      if (ERROR_CERTIFICATE_EXPIRED == rc) {
   2700                          mqtt_err("certificate is expired! rc = %d", rc);
   2701                          rc = ERROR_CERT_VERIFY_FAIL;
   2702                          HAL_SleepMs(retry_interval);
   2703                          continue;
   2704                      } else {
   2705                          rc = MQTT_NETWORK_CONNECT_ERROR;
   2706                          HAL_SleepMs(retry_interval);
   \                     ??wrapper_mqtt_connect_1: (+1)
   \       0x10   0x....'....        BL       HAL_SleepMs
   2707                          continue;
   2708                      }
   2709                  } else {
   2710                      mqtt_debug("rc = pClient->ipstack.connect() = %d, success @ [%d/%d] iteration", rc, retry_cnt, retry_max);
   2711                      break;
   2712                  }
   2713              } while (++retry_cnt <= retry_max);
   \                     ??wrapper_mqtt_connect_2: (+1)
   \       0x14   0x1C76             ADDS     R6,R6,#+1
   \       0x16   0x2E04             CMP      R6,#+4
   \       0x18   0xDB04             BLT.N    ??wrapper_mqtt_connect_0
   2714          
   2715          #ifdef ASYNC_PROTOCOL_STACK
   2716              iotx_mc_set_client_state(pClient, IOTX_MC_STATE_CONNECT_BLOCK);
   2717              rc = MQTT_CONNECT_BLOCK;
   2718          #else
   2719              rc = _mqtt_connect(pClient);
   2720          #endif
   2721              return rc;
   \                     ??wrapper_mqtt_connect_3: (+1)
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x20   0x....'....        B.W      _mqtt_connect
   \                     ??wrapper_mqtt_connect_0: (+1)
   \       0x24   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x28   0x6D69             LDR      R1,[R5, #+84]
   \       0x2A   0x4788             BLX      R1
   \       0x2C   0x0004             MOVS     R4,R0
   \       0x2E   0xD0F4             BEQ.N    ??wrapper_mqtt_connect_3
   \       0x30   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x34   0x6D29             LDR      R1,[R5, #+80]
   \       0x36   0x4788             BLX      R1
   \       0x38   0x....             LDR.N    R0,??DataTable8_1  ;; 0xfffffc09
   \       0x3A   0x4284             CMP      R4,R0
   \       0x3C   0xF44F 0x707A      MOV      R0,#+1000
   \       0x40   0xD1E6             BNE.N    ??wrapper_mqtt_connect_1
   \       0x42   0x....'....        BL       HAL_SleepMs
   \       0x46   0xE7E5             B.N      ??wrapper_mqtt_connect_2
   2722          }
   2723          

   \                                 In section .text, align 2, keep-with-next
   2724          int wrapper_mqtt_release(void **c)
   2725          {
   \                     wrapper_mqtt_release: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2726              iotx_mc_client_t *pClient;
   2727          #ifdef PLATFORM_HAS_DYNMEM
   2728              iotx_mc_topic_handle_t *node = NULL, *next = NULL;
   2729          #endif
   2730              if (NULL == c) {
   \        0x4   0xD002             BEQ.N    ??wrapper_mqtt_release_0
   2731                  return NULL_VALUE_ERROR;
   2732              }
   2733          
   2734              pClient = (iotx_mc_client_t *)*c;
   \        0x6   0x6825             LDR      R5,[R4, #+0]
   2735              if (NULL == pClient) {
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD102             BNE.N    ??wrapper_mqtt_release_1
   2736                  return NULL_VALUE_ERROR;
   \                     ??wrapper_mqtt_release_0: (+1)
   \        0xC   0xF06F 0x0001      MVN      R0,#+1
   \       0x10   0xBDF2             POP      {R1,R4-R7,PC}
   2737              }
   2738              /* iotx_delete_thread(pClient); */
   2739              HAL_SleepMs(100);
   \                     ??wrapper_mqtt_release_1: (+1)
   \       0x12   0x2064             MOVS     R0,#+100
   \       0x14   0x....'....        BL       HAL_SleepMs
   2740          
   2741              iotx_mc_disconnect(pClient);
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       iotx_mc_disconnect
   2742              iotx_mc_set_client_state(pClient, IOTX_MC_STATE_INVALID);
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x....'....        BL       iotx_mc_set_client_state
   2743              HAL_SleepMs(100);
   \       0x26   0x2064             MOVS     R0,#+100
   \       0x28   0x....'....        BL       HAL_SleepMs
   2744          
   2745          #ifdef PLATFORM_HAS_DYNMEM
   2746              list_for_each_entry_safe(node, next, &pClient->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   \       0x2C   0x6B28             LDR      R0,[R5, #+48]
   \       0x2E   0xF1A0 0x0610      SUB      R6,R0,#+16
   \       0x32   0x6970             LDR      R0,[R6, #+20]
   \       0x34   0xF1A0 0x0710      SUB      R7,R0,#+16
   \       0x38   0xE00D             B.N      ??wrapper_mqtt_release_2
   2747                  list_del(&node->linked_list);
   \                     ??wrapper_mqtt_release_3: (+1)
   \       0x3A   0x....'....        BL       dlist_del
   2748                  mqtt_free(node->topic_filter);
   \       0x3E   0x68F0             LDR      R0,[R6, #+12]
   \       0x40   0x....'....        BL       HAL_Free
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x60F0             STR      R0,[R6, #+12]
   2749                  mqtt_free(node);
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0x....'....        BL       HAL_Free
   2750              }
   \       0x4E   0x463E             MOV      R6,R7
   \       0x50   0x6978             LDR      R0,[R7, #+20]
   \       0x52   0xF1A0 0x0710      SUB      R7,R0,#+16
   \                     ??wrapper_mqtt_release_2: (+1)
   \       0x56   0xF106 0x0010      ADD      R0,R6,#+16
   \       0x5A   0xF105 0x012C      ADD      R1,R5,#+44
   \       0x5E   0x4288             CMP      R0,R1
   \       0x60   0xD1EB             BNE.N    ??wrapper_mqtt_release_3
   2751          #else
   2752              memset(pClient->list_sub_handle, 0, sizeof(iotx_mc_topic_handle_t) * IOTX_MC_SUBHANDLE_LIST_MAX_LEN);
   2753          #endif
   2754              HAL_MutexDestroy(pClient->lock_generic);
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x....'....        BL       HAL_MutexDestroy
   2755              HAL_MutexDestroy(pClient->lock_list_pub);
   \       0x68   0xF8D5 0x00D0      LDR      R0,[R5, #+208]
   \       0x6C   0x....'....        BL       HAL_MutexDestroy
   2756              HAL_MutexDestroy(pClient->lock_write_buf);
   \       0x70   0xF8D5 0x00D4      LDR      R0,[R5, #+212]
   \       0x74   0x....'....        BL       HAL_MutexDestroy
   2757              HAL_MutexDestroy(pClient->lock_yield);
   \       0x78   0xF8D5 0x00DC      LDR      R0,[R5, #+220]
   \       0x7C   0x....'....        BL       HAL_MutexDestroy
   2758              HAL_MutexDestroy(pClient->lock_read_buf);
   \       0x80   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x84   0x....'....        BL       HAL_MutexDestroy
   2759          
   2760          #if !WITH_MQTT_ONLY_QOS0
   2761              iotx_mc_pub_wait_list_deinit(pClient);
   \       0x88   0x4628             MOV      R0,R5
   \       0x8A   0x....'....        BL       iotx_mc_pub_wait_list_deinit
   2762          #endif
   2763          #ifdef PLATFORM_HAS_DYNMEM
   2764              if (pClient->buf_send != NULL) {
   \       0x8E   0x6A68             LDR      R0,[R5, #+36]
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD003             BEQ.N    ??wrapper_mqtt_release_4
   2765                  mqtt_free(pClient->buf_send);
   \       0x94   0x....'....        BL       HAL_Free
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x6268             STR      R0,[R5, #+36]
   2766                  pClient->buf_send = NULL;
   2767              }
   2768              if (pClient->buf_read != NULL) {
   \                     ??wrapper_mqtt_release_4: (+1)
   \       0x9C   0x6AA8             LDR      R0,[R5, #+40]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD003             BEQ.N    ??wrapper_mqtt_release_5
   2769                  mqtt_free(pClient->buf_read);
   \       0xA2   0x....'....        BL       HAL_Free
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x62A8             STR      R0,[R5, #+40]
   2770                  pClient->buf_read = NULL;
   2771              }
   2772              mqtt_free(pClient);
   \                     ??wrapper_mqtt_release_5: (+1)
   \       0xAA   0x4628             MOV      R0,R5
   \       0xAC   0x....'....        BL       HAL_Free
   2773          #else
   2774              memset(pClient, 0, sizeof(iotx_mc_client_t));
   2775          #endif
   2776              *c = NULL;
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x6020             STR      R0,[R4, #+0]
   2777              mqtt_info("mqtt release!");
   2778              return SUCCESS_RETURN;
   \       0xB4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2779          }
   2780          

   \                                 In section .text, align 2, keep-with-next
   2781          int wrapper_mqtt_yield(void *client, int timeout_ms)
   2782          {
   \                     wrapper_mqtt_yield: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   2783              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
   2784          
   2785              if (pClient == NULL) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD102             BNE.N    ??wrapper_mqtt_yield_0
   2786                  return NULL_VALUE_ERROR;
   \        0xA   0xF06F 0x0001      MVN      R0,#+1
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
   2787              }
   2788          
   2789              if (timeout_ms < 0) {
   \                     ??wrapper_mqtt_yield_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD502             BPL.N    ??wrapper_mqtt_yield_1
   2790                  mqtt_err("Invalid argument, timeout_ms = %d", timeout_ms);
   2791                  return -1;
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD32             POP      {R1,R4,R5,PC}
   2792              }
   2793              if (timeout_ms == 0) {
   \                     ??wrapper_mqtt_yield_1: (+1)
   \       0x1A   0xD100             BNE.N    ??wrapper_mqtt_yield_2
   2794                  timeout_ms = 10;
   \       0x1C   0x240A             MOVS     R4,#+10
   2795              }
   2796          
   2797              HAL_MutexLock(pClient->lock_yield);
   \                     ??wrapper_mqtt_yield_2: (+1)
   \       0x1E   0xF8D5 0x00DC      LDR      R0,[R5, #+220]
   \       0x22   0x....'....        BL       HAL_MutexLock
   2798              pClient->cycle_timeout_ms = timeout_ms;
   \       0x26   0x60EC             STR      R4,[R5, #+12]
   2799              /* Keep MQTT alive or reconnect if connection abort */
   2800              iotx_mc_keepalive(pClient);
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       iotx_mc_keepalive
   2801              HAL_MutexUnlock(pClient->lock_yield);
   \       0x2E   0xF8D5 0x00DC      LDR      R0,[R5, #+220]
   \       0x32   0x....'....        BL       HAL_MutexUnlock
   2802          
   2803          #ifndef ASYNC_PROTOCOL_STACK
   2804              _mqtt_cycle(client);
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x....'....        BL       _mqtt_cycle
   2805          #else
   2806              if (pClient->client_state == IOTX_MC_STATE_CONNECTED) {
   2807          #if !WITH_MQTT_ONLY_QOS0
   2808                  /* check list of wait publish ACK to remove node that is ACKED or timeout */
   2809                  MQTTPubInfoProc(pClient);
   2810          #endif
   2811              }
   2812              HAL_SleepMs(timeout_ms);
   2813          #endif
   2814          
   2815              return 0;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2816          }
   2817          
   2818          
   2819          /* check MQTT client is in normal state */
   2820          /* 0, in abnormal state; 1, in normal state */

   \                                 In section .text, align 2, keep-with-next
   2821          int wrapper_mqtt_check_state(void *client)
   2822          {
   \                     wrapper_mqtt_check_state: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2823              if (!client) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??wrapper_mqtt_check_state_0
   2824                  return 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}
   2825              }
   2826          
   2827              if (iotx_mc_get_client_state((iotx_mc_client_t *)client) == IOTX_MC_STATE_CONNECTED) {
   \                     ??wrapper_mqtt_check_state_0: (+1)
   \        0xA   0x....'....        BL       iotx_mc_get_client_state
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE.N    ??wrapper_mqtt_check_state_1
   2828                  return 1;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xBD02             POP      {R1,PC}
   2829              }
   2830          
   2831              return 0;
   \                     ??wrapper_mqtt_check_state_1: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xBD02             POP      {R1,PC}          ;; return
   2832          }
   2833          

   \                                 In section .text, align 2, keep-with-next
   2834          int wrapper_mqtt_subscribe(void *client,
   2835                                     const char *topicFilter,
   2836                                     iotx_mqtt_qos_t qos,
   2837                                     iotx_mqtt_event_handle_func_fpt topic_handle_func,
   2838                                     void *pcontext)
   2839          {
   \                     wrapper_mqtt_subscribe: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
   2840              int rc = FAIL_RETURN;
   2841              unsigned int msgId;
   2842              iotx_mc_client_t *c;
   2843          
   2844              if (NULL == client || NULL == topicFilter || strlen(topicFilter) == 0 || !topic_handle_func) {
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD008             BEQ.N    ??wrapper_mqtt_subscribe_0
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD006             BEQ.N    ??wrapper_mqtt_subscribe_0
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       strlen
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??wrapper_mqtt_subscribe_0
   \       0x1E   0x0038             MOVS     R0,R7
   \       0x20   0xD102             BNE.N    ??wrapper_mqtt_subscribe_1
   2845                  mqtt_err(" paras error");
   2846                  return NULL_VALUE_ERROR;
   \                     ??wrapper_mqtt_subscribe_0: (+1)
   \       0x22   0xF06F 0x0001      MVN      R0,#+1
   \       0x26   0xE029             B.N      ??wrapper_mqtt_subscribe_2
   2847              }
   2848          
   2849              c = (iotx_mc_client_t *)client;
   2850          
   2851              msgId = iotx_mc_get_next_packetid(c);
   \                     ??wrapper_mqtt_subscribe_1: (+1)
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       iotx_mc_get_next_packetid
   \       0x2E   0x4680             MOV      R8,R0
   2852          
   2853              if (!wrapper_mqtt_check_state(c)) {
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x....'....        BL       wrapper_mqtt_check_state
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD102             BNE.N    ??wrapper_mqtt_subscribe_3
   2854                  mqtt_err("mqtt client state is error,state = %d", iotx_mc_get_client_state(c));
   2855                  return MQTT_STATE_ERROR;
   \       0x3A   0xF06F 0x001A      MVN      R0,#+26
   \       0x3E   0xE01D             B.N      ??wrapper_mqtt_subscribe_2
   2856              }
   2857          
   2858              if (0 != iotx_mc_check_topic(topicFilter, TOPIC_FILTER_TYPE)) {
   \                     ??wrapper_mqtt_subscribe_3: (+1)
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0x....'....        BL       iotx_mc_check_topic
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD002             BEQ.N    ??wrapper_mqtt_subscribe_4
   2859                  mqtt_err("topic format is error,topicFilter = %s", topicFilter);
   2860                  return MQTT_TOPIC_FORMAT_ERROR;
   \       0x4C   0xF06F 0x0028      MVN      R0,#+40
   \       0x50   0xE014             B.N      ??wrapper_mqtt_subscribe_2
   2861              }
   \                     ??wrapper_mqtt_subscribe_4: (+1)
   \       0x52   0x9808             LDR      R0,[SP, #+32]
   2862          
   2863              mqtt_debug("PERFORM subscribe to '%s' (msgId=%d)", topicFilter, msgId);
   2864              rc = MQTTSubscribe(c, topicFilter, qos, msgId, topic_handle_func, pcontext);
   \       0x54   0x9001             STR      R0,[SP, #+4]
   \       0x56   0x9700             STR      R7,[SP, #+0]
   \       0x58   0x4643             MOV      R3,R8
   \       0x5A   0x4632             MOV      R2,R6
   \       0x5C   0x4621             MOV      R1,R4
   \       0x5E   0x4628             MOV      R0,R5
   \       0x60   0x....'....        BL       MQTTSubscribe
   \       0x64   0x0004             MOVS     R4,R0
   2865              if (rc != SUCCESS_RETURN) {
   \       0x66   0xD008             BEQ.N    ??wrapper_mqtt_subscribe_5
   2866                  if (rc == MQTT_NETWORK_ERROR) {
   \       0x68   0xF114 0x0F0E      CMN      R4,#+14
   \       0x6C   0xD103             BNE.N    ??wrapper_mqtt_subscribe_6
   2867                      iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x6E   0x2103             MOVS     R1,#+3
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x....'....        BL       iotx_mc_set_client_state
   2868                  }
   2869          
   2870                  mqtt_err("run MQTTSubscribe error, rc = %d", rc);
   2871                  return rc;
   \                     ??wrapper_mqtt_subscribe_6: (+1)
   \       0x76   0x4620             MOV      R0,R4
   \       0x78   0xE000             B.N      ??wrapper_mqtt_subscribe_2
   2872              }
   2873          
   2874              mqtt_info("mqtt subscribe packet sent,topic = %s!", topicFilter);
   2875              return msgId;
   \                     ??wrapper_mqtt_subscribe_5: (+1)
   \       0x7A   0x4640             MOV      R0,R8
   \                     ??wrapper_mqtt_subscribe_2: (+1)
   \       0x7C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2876          }
   2877          

   \                                 In section .text, align 2, keep-with-next
   2878          int wrapper_mqtt_subscribe_sync(void *c,
   2879                                          const char *topic_filter,
   2880                                          iotx_mqtt_qos_t qos,
   2881                                          iotx_mqtt_event_handle_func_fpt topic_handle_func,
   2882                                          void *pcontext,
   2883                                          int timeout_ms)
   2884          {
   \                     wrapper_mqtt_subscribe_sync: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x4698             MOV      R8,R3
   2885              int             subed;
   2886              int             ret;
   2887              iotx_time_t     timer;
   2888              iotx_mc_client_t *client = (iotx_mc_client_t *)c;
   2889              int cnt = 0;
   2890              mqtt_sub_sync_node_t *node = NULL;
   2891          #ifdef PLATFORM_HAS_DYNMEM
   2892              mqtt_sub_sync_node_t *next = NULL;
   2893          #else
   2894              int idx = 0;
   2895          #endif
   2896              if (client == NULL) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD102             BNE.N    ??wrapper_mqtt_subscribe_sync_0
   2897                  return NULL_VALUE_ERROR;
   \       0x10   0xF06F 0x0001      MVN      R0,#+1
   \       0x14   0xE097             B.N      ??wrapper_mqtt_subscribe_sync_1
   2898              }
   2899          
   2900          #ifdef SUB_PERSISTENCE_ENABLED
   2901              if (qos > IOTX_MQTT_QOS3_SUB_LOCAL) {
   2902                  mqtt_warning("Invalid qos(%d) out of [%d, %d], using %d",
   2903                               qos,
   2904                               IOTX_MQTT_QOS0, IOTX_MQTT_QOS3_SUB_LOCAL, IOTX_MQTT_QOS0);
   2905                  qos = IOTX_MQTT_QOS0;
   2906              }
   2907          #else
   2908              if (qos > IOTX_MQTT_QOS2) {
   \                     ??wrapper_mqtt_subscribe_sync_0: (+1)
   \       0x16   0x4650             MOV      R0,R10
   \       0x18   0x2803             CMP      R0,#+3
   \       0x1A   0xDB01             BLT.N    ??wrapper_mqtt_subscribe_sync_2
   2909                  mqtt_warning("Invalid qos(%d) out of [%d, %d], using %d",
   2910                               qos,
   2911                               IOTX_MQTT_QOS0, IOTX_MQTT_QOS2, IOTX_MQTT_QOS0);
   2912                  qos = IOTX_MQTT_QOS0;
   \       0x1C   0xF04F 0x0A00      MOV      R10,#+0
   \                     ??wrapper_mqtt_subscribe_sync_2: (+1)
   \       0x20   0x9C0D             LDR      R4,[SP, #+52]
   2913              }
   2914          #endif
   2915          
   2916              iotx_time_init(&timer);
   \       0x22   0xA801             ADD      R0,SP,#+4
   \       0x24   0x....'....        BL       iotx_time_init
   2917              utils_time_countdown_ms(&timer, timeout_ms);
   \       0x28   0x4621             MOV      R1,R4
   \       0x2A   0xA801             ADD      R0,SP,#+4
   \       0x2C   0x....'....        BL       utils_time_countdown_ms
   2918          
   2919              ret = -1;
   \       0x30   0xF04F 0x39FF      MOV      R9,#-1
   \       0x34   0x464F             MOV      R7,R9
   2920              subed = 0;
   \       0x36   0x2400             MOVS     R4,#+0
   \       0x38   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   2921              cnt = 0;
   2922              cnt = cnt;
   \       0x3C   0x9502             STR      R5,[SP, #+8]
   2923              do {
   2924          #ifdef PLATFORM_HAS_DYNMEM
   2925                  mqtt_sub_sync_node_t *node = NULL;
   2926                  mqtt_sub_sync_node_t *next = NULL;
   2927          #else
   2928                  int idx = 0;
   2929          #endif
   2930                  if (ret < 0) {
   \                     ??wrapper_mqtt_subscribe_sync_3: (+1)
   \       0x3E   0x2F00             CMP      R7,#+0
   \       0x40   0xD50F             BPL.N    ??wrapper_mqtt_subscribe_sync_4
   2931                      ret = wrapper_mqtt_subscribe(client, topic_filter, qos, topic_handle_func, pcontext);
   \       0x42   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \       0x46   0x4643             MOV      R3,R8
   \       0x48   0x4652             MOV      R2,R10
   \       0x4A   0x9902             LDR      R1,[SP, #+8]
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x....'....        BL       wrapper_mqtt_subscribe
   \       0x52   0x4607             MOV      R7,R0
   2932                      if (_is_in_yield_cb() != 0 || qos == IOTX_MQTT_QOS3_SUB_LOCAL) {
   \       0x54   0x....'....        BL       _is_in_yield_cb
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD176             BNE.N    ??wrapper_mqtt_subscribe_sync_5
   \       0x5C   0x4650             MOV      R0,R10
   \       0x5E   0x2803             CMP      R0,#+3
   \       0x60   0xD073             BEQ.N    ??wrapper_mqtt_subscribe_sync_5
   2933                          return ret;
   2934                      }
   2935                  }
   2936          
   2937                  if (!subed && ret >= 0) {
   \                     ??wrapper_mqtt_subscribe_sync_4: (+1)
   \       0x62   0x2C00             CMP      R4,#+0
   \       0x64   0xD116             BNE.N    ??wrapper_mqtt_subscribe_sync_6
   \       0x66   0x2F00             CMP      R7,#+0
   \       0x68   0xD414             BMI.N    ??wrapper_mqtt_subscribe_sync_6
   2938                      mqtt_sub_sync_node_t *node = NULL;
   2939          #ifndef PLATFORM_HAS_DYNMEM
   2940                      int idx = 0;
   2941          #endif
   2942          #ifdef PLATFORM_HAS_DYNMEM
   2943                      node = (mqtt_sub_sync_node_t *)mqtt_malloc(sizeof(mqtt_sub_sync_node_t));
   \       0x6A   0x2014             MOVS     R0,#+20
   \       0x6C   0x....'....        BL       HAL_Malloc
   \       0x70   0x0005             MOVS     R5,R0
   2944          #else
   2945                      for (idx = 0; idx < IOTX_MC_SUBSYNC_LIST_MAX_LEN; idx++) {
   2946                          if (client->list_sub_sync_ack[idx].used == 0) {
   2947                              memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   2948                              client->list_sub_sync_ack[idx].used = 1;
   2949                              node = &client->list_sub_sync_ack[idx];
   2950                              break;
   2951                          }
   2952                      }
   2953          #endif
   2954                      if (node != NULL) {
   \       0x72   0xD00F             BEQ.N    ??wrapper_mqtt_subscribe_sync_6
   2955                          mqtt_debug("packet_id = %d", ret);
   2956                          node->packet_id = ret;
   \       0x74   0x602F             STR      R7,[R5, #+0]
   2957                          node->ack_type = IOTX_MQTT_EVENT_UNDEF;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x7128             STRB     R0,[R5, #+4]
   2958          #ifdef PLATFORM_HAS_DYNMEM
   2959                          HAL_MutexLock(client->lock_generic);
   \       0x7A   0x6830             LDR      R0,[R6, #+0]
   \       0x7C   0x....'....        BL       HAL_MutexLock
   2960                          list_add_tail(&node->linked_list, &client->list_sub_sync_ack);
   \       0x80   0xF106 0x01C8      ADD      R1,R6,#+200
   \       0x84   0xF105 0x000C      ADD      R0,R5,#+12
   \       0x88   0x....'....        BL       dlist_add_tail
   2961                          HAL_MutexUnlock(client->lock_generic);
   \       0x8C   0x6830             LDR      R0,[R6, #+0]
   \       0x8E   0x....'....        BL       HAL_MutexUnlock
   2962          #endif
   2963                          subed = 1;
   \       0x92   0x2401             MOVS     R4,#+1
   2964                      }
   2965          
   2966                  }
   2967                  wrapper_mqtt_yield(client, 100);
   \                     ??wrapper_mqtt_subscribe_sync_6: (+1)
   \       0x94   0x2164             MOVS     R1,#+100
   \       0x96   0x4630             MOV      R0,R6
   \       0x98   0x....'....        BL       wrapper_mqtt_yield
   2968          
   2969                  HAL_MutexLock(client->lock_generic);
   \       0x9C   0x6830             LDR      R0,[R6, #+0]
   \       0x9E   0x....'....        BL       HAL_MutexLock
   2970          #ifdef PLATFORM_HAS_DYNMEM
   2971                  list_for_each_entry_safe(node, next, &client->list_sub_sync_ack, linked_list, mqtt_sub_sync_node_t) {
   \       0xA2   0xF8D6 0x00CC      LDR      R0,[R6, #+204]
   \       0xA6   0xF1A0 0x050C      SUB      R5,R0,#+12
   \       0xAA   0xF106 0x01C8      ADD      R1,R6,#+200
   \       0xAE   0x4288             CMP      R0,R1
   \       0xB0   0xD012             BEQ.N    ??wrapper_mqtt_subscribe_sync_7
   2972                      if (node->packet_id == ret) {
   \       0xB2   0x6828             LDR      R0,[R5, #+0]
   \       0xB4   0x42B8             CMP      R0,R7
   \       0xB6   0xD10F             BNE.N    ??wrapper_mqtt_subscribe_sync_7
   2973                          mqtt_debug("node->ack_type=%d cnt=%d", node->ack_type, cnt++);
   2974                          if (node->ack_type == IOTX_MQTT_EVENT_SUBCRIBE_SUCCESS) {
   \       0xB8   0x7928             LDRB     R0,[R5, #+4]
   \       0xBA   0x2803             CMP      R0,#+3
   \       0xBC   0xD01F             BEQ.N    ??wrapper_mqtt_subscribe_sync_8
   2975                              list_del(&node->linked_list);
   2976                              mqtt_free(node);
   2977                              mqtt_debug("success!!");
   2978                              HAL_MutexUnlock(client->lock_generic);
   2979                              return ret;
   2980                          } else if (node->ack_type == IOTX_MQTT_EVENT_SUBCRIBE_NACK) {
   \       0xBE   0x2805             CMP      R0,#+5
   \       0xC0   0xD001             BEQ.N    ??wrapper_mqtt_subscribe_sync_9
   2981                              list_del(&node->linked_list);
   2982                              mqtt_free(node);
   2983                              ret = -1; /* resub */
   2984                              subed = 0;
   2985                          } else if (node->ack_type == IOTX_MQTT_EVENT_SUBCRIBE_TIMEOUT) {
   \       0xC2   0x2804             CMP      R0,#+4
   \       0xC4   0xD108             BNE.N    ??wrapper_mqtt_subscribe_sync_7
   2986                              list_del(&node->linked_list);
   \                     ??wrapper_mqtt_subscribe_sync_9: (+1)
   \       0xC6   0xF105 0x000C      ADD      R0,R5,#+12
   \       0xCA   0x....'....        BL       dlist_del
   2987                              mqtt_free(node);
   \       0xCE   0x4628             MOV      R0,R5
   \       0xD0   0x....'....        BL       HAL_Free
   2988                              ret = -1; /* resub */
   \       0xD4   0x464F             MOV      R7,R9
   2989                              subed = 0;
   \       0xD6   0x2400             MOVS     R4,#+0
   2990                          }
   2991                      }
   2992                      break;
   2993                  }
   2994          #else
   2995                  for (idx = 0; idx < IOTX_MC_SUBSYNC_LIST_MAX_LEN; idx++) {
   2996                      if (client->list_sub_sync_ack[idx].used == 0) {
   2997                          continue;
   2998                      }
   2999          
   3000                      if (client->list_sub_sync_ack[idx].packet_id == ret) {
   3001                          mqtt_debug("client->list_sub_sync_ack[%d].ack_type=%d cnt=%d", idx, client->list_sub_sync_ack[idx].ack_type, cnt++);
   3002                          if (client->list_sub_sync_ack[idx].ack_type == IOTX_MQTT_EVENT_SUBCRIBE_SUCCESS) {
   3003                              memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   3004                              mqtt_debug("success!!");
   3005                              HAL_MutexUnlock(client->lock_generic);
   3006                              return ret;
   3007                          } else if (client->list_sub_sync_ack[idx].ack_type == IOTX_MQTT_EVENT_SUBCRIBE_NACK) {
   3008                              memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   3009                              ret = -1; /* resub */
   3010                              subed = 0;
   3011                          } else if (client->list_sub_sync_ack[idx].ack_type == IOTX_MQTT_EVENT_SUBCRIBE_TIMEOUT) {
   3012                              memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   3013                              ret = -1; /* resub */
   3014                              subed = 0;
   3015                          }
   3016                      }
   3017                      break;
   3018                  }
   3019          #endif
   3020                  HAL_MutexUnlock(client->lock_generic);
   \                     ??wrapper_mqtt_subscribe_sync_7: (+1)
   \       0xD8   0x6830             LDR      R0,[R6, #+0]
   \       0xDA   0x....'....        BL       HAL_MutexUnlock
   3021              } while (!utils_time_is_expired(&timer));
   \       0xDE   0xA801             ADD      R0,SP,#+4
   \       0xE0   0x....'....        BL       utils_time_is_expired
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD0AA             BEQ.N    ??wrapper_mqtt_subscribe_sync_3
   3022              mqtt_warning("sync subscribe time out!!");
   3023          
   3024              HAL_MutexLock(client->lock_generic);
   \       0xE8   0x6830             LDR      R0,[R6, #+0]
   \       0xEA   0x....'....        BL       HAL_MutexLock
   3025          #ifdef PLATFORM_HAS_DYNMEM
   3026              list_for_each_entry_safe(node, next, &client->list_sub_sync_ack, linked_list, mqtt_sub_sync_node_t) {
   \       0xEE   0xF8D6 0x00CC      LDR      R0,[R6, #+204]
   \       0xF2   0xF1A0 0x040C      SUB      R4,R0,#+12
   \       0xF6   0x6920             LDR      R0,[R4, #+16]
   \       0xF8   0xF1A0 0x050C      SUB      R5,R0,#+12
   \       0xFC   0xE019             B.N      ??wrapper_mqtt_subscribe_sync_10
   \                     ??wrapper_mqtt_subscribe_sync_8: (+1)
   \       0xFE   0xF105 0x000C      ADD      R0,R5,#+12
   \      0x102   0x....'....        BL       dlist_del
   \      0x106   0x4628             MOV      R0,R5
   \      0x108   0x....'....        BL       HAL_Free
   \      0x10C   0x6830             LDR      R0,[R6, #+0]
   \      0x10E   0x....'....        BL       HAL_MutexUnlock
   \      0x112   0x4638             MOV      R0,R7
   \      0x114   0xE017             B.N      ??wrapper_mqtt_subscribe_sync_1
   3027                  if (node->packet_id == ret) {
   \                     ??wrapper_mqtt_subscribe_sync_11: (+1)
   \      0x116   0x6820             LDR      R0,[R4, #+0]
   \      0x118   0x42B8             CMP      R0,R7
   \      0x11A   0xD106             BNE.N    ??wrapper_mqtt_subscribe_sync_12
   3028                      list_del(&node->linked_list);
   \      0x11C   0xF104 0x000C      ADD      R0,R4,#+12
   \      0x120   0x....'....        BL       dlist_del
   3029                      mqtt_free(node);
   \      0x124   0x4620             MOV      R0,R4
   \      0x126   0x....'....        BL       HAL_Free
   3030                  }
   3031              }
   \                     ??wrapper_mqtt_subscribe_sync_12: (+1)
   \      0x12A   0x462C             MOV      R4,R5
   \      0x12C   0x6928             LDR      R0,[R5, #+16]
   \      0x12E   0xF1A0 0x050C      SUB      R5,R0,#+12
   \                     ??wrapper_mqtt_subscribe_sync_10: (+1)
   \      0x132   0xF104 0x000C      ADD      R0,R4,#+12
   \      0x136   0xF106 0x01C8      ADD      R1,R6,#+200
   \      0x13A   0x4288             CMP      R0,R1
   \      0x13C   0xD1EB             BNE.N    ??wrapper_mqtt_subscribe_sync_11
   3032          #else
   3033              for (idx = 0; idx < IOTX_MC_SUBSYNC_LIST_MAX_LEN; idx++) {
   3034                  if (client->list_sub_sync_ack[idx].used && node->packet_id == ret) {
   3035                      memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   3036                  }
   3037              }
   3038          #endif
   3039              HAL_MutexUnlock(client->lock_generic);
   \      0x13E   0x6830             LDR      R0,[R6, #+0]
   \      0x140   0x....'....        BL       HAL_MutexUnlock
   3040          
   3041              return -1;
   \      0x144   0x4648             MOV      R0,R9
   \                     ??wrapper_mqtt_subscribe_sync_1: (+1)
   \      0x146   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   \                     ??wrapper_mqtt_subscribe_sync_5: (+1)
   \      0x14A   0x4638             MOV      R0,R7
   \      0x14C   0xE7FB             B.N      ??wrapper_mqtt_subscribe_sync_1
   3042          }
   3043          

   \                                 In section .text, align 2, keep-with-next
   3044          int wrapper_mqtt_unsubscribe(void *client, const char *topicFilter)
   3045          {
   \                     wrapper_mqtt_unsubscribe: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   3046              int rc = FAIL_RETURN;
   3047              iotx_mc_client_t *c = (iotx_mc_client_t *)client;
   3048              unsigned int msgId;
   3049          
   3050              if (NULL == c || NULL == topicFilter) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD001             BEQ.N    ??wrapper_mqtt_unsubscribe_0
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??wrapper_mqtt_unsubscribe_1
   3051                  return NULL_VALUE_ERROR;
   \                     ??wrapper_mqtt_unsubscribe_0: (+1)
   \        0xE   0xF06F 0x0001      MVN      R0,#+1
   \       0x12   0xBD70             POP      {R4-R6,PC}
   3052              }
   3053              msgId = iotx_mc_get_next_packetid(c);
   \                     ??wrapper_mqtt_unsubscribe_1: (+1)
   \       0x14   0x....'....        BL       iotx_mc_get_next_packetid
   \       0x18   0x4606             MOV      R6,R0
   3054          
   3055              if (0 != iotx_mc_check_topic(topicFilter, TOPIC_FILTER_TYPE)) {
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       iotx_mc_check_topic
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD002             BEQ.N    ??wrapper_mqtt_unsubscribe_2
   3056                  mqtt_err("topic format is error,topicFilter = %s", topicFilter);
   3057                  return MQTT_TOPIC_FORMAT_ERROR;
   \       0x26   0xF06F 0x0028      MVN      R0,#+40
   \       0x2A   0xBD70             POP      {R4-R6,PC}
   3058              }
   3059          
   3060              if (!wrapper_mqtt_check_state(c)) {
   \                     ??wrapper_mqtt_unsubscribe_2: (+1)
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x....'....        BL       wrapper_mqtt_check_state
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD102             BNE.N    ??wrapper_mqtt_unsubscribe_3
   3061                  mqtt_err("mqtt client state is error,state = %d", iotx_mc_get_client_state(c));
   3062                  return MQTT_STATE_ERROR;
   \       0x36   0xF06F 0x001A      MVN      R0,#+26
   \       0x3A   0xBD70             POP      {R4-R6,PC}
   3063              }
   3064          
   3065              rc = MQTTUnsubscribe(c, topicFilter, msgId);
   \                     ??wrapper_mqtt_unsubscribe_3: (+1)
   \       0x3C   0x4632             MOV      R2,R6
   \       0x3E   0x4621             MOV      R1,R4
   \       0x40   0x4628             MOV      R0,R5
   \       0x42   0x....'....        BL       MQTTUnsubscribe
   \       0x46   0x0004             MOVS     R4,R0
   3066              if (rc != SUCCESS_RETURN) {
   \       0x48   0xD008             BEQ.N    ??wrapper_mqtt_unsubscribe_4
   3067                  if (rc == MQTT_NETWORK_ERROR) { /* send the subscribe packet */
   \       0x4A   0xF114 0x0F0E      CMN      R4,#+14
   \       0x4E   0xD103             BNE.N    ??wrapper_mqtt_unsubscribe_5
   3068                      iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x50   0x2103             MOVS     R1,#+3
   \       0x52   0x4628             MOV      R0,R5
   \       0x54   0x....'....        BL       iotx_mc_set_client_state
   3069                  }
   3070          
   3071                  mqtt_err("run MQTTUnsubscribe error!, rc = %d", rc);
   3072                  return rc;
   \                     ??wrapper_mqtt_unsubscribe_5: (+1)
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0xBD70             POP      {R4-R6,PC}
   3073              }
   3074          
   3075              mqtt_info("mqtt unsubscribe packet sent,topic = %s!", topicFilter);
   3076              return (int)msgId;
   \                     ??wrapper_mqtt_unsubscribe_4: (+1)
   \       0x5C   0x4630             MOV      R0,R6
   \       0x5E   0xBD70             POP      {R4-R6,PC}       ;; return
   3077          }
   3078          

   \                                 In section .text, align 2, keep-with-next
   3079          int wrapper_mqtt_publish(void *client, const char *topicName, iotx_mqtt_topic_info_pt topic_msg)
   3080          {
   \                     wrapper_mqtt_publish: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4615             MOV      R5,R2
   3081              uint16_t msg_id = 0;
   \        0x8   0x2700             MOVS     R7,#+0
   3082              int rc = FAIL_RETURN;
   3083              iotx_mc_client_t *c = (iotx_mc_client_t *)client;
   3084              if (c == NULL || topicName == NULL || topic_msg == NULL || topic_msg->payload == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD006             BEQ.N    ??wrapper_mqtt_publish_0
   \        0xE   0x2E00             CMP      R6,#+0
   \       0x10   0xD004             BEQ.N    ??wrapper_mqtt_publish_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD002             BEQ.N    ??wrapper_mqtt_publish_0
   \       0x16   0x6928             LDR      R0,[R5, #+16]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD102             BNE.N    ??wrapper_mqtt_publish_1
   3085                  return NULL_VALUE_ERROR;
   \                     ??wrapper_mqtt_publish_0: (+1)
   \       0x1C   0xF06F 0x0001      MVN      R0,#+1
   \       0x20   0xBDF2             POP      {R1,R4-R7,PC}
   3086              }
   3087          
   3088              if (0 != iotx_mc_check_topic(topicName, TOPIC_NAME_TYPE)) {
   \                     ??wrapper_mqtt_publish_1: (+1)
   \       0x22   0x4639             MOV      R1,R7
   \       0x24   0x4630             MOV      R0,R6
   \       0x26   0x....'....        BL       iotx_mc_check_topic
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD002             BEQ.N    ??wrapper_mqtt_publish_2
   3089                  mqtt_err("topic format is error,topicFilter = %s", topicName);
   3090                  return MQTT_TOPIC_FORMAT_ERROR;
   \       0x2E   0xF06F 0x0028      MVN      R0,#+40
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}
   3091              }
   3092          
   3093              if (!wrapper_mqtt_check_state(c)) {
   \                     ??wrapper_mqtt_publish_2: (+1)
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       wrapper_mqtt_check_state
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD102             BNE.N    ??wrapper_mqtt_publish_3
   3094                  mqtt_err("mqtt client state is error,state = %d", iotx_mc_get_client_state(c));
   3095                  return MQTT_STATE_ERROR;
   \       0x3E   0xF06F 0x001A      MVN      R0,#+26
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}
   3096              }
   3097          
   3098          #if !WITH_MQTT_ONLY_QOS0
   3099              if (topic_msg->qos == IOTX_MQTT_QOS1 || topic_msg->qos == IOTX_MQTT_QOS2) {
   \                     ??wrapper_mqtt_publish_3: (+1)
   \       0x44   0x78A8             LDRB     R0,[R5, #+2]
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD001             BEQ.N    ??wrapper_mqtt_publish_4
   \       0x4A   0x2802             CMP      R0,#+2
   \       0x4C   0xD104             BNE.N    ??wrapper_mqtt_publish_5
   3100                  msg_id = iotx_mc_get_next_packetid(c);
   \                     ??wrapper_mqtt_publish_4: (+1)
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x....'....        BL       iotx_mc_get_next_packetid
   \       0x54   0x4607             MOV      R7,R0
   3101                  topic_msg->packet_id = msg_id;
   \       0x56   0x802F             STRH     R7,[R5, #+0]
   3102              }
   3103              if (topic_msg->qos == IOTX_MQTT_QOS2) {
   \                     ??wrapper_mqtt_publish_5: (+1)
   \       0x58   0x78A8             LDRB     R0,[R5, #+2]
   \       0x5A   0x2802             CMP      R0,#+2
   \       0x5C   0xD102             BNE.N    ??wrapper_mqtt_publish_6
   3104                  mqtt_err("MQTTPublish return error,MQTT_QOS2 is now not supported.");
   3105                  return MQTT_PUBLISH_QOS_ERROR;
   \       0x5E   0xF06F 0x0013      MVN      R0,#+19
   \       0x62   0xBDF2             POP      {R1,R4-R7,PC}
   3106              }
   3107          #else
   3108              topic_msg->qos = IOTX_MQTT_QOS0;
   3109          #endif
   3110          
   3111          #if defined(INSPECT_MQTT_FLOW) && defined(INFRA_LOG)
   3112              HEXDUMP_DEBUG(topicName, strlen(topicName));
   3113              HEXDUMP_DEBUG(topic_msg->payload, topic_msg->payload_len);
   3114          #endif
   3115          
   3116              rc = MQTTPublish(c, topicName, topic_msg);
   \                     ??wrapper_mqtt_publish_6: (+1)
   \       0x64   0x462A             MOV      R2,R5
   \       0x66   0x4631             MOV      R1,R6
   \       0x68   0x4620             MOV      R0,R4
   \       0x6A   0x....'....        BL       MQTTPublish
   \       0x6E   0x0005             MOVS     R5,R0
   3117              if (rc != SUCCESS_RETURN) { /* send the subscribe packet */
   \       0x70   0xD008             BEQ.N    ??wrapper_mqtt_publish_7
   3118                  if (rc == MQTT_NETWORK_ERROR) {
   \       0x72   0xF115 0x0F0E      CMN      R5,#+14
   \       0x76   0xD103             BNE.N    ??wrapper_mqtt_publish_8
   3119                      iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x78   0x2103             MOVS     R1,#+3
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0x....'....        BL       iotx_mc_set_client_state
   3120                  }
   3121                  mqtt_err("MQTTPublish is error, rc = %d", rc);
   3122                  return rc;
   \                     ??wrapper_mqtt_publish_8: (+1)
   \       0x80   0x4628             MOV      R0,R5
   \       0x82   0xBDF2             POP      {R1,R4-R7,PC}
   3123              }
   3124          
   3125              return (int)msg_id;
   \                     ??wrapper_mqtt_publish_7: (+1)
   \       0x84   0xB2BF             UXTH     R7,R7
   \       0x86   0x4638             MOV      R0,R7
   \       0x88   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3126          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     iotx_ca_crt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0xFFFF'FC0A        DC32     0xfffffc0a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     _in_yield_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     _in_yield_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0xFFFF'FC09        DC32     0xfffffc09

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x6D 0x71          DC8 "mqtt read buffer is too short"
   \              0x74 0x74    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x20    
   \              0x62 0x75    
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x00    
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \        0x0   0x2F 0x00          DC8 "/"
   3127          
   3128          #ifdef ASYNC_PROTOCOL_STACK
   3129          int wrapper_mqtt_nwk_event_handler(void *client, iotx_mqtt_nwk_event_t event, iotx_mqtt_nwk_param_t *param)
   3130          {
   3131              int rc = FAIL_RETURN;
   3132              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
   3133              if (client == NULL || event >= IOTX_MQTT_SOC_MAX) {
   3134                  return NULL_VALUE_ERROR;
   3135              }
   3136          
   3137              switch (event) {
   3138                  case IOTX_MQTT_SOC_CONNECTED: {
   3139                      rc = _mqtt_connect(pClient);
   3140                      if (rc == SUCCESS_RETURN) {
   3141                          iotx_mc_set_client_state(pClient, IOTX_MC_STATE_CONNECTED);
   3142                      }
   3143                  }
   3144                  break;
   3145                  case IOTX_MQTT_SOC_CLOSE: {
   3146                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED);
   3147                  }
   3148                  break;
   3149                  case IOTX_MQTT_SOC_READ: {
   3150                      HAL_MutexLock(pClient->lock_yield);
   3151                      _mqtt_cycle(pClient);
   3152                      HAL_MutexUnlock(pClient->lock_yield);
   3153                      rc = SUCCESS_RETURN;
   3154                  }
   3155                  break;
   3156                  case IOTX_MQTT_SOC_WRITE: {
   3157          
   3158                  }
   3159                  break;
   3160                  default: {
   3161                      mqtt_err("unknown event: %d", event);
   3162                  }
   3163                  break;
   3164              }
   3165          
   3166              return rc;
   3167          }
   3168          #endif
   3169          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   INIT_AOS_DLIST_HEAD
      16   MQTTConnect
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> MQTTSerialize_connect
        16   -> _alloc_send_buffer
        16   -> _get_connect_length
        16   -> _reset_send_buffer
        16   -> iotx_mc_send_packet
        16   -> iotx_time_init
        16   -> utils_time_countdown_ms
      24   MQTTDisconnect
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> MQTTSerialize_disconnect
        24   -> _alloc_send_buffer
        24   -> _reset_send_buffer
        24   -> iotx_mc_send_packet
        24   -> iotx_time_init
        24   -> utils_time_countdown_ms
      16   MQTTKeepalive
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> MQTTSerialize_pingreq
        16   -> _alloc_send_buffer
        16   -> _reset_send_buffer
        16   -> iotx_mc_send_packet
        16   -> iotx_time_init
        16   -> utils_time_countdown_ms
      24   MQTTPubInfoProc
        24   -> HAL_Free
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> MQTTRePublish
        24   -> dlist_del
        24   -> iotx_mc_get_client_state
        24   -> iotx_mc_set_client_state
        24   -> iotx_time_start
        24   -> utils_time_spend
      24   MQTTPuback
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> MQTTSerialize_ack
        24   -> _alloc_send_buffer
        24   -> _reset_send_buffer
        24   -> iotx_mc_send_packet
        24   -> iotx_time_init
        24   -> utils_time_countdown_ms
      64   MQTTPublish
        64   -> HAL_Free
        64   -> HAL_MutexLock
        64   -> HAL_MutexUnlock
        64   -> MQTTSerialize_publish
        64   -> _alloc_send_buffer
        64   -> _reset_send_buffer
        64   -> dlist_del
        64   -> iotx_facility_json_print
        64   -> iotx_mc_push_pubInfo_to
        64   -> iotx_mc_send_packet
        64   -> iotx_time_init
        64   -> strlen
        64   -> utils_time_countdown_ms
      24   MQTTRePublish
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> iotx_mc_send_packet
        24   -> iotx_time_init
        24   -> utils_time_countdown_ms
      64   MQTTSubscribe
        64   -> HAL_Free
        64   -> HAL_Malloc
        64   -> HAL_MutexLock
        64   -> HAL_MutexUnlock
        64   -> INIT_AOS_DLIST_HEAD
        64   -> MQTTSerialize_subscribe
        64   -> __aeabi_memcpy
        64   -> __aeabi_memset
        64   -> __aeabi_memset4
        64   -> _alloc_send_buffer
        64   -> _reset_send_buffer
        64   -> dlist_add_tail
        64   -> iotx_mc_check_handle_is_identical
        64   -> iotx_mc_send_packet
        64   -> iotx_time_init
        64   -> strlen
        64   -> utils_time_countdown_ms
      56   MQTTUnsubscribe
        56   -> HAL_Free
        56   -> HAL_Malloc
        56   -> HAL_MutexLock
        56   -> HAL_MutexUnlock
        56   -> MQTTPacket_equals
        56   -> MQTTSerialize_unsubscribe
        56   -> __aeabi_memcpy
        56   -> __aeabi_memset
        56   -> __aeabi_memset4
        56   -> _alloc_send_buffer
        56   -> _reset_send_buffer
        56   -> dlist_del
        56   -> iotx_mc_is_topic_matched
        56   -> iotx_mc_send_packet
        56   -> iotx_time_init
        56   -> strlen
        56   -> utils_time_countdown_ms
       0   __dlist_add
       0   __dlist_entry_number
      16   _alloc_recv_buffer
        16   -> HAL_Free
        16   -> HAL_Malloc
        16   -> __aeabi_memcpy
        16   -> __aeabi_memset
      16   _alloc_send_buffer
        16   -> HAL_Free
        16   -> HAL_Malloc
        16   -> __aeabi_memset
       8   _get_connect_length
         0   -> MQTTPacket_len
         8   -> MQTTSerialize_connectLength
       8   _handle_event
         8   -- Indirect call
      16   _iotx_mqtt_event_handle_sub
        16   -> HAL_MutexLock
         0   -> HAL_MutexUnlock
       0   _is_in_yield_cb
      16   _mqtt_connect
        16   -- Indirect call
        16   -> HAL_SleepMs
        16   -> MQTTConnect
        16   -> iotx_mc_set_client_state
        16   -> iotx_mc_wait_CONNACK
        16   -> utils_time_countdown_ms
      16   _mqtt_cycle
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> HAL_SleepMs
        16   -> MQTTPubInfoProc
        16   -> iotx_mc_cycle
        16   -> iotx_time_init
        16   -> iotx_time_left
        16   -> utils_time_countdown_ms
        16   -> utils_time_is_expired
       8   _reset_recv_buffer
         8   -> HAL_Free
       8   _reset_send_buffer
         8   -> HAL_Free
       0   dlist_add_tail
         0   -> __dlist_add
       0   dlist_del
       8   iotx_mc_attempt_reconnect
         8   -- Indirect call
         0   -> wrapper_mqtt_connect
      16   iotx_mc_check_handle_is_identical
        16   -> iotx_mc_check_handle_is_identical_ex
      16   iotx_mc_check_handle_is_identical_ex
        16   -> strlen
        16   -> strncmp
      16   iotx_mc_check_rule
        16   -> strlen
     152   iotx_mc_check_topic
       152   -> __aeabi_memset4
       152   -> infra_strtok
       152   -> iotx_mc_check_rule
       152   -> strlen
       152   -> strncpy
      24   iotx_mc_cycle
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> _reset_recv_buffer
        24   -> iotx_mc_get_client_state
        24   -> iotx_mc_handle_recv_PUBACK
        24   -> iotx_mc_handle_recv_PUBLISH
        24   -> iotx_mc_handle_recv_SUBACK
        24   -> iotx_mc_handle_recv_UNSUBACK
        24   -> iotx_mc_read_packet
        24   -> iotx_mc_set_client_state
      32   iotx_mc_decode_packet
        32   -- Indirect call
      32   iotx_mc_deliver_message
        32   -> HAL_MutexLock
        32   -> HAL_MutexUnlock
        32   -> MQTTPacket_equals
        32   -> _handle_event
        32   -> iotx_mc_is_topic_matched
       8   iotx_mc_disconnect
         8   -- Indirect call
         8   -> MQTTDisconnect
         8   -> iotx_mc_set_client_state
         8   -> wrapper_mqtt_check_state
      16   iotx_mc_disconnect_callback
        16   -- Indirect call
      16   iotx_mc_get_client_state
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      16   iotx_mc_get_next_packetid
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      16   iotx_mc_handle_reconnect
        16   -> HAL_SleepMs
        16   -> iotx_mc_attempt_reconnect
        16   -> iotx_mc_set_client_state
        16   -> utils_time_countdown_ms
        16   -> utils_time_is_expired
      16   iotx_mc_handle_recv_CONNACK
        16   -> MQTTDeserialize_connack
      24   iotx_mc_handle_recv_PUBACK
        24   -> MQTTDeserialize_ack
        24   -> _handle_event
        24   -> iotx_mc_mask_pubInfo_from
      72   iotx_mc_handle_recv_PUBLISH
        72   -> MQTTDeserialize_publish
        72   -> MQTTPuback
        72   -> __aeabi_memset4
        72   -> get_msgid
        72   -> iotx_facility_json_print
        72   -> iotx_mc_deliver_message
      64   iotx_mc_handle_recv_SUBACK
        64   -> MQTTDeserialize_suback
        64   -> _handle_event
        64   -> _iotx_mqtt_event_handle_sub
      24   iotx_mc_handle_recv_UNSUBACK
        24   -> MQTTDeserialize_unsuback
        24   -> _handle_event
     112   iotx_mc_init
       112   -> HAL_Free
       112   -> HAL_MutexCreate
       112   -> HAL_MutexDestroy
       112   -> INIT_AOS_DLIST_HEAD
       112   -> __aeabi_memcpy4
       112   -> __aeabi_memset4
       112   -> iotx_mc_pub_wait_list_init
       112   -> iotx_mc_set_client_state
       112   -> iotx_mc_set_connect_params
       112   -> iotx_net_init
       112   -> iotx_time_init
       4   iotx_mc_is_topic_matched
       8   iotx_mc_keepalive
         8   -- Indirect call
         8   -> iotx_mc_disconnect_callback
         8   -> iotx_mc_get_client_state
         8   -> iotx_mc_handle_reconnect
         8   -> iotx_mc_keepalive_sub
         8   -> iotx_mc_reconnect_callback
         0   -> iotx_mc_set_client_state
         8   -> utils_time_countdown_ms
      16   iotx_mc_keepalive_sub
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> MQTTKeepalive
        16   -> iotx_mc_set_client_state
        16   -> utils_time_countdown_ms
        16   -> utils_time_is_expired
        16   -> wrapper_mqtt_check_state
      16   iotx_mc_mask_pubInfo_from
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      16   iotx_mc_pub_wait_list_deinit
        16   -> HAL_Free
        16   -> dlist_del
       0   iotx_mc_pub_wait_list_init
         0   -> INIT_AOS_DLIST_HEAD
      24   iotx_mc_push_pubInfo_to
        24   -> HAL_Malloc
        24   -> INIT_AOS_DLIST_HEAD
        24   -> __aeabi_memcpy
        24   -> __dlist_entry_number
        24   -> dlist_add_tail
        24   -> iotx_time_start
      40   iotx_mc_read_packet
        40   -- Indirect call
        40   -> HAL_Free
        40   -> HAL_Malloc
        40   -> HAL_MutexLock
        40   -> HAL_MutexUnlock
        40   -> MQTTPacket_encode
        40   -> _alloc_recv_buffer
        40   -> _handle_event
        40   -> iotx_mc_decode_packet
        40   -> iotx_time_left
      16   iotx_mc_reconnect_callback
        16   -- Indirect call
       0   iotx_mc_release
         0   -> HAL_Free
      24   iotx_mc_send_packet
        24   -- Indirect call
        24   -> iotx_time_left
        24   -> utils_time_is_expired
      16   iotx_mc_set_client_state
        16   -> HAL_MutexLock
         0   -> HAL_MutexUnlock
      16   iotx_mc_set_connect_params
        16   -> __aeabi_memcpy4
      24   iotx_mc_wait_CONNACK
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> _reset_recv_buffer
        24   -> iotx_mc_handle_recv_CONNACK
        24   -> iotx_mc_read_packet
        24   -> iotx_time_init
        24   -> utils_time_countdown_ms
       8   wrapper_mqtt_check_state
         8   -> iotx_mc_get_client_state
      16   wrapper_mqtt_connect
        16   -- Indirect call
        16   -> HAL_SleepMs
         0   -> _mqtt_connect
      16   wrapper_mqtt_init
        16   -> HAL_Malloc
        16   -> __aeabi_memset4
        16   -> iotx_mc_init
        16   -> iotx_mc_release
      24   wrapper_mqtt_publish
        24   -> MQTTPublish
        24   -> iotx_mc_check_topic
        24   -> iotx_mc_get_next_packetid
        24   -> iotx_mc_set_client_state
        24   -> wrapper_mqtt_check_state
      24   wrapper_mqtt_release
        24   -> HAL_Free
        24   -> HAL_MutexDestroy
        24   -> HAL_SleepMs
        24   -> dlist_del
        24   -> iotx_mc_disconnect
        24   -> iotx_mc_pub_wait_list_deinit
        24   -> iotx_mc_set_client_state
      32   wrapper_mqtt_subscribe
        32   -> MQTTSubscribe
        32   -> iotx_mc_check_topic
        32   -> iotx_mc_get_next_packetid
        32   -> iotx_mc_set_client_state
        32   -> strlen
        32   -> wrapper_mqtt_check_state
      48   wrapper_mqtt_subscribe_sync
        48   -> HAL_Free
        48   -> HAL_Malloc
        48   -> HAL_MutexLock
        48   -> HAL_MutexUnlock
        48   -> _is_in_yield_cb
        48   -> dlist_add_tail
        48   -> dlist_del
        48   -> iotx_time_init
        48   -> utils_time_countdown_ms
        48   -> utils_time_is_expired
        48   -> wrapper_mqtt_subscribe
        48   -> wrapper_mqtt_yield
      16   wrapper_mqtt_unsubscribe
        16   -> MQTTUnsubscribe
        16   -> iotx_mc_check_topic
        16   -> iotx_mc_get_next_packetid
        16   -> iotx_mc_set_client_state
        16   -> wrapper_mqtt_check_state
      16   wrapper_mqtt_yield
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> _mqtt_cycle
        16   -> iotx_mc_keepalive


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
      32  ?_0
       2  ?_1
      88  ?_2
      12  ?_3
      12  ?_4
      12  ?_5
       6  INIT_AOS_DLIST_HEAD
     158  MQTTConnect
     108  MQTTDisconnect
     146  MQTTKeepalive
     144  MQTTPubInfoProc
     176  MQTTPuback
     354  MQTTPublish
      68  MQTTRePublish
     448  MQTTSubscribe
     454  MQTTUnsubscribe
      10  __dlist_add
      20  __dlist_entry_number
     110  _alloc_recv_buffer
      72  _alloc_send_buffer
      14  _get_connect_length
      36  _handle_event
       4  _in_yield_cb
      74  _iotx_mqtt_event_handle_sub
       8  _is_in_yield_cb
     146  _mqtt_connect
      86  _mqtt_cycle
      30  _reset_recv_buffer
      30  _reset_send_buffer
       6  dlist_add_tail
      10  dlist_del
      30  iotx_mc_attempt_reconnect
      46  iotx_mc_check_handle_is_identical
      76  iotx_mc_check_handle_is_identical_ex
      68  iotx_mc_check_rule
     116  iotx_mc_check_topic
     270  iotx_mc_cycle
     114  iotx_mc_decode_packet
     178  iotx_mc_deliver_message
      46  iotx_mc_disconnect
      38  iotx_mc_disconnect_callback
      24  iotx_mc_get_client_state
      48  iotx_mc_get_next_packetid
     108  iotx_mc_handle_reconnect
     106  iotx_mc_handle_recv_CONNACK
      98  iotx_mc_handle_recv_PUBACK
     188  iotx_mc_handle_recv_PUBLISH
     156  iotx_mc_handle_recv_SUBACK
      78  iotx_mc_handle_recv_UNSUBACK
     418  iotx_mc_init
     114  iotx_mc_is_topic_matched
      96  iotx_mc_keepalive
     108  iotx_mc_keepalive_sub
      72  iotx_mc_mask_pubInfo_from
      52  iotx_mc_pub_wait_list_deinit
       4  iotx_mc_pub_wait_list_init
     136  iotx_mc_push_pubInfo_to
     484  iotx_mc_read_packet
      38  iotx_mc_reconnect_callback
       4  iotx_mc_release
     104  iotx_mc_send_packet
      26  iotx_mc_set_client_state
     202  iotx_mc_set_connect_params
     152  iotx_mc_wait_CONNACK
      26  wrapper_mqtt_check_state
      72  wrapper_mqtt_connect
      48  wrapper_mqtt_init
     138  wrapper_mqtt_publish
     182  wrapper_mqtt_release
     128  wrapper_mqtt_subscribe
     334  wrapper_mqtt_subscribe_sync
      96  wrapper_mqtt_unsubscribe
      64  wrapper_mqtt_yield

 
     4 bytes in section .bss
   158 bytes in section .rodata
 7 632 bytes in section .text
 
 7 632 bytes of CODE  memory
   158 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
