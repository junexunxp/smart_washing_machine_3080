###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:38
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\os_misc.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW26B2.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\os_misc.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\os_misc.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\os_misc.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\os_misc.c
      1          /*
      2           * Copyright (C) 2015-2018 Alibaba Group Holding Limited
      3           */
      4          #include "dev_bind_internal.h"

  typedef void *p_HAL_Aes128_t;
                ^
"C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\os.h",49  Warning[Pe301]: 
          typedef name has already been declared (with same type)
      5          
      6          /****** Convert values between host and big-/little-endian byte order ******/
      7          
      8          /* reverse byte order */

   \                                 In section .text, align 2, keep-with-next
      9          static uint16_t reverse_16bit(uint16_t data)
     10          {
   \                     reverse_16bit: (+1)
   \        0x0   0x4601             MOV      R1,R0
     11              return (data >> 8) | (data << 8);
   \        0x2   0x0A00             LSRS     R0,R0,#+8
   \        0x4   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \        0x8   0xB280             UXTH     R0,R0
   \        0xA   0x4770             BX       LR               ;; return
     12          }
     13          
     14          /* host byte order to big endian */

   \                                 In section .text, align 2, keep-with-next
     15          uint16_t os_htobe16(uint16_t data)
     16          {
   \                     os_htobe16: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     17              if (os_is_big_endian()) {
   \        0x4   0x....'....        BL       os_is_big_endian
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0xD102             BNE.N    ??os_htobe16_0
     18                  return data;
     19              }
     20          
     21              return reverse_16bit(data);
   \        0xE   0xE8BD 0x4010      POP      {R4,LR}
   \       0x12   0x....             B.N      reverse_16bit
   \                     ??os_htobe16_0: (+1)
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
     22          }
     23          
     24          /* host byte order to little endian */

   \                                 In section .text, align 2, keep-with-next
     25          uint16_t os_htole16(uint16_t data)
     26          {
   \                     os_htole16: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     27              if (os_is_big_endian()) {
   \        0x4   0x....'....        BL       os_is_big_endian
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0xD002             BEQ.N    ??os_htole16_0
     28                  return reverse_16bit(data);
   \        0xE   0xE8BD 0x4010      POP      {R4,LR}
   \       0x12   0x....             B.N      reverse_16bit
     29              }
     30          
     31              return data;
   \                     ??os_htole16_0: (+1)
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
     32          }
     33          
     34          /* big endian to host byte order */

   \                                 In section .text, align 2, keep-with-next
     35          uint16_t os_be16toh(uint16_t data)
     36          {
     37              return os_htobe16(data);
   \                     os_be16toh: (+1)
   \        0x0   0x....             B.N      os_htobe16
     38          }
     39          
     40          /* little endian to host byte order */

   \                                 In section .text, align 2, keep-with-next
     41          uint16_t os_le16toh(uint16_t data)
     42          {
     43              return os_htole16(data);
   \                     os_le16toh: (+1)
   \        0x0   0x....             B.N      os_htole16
     44          }
     45          
     46          /* get unaligned data in big endian. */

   \                                 In section .text, align 2, keep-with-next
     47          uint16_t os_get_unaligned_be16(uint8_t * ptr)
     48          {
   \                     os_get_unaligned_be16: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4601             MOV      R1,R0
     49              uint16_t res;
     50          
     51              memcpy(&res, ptr, sizeof(uint16_t));
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x....'....        BL       __aeabi_memcpy
     52          
     53              return os_be16toh(res);
   \        0xC   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x10   0x....'....        BL       os_be16toh
   \       0x14   0xBD02             POP      {R1,PC}          ;; return
     54          }
     55          
     56          /* get unaligned data in little endian. */

   \                                 In section .text, align 2, keep-with-next
     57          uint16_t os_get_unaligned_le16(uint8_t * ptr)
     58          {
   \                     os_get_unaligned_le16: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4601             MOV      R1,R0
     59              uint16_t res;
     60          
     61              memcpy(&res, ptr, sizeof(uint16_t));
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x....'....        BL       __aeabi_memcpy
     62          
     63              return os_le16toh(res);
   \        0xC   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x10   0x....'....        BL       os_le16toh
   \       0x14   0xBD02             POP      {R1,PC}          ;; return
     64          
     65          }
     66          
     67          /* format mac string uppercase */

   \                                 In section .text, align 2, keep-with-next
     68          char *os_wifi_get_mac_str(char mac_str[OS_MAC_LEN])
     69          {
   \                     os_wifi_get_mac_str: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     70              char *str;
     71              int colon_num = 0, i;
     72          
     73              str = HAL_Wifi_Get_Mac(mac_str);
   \        0x4   0x....'....        BL       HAL_Wifi_Get_Mac
   \        0x8   0xE005             B.N      ??os_wifi_get_mac_str_0
     74          
     75              /* sanity check */
     76              while (str) {
     77                  str = strchr(str, ':');
   \                     ??os_wifi_get_mac_str_1: (+1)
   \        0xA   0x213A             MOVS     R1,#+58
   \        0xC   0x....'....        BL       strchr
     78                  if (str) {
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD000             BEQ.N    ??os_wifi_get_mac_str_0
     79                      colon_num ++;
     80                      str ++; /* eating char ':' */
   \       0x14   0x1C40             ADDS     R0,R0,#+1
     81                  }
     82              }
   \                     ??os_wifi_get_mac_str_0: (+1)
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD1F7             BNE.N    ??os_wifi_get_mac_str_1
     83          
     84              /* convert to capital letter */
     85              for (i = 0; i < OS_MAC_LEN && mac_str[i]; i ++) {
   \       0x1A   0x2100             MOVS     R1,#+0
   \                     ??os_wifi_get_mac_str_2: (+1)
   \       0x1C   0x2912             CMP      R1,#+18
   \       0x1E   0xDA0A             BGE.N    ??os_wifi_get_mac_str_3
   \       0x20   0x5C60             LDRB     R0,[R4, R1]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD007             BEQ.N    ??os_wifi_get_mac_str_3
     86                  if ('a' <= mac_str[i] && mac_str[i] <= 'z') {
   \       0x26   0x3861             SUBS     R0,R0,#+97
   \       0x28   0x281A             CMP      R0,#+26
   \       0x2A   0xD202             BCS.N    ??os_wifi_get_mac_str_4
     87                      mac_str[i] -= 'a' - 'A';
   \       0x2C   0x5C60             LDRB     R0,[R4, R1]
   \       0x2E   0x3820             SUBS     R0,R0,#+32
   \       0x30   0x5460             STRB     R0,[R4, R1]
     88                  }
     89              }
   \                     ??os_wifi_get_mac_str_4: (+1)
   \       0x32   0x1C49             ADDS     R1,R1,#+1
   \       0x34   0xE7F2             B.N      ??os_wifi_get_mac_str_2
     90          
     91              return mac_str;
   \                     ??os_wifi_get_mac_str_3: (+1)
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0xBD10             POP      {R4,PC}          ;; return
     92          }

   \                                 In section .text, align 2, keep-with-next
     93          char *os_wifi_str2mac(char mac_str[OS_MAC_LEN], char mac[OS_ETH_ALEN])
     94          {
   \                     os_wifi_str2mac: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
     95              int i = 0;
   \        0x4   0x2500             MOVS     R5,#+0
     96              char *ptr = mac_str;
   \        0x6   0x9000             STR      R0,[SP, #+0]
     97              char mac_addr[OS_ETH_ALEN] = {0};
   \        0x8   0xA801             ADD      R0,SP,#+4
   \        0xA   0x4629             MOV      R1,R5
   \        0xC   0x460A             MOV      R2,R1
   \        0xE   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
     98          
     99              if (ptr == NULL)
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD01E             BEQ.N    ??os_wifi_str2mac_0
    100                  return NULL;
    101          
    102              while (isxdigit(*ptr) && i < OS_ETH_ALEN) {
   \                     ??os_wifi_str2mac_1: (+1)
   \       0x18   0x9800             LDR      R0,[SP, #+0]
   \       0x1A   0x7800             LDRB     R0,[R0, #+0]
   \       0x1C   0x....'....        BL       isxdigit
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD016             BEQ.N    ??os_wifi_str2mac_2
   \       0x24   0x2D06             CMP      R5,#+6
   \       0x26   0xDA14             BGE.N    ??os_wifi_str2mac_2
    103                  mac_addr[i ++] = (uint8_t)strtol(ptr, &ptr, 16);
   \       0x28   0x2210             MOVS     R2,#+16
   \       0x2A   0x4669             MOV      R1,SP
   \       0x2C   0x9800             LDR      R0,[SP, #+0]
   \       0x2E   0x....'....        BL       strtol
   \       0x32   0xA901             ADD      R1,SP,#+4
   \       0x34   0x5548             STRB     R0,[R1, R5]
   \       0x36   0x1C6D             ADDS     R5,R5,#+1
    104                  ++ ptr;
   \       0x38   0x9800             LDR      R0,[SP, #+0]
   \       0x3A   0x1C40             ADDS     R0,R0,#+1
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   \       0x3E   0xE7EB             B.N      ??os_wifi_str2mac_1
    105              }
    106          
    107              if (i < OS_ETH_ALEN)  /* don't touch mac when fail */
    108                  return NULL;
    109          
    110              if (mac) memcpy(mac, mac_addr, OS_ETH_ALEN);
   \                     ??os_wifi_str2mac_3: (+1)
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD004             BEQ.N    ??os_wifi_str2mac_4
   \       0x44   0x2206             MOVS     R2,#+6
   \       0x46   0xA901             ADD      R1,SP,#+4
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x....'....        BL       __aeabi_memcpy
    111          
    112              return mac;
   \                     ??os_wifi_str2mac_4: (+1)
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0xBD3E             POP      {R1-R5,PC}       ;; return
   \                     ??os_wifi_str2mac_2: (+1)
   \       0x52   0x2D06             CMP      R5,#+6
   \       0x54   0xDAF4             BGE.N    ??os_wifi_str2mac_3
   \                     ??os_wifi_str2mac_0: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xBD3E             POP      {R1-R5,PC}
    113          }
    114          

   \                                 In section .text, align 2, keep-with-next
    115          uint8_t *os_wifi_get_mac(uint8_t mac[OS_ETH_ALEN])
    116          {
   \                     os_wifi_get_mac: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x4604             MOV      R4,R0
    117              char mac_str[OS_MAC_LEN] = {0};
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x2114             MOVS     R1,#+20
   \        0xA   0x....'....        BL       __aeabi_memclr4
    118          
    119              os_wifi_get_mac_str(mac_str);
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x....'....        BL       os_wifi_get_mac_str
    120          
    121              return (uint8_t *)os_wifi_str2mac(mac_str, (char *)mac);
   \       0x14   0x4621             MOV      R1,R4
   \       0x16   0x4668             MOV      R0,SP
   \       0x18   0x....'....        BL       os_wifi_str2mac
   \       0x1C   0xB006             ADD      SP,SP,#+24
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
    122          }
    123          

   \                                 In section .text, align 2, keep-with-next
    124          void *os_zalloc(uint32_t size)
    125          {
   \                     os_zalloc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
    126              void *ptr = HAL_Malloc(size);
   \        0x4   0x....'....        BL       HAL_Malloc
   \        0x8   0x0004             MOVS     R4,R0
    127              if (ptr != NULL) {
   \        0xA   0xD003             BEQ.N    ??os_zalloc_0
    128                  memset(ptr, 0, size);
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x4629             MOV      R1,R5
   \       0x10   0x....'....        BL       __aeabi_memset
    129              }
    130              return ptr;
   \                     ??os_zalloc_0: (+1)
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    131          }
    132          

   \                                 In section .text, align 2, keep-with-next
    133          uint32_t os_get_time_ms(void)
    134          {
   \                     os_get_time_ms: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    135              static uint32_t fixed_delta;
    136          
    137              if (!fixed_delta) {
   \        0x2   0x....             LDR.N    R4,??DataTable1
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD104             BNE.N    ??os_get_time_ms_0
    138                  fixed_delta = (uint32_t)HAL_UptimeMs() - 0xFFFF0000;
   \        0xA   0x....'....        BL       HAL_UptimeMs
   \        0xE   0xF500 0x3080      ADD      R0,R0,#+65536
   \       0x12   0x6020             STR      R0,[R4, #+0]
    139              }
    140          
    141              /* add a big offset, for easier caught time overflow bug */
    142              return (uint32_t)HAL_UptimeMs() - fixed_delta;
   \                     ??os_get_time_ms_0: (+1)
   \       0x14   0x....'....        BL       HAL_UptimeMs
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x1A40             SUBS     R0,R0,R1
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
    143          }

   \                                 In section .bss, align 4
   \                     `os_get_time_ms::fixed_delta`:
   \        0x0                      DS8 4
    144          

   \                                 In section .text, align 2, keep-with-next
    145          uint32_t time_elapsed_ms_since(uint32_t start_timestamp)
    146          {
   \                     time_elapsed_ms_since: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    147              uint32_t now = os_get_time_ms();
    148              return now - start_timestamp;
   \        0x4   0x....'....        BL       os_get_time_ms
   \        0x8   0x1B04             SUBS     R4,R0,R4
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    149          }
    150          

   \                                 In section .text, align 2, keep-with-next
    151          int os_is_big_endian(void)
    152          {
   \                     os_is_big_endian: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    153              uint32_t data = 0xFF000000;
   \        0x2   0xF04F 0x407F      MOV      R0,#-16777216
   \        0x6   0x9000             STR      R0,[SP, #+0]
    154          
    155              if (0xFF == *(uint8_t *) & data) {
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x28FF             CMP      R0,#+255
   \        0xC   0xD100             BNE.N    ??os_is_big_endian_0
    156                  return 1;                                    /* big endian */
   \        0xE   0x2001             MOVS     R0,#+1
    157              }
    158          
    159              return 0;                                         /* little endian */
   \                     ??os_is_big_endian_0: (+1)
   \       0x10   0xB001             ADD      SP,SP,#+4
   \       0x12   0x4770             BX       LR               ;; return
    160          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     `os_get_time_ms::fixed_delta`

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    161          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   os_be16toh
         0   -> os_htobe16
       8   os_get_time_ms
         8   -> HAL_UptimeMs
       8   os_get_unaligned_be16
         8   -> __aeabi_memcpy
         8   -> os_be16toh
       8   os_get_unaligned_le16
         8   -> __aeabi_memcpy
         8   -> os_le16toh
       8   os_htobe16
         8   -> os_is_big_endian
         0   -> reverse_16bit
       8   os_htole16
         8   -> os_is_big_endian
         0   -> reverse_16bit
       4   os_is_big_endian
       0   os_le16toh
         0   -> os_htole16
      32   os_wifi_get_mac
        32   -> __aeabi_memclr4
        32   -> os_wifi_get_mac_str
        32   -> os_wifi_str2mac
       8   os_wifi_get_mac_str
         8   -> HAL_Wifi_Get_Mac
         8   -> strchr
      24   os_wifi_str2mac
        24   -> __aeabi_memcpy
        24   -> isxdigit
        24   -> strtol
      16   os_zalloc
        16   -> HAL_Malloc
        16   -> __aeabi_memset
       0   reverse_16bit
       8   time_elapsed_ms_since
         8   -> os_get_time_ms


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       8  ?_0
      20  ?_1
       4  fixed_delta
       2  os_be16toh
      30  os_get_time_ms
      22  os_get_unaligned_be16
      22  os_get_unaligned_le16
      22  os_htobe16
      22  os_htole16
      20  os_is_big_endian
       2  os_le16toh
      32  os_wifi_get_mac
      58  os_wifi_get_mac_str
      90  os_wifi_str2mac
      24  os_zalloc
      12  reverse_16bit
      14  time_elapsed_ms_since

 
   4 bytes in section .bss
  28 bytes in section .rodata
 376 bytes in section .text
 
 376 bytes of CODE  memory
  28 bytes of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: 1
