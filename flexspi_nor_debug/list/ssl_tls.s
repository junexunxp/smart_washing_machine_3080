///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM        10/Jun/2019  13:48:55
// Copyright 1999-2019 IAR Systems AB.
//
//    Cpu mode     =  
//    Endian       =  little
//    Source file  =  
//        C:\Development\smart_washing_machine_3080\mbedtls\library\ssl_tls.c
//    Command line =  
//        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW590E.tmp
//        (C:\Development\smart_washing_machine_3080\mbedtls\library\ssl_tls.c
//        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
//        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
//        -D PRINTF_ADVANCED_ENABLE -D
//        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
//        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
//        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
//        --diag_suppress Pa082,Pa050 -o
//        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
//        --no_clustering --no_scheduling --debug --endian=little
//        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
//        (x86)\IAR Systems\Embedded Workbench
//        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
//        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
//        C:\Development\smart_washing_machine_3080/board\ -I
//        C:\Development\smart_washing_machine_3080/source\ -I
//        C:\Development\smart_washing_machine_3080/CMSIS\ -I
//        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
//        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
//        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
//        C:\Development\smart_washing_machine_3080/component/serial_manager\
//        -I C:\Development\smart_washing_machine_3080/component/uart\ -I
//        C:\Development\smart_washing_machine_3080/component/kv\ -I
//        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
//        C:\Development\smart_washing_machine_3080/device\ -I
//        C:\Development\smart_washing_machine_3080/doc\ -I
//        C:\Development\smart_washing_machine_3080/drivers\ -I
//        C:\Development\smart_washing_machine_3080/src\ -I
//        C:\Development\smart_washing_machine_3080/startup\ -I
//        C:\Development\smart_washing_machine_3080/utilities\ -I
//        C:\Development\smart_washing_machine_3080/xip\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
//        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
//        -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
//        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
//        -I
//        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
//        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
//        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
//        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
//    Locale       =  C
//    List file    =  
//        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\ssl_tls.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "0"
        RTMODEL "__dlib_full_locale_support", "0"
        RTMODEL "__dlib_version", "6"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN __aeabi_llsl
        EXTERN __aeabi_llsr
        EXTERN __aeabi_memcpy
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_memmove
        EXTERN __aeabi_memset
        EXTERN __aeabi_memset4
        EXTERN mbedtls_calloc
        EXTERN mbedtls_cipher_auth_decrypt
        EXTERN mbedtls_cipher_auth_encrypt
        EXTERN mbedtls_cipher_crypt
        EXTERN mbedtls_cipher_free
        EXTERN mbedtls_cipher_info_from_type
        EXTERN mbedtls_cipher_init
        EXTERN mbedtls_cipher_set_padding_mode
        EXTERN mbedtls_cipher_setkey
        EXTERN mbedtls_cipher_setup
        EXTERN mbedtls_debug_print_buf
        EXTERN mbedtls_debug_print_crt
        EXTERN mbedtls_debug_print_mpi
        EXTERN mbedtls_debug_print_msg
        EXTERN mbedtls_debug_print_ret
        EXTERN mbedtls_dhm_calc_secret
        EXTERN mbedtls_dhm_free
        EXTERN mbedtls_dhm_init
        EXTERN mbedtls_ecdh_calc_secret
        EXTERN mbedtls_ecdh_free
        EXTERN mbedtls_ecdh_init
        EXTERN mbedtls_ecp_grp_id_list
        EXTERN mbedtls_free
        EXTERN mbedtls_md5_clone
        EXTERN mbedtls_md5_finish_ret
        EXTERN mbedtls_md5_free
        EXTERN mbedtls_md5_init
        EXTERN mbedtls_md5_starts_ret
        EXTERN mbedtls_md5_update_ret
        EXTERN mbedtls_md_finish
        EXTERN mbedtls_md_free
        EXTERN mbedtls_md_get_size
        EXTERN mbedtls_md_hmac_finish
        EXTERN mbedtls_md_hmac_reset
        EXTERN mbedtls_md_hmac_starts
        EXTERN mbedtls_md_hmac_update
        EXTERN mbedtls_md_info_from_type
        EXTERN mbedtls_md_init
        EXTERN mbedtls_md_process
        EXTERN mbedtls_md_setup
        EXTERN mbedtls_md_starts
        EXTERN mbedtls_md_update
        EXTERN mbedtls_mpi_copy
        EXTERN mbedtls_mpi_free
        EXTERN mbedtls_mpi_read_binary
        EXTERN mbedtls_mpi_read_string
        EXTERN mbedtls_pk_can_do
        EXTERN mbedtls_platform_zeroize
        EXTERN mbedtls_sha1_clone
        EXTERN mbedtls_sha1_finish_ret
        EXTERN mbedtls_sha1_free
        EXTERN mbedtls_sha1_init
        EXTERN mbedtls_sha1_starts_ret
        EXTERN mbedtls_sha1_update_ret
        EXTERN mbedtls_sha256_clone
        EXTERN mbedtls_sha256_finish_ret
        EXTERN mbedtls_sha256_free
        EXTERN mbedtls_sha256_init
        EXTERN mbedtls_sha256_starts_ret
        EXTERN mbedtls_sha256_update_ret
        EXTERN mbedtls_sha512_clone
        EXTERN mbedtls_sha512_finish_ret
        EXTERN mbedtls_sha512_free
        EXTERN mbedtls_sha512_init
        EXTERN mbedtls_sha512_starts_ret
        EXTERN mbedtls_sha512_update_ret
        EXTERN mbedtls_ssl_get_ciphersuite_name
        EXTERN mbedtls_ssl_handshake_client_step
        EXTERN mbedtls_ssl_handshake_server_step
        EXTERN mbedtls_ssl_list_ciphersuites
        EXTERN mbedtls_x509_crt_check_extended_key_usage
        EXTERN mbedtls_x509_crt_check_key_usage
        EXTERN mbedtls_x509_crt_free
        EXTERN mbedtls_x509_crt_init
        EXTERN mbedtls_x509_crt_parse_der
        EXTERN mbedtls_x509_crt_profile_default
        EXTERN mbedtls_x509_crt_profile_suiteb
        EXTERN mbedtls_x509_crt_verify_with_profile
        EXTERN memcmp
        EXTERN strlen

        PUBLIC mbedtls_ssl_check_cert_usage
        PUBLIC mbedtls_ssl_check_curve
        PUBLIC mbedtls_ssl_check_pending
        PUBLIC mbedtls_ssl_check_sig_hash
        PUBLIC mbedtls_ssl_close_notify
        PUBLIC mbedtls_ssl_conf_alpn_protocols
        PUBLIC mbedtls_ssl_conf_authmode
        PUBLIC mbedtls_ssl_conf_ca_chain
        PUBLIC mbedtls_ssl_conf_cbc_record_splitting
        PUBLIC mbedtls_ssl_conf_cert_profile
        PUBLIC mbedtls_ssl_conf_cert_req_ca_list
        PUBLIC mbedtls_ssl_conf_ciphersuites
        PUBLIC mbedtls_ssl_conf_ciphersuites_for_version
        PUBLIC mbedtls_ssl_conf_curves
        PUBLIC mbedtls_ssl_conf_dbg
        PUBLIC mbedtls_ssl_conf_dh_param
        PUBLIC mbedtls_ssl_conf_dh_param_bin
        PUBLIC mbedtls_ssl_conf_dh_param_ctx
        PUBLIC mbedtls_ssl_conf_dhm_min_bitlen
        PUBLIC mbedtls_ssl_conf_dtls_anti_replay
        PUBLIC mbedtls_ssl_conf_dtls_badmac_limit
        PUBLIC mbedtls_ssl_conf_encrypt_then_mac
        PUBLIC mbedtls_ssl_conf_endpoint
        PUBLIC mbedtls_ssl_conf_export_keys_cb
        PUBLIC mbedtls_ssl_conf_extended_master_secret
        PUBLIC mbedtls_ssl_conf_fallback
        PUBLIC mbedtls_ssl_conf_handshake_timeout
        PUBLIC mbedtls_ssl_conf_legacy_renegotiation
        PUBLIC mbedtls_ssl_conf_max_frag_len
        PUBLIC mbedtls_ssl_conf_max_version
        PUBLIC mbedtls_ssl_conf_min_version
        PUBLIC mbedtls_ssl_conf_own_cert
        PUBLIC mbedtls_ssl_conf_psk
        PUBLIC mbedtls_ssl_conf_psk_cb
        PUBLIC mbedtls_ssl_conf_read_timeout
        PUBLIC mbedtls_ssl_conf_renegotiation
        PUBLIC mbedtls_ssl_conf_renegotiation_enforced
        PUBLIC mbedtls_ssl_conf_renegotiation_period
        PUBLIC mbedtls_ssl_conf_rng
        PUBLIC mbedtls_ssl_conf_session_cache
        PUBLIC mbedtls_ssl_conf_session_tickets
        PUBLIC mbedtls_ssl_conf_session_tickets_cb
        PUBLIC mbedtls_ssl_conf_sig_hashes
        PUBLIC mbedtls_ssl_conf_sni
        PUBLIC mbedtls_ssl_conf_transport
        PUBLIC mbedtls_ssl_conf_truncated_hmac
        PUBLIC mbedtls_ssl_conf_verify
        PUBLIC mbedtls_ssl_config_defaults
        PUBLIC mbedtls_ssl_config_free
        PUBLIC mbedtls_ssl_config_init
        PUBLIC mbedtls_ssl_derive_keys
        PUBLIC mbedtls_ssl_dtls_replay_check
        PUBLIC mbedtls_ssl_dtls_replay_update
        PUBLIC mbedtls_ssl_fetch_input
        PUBLIC mbedtls_ssl_flight_transmit
        PUBLIC mbedtls_ssl_flush_output
        PUBLIC mbedtls_ssl_free
        PUBLIC mbedtls_ssl_get_alpn_protocol
        PUBLIC mbedtls_ssl_get_bytes_avail
        PUBLIC mbedtls_ssl_get_ciphersuite
        PUBLIC mbedtls_ssl_get_key_exchange_md_ssl_tls
        PUBLIC mbedtls_ssl_get_key_exchange_md_tls1_2
        PUBLIC mbedtls_ssl_get_max_frag_len
        PUBLIC mbedtls_ssl_get_max_out_record_payload
        PUBLIC mbedtls_ssl_get_peer_cert
        PUBLIC mbedtls_ssl_get_record_expansion
        PUBLIC mbedtls_ssl_get_session
        PUBLIC mbedtls_ssl_get_verify_result
        PUBLIC mbedtls_ssl_get_version
        PUBLIC mbedtls_ssl_handle_message_type
        PUBLIC mbedtls_ssl_handshake
        PUBLIC mbedtls_ssl_handshake_free
        PUBLIC mbedtls_ssl_handshake_step
        PUBLIC mbedtls_ssl_handshake_wrapup
        PUBLIC mbedtls_ssl_hash_from_md_alg
        PUBLIC mbedtls_ssl_init
        PUBLIC mbedtls_ssl_md_alg_from_hash
        PUBLIC mbedtls_ssl_optimize_checksum
        PUBLIC mbedtls_ssl_parse_certificate
        PUBLIC mbedtls_ssl_parse_change_cipher_spec
        PUBLIC mbedtls_ssl_parse_finished
        PUBLIC mbedtls_ssl_pk_alg_from_sig
        PUBLIC mbedtls_ssl_prepare_handshake_record
        PUBLIC mbedtls_ssl_psk_derive_premaster
        PUBLIC mbedtls_ssl_read
        PUBLIC mbedtls_ssl_read_record
        PUBLIC mbedtls_ssl_read_version
        PUBLIC mbedtls_ssl_recv_flight_completed
        PUBLIC mbedtls_ssl_renegotiate
        PUBLIC mbedtls_ssl_resend
        PUBLIC mbedtls_ssl_reset_checksum
        PUBLIC mbedtls_ssl_send_alert_message
        PUBLIC mbedtls_ssl_send_fatal_handshake_failure
        PUBLIC mbedtls_ssl_send_flight_completed
        PUBLIC mbedtls_ssl_session_free
        PUBLIC mbedtls_ssl_session_init
        PUBLIC mbedtls_ssl_session_reset
        PUBLIC mbedtls_ssl_set_bio
        PUBLIC mbedtls_ssl_set_calc_verify_md
        PUBLIC mbedtls_ssl_set_datagram_packing
        PUBLIC mbedtls_ssl_set_hostname
        PUBLIC mbedtls_ssl_set_hs_authmode
        PUBLIC mbedtls_ssl_set_hs_ca_chain
        PUBLIC mbedtls_ssl_set_hs_own_cert
        PUBLIC mbedtls_ssl_set_hs_psk
        PUBLIC mbedtls_ssl_set_mtu
        PUBLIC mbedtls_ssl_set_session
        PUBLIC mbedtls_ssl_set_timer_cb
        PUBLIC mbedtls_ssl_setup
        PUBLIC mbedtls_ssl_sig_from_pk
        PUBLIC mbedtls_ssl_sig_from_pk_alg
        PUBLIC mbedtls_ssl_sig_hash_set_add
        PUBLIC mbedtls_ssl_sig_hash_set_const_hash
        PUBLIC mbedtls_ssl_sig_hash_set_find
        PUBLIC mbedtls_ssl_transform_free
        PUBLIC mbedtls_ssl_update_handshake_status
        PUBLIC mbedtls_ssl_write
        PUBLIC mbedtls_ssl_write_certificate
        PUBLIC mbedtls_ssl_write_change_cipher_spec
        PUBLIC mbedtls_ssl_write_finished
        PUBLIC mbedtls_ssl_write_handshake_msg
        PUBLIC mbedtls_ssl_write_record
        PUBLIC mbedtls_ssl_write_version
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        
// C:\Development\smart_washing_machine_3080\mbedtls\library\ssl_tls.c
//    1 /*
//    2  *  SSLv3/TLSv1 shared functions
//    3  *
//    4  *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
//    5  *  SPDX-License-Identifier: Apache-2.0
//    6  *
//    7  *  Licensed under the Apache License, Version 2.0 (the "License"); you may
//    8  *  not use this file except in compliance with the License.
//    9  *  You may obtain a copy of the License at
//   10  *
//   11  *  http://www.apache.org/licenses/LICENSE-2.0
//   12  *
//   13  *  Unless required by applicable law or agreed to in writing, software
//   14  *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//   15  *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   16  *  See the License for the specific language governing permissions and
//   17  *  limitations under the License.
//   18  *
//   19  *  This file is part of mbed TLS (https://tls.mbed.org)
//   20  */
//   21 /*
//   22  *  The SSL 3.0 specification was drafted by Netscape in 1996,
//   23  *  and became an IETF standard in 1999.
//   24  *
//   25  *  http://wp.netscape.com/eng/ssl3/
//   26  *  http://www.ietf.org/rfc/rfc2246.txt
//   27  *  http://www.ietf.org/rfc/rfc4346.txt
//   28  */
//   29 
//   30 #if !defined(MBEDTLS_CONFIG_FILE)
//   31 #include "mbedtls/config.h"
//   32 #else
//   33 #include MBEDTLS_CONFIG_FILE
//   34 #endif
//   35 
//   36 #if defined(MBEDTLS_SSL_TLS_C)
//   37 
//   38 #if defined(MBEDTLS_PLATFORM_C)
//   39 #include "mbedtls/platform.h"
//   40 #else
//   41 #include <stdlib.h>
//   42 #define mbedtls_calloc    calloc
//   43 #define mbedtls_free      free
//   44 #endif
//   45 
//   46 #include "mbedtls/debug.h"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function mbedtls_pk_ec
          CFI NoCalls
        THUMB
// static __interwork __softfp mbedtls_ecp_keypair *mbedtls_pk_ec(mbedtls_pk_context const)
mbedtls_pk_ec:
        MOV      R0,R1
        BX       LR               ;; return
          CFI EndBlock cfiBlock0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function mbedtls_cipher_get_block_size
          CFI NoCalls
        THUMB
// static __interwork __softfp unsigned int mbedtls_cipher_get_block_size(mbedtls_cipher_context_t const *)
mbedtls_cipher_get_block_size:
        CMP      R0,#+0
        BEQ.N    ??mbedtls_cipher_get_block_size_0
        LDR      R1,[R0, #+0]
        CMP      R1,#+0
        BNE.N    ??mbedtls_cipher_get_block_size_1
??mbedtls_cipher_get_block_size_0:
        MOVS     R0,#+0
        BX       LR
??mbedtls_cipher_get_block_size_1:
        MOV      R0,R1
        LDR      R0,[R0, #+20]
        BX       LR               ;; return
          CFI EndBlock cfiBlock1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function mbedtls_cipher_get_cipher_mode
          CFI NoCalls
        THUMB
// static __interwork __softfp enum <unnamed>#118 mbedtls_cipher_get_cipher_mode(mbedtls_cipher_context_t const *)
mbedtls_cipher_get_cipher_mode:
        CMP      R0,#+0
        BEQ.N    ??mbedtls_cipher_get_cipher_mode_0
        LDR      R1,[R0, #+0]
        CMP      R1,#+0
        BNE.N    ??mbedtls_cipher_get_cipher_mode_1
??mbedtls_cipher_get_cipher_mode_0:
        MOVS     R0,#+0
        BX       LR
??mbedtls_cipher_get_cipher_mode_1:
        MOV      R0,R1
        LDRB     R0,[R0, #+1]
        BX       LR               ;; return
          CFI EndBlock cfiBlock2
//   47 #include "mbedtls/ssl.h"
//   48 #include "mbedtls/ssl_internal.h"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function mbedtls_ssl_sig_hash_set_init
        THUMB
// static __interwork __softfp void mbedtls_ssl_sig_hash_set_init(mbedtls_ssl_sig_hash_set_t *)
mbedtls_ssl_sig_hash_set_init:
        MOVS     R1,#+0
          CFI FunCall mbedtls_ssl_sig_hash_set_const_hash
        B.W      mbedtls_ssl_sig_hash_set_const_hash
          CFI EndBlock cfiBlock3

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function mbedtls_ssl_own_cert
          CFI NoCalls
        THUMB
// static __interwork __softfp mbedtls_x509_crt *mbedtls_ssl_own_cert(mbedtls_ssl_context *)
mbedtls_ssl_own_cert:
        LDR      R1,[R0, #+60]
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_own_cert_0
        LDR      R1,[R1, #+448]
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_own_cert_0
        MOV      R0,R1
        B.N      ??mbedtls_ssl_own_cert_1
??mbedtls_ssl_own_cert_0:
        LDR      R0,[R0, #+0]
        LDR      R0,[R0, #+104]
??mbedtls_ssl_own_cert_1:
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_own_cert_2
        MOVS     R0,#+0
        BX       LR
??mbedtls_ssl_own_cert_2:
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock4

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function mbedtls_ssl_hdr_len
          CFI NoCalls
        THUMB
// static __interwork __softfp size_t mbedtls_ssl_hdr_len(mbedtls_ssl_context const *)
mbedtls_ssl_hdr_len:
        LDR      R0,[R0, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_hdr_len_0
        MOVS     R0,#+13
        BX       LR
??mbedtls_ssl_hdr_len_0:
        MOVS     R0,#+5
        BX       LR               ;; return
          CFI EndBlock cfiBlock5

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function mbedtls_ssl_hs_hdr_len
          CFI NoCalls
        THUMB
// static __interwork __softfp size_t mbedtls_ssl_hs_hdr_len(mbedtls_ssl_context const *)
mbedtls_ssl_hs_hdr_len:
        LDR      R0,[R0, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_hs_hdr_len_0
        MOVS     R0,#+12
        BX       LR
??mbedtls_ssl_hs_hdr_len_0:
        MOVS     R0,#+4
        BX       LR               ;; return
          CFI EndBlock cfiBlock6

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function mbedtls_ssl_safer_memcmp
          CFI NoCalls
        THUMB
// static __interwork __softfp int mbedtls_ssl_safer_memcmp(void const *, void const *, size_t)
mbedtls_ssl_safer_memcmp:
        PUSH     {R3-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R3,#+0
        STRB     R3,[SP, #+0]
        B.N      ??mbedtls_ssl_safer_memcmp_0
??mbedtls_ssl_safer_memcmp_1:
        LDRB     R4,[R0, R3]
        LDRB     R5,[R1, R3]
        LDRB     R6,[SP, #+0]
        EORS     R4,R5,R4
        ORRS     R4,R4,R6
        STRB     R4,[SP, #+0]
        ADDS     R3,R3,#+1
??mbedtls_ssl_safer_memcmp_0:
        CMP      R3,R2
        BCC.N    ??mbedtls_ssl_safer_memcmp_1
        LDRB     R0,[SP, #+0]
        POP      {R1,R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock7
//   49 #include "mbedtls/platform_util.h"
//   50 
//   51 #include <string.h>
//   52 
//   53 #if defined(MBEDTLS_X509_CRT_PARSE_C)
//   54 #include "mbedtls/oid.h"
//   55 #endif
//   56 
//   57 static void ssl_reset_in_out_pointers( mbedtls_ssl_context *ssl );
//   58 static uint32_t ssl_get_hs_total_len( mbedtls_ssl_context const *ssl );
//   59 
//   60 /* Length of the "epoch" field in the record header */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function ssl_ep_len
          CFI NoCalls
        THUMB
//   61 static inline size_t ssl_ep_len( const mbedtls_ssl_context *ssl )
//   62 {
//   63 #if defined(MBEDTLS_SSL_PROTO_DTLS)
//   64     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
ssl_ep_len:
        LDR      R0,[R0, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_ep_len_0
//   65         return( 2 );
        MOVS     R0,#+2
        BX       LR
//   66 #else
//   67     ((void) ssl);
//   68 #endif
//   69     return( 0 );
??ssl_ep_len_0:
        MOVS     R0,#+0
        BX       LR               ;; return
//   70 }
          CFI EndBlock cfiBlock8
//   71 
//   72 /*
//   73  * Start a timer.
//   74  * Passing millisecs = 0 cancels a running timer.
//   75  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function ssl_set_timer
        THUMB
//   76 static void ssl_set_timer( mbedtls_ssl_context *ssl, uint32_t millisecs )
//   77 {
ssl_set_timer:
        PUSH     {R1-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R5,R1
//   78     if( ssl->f_set_timer == NULL )
        LDR      R0,[R4, #+84]
        CMP      R0,#+0
        BEQ.N    ??ssl_set_timer_0
//   79         return;
//   80 
//   81     MBEDTLS_SSL_DEBUG_MSG( 3, ( "set_timer to %d ms", (int) millisecs ) );
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable10
        STR      R0,[SP, #+0]
        MOVS     R3,#+81
        LDR.W    R2,??DataTable12
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//   82     ssl->f_set_timer( ssl->p_timer, millisecs / 4, millisecs );
        MOV      R2,R5
        LSRS     R5,R5,#+2
        MOV      R1,R5
        LDR      R0,[R4, #+80]
        LDR      R3,[R4, #+84]
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall
        ANOTE "tailcall"
        BX       R3
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??ssl_set_timer_0:
        POP      {R0-R2,R4,R5,PC}  ;; return
//   83 }
          CFI EndBlock cfiBlock9
//   84 
//   85 /*
//   86  * Return -1 is timer is expired, 0 if it isn't.
//   87  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function ssl_check_timer
        THUMB
//   88 static int ssl_check_timer( mbedtls_ssl_context *ssl )
//   89 {
ssl_check_timer:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        MOV      R4,R0
//   90     if( ssl->f_get_timer == NULL )
        LDR      R0,[R4, #+88]
        CMP      R0,#+0
        BNE.N    ??ssl_check_timer_0
//   91         return( 0 );
        MOVS     R0,#+0
        POP      {R1,R2,R4,PC}
//   92 
//   93     if( ssl->f_get_timer( ssl->p_timer ) == 2 )
??ssl_check_timer_0:
        LDR      R0,[R4, #+80]
        LDR      R1,[R4, #+88]
          CFI FunCall
        BLX      R1
        CMP      R0,#+2
        BNE.N    ??ssl_check_timer_1
//   94     {
//   95         MBEDTLS_SSL_DEBUG_MSG( 3, ( "timer expired" ) );
        LDR.W    R0,??DataTable10_1
        STR      R0,[SP, #+0]
        MOVS     R3,#+95
        LDR.W    R2,??DataTable12
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//   96         return( -1 );
        MOV      R0,#-1
        POP      {R1,R2,R4,PC}
//   97     }
//   98 
//   99     return( 0 );
??ssl_check_timer_1:
        MOVS     R0,#+0
        POP      {R1,R2,R4,PC}    ;; return
//  100 }
          CFI EndBlock cfiBlock10
//  101 
//  102 static void ssl_update_out_pointers( mbedtls_ssl_context *ssl,
//  103                                      mbedtls_ssl_transform *transform );
//  104 static void ssl_update_in_pointers( mbedtls_ssl_context *ssl,
//  105                                     mbedtls_ssl_transform *transform );
//  106 
//  107 #define SSL_DONT_FORCE_FLUSH 0
//  108 #define SSL_FORCE_FLUSH      1
//  109 
//  110 #if defined(MBEDTLS_SSL_PROTO_DTLS)
//  111 
//  112 /* Forward declarations for functions related to message buffering. */
//  113 static void ssl_buffering_free( mbedtls_ssl_context *ssl );
//  114 static void ssl_buffering_free_slot( mbedtls_ssl_context *ssl,
//  115                                      uint8_t slot );
//  116 static void ssl_free_buffered_record( mbedtls_ssl_context *ssl );
//  117 static int ssl_load_buffered_message( mbedtls_ssl_context *ssl );
//  118 static int ssl_load_buffered_record( mbedtls_ssl_context *ssl );
//  119 static int ssl_buffer_message( mbedtls_ssl_context *ssl );
//  120 static int ssl_buffer_future_record( mbedtls_ssl_context *ssl );
//  121 static int ssl_next_record_is_in_datagram( mbedtls_ssl_context *ssl );
//  122 
//  123 static size_t ssl_get_current_mtu( const mbedtls_ssl_context *ssl );

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function ssl_get_maximum_datagram_size
        THUMB
//  124 static size_t ssl_get_maximum_datagram_size( mbedtls_ssl_context const *ssl )
//  125 {
ssl_get_maximum_datagram_size:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  126     size_t mtu = ssl_get_current_mtu( ssl );
          CFI FunCall ssl_get_current_mtu
        BL       ssl_get_current_mtu
//  127 
//  128     if( mtu != 0 && mtu < MBEDTLS_SSL_OUT_BUFFER_LEN )
        CMP      R0,#+0
        BEQ.N    ??ssl_get_maximum_datagram_size_0
        MOVW     R1,#+10573
        CMP      R0,R1
        BCC.N    ??ssl_get_maximum_datagram_size_1
//  129         return( mtu );
//  130 
//  131     return( MBEDTLS_SSL_OUT_BUFFER_LEN );
??ssl_get_maximum_datagram_size_0:
        MOVW     R0,#+10573
??ssl_get_maximum_datagram_size_1:
        POP      {R1,PC}          ;; return
//  132 }
          CFI EndBlock cfiBlock11
//  133 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function ssl_get_remaining_space_in_datagram
        THUMB
//  134 static int ssl_get_remaining_space_in_datagram( mbedtls_ssl_context const *ssl )
//  135 {
ssl_get_remaining_space_in_datagram:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  136     size_t const bytes_written = ssl->out_left;
        LDR      R4,[R0, #+208]
//  137     size_t const mtu           = ssl_get_maximum_datagram_size( ssl );
          CFI FunCall ssl_get_maximum_datagram_size
        BL       ssl_get_maximum_datagram_size
//  138 
//  139     /* Double-check that the write-index hasn't gone
//  140      * past what we can transmit in a single datagram. */
//  141     if( bytes_written > mtu )
        CMP      R0,R4
        BCS.N    ??ssl_get_remaining_space_in_datagram_0
//  142     {
//  143         /* Should never happen... */
//  144         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable12_1  ;; 0xffff9400
        POP      {R4,PC}
//  145     }
//  146 
//  147     return( (int) ( mtu - bytes_written ) );
??ssl_get_remaining_space_in_datagram_0:
        SUBS     R4,R0,R4
        MOV      R0,R4
        POP      {R4,PC}          ;; return
//  148 }
          CFI EndBlock cfiBlock12
//  149 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function ssl_get_remaining_payload_in_datagram
        THUMB
//  150 static int ssl_get_remaining_payload_in_datagram( mbedtls_ssl_context const *ssl )
//  151 {
ssl_get_remaining_payload_in_datagram:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
//  152     int ret;
//  153     size_t remaining, expansion;
//  154     size_t max_len = MBEDTLS_SSL_MAX_CONTENT_LEN;
        MOV      R5,#+10240
//  155 
//  156 #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
//  157     const size_t mfl = mbedtls_ssl_get_max_frag_len( ssl );
          CFI FunCall mbedtls_ssl_get_max_frag_len
        BL       mbedtls_ssl_get_max_frag_len
//  158 
//  159     if( max_len > mfl )
        CMP      R0,#+10240
        BCS.N    ??ssl_get_remaining_payload_in_datagram_0
//  160         max_len = mfl;
        MOV      R5,R0
//  161 
//  162     /* By the standard (RFC 6066 Sect. 4), the MFL extension
//  163      * only limits the maximum record payload size, so in theory
//  164      * we would be allowed to pack multiple records of payload size
//  165      * MFL into a single datagram. However, this would mean that there's
//  166      * no way to explicitly communicate MTU restrictions to the peer.
//  167      *
//  168      * The following reduction of max_len makes sure that we never
//  169      * write datagrams larger than MFL + Record Expansion Overhead.
//  170      */
//  171     if( max_len <= ssl->out_left )
??ssl_get_remaining_payload_in_datagram_0:
        LDR      R0,[R4, #+208]
        CMP      R0,R5
        BCS.N    ??ssl_get_remaining_payload_in_datagram_1
//  172         return( 0 );
//  173 
//  174     max_len -= ssl->out_left;
        SUBS     R5,R5,R0
//  175 #endif
//  176 
//  177     ret = ssl_get_remaining_space_in_datagram( ssl );
        MOV      R0,R4
          CFI FunCall ssl_get_remaining_space_in_datagram
        BL       ssl_get_remaining_space_in_datagram
//  178     if( ret < 0 )
        CMP      R0,#+0
        BMI.N    ??ssl_get_remaining_payload_in_datagram_2
//  179         return( ret );
//  180     remaining = (size_t) ret;
        MOV      R6,R0
//  181 
//  182     ret = mbedtls_ssl_get_record_expansion( ssl );
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_get_record_expansion
        BL       mbedtls_ssl_get_record_expansion
//  183     if( ret < 0 )
        CMP      R0,#+0
        BMI.N    ??ssl_get_remaining_payload_in_datagram_2
//  184         return( ret );
//  185     expansion = (size_t) ret;
//  186 
//  187     if( remaining <= expansion )
        CMP      R0,R6
        BCC.N    ??ssl_get_remaining_payload_in_datagram_3
//  188         return( 0 );
??ssl_get_remaining_payload_in_datagram_1:
        MOVS     R0,#+0
        POP      {R4-R6,PC}
//  189 
//  190     remaining -= expansion;
??ssl_get_remaining_payload_in_datagram_3:
        SUBS     R0,R6,R0
//  191     if( remaining >= max_len )
        CMP      R5,R0
        BLS.N    ??ssl_get_remaining_payload_in_datagram_4
        MOV      R5,R0
//  192         remaining = max_len;
//  193 
//  194     return( (int) remaining );
??ssl_get_remaining_payload_in_datagram_4:
        MOV      R0,R5
??ssl_get_remaining_payload_in_datagram_2:
        POP      {R4-R6,PC}       ;; return
//  195 }
          CFI EndBlock cfiBlock13
//  196 
//  197 /*
//  198  * Double the retransmit timeout value, within the allowed range,
//  199  * returning -1 if the maximum value has already been reached.
//  200  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function ssl_double_retransmit_timeout
        THUMB
//  201 static int ssl_double_retransmit_timeout( mbedtls_ssl_context *ssl )
//  202 {
ssl_double_retransmit_timeout:
        PUSH     {R5-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
//  203     uint32_t new_timeout;
//  204 
//  205     if( ssl->handshake->retransmit_timeout >= ssl->conf->hs_timeout_max )
        LDR      R1,[R0, #+60]
        LDR      R1,[R1, #+484]
        LDR      R2,[R0, #+0]
        LDR      R2,[R2, #+176]
        CMP      R1,R2
        BCC.N    ??ssl_double_retransmit_timeout_0
//  206         return( -1 );
        MOV      R0,#-1
        POP      {R1-R3,PC}
//  207 
//  208     /* Implement the final paragraph of RFC 6347 section 4.1.1.1
//  209      * in the following way: after the initial transmission and a first
//  210      * retransmission, back off to a temporary estimated MTU of 508 bytes.
//  211      * This value is guaranteed to be deliverable (if not guaranteed to be
//  212      * delivered) of any compliant IPv4 (and IPv6) network, and should work
//  213      * on most non-IP stacks too. */
//  214     if( ssl->handshake->retransmit_timeout != ssl->conf->hs_timeout_min )
??ssl_double_retransmit_timeout_0:
        LDR      R1,[R0, #+60]
        LDR      R1,[R1, #+484]
        LDR      R2,[R0, #+0]
        LDR      R2,[R2, #+172]
        CMP      R1,R2
        BEQ.N    ??ssl_double_retransmit_timeout_1
//  215         ssl->handshake->mtu = 508;
        MOV      R1,#+508
        LDR      R2,[R0, #+60]
        STRH     R1,[R2, #+588]
//  216 
//  217     new_timeout = 2 * ssl->handshake->retransmit_timeout;
??ssl_double_retransmit_timeout_1:
        LDR      R1,[R0, #+60]
        LDR      R1,[R1, #+484]
        LSLS     R1,R1,#+1
//  218 
//  219     /* Avoid arithmetic overflow and range overflow */
//  220     if( new_timeout < ssl->handshake->retransmit_timeout ||
//  221         new_timeout > ssl->conf->hs_timeout_max )
        LDR      R2,[R0, #+60]
        LDR      R2,[R2, #+484]
        CMP      R1,R2
        BCC.N    ??ssl_double_retransmit_timeout_2
        LDR      R2,[R0, #+0]
        LDR      R2,[R2, #+176]
        CMP      R2,R1
        BCS.N    ??ssl_double_retransmit_timeout_3
//  222     {
//  223         new_timeout = ssl->conf->hs_timeout_max;
??ssl_double_retransmit_timeout_2:
        LDR      R1,[R0, #+0]
        LDR      R1,[R1, #+176]
//  224     }
//  225 
//  226     ssl->handshake->retransmit_timeout = new_timeout;
??ssl_double_retransmit_timeout_3:
        LDR      R2,[R0, #+60]
        STR      R1,[R2, #+484]
//  227     MBEDTLS_SSL_DEBUG_MSG( 3, ( "update timeout value to %d millisecs",
//  228                         ssl->handshake->retransmit_timeout ) );
        LDR      R1,[R0, #+60]
        LDR      R1,[R1, #+484]
        STR      R1,[SP, #+4]
        LDR.W    R1,??DataTable12_2
        STR      R1,[SP, #+0]
        MOVS     R3,#+228
        LDR.W    R2,??DataTable12
        MOVS     R1,#+3
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//  229 
//  230     return( 0 );
        MOVS     R0,#+0
        POP      {R1-R3,PC}       ;; return
//  231 }
          CFI EndBlock cfiBlock14
//  232 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function ssl_reset_retransmit_timeout
        THUMB
//  233 static void ssl_reset_retransmit_timeout( mbedtls_ssl_context *ssl )
//  234 {
ssl_reset_retransmit_timeout:
        PUSH     {R5-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
//  235     ssl->handshake->retransmit_timeout = ssl->conf->hs_timeout_min;
        LDR      R1,[R0, #+0]
        LDR      R1,[R1, #+172]
        LDR      R2,[R0, #+60]
        STR      R1,[R2, #+484]
//  236     MBEDTLS_SSL_DEBUG_MSG( 3, ( "update timeout value to %d millisecs",
//  237                         ssl->handshake->retransmit_timeout ) );
        LDR      R1,[R0, #+60]
        LDR      R1,[R1, #+484]
        STR      R1,[SP, #+4]
        LDR.W    R1,??DataTable12_2
        STR      R1,[SP, #+0]
        MOVS     R3,#+237
        LDR.W    R2,??DataTable12
        MOVS     R1,#+3
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//  238 }
        POP      {R0-R2,PC}       ;; return
          CFI EndBlock cfiBlock15
//  239 #endif /* MBEDTLS_SSL_PROTO_DTLS */
//  240 
//  241 #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
//  242 /*
//  243  * Convert max_fragment_length codes to length.
//  244  * RFC 6066 says:
//  245  *    enum{
//  246  *        2^9(1), 2^10(2), 2^11(3), 2^12(4), (255)
//  247  *    } MaxFragmentLength;
//  248  * and we add 0 -> extension unused
//  249  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function ssl_mfl_code_to_length
          CFI NoCalls
        THUMB
//  250 static unsigned int ssl_mfl_code_to_length( int mfl )
//  251 {
//  252     switch( mfl )
ssl_mfl_code_to_length:
        SUBS     R0,R0,#+1
        CMP      R0,#+3
        BHI.N    ??ssl_mfl_code_to_length_1
        TBB      [PC, R0]
        DATA
??ssl_mfl_code_to_length_0:
        DC8      0x2,0x5,0x8,0xB
        THUMB
//  253     {
//  254     case MBEDTLS_SSL_MAX_FRAG_LEN_NONE:
//  255         return ( MBEDTLS_TLS_EXT_ADV_CONTENT_LEN );
//  256     case MBEDTLS_SSL_MAX_FRAG_LEN_512:
//  257         return 512;
??ssl_mfl_code_to_length_2:
        MOV      R0,#+512
        BX       LR
//  258     case MBEDTLS_SSL_MAX_FRAG_LEN_1024:
//  259         return 1024;
??ssl_mfl_code_to_length_3:
        MOV      R0,#+1024
        BX       LR
//  260     case MBEDTLS_SSL_MAX_FRAG_LEN_2048:
//  261         return 2048;
??ssl_mfl_code_to_length_4:
        MOV      R0,#+2048
        BX       LR
//  262     case MBEDTLS_SSL_MAX_FRAG_LEN_4096:
//  263         return 4096;
??ssl_mfl_code_to_length_5:
        MOV      R0,#+4096
        BX       LR
//  264     default:
//  265         return ( MBEDTLS_TLS_EXT_ADV_CONTENT_LEN );
??ssl_mfl_code_to_length_1:
        MOV      R0,#+10240
        BX       LR               ;; return
//  266     }
//  267 }
          CFI EndBlock cfiBlock16
//  268 #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
//  269 
//  270 #if defined(MBEDTLS_SSL_CLI_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function ssl_session_copy
        THUMB
//  271 static int ssl_session_copy( mbedtls_ssl_session *dst, const mbedtls_ssl_session *src )
//  272 {
ssl_session_copy:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
        MOV      R6,R1
//  273     mbedtls_ssl_session_free( dst );
          CFI FunCall mbedtls_ssl_session_free
        BL       mbedtls_ssl_session_free
//  274     memcpy( dst, src, sizeof( mbedtls_ssl_session ) );
        MOVS     R2,#+124
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
//  275 
//  276 #if defined(MBEDTLS_X509_CRT_PARSE_C)
//  277     if( src->peer_cert != NULL )
        LDR      R0,[R6, #+92]
        CMP      R0,#+0
        BEQ.N    ??ssl_session_copy_0
//  278     {
//  279         int ret;
//  280 
//  281         dst->peer_cert = mbedtls_calloc( 1, sizeof(mbedtls_x509_crt) );
        MOV      R1,#+308
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R5, #+92]
//  282         if( dst->peer_cert == NULL )
        CMP      R0,#+0
        BEQ.N    ??ssl_session_copy_1
//  283             return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
//  284 
//  285         mbedtls_x509_crt_init( dst->peer_cert );
          CFI FunCall mbedtls_x509_crt_init
        BL       mbedtls_x509_crt_init
//  286 
//  287         if( ( ret = mbedtls_x509_crt_parse_der( dst->peer_cert, src->peer_cert->raw.p,
//  288                                         src->peer_cert->raw.len ) ) != 0 )
        LDR      R0,[R6, #+92]
        LDR      R2,[R0, #+4]
        LDR      R1,[R0, #+8]
        LDR      R0,[R5, #+92]
          CFI FunCall mbedtls_x509_crt_parse_der
        BL       mbedtls_x509_crt_parse_der
        MOVS     R4,R0
        BEQ.N    ??ssl_session_copy_0
//  289         {
//  290             mbedtls_free( dst->peer_cert );
        LDR      R0,[R5, #+92]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
//  291             dst->peer_cert = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+92]
//  292             return( ret );
        MOV      R0,R4
        POP      {R4-R6,PC}
//  293         }
//  294     }
//  295 #endif /* MBEDTLS_X509_CRT_PARSE_C */
//  296 
//  297 #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
//  298     if( src->ticket != NULL )
??ssl_session_copy_0:
        LDR      R0,[R6, #+100]
        CMP      R0,#+0
        BEQ.N    ??ssl_session_copy_2
//  299     {
//  300         dst->ticket = mbedtls_calloc( 1, src->ticket_len );
        LDR      R1,[R6, #+104]
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R5, #+100]
//  301         if( dst->ticket == NULL )
        CMP      R0,#+0
        BNE.N    ??ssl_session_copy_3
//  302             return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
??ssl_session_copy_1:
        LDR.W    R0,??DataTable13  ;; 0xffff8100
        POP      {R4-R6,PC}
//  303 
//  304         memcpy( dst->ticket, src->ticket, src->ticket_len );
??ssl_session_copy_3:
        LDR      R2,[R6, #+104]
        LDR      R1,[R6, #+100]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  305     }
//  306 #endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */
//  307 
//  308     return( 0 );
??ssl_session_copy_2:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
//  309 }
          CFI EndBlock cfiBlock17
//  310 #endif /* MBEDTLS_SSL_CLI_C */
//  311 
//  312 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
//  313 int (*mbedtls_ssl_hw_record_init)( mbedtls_ssl_context *ssl,
//  314                      const unsigned char *key_enc, const unsigned char *key_dec,
//  315                      size_t keylen,
//  316                      const unsigned char *iv_enc,  const unsigned char *iv_dec,
//  317                      size_t ivlen,
//  318                      const unsigned char *mac_enc, const unsigned char *mac_dec,
//  319                      size_t maclen ) = NULL;
//  320 int (*mbedtls_ssl_hw_record_activate)( mbedtls_ssl_context *ssl, int direction) = NULL;
//  321 int (*mbedtls_ssl_hw_record_reset)( mbedtls_ssl_context *ssl ) = NULL;
//  322 int (*mbedtls_ssl_hw_record_write)( mbedtls_ssl_context *ssl ) = NULL;
//  323 int (*mbedtls_ssl_hw_record_read)( mbedtls_ssl_context *ssl ) = NULL;
//  324 int (*mbedtls_ssl_hw_record_finish)( mbedtls_ssl_context *ssl ) = NULL;
//  325 #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
//  326 
//  327 /*
//  328  * Key material generation
//  329  */
//  330 #if defined(MBEDTLS_SSL_PROTO_SSL3)
//  331 static int ssl3_prf( const unsigned char *secret, size_t slen,
//  332                      const char *label,
//  333                      const unsigned char *random, size_t rlen,
//  334                      unsigned char *dstbuf, size_t dlen )
//  335 {
//  336     int ret = 0;
//  337     size_t i;
//  338     mbedtls_md5_context md5;
//  339     mbedtls_sha1_context sha1;
//  340     unsigned char padding[16];
//  341     unsigned char sha1sum[20];
//  342     ((void)label);
//  343 
//  344     mbedtls_md5_init(  &md5  );
//  345     mbedtls_sha1_init( &sha1 );
//  346 
//  347     /*
//  348      *  SSLv3:
//  349      *    block =
//  350      *      MD5( secret + SHA1( 'A'    + secret + random ) ) +
//  351      *      MD5( secret + SHA1( 'BB'   + secret + random ) ) +
//  352      *      MD5( secret + SHA1( 'CCC'  + secret + random ) ) +
//  353      *      ...
//  354      */
//  355     for( i = 0; i < dlen / 16; i++ )
//  356     {
//  357         memset( padding, (unsigned char) ('A' + i), 1 + i );
//  358 
//  359         if( ( ret = mbedtls_sha1_starts_ret( &sha1 ) ) != 0 )
//  360             goto exit;
//  361         if( ( ret = mbedtls_sha1_update_ret( &sha1, padding, 1 + i ) ) != 0 )
//  362             goto exit;
//  363         if( ( ret = mbedtls_sha1_update_ret( &sha1, secret, slen ) ) != 0 )
//  364             goto exit;
//  365         if( ( ret = mbedtls_sha1_update_ret( &sha1, random, rlen ) ) != 0 )
//  366             goto exit;
//  367         if( ( ret = mbedtls_sha1_finish_ret( &sha1, sha1sum ) ) != 0 )
//  368             goto exit;
//  369 
//  370         if( ( ret = mbedtls_md5_starts_ret( &md5 ) ) != 0 )
//  371             goto exit;
//  372         if( ( ret = mbedtls_md5_update_ret( &md5, secret, slen ) ) != 0 )
//  373             goto exit;
//  374         if( ( ret = mbedtls_md5_update_ret( &md5, sha1sum, 20 ) ) != 0 )
//  375             goto exit;
//  376         if( ( ret = mbedtls_md5_finish_ret( &md5, dstbuf + i * 16 ) ) != 0 )
//  377             goto exit;
//  378     }
//  379 
//  380 exit:
//  381     mbedtls_md5_free(  &md5  );
//  382     mbedtls_sha1_free( &sha1 );
//  383 
//  384     mbedtls_platform_zeroize( padding, sizeof( padding ) );
//  385     mbedtls_platform_zeroize( sha1sum, sizeof( sha1sum ) );
//  386 
//  387     return( ret );
//  388 }
//  389 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
//  390 
//  391 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function tls1_prf
        THUMB
//  392 static int tls1_prf( const unsigned char *secret, size_t slen,
//  393                      const char *label,
//  394                      const unsigned char *random, size_t rlen,
//  395                      unsigned char *dstbuf, size_t dlen )
//  396 {
tls1_prf:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+160
          CFI CFA R13+192
        MOV      R5,R0
        MOV      R7,R1
        MOV      R9,R2
        MOV      R8,R3
        LDR      R4,[SP, #+192]
//  397     size_t nb, hs;
//  398     size_t i, j, k;
//  399     const unsigned char *S1, *S2;
//  400     unsigned char tmp[128];
//  401     unsigned char h_i[20];
//  402     const mbedtls_md_info_t *md_info;
//  403     mbedtls_md_context_t md_ctx;
//  404     int ret;
//  405 
//  406     mbedtls_md_init( &md_ctx );
        MOV      R0,SP
          CFI FunCall mbedtls_md_init
        BL       mbedtls_md_init
//  407 
//  408     if( sizeof( tmp ) < 20 + strlen( label ) + rlen )
        MOV      R0,R9
          CFI FunCall strlen
        BL       strlen
        ADDS     R0,R4,R0
        ADDS     R0,R0,#+20
        CMP      R0,#+129
        BCC.N    ??tls1_prf_0
//  409         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable12_3  ;; 0xffff8f00
        B.N      ??tls1_prf_1
//  410 
//  411     hs = ( slen + 1 ) / 2;
??tls1_prf_0:
        ADDS     R6,R7,#+1
        LSRS     R6,R6,#+1
//  412     S1 = secret;
//  413     S2 = secret + slen - hs;
        ADDS     R0,R5,R7
        RSBS     R1,R6,#+0
        ADDS     R7,R0,R1
//  414 
//  415     nb = strlen( label );
        MOV      R0,R9
          CFI FunCall strlen
        BL       strlen
        MOV      R10,R0
//  416     memcpy( tmp + 20, label, nb );
        MOV      R2,R10
        MOV      R1,R9
        ADD      R0,SP,#+52
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  417     memcpy( tmp + 20 + nb, random, rlen );
        MOV      R2,R4
        MOV      R1,R8
        ADD      R0,SP,#+32
        ADD      R0,R0,R10
        ADDS     R0,R0,#+20
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  418     nb += rlen;
        ADD      R4,R4,R10
//  419 
//  420     /*
//  421      * First compute P_md5(secret,label+random)[0..dlen]
//  422      */
//  423     if( ( md_info = mbedtls_md_info_from_type( MBEDTLS_MD_MD5 ) ) == NULL )
        MOVS     R0,#+3
          CFI FunCall mbedtls_md_info_from_type
        BL       mbedtls_md_info_from_type
        CMP      R0,#+0
        BEQ.N    ??tls1_prf_2
//  424         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
//  425 
//  426     if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 1 ) ) != 0 )
        MOVS     R2,#+1
        MOV      R1,R0
        MOV      R0,SP
          CFI FunCall mbedtls_md_setup
        BL       mbedtls_md_setup
        CMP      R0,#+0
        BNE.W    ??tls1_prf_1
//  427         return( ret );
//  428 
//  429     mbedtls_md_hmac_starts( &md_ctx, S1, hs );
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_starts
        BL       mbedtls_md_hmac_starts
//  430     mbedtls_md_hmac_update( &md_ctx, tmp + 20, nb );
        MOV      R2,R4
        ADD      R1,SP,#+52
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
//  431     mbedtls_md_hmac_finish( &md_ctx, 4 + tmp );
        ADD      R1,SP,#+36
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
//  432 
//  433     for( i = 0; i < dlen; i += 16 )
        MOV      R9,#+0
        LDR      R5,[SP, #+196]
        LDR      R8,[SP, #+200]
        B.N      ??tls1_prf_3
//  434     {
//  435         mbedtls_md_hmac_reset ( &md_ctx );
//  436         mbedtls_md_hmac_update( &md_ctx, 4 + tmp, 16 + nb );
//  437         mbedtls_md_hmac_finish( &md_ctx, h_i );
//  438 
//  439         mbedtls_md_hmac_reset ( &md_ctx );
//  440         mbedtls_md_hmac_update( &md_ctx, 4 + tmp, 16 );
//  441         mbedtls_md_hmac_finish( &md_ctx, 4 + tmp );
//  442 
//  443         k = ( i + 16 > dlen ) ? dlen % 16 : 16;
//  444 
//  445         for( j = 0; j < k; j++ )
//  446             dstbuf[i + j]  = h_i[j];
??tls1_prf_4:
        ADD      R2,SP,#+12
        LDRB     R2,[R2, R0]
        ADD      R3,R0,R9
        STRB     R2,[R5, R3]
        ADDS     R0,R0,#+1
??tls1_prf_5:
        CMP      R0,R1
        BCC.N    ??tls1_prf_4
        ADD      R9,R9,#+16
??tls1_prf_3:
        CMP      R9,R8
        MOV      R0,SP
        BCS.N    ??tls1_prf_6
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
        ADD      R2,R4,#+16
        ADD      R1,SP,#+36
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
        ADD      R1,SP,#+12
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
        MOVS     R2,#+16
        ADD      R1,SP,#+36
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
        ADD      R1,SP,#+36
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
        ADD      R0,R9,#+16
        CMP      R8,R0
        BCS.N    ??tls1_prf_7
        AND      R1,R8,#0xF
        B.N      ??tls1_prf_8
??tls1_prf_7:
        MOVS     R1,#+16
??tls1_prf_8:
        MOVS     R0,#+0
        B.N      ??tls1_prf_5
//  447     }
//  448 
//  449     mbedtls_md_free( &md_ctx );
??tls1_prf_6:
          CFI FunCall mbedtls_md_free
        BL       mbedtls_md_free
//  450 
//  451     /*
//  452      * XOR out with P_sha1(secret,label+random)[0..dlen]
//  453      */
//  454     if( ( md_info = mbedtls_md_info_from_type( MBEDTLS_MD_SHA1 ) ) == NULL )
        MOVS     R0,#+4
          CFI FunCall mbedtls_md_info_from_type
        BL       mbedtls_md_info_from_type
        CMP      R0,#+0
        BNE.N    ??tls1_prf_9
//  455         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
??tls1_prf_2:
        LDR.W    R0,??DataTable13_1  ;; 0xffff9400
        B.N      ??tls1_prf_1
//  456 
//  457     if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 1 ) ) != 0 )
??tls1_prf_9:
        MOVS     R2,#+1
        MOV      R1,R0
        MOV      R0,SP
          CFI FunCall mbedtls_md_setup
        BL       mbedtls_md_setup
        CMP      R0,#+0
        BNE.N    ??tls1_prf_1
//  458         return( ret );
//  459 
//  460     mbedtls_md_hmac_starts( &md_ctx, S2, hs );
        MOV      R2,R6
        MOV      R1,R7
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_starts
        BL       mbedtls_md_hmac_starts
//  461     mbedtls_md_hmac_update( &md_ctx, tmp + 20, nb );
        MOV      R2,R4
        ADD      R1,SP,#+52
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
//  462     mbedtls_md_hmac_finish( &md_ctx, tmp );
        ADD      R1,SP,#+32
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
//  463 
//  464     for( i = 0; i < dlen; i += 20 )
        MOVS     R6,#+0
        B.N      ??tls1_prf_10
//  465     {
//  466         mbedtls_md_hmac_reset ( &md_ctx );
//  467         mbedtls_md_hmac_update( &md_ctx, tmp, 20 + nb );
//  468         mbedtls_md_hmac_finish( &md_ctx, h_i );
//  469 
//  470         mbedtls_md_hmac_reset ( &md_ctx );
//  471         mbedtls_md_hmac_update( &md_ctx, tmp, 20 );
//  472         mbedtls_md_hmac_finish( &md_ctx, tmp );
//  473 
//  474         k = ( i + 20 > dlen ) ? dlen % 20 : 20;
//  475 
//  476         for( j = 0; j < k; j++ )
//  477             dstbuf[i + j] = (unsigned char)( dstbuf[i + j] ^ h_i[j] );
??tls1_prf_11:
        ADDS     R2,R0,R6
        LDRB     R2,[R5, R2]
        ADD      R3,SP,#+12
        LDRB     R3,[R3, R0]
        EORS     R2,R3,R2
        ADDS     R3,R0,R6
        STRB     R2,[R5, R3]
        ADDS     R0,R0,#+1
??tls1_prf_12:
        CMP      R0,R1
        BCC.N    ??tls1_prf_11
        ADDS     R6,R6,#+20
??tls1_prf_10:
        CMP      R6,R8
        MOV      R0,SP
        BCS.N    ??tls1_prf_13
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
        ADD      R2,R4,#+20
        ADD      R1,SP,#+32
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
        ADD      R1,SP,#+12
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
        MOVS     R2,#+20
        ADD      R1,SP,#+32
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
        ADD      R1,SP,#+32
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
        ADD      R0,R6,#+20
        CMP      R8,R0
        BCS.N    ??tls1_prf_14
        MOVS     R0,#+20
        UDIV     R0,R8,R0
        ADD      R1,R0,R0, LSL #+2
        SUB      R1,R8,R1, LSL #+2
        B.N      ??tls1_prf_15
??tls1_prf_14:
        MOVS     R1,#+20
??tls1_prf_15:
        MOVS     R0,#+0
        B.N      ??tls1_prf_12
//  478     }
//  479 
//  480     mbedtls_md_free( &md_ctx );
??tls1_prf_13:
          CFI FunCall mbedtls_md_free
        BL       mbedtls_md_free
//  481 
//  482     mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
        MOVS     R1,#+128
        ADD      R0,SP,#+32
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
//  483     mbedtls_platform_zeroize( h_i, sizeof( h_i ) );
        MOVS     R1,#+20
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
//  484 
//  485     return( 0 );
        MOVS     R0,#+0
??tls1_prf_1:
        ADD      SP,SP,#+160
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
//  486 }
          CFI EndBlock cfiBlock18
//  487 #endif /* MBEDTLS_SSL_PROTO_TLS1) || MBEDTLS_SSL_PROTO_TLS1_1 */
//  488 
//  489 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function tls_prf_generic
        THUMB
//  490 static int tls_prf_generic( mbedtls_md_type_t md_type,
//  491                             const unsigned char *secret, size_t slen,
//  492                             const char *label,
//  493                             const unsigned char *random, size_t rlen,
//  494                             unsigned char *dstbuf, size_t dlen )
//  495 {
tls_prf_generic:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+204
          CFI CFA R13+240
        MOV      R6,R0
        MOV      R4,R1
        MOV      R5,R2
        MOV      R9,R3
//  496     size_t nb;
//  497     size_t i, j, k, md_len;
//  498     unsigned char tmp[128];
//  499     unsigned char h_i[MBEDTLS_MD_MAX_SIZE];
//  500     const mbedtls_md_info_t *md_info;
//  501     mbedtls_md_context_t md_ctx;
//  502     int ret;
//  503 
//  504     mbedtls_md_init( &md_ctx );
        MOV      R0,SP
          CFI FunCall mbedtls_md_init
        BL       mbedtls_md_init
//  505 
//  506     if( ( md_info = mbedtls_md_info_from_type( md_type ) ) == NULL )
        MOV      R0,R6
          CFI FunCall mbedtls_md_info_from_type
        BL       mbedtls_md_info_from_type
        MOVS     R6,R0
        BNE.N    ??tls_prf_generic_0
//  507         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable12_1  ;; 0xffff9400
        B.N      ??tls_prf_generic_1
??tls_prf_generic_0:
        LDR      R8,[SP, #+244]
//  508 
//  509     md_len = mbedtls_md_get_size( md_info );
          CFI FunCall mbedtls_md_get_size
        BL       mbedtls_md_get_size
        MOV      R7,R0
//  510 
//  511     if( sizeof( tmp ) < md_len + strlen( label ) + rlen )
        MOV      R0,R9
          CFI FunCall strlen
        BL       strlen
        ADDS     R0,R0,R7
        ADD      R0,R8,R0
        CMP      R0,#+129
        BCC.N    ??tls_prf_generic_2
//  512         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable12_3  ;; 0xffff8f00
        B.N      ??tls_prf_generic_1
??tls_prf_generic_2:
        LDR      R10,[SP, #+240]
//  513 
//  514     nb = strlen( label );
        MOV      R0,R9
          CFI FunCall strlen
        BL       strlen
        MOV      R11,R0
//  515     memcpy( tmp + md_len, label, nb );
        MOV      R2,R11
        MOV      R1,R9
        ADD      R0,SP,#+76
        ADD      R0,R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  516     memcpy( tmp + md_len + nb, random, rlen );
        MOV      R2,R8
        MOV      R1,R10
        ADD      R0,SP,#+76
        ADD      R0,R0,R7
        ADD      R0,R0,R11
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  517     nb += rlen;
        ADD      R8,R8,R11
//  518 
//  519     /*
//  520      * Compute P_<hash>(secret, label + random)[0..dlen]
//  521      */
//  522     if ( ( ret = mbedtls_md_setup( &md_ctx, md_info, 1 ) ) != 0 )
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall mbedtls_md_setup
        BL       mbedtls_md_setup
        CMP      R0,#+0
        BNE.N    ??tls_prf_generic_1
//  523         return( ret );
        MOV      R2,R5
        MOV      R1,R4
//  524 
//  525     mbedtls_md_hmac_starts( &md_ctx, secret, slen );
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_starts
        BL       mbedtls_md_hmac_starts
//  526     mbedtls_md_hmac_update( &md_ctx, tmp + md_len, nb );
        MOV      R2,R8
        ADD      R0,SP,#+76
        ADDS     R1,R0,R7
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
//  527     mbedtls_md_hmac_finish( &md_ctx, tmp );
        ADD      R1,SP,#+76
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
//  528 
//  529     for( i = 0; i < dlen; i += md_len )
        MOVS     R6,#+0
        LDR      R5,[SP, #+248]
        LDR      R4,[SP, #+252]
        B.N      ??tls_prf_generic_3
//  530     {
//  531         mbedtls_md_hmac_reset ( &md_ctx );
//  532         mbedtls_md_hmac_update( &md_ctx, tmp, md_len + nb );
//  533         mbedtls_md_hmac_finish( &md_ctx, h_i );
//  534 
//  535         mbedtls_md_hmac_reset ( &md_ctx );
//  536         mbedtls_md_hmac_update( &md_ctx, tmp, md_len );
//  537         mbedtls_md_hmac_finish( &md_ctx, tmp );
//  538 
//  539         k = ( i + md_len > dlen ) ? dlen % md_len : md_len;
//  540 
//  541         for( j = 0; j < k; j++ )
//  542             dstbuf[i + j]  = h_i[j];
??tls_prf_generic_4:
        ADD      R2,SP,#+12
        LDRB     R2,[R2, R0]
        ADDS     R3,R0,R6
        STRB     R2,[R5, R3]
        ADDS     R0,R0,#+1
??tls_prf_generic_5:
        CMP      R0,R1
        BCC.N    ??tls_prf_generic_4
        ADDS     R6,R7,R6
??tls_prf_generic_3:
        CMP      R6,R4
        MOV      R0,SP
        BCS.N    ??tls_prf_generic_6
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
        ADD      R2,R8,R7
        ADD      R1,SP,#+76
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
        ADD      R1,SP,#+12
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
        MOV      R2,R7
        ADD      R1,SP,#+76
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
        ADD      R1,SP,#+76
        MOV      R0,SP
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
        ADDS     R0,R7,R6
        CMP      R4,R0
        BCS.N    ??tls_prf_generic_7
        UDIV     R1,R4,R7
        MLS      R1,R7,R1,R4
        B.N      ??tls_prf_generic_8
??tls_prf_generic_7:
        MOV      R1,R7
??tls_prf_generic_8:
        MOVS     R0,#+0
        B.N      ??tls_prf_generic_5
//  543     }
//  544 
//  545     mbedtls_md_free( &md_ctx );
??tls_prf_generic_6:
          CFI FunCall mbedtls_md_free
        BL       mbedtls_md_free
//  546 
//  547     mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
        MOVS     R1,#+128
        ADD      R0,SP,#+76
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
//  548     mbedtls_platform_zeroize( h_i, sizeof( h_i ) );
        MOVS     R1,#+64
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
//  549 
//  550     return( 0 );
        MOVS     R0,#+0
??tls_prf_generic_1:
        ADD      SP,SP,#+204
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
//  551 }
          CFI EndBlock cfiBlock19
//  552 
//  553 #if defined(MBEDTLS_SHA256_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function tls_prf_sha256
        THUMB
//  554 static int tls_prf_sha256( const unsigned char *secret, size_t slen,
//  555                            const char *label,
//  556                            const unsigned char *random, size_t rlen,
//  557                            unsigned char *dstbuf, size_t dlen )
//  558 {
tls_prf_sha256:
        PUSH     {R0-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+32
        LDR      R4,[SP, #+32]
        LDR      R5,[SP, #+36]
        LDR      R6,[SP, #+40]
//  559     return( tls_prf_generic( MBEDTLS_MD_SHA256, secret, slen,
//  560                              label, random, rlen, dstbuf, dlen ) );
        STR      R6,[SP, #+12]
        STR      R5,[SP, #+8]
        STR      R4,[SP, #+4]
        STR      R3,[SP, #+0]
        MOV      R3,R2
        MOV      R2,R1
        MOV      R1,R0
        MOVS     R0,#+6
          CFI FunCall tls_prf_generic
        BL       tls_prf_generic
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
//  561 }
          CFI EndBlock cfiBlock20
//  562 #endif /* MBEDTLS_SHA256_C */
//  563 
//  564 #if defined(MBEDTLS_SHA512_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function tls_prf_sha384
        THUMB
//  565 static int tls_prf_sha384( const unsigned char *secret, size_t slen,
//  566                            const char *label,
//  567                            const unsigned char *random, size_t rlen,
//  568                            unsigned char *dstbuf, size_t dlen )
//  569 {
tls_prf_sha384:
        PUSH     {R0-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+32
        LDR      R4,[SP, #+32]
        LDR      R5,[SP, #+36]
        LDR      R6,[SP, #+40]
//  570     return( tls_prf_generic( MBEDTLS_MD_SHA384, secret, slen,
//  571                              label, random, rlen, dstbuf, dlen ) );
        STR      R6,[SP, #+12]
        STR      R5,[SP, #+8]
        STR      R4,[SP, #+4]
        STR      R3,[SP, #+0]
        MOV      R3,R2
        MOV      R2,R1
        MOV      R1,R0
        MOVS     R0,#+7
          CFI FunCall tls_prf_generic
        BL       tls_prf_generic
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
//  572 }
          CFI EndBlock cfiBlock21
//  573 #endif /* MBEDTLS_SHA512_C */
//  574 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
//  575 
//  576 static void ssl_update_checksum_start( mbedtls_ssl_context *, const unsigned char *, size_t );
//  577 
//  578 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ 
//  579     defined(MBEDTLS_SSL_PROTO_TLS1_1)
//  580 static void ssl_update_checksum_md5sha1( mbedtls_ssl_context *, const unsigned char *, size_t );
//  581 #endif
//  582 
//  583 #if defined(MBEDTLS_SSL_PROTO_SSL3)
//  584 static void ssl_calc_verify_ssl( mbedtls_ssl_context *, unsigned char * );
//  585 static void ssl_calc_finished_ssl( mbedtls_ssl_context *, unsigned char *, int );
//  586 #endif
//  587 
//  588 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)
//  589 static void ssl_calc_verify_tls( mbedtls_ssl_context *, unsigned char * );
//  590 static void ssl_calc_finished_tls( mbedtls_ssl_context *, unsigned char *, int );
//  591 #endif
//  592 
//  593 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
//  594 #if defined(MBEDTLS_SHA256_C)
//  595 static void ssl_update_checksum_sha256( mbedtls_ssl_context *, const unsigned char *, size_t );
//  596 static void ssl_calc_verify_tls_sha256( mbedtls_ssl_context *,unsigned char * );
//  597 static void ssl_calc_finished_tls_sha256( mbedtls_ssl_context *,unsigned char *, int );
//  598 #endif
//  599 
//  600 #if defined(MBEDTLS_SHA512_C)
//  601 static void ssl_update_checksum_sha384( mbedtls_ssl_context *, const unsigned char *, size_t );
//  602 static void ssl_calc_verify_tls_sha384( mbedtls_ssl_context *, unsigned char * );
//  603 static void ssl_calc_finished_tls_sha384( mbedtls_ssl_context *, unsigned char *, int );
//  604 #endif
//  605 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
//  606 

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function mbedtls_ssl_derive_keys
        THUMB
//  607 int mbedtls_ssl_derive_keys( mbedtls_ssl_context *ssl )
//  608 {
mbedtls_ssl_derive_keys:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+380
          CFI CFA R13+416
        MOV      R7,R0
//  609     int ret = 0;
//  610     unsigned char tmp[64];
//  611     unsigned char keyblk[256];
//  612     unsigned char *key1;
//  613     unsigned char *key2;
//  614     unsigned char *mac_enc;
//  615     unsigned char *mac_dec;
//  616     size_t mac_key_len;
//  617     size_t iv_copy_len;
//  618     const mbedtls_cipher_info_t *cipher_info;
//  619     const mbedtls_md_info_t *md_info;
//  620 
//  621     mbedtls_ssl_session *session = ssl->session_negotiate;
        LDR      R8,[R7, #+56]
//  622     mbedtls_ssl_transform *transform = ssl->transform_negotiate;
        LDR      R9,[R7, #+76]
//  623     mbedtls_ssl_handshake_params *handshake = ssl->handshake;
        LDR      R11,[R7, #+60]
//  624 
//  625     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> derive keys" ) );
        LDR.W    R10,??DataTable12
        LDR.W    R0,??DataTable13_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+625
        MOV      R2,R10
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//  626 
//  627     cipher_info = mbedtls_cipher_info_from_type( transform->ciphersuite_info->cipher );
        LDR      R0,[R9, #+0]
        LDRB     R0,[R0, #+8]
          CFI FunCall mbedtls_cipher_info_from_type
        BL       mbedtls_cipher_info_from_type
        MOVS     R5,R0
//  628     if( cipher_info == NULL )
        LDR      R0,[R9, #+0]
        BNE.N    ??mbedtls_ssl_derive_keys_1
//  629     {
//  630         MBEDTLS_SSL_DEBUG_MSG( 1, ( "cipher info for %d not found",
//  631                             transform->ciphersuite_info->cipher ) );
        LDRB     R0,[R0, #+8]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable13_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+631
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//  632         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable12_3  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_derive_keys_2
//  633     }
//  634 
//  635     md_info = mbedtls_md_info_from_type( transform->ciphersuite_info->mac );
??mbedtls_ssl_derive_keys_1:
        LDRB     R0,[R0, #+9]
          CFI FunCall mbedtls_md_info_from_type
        BL       mbedtls_md_info_from_type
        MOVS     R6,R0
//  636     if( md_info == NULL )
        BNE.N    ??mbedtls_ssl_derive_keys_3
//  637     {
//  638         MBEDTLS_SSL_DEBUG_MSG( 1, ( "mbedtls_md info for %d not found",
//  639                             transform->ciphersuite_info->mac ) );
        LDR      R0,[R9, #+0]
        LDRB     R0,[R0, #+9]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable13_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+639
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//  640         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable12_3  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_derive_keys_2
//  641     }
//  642 
//  643     /*
//  644      * Set appropriate PRF function and other SSL / TLS / TLS1.2 functions
//  645      */
//  646 #if defined(MBEDTLS_SSL_PROTO_SSL3)
//  647     if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
//  648     {
//  649         handshake->tls_prf = ssl3_prf;
//  650         handshake->calc_verify = ssl_calc_verify_ssl;
//  651         handshake->calc_finished = ssl_calc_finished_ssl;
//  652     }
//  653     else
//  654 #endif
//  655 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)
//  656     if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )
??mbedtls_ssl_derive_keys_3:
        LDR      R0,[R7, #+20]
        CMP      R0,#+3
        BGE.N    ??mbedtls_ssl_derive_keys_4
//  657     {
//  658         handshake->tls_prf = tls1_prf;
        LDR.W    R0,??DataTable13_5
        STR      R0,[R11, #+1108]
//  659         handshake->calc_verify = ssl_calc_verify_tls;
        LDR.W    R0,??DataTable13_6
        STR      R0,[R11, #+1100]
//  660         handshake->calc_finished = ssl_calc_finished_tls;
        LDR.W    R0,??DataTable13_7
        STR      R0,[R11, #+1104]
//  661     }
//  662     else
//  663 #endif
//  664 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
//  665 #if defined(MBEDTLS_SHA512_C)
//  666     if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 &&
//  667         transform->ciphersuite_info->mac == MBEDTLS_MD_SHA384 )
//  668     {
//  669         handshake->tls_prf = tls_prf_sha384;
//  670         handshake->calc_verify = ssl_calc_verify_tls_sha384;
//  671         handshake->calc_finished = ssl_calc_finished_tls_sha384;
//  672     }
//  673     else
//  674 #endif
//  675 #if defined(MBEDTLS_SHA256_C)
//  676     if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
//  677     {
//  678         handshake->tls_prf = tls_prf_sha256;
//  679         handshake->calc_verify = ssl_calc_verify_tls_sha256;
//  680         handshake->calc_finished = ssl_calc_finished_tls_sha256;
//  681     }
//  682     else
//  683 #endif
//  684 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
//  685     {
//  686         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
//  687         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
//  688     }
//  689 
//  690     /*
//  691      * SSLv3:
//  692      *   master =
//  693      *     MD5( premaster + SHA1( 'A'   + premaster + randbytes ) ) +
//  694      *     MD5( premaster + SHA1( 'BB'  + premaster + randbytes ) ) +
//  695      *     MD5( premaster + SHA1( 'CCC' + premaster + randbytes ) )
//  696      *
//  697      * TLSv1+:
//  698      *   master = PRF( premaster, "master secret", randbytes )[0..47]
//  699      */
//  700     if( handshake->resume == 0 )
??mbedtls_ssl_derive_keys_5:
        LDR      R0,[R11, #+1728]
        CMP      R0,#+0
        BNE.W    ??mbedtls_ssl_derive_keys_6
//  701     {
//  702         MBEDTLS_SSL_DEBUG_BUF( 3, "premaster secret", handshake->premaster,
//  703                        handshake->pmslen );
        LDR      R0,[R11, #+1112]
        STR      R0,[SP, #+8]
        ADDW     R0,R11,#+1180
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable13_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+703
        MOV      R2,R10
        MOVS     R1,#+3
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
//  704 
//  705 #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
//  706         if( ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED )
        LDR      R0,[R7, #+60]
        LDR      R0,[R0, #+1748]
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_derive_keys_7
//  707         {
//  708             unsigned char session_hash[48];
//  709             size_t hash_len;
//  710 
//  711             MBEDTLS_SSL_DEBUG_MSG( 3, ( "using extended master secret" ) );
        LDR.W    R0,??DataTable13_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+711
        MOV      R2,R10
        MOVS     R1,#+3
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//  712 
//  713             ssl->handshake->calc_verify( ssl, session_hash );
        ADD      R1,SP,#+12
        MOV      R0,R7
        LDR      R2,[R7, #+60]
        LDR      R2,[R2, #+1100]
          CFI FunCall
        BLX      R2
//  714 
//  715 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
//  716             if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
        LDR      R0,[R7, #+20]
        CMP      R0,#+3
        BNE.N    ??mbedtls_ssl_derive_keys_8
//  717             {
//  718 #if defined(MBEDTLS_SHA512_C)
//  719                 if( ssl->transform_negotiate->ciphersuite_info->mac ==
//  720                     MBEDTLS_MD_SHA384 )
        LDR      R0,[R7, #+76]
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+9]
        CMP      R0,#+7
        BNE.N    ??mbedtls_ssl_derive_keys_9
//  721                 {
//  722                     hash_len = 48;
        MOVS     R4,#+48
        B.N      ??mbedtls_ssl_derive_keys_10
//  723                 }
??mbedtls_ssl_derive_keys_4:
        BNE.N    ??mbedtls_ssl_derive_keys_11
        LDR      R0,[R9, #+0]
        LDRB     R0,[R0, #+9]
        CMP      R0,#+7
        BNE.N    ??mbedtls_ssl_derive_keys_11
        LDR.W    R0,??DataTable13_10
        STR      R0,[R11, #+1108]
        LDR.W    R0,??DataTable13_11
        STR      R0,[R11, #+1100]
        LDR.W    R0,??DataTable13_12
        STR      R0,[R11, #+1104]
        B.N      ??mbedtls_ssl_derive_keys_5
??mbedtls_ssl_derive_keys_11:
        LDR      R0,[R7, #+20]
        CMP      R0,#+3
        BNE.N    ??mbedtls_ssl_derive_keys_12
        LDR.W    R0,??DataTable13_13
        STR      R0,[R11, #+1108]
        LDR.W    R0,??DataTable13_14
        STR      R0,[R11, #+1100]
        LDR.W    R0,??DataTable13_15
        STR      R0,[R11, #+1104]
        B.N      ??mbedtls_ssl_derive_keys_5
??mbedtls_ssl_derive_keys_12:
        LDR.W    R0,??DataTable13_16
        STR      R0,[SP, #+0]
        MOVW     R3,#+686
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable12_1  ;; 0xffff9400
        B.N      ??mbedtls_ssl_derive_keys_2
//  724                 else
//  725 #endif
//  726                     hash_len = 32;
??mbedtls_ssl_derive_keys_9:
        MOVS     R4,#+32
        B.N      ??mbedtls_ssl_derive_keys_10
//  727             }
//  728             else
//  729 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
//  730                 hash_len = 36;
??mbedtls_ssl_derive_keys_8:
        MOVS     R4,#+36
//  731 
//  732             MBEDTLS_SSL_DEBUG_BUF( 3, "session hash", session_hash, hash_len );
??mbedtls_ssl_derive_keys_10:
        STR      R4,[SP, #+8]
        ADD      R0,SP,#+12
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable13_17
        STR      R0,[SP, #+0]
        MOV      R3,#+732
        MOV      R2,R10
        MOVS     R1,#+3
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
//  733 
//  734             ret = handshake->tls_prf( handshake->premaster, handshake->pmslen,
//  735                                       "extended master secret",
//  736                                       session_hash, hash_len,
//  737                                       session->master, 48 );
        MOVS     R0,#+48
        STR      R0,[SP, #+8]
        ADD      R0,R8,#+44
        STR      R0,[SP, #+4]
        STR      R4,[SP, #+0]
        ADD      R3,SP,#+12
        LDR.W    R2,??DataTable13_18
        LDR      R1,[R11, #+1112]
        ADDW     R0,R11,#+1180
        LDR      R4,[R11, #+1108]
          CFI FunCall
        BLX      R4
        MOVS     R4,R0
//  738             if( ret != 0 )
        BEQ.N    ??mbedtls_ssl_derive_keys_13
//  739             {
//  740                 MBEDTLS_SSL_DEBUG_RET( 1, "prf", ret );
        STR      R4,[SP, #+4]
        ADR.N    R0,??mbedtls_ssl_derive_keys_0  ;; "prf"
        STR      R0,[SP, #+0]
        MOV      R3,#+740
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
//  741                 return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
//  742             }
//  743 
//  744         }
//  745         else
//  746 #endif
//  747         ret = handshake->tls_prf( handshake->premaster, handshake->pmslen,
//  748                                   "master secret",
//  749                                   handshake->randbytes, 64,
//  750                                   session->master, 48 );
??mbedtls_ssl_derive_keys_7:
        MOVS     R0,#+48
        STR      R0,[SP, #+8]
        ADD      R0,R8,#+44
        STR      R0,[SP, #+4]
        MOVS     R0,#+64
        STR      R0,[SP, #+0]
        ADDW     R3,R11,#+1116
        LDR.W    R2,??DataTable13_19
        LDR      R1,[R11, #+1112]
        ADDW     R0,R11,#+1180
        LDR      R4,[R11, #+1108]
          CFI FunCall
        BLX      R4
        MOV      R4,R0
//  751         if( ret != 0 )
??mbedtls_ssl_derive_keys_13:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_derive_keys_14
//  752         {
//  753             MBEDTLS_SSL_DEBUG_RET( 1, "prf", ret );
        STR      R4,[SP, #+4]
        ADR.N    R0,??mbedtls_ssl_derive_keys_0  ;; "prf"
        STR      R0,[SP, #+0]
        MOVW     R3,#+753
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
//  754             return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
//  755         }
//  756 
//  757         mbedtls_platform_zeroize( handshake->premaster,
//  758                                   sizeof(handshake->premaster) );
??mbedtls_ssl_derive_keys_14:
        MOV      R1,#+548
        ADDW     R0,R11,#+1180
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
        B.N      ??mbedtls_ssl_derive_keys_15
//  759     }
//  760     else
//  761         MBEDTLS_SSL_DEBUG_MSG( 3, ( "no premaster (session resumed)" ) );
??mbedtls_ssl_derive_keys_6:
        LDR.W    R0,??DataTable13_20
        STR      R0,[SP, #+0]
        MOVW     R3,#+761
        MOV      R2,R10
        MOVS     R1,#+3
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//  762 
//  763     /*
//  764      * Swap the client and server random values.
//  765      */
//  766     memcpy( tmp, handshake->randbytes, 64 );
??mbedtls_ssl_derive_keys_15:
        MOVS     R2,#+64
        ADDW     R1,R11,#+1116
        ADD      R0,SP,#+316
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
//  767     memcpy( handshake->randbytes, tmp + 32, 32 );
        MOVS     R2,#+32
        ADD      R1,SP,#+348
        ADDW     R0,R11,#+1116
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
//  768     memcpy( handshake->randbytes + 32, tmp, 32 );
        MOVS     R2,#+32
        ADD      R1,SP,#+316
        ADDW     R0,R11,#+1148
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
//  769     mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
        MOVS     R1,#+64
        ADD      R0,SP,#+316
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
//  770 
//  771     /*
//  772      *  SSLv3:
//  773      *    key block =
//  774      *      MD5( master + SHA1( 'A'    + master + randbytes ) ) +
//  775      *      MD5( master + SHA1( 'BB'   + master + randbytes ) ) +
//  776      *      MD5( master + SHA1( 'CCC'  + master + randbytes ) ) +
//  777      *      MD5( master + SHA1( 'DDDD' + master + randbytes ) ) +
//  778      *      ...
//  779      *
//  780      *  TLSv1:
//  781      *    key block = PRF( master, "key expansion", randbytes )
//  782      */
//  783     ret = handshake->tls_prf( session->master, 48, "key expansion",
//  784                               handshake->randbytes, 64, keyblk, 256 );
        MOV      R0,#+256
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+60
        STR      R0,[SP, #+4]
        MOVS     R0,#+64
        STR      R0,[SP, #+0]
        ADDW     R3,R11,#+1116
        LDR.W    R2,??DataTable13_21
        MOVS     R1,#+48
        ADD      R0,R8,#+44
        LDR      R4,[R11, #+1108]
          CFI FunCall
        BLX      R4
        MOVS     R4,R0
//  785     if( ret != 0 )
        BEQ.N    ??mbedtls_ssl_derive_keys_16
//  786     {
//  787         MBEDTLS_SSL_DEBUG_RET( 1, "prf", ret );
        STR      R4,[SP, #+4]
        ADR.N    R0,??mbedtls_ssl_derive_keys_0  ;; "prf"
        STR      R0,[SP, #+0]
        MOVW     R3,#+787
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
//  788         return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
//  789     }
//  790 
//  791     MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite = %s",
//  792                    mbedtls_ssl_get_ciphersuite_name( session->ciphersuite ) ) );
??mbedtls_ssl_derive_keys_16:
        LDR      R0,[R8, #+0]
          CFI FunCall mbedtls_ssl_get_ciphersuite_name
        BL       mbedtls_ssl_get_ciphersuite_name
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable13_22
        STR      R0,[SP, #+0]
        MOV      R3,#+792
        MOV      R2,R10
        MOVS     R1,#+3
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//  793     MBEDTLS_SSL_DEBUG_BUF( 3, "master secret", session->master, 48 );
        MOVS     R0,#+48
        STR      R0,[SP, #+8]
        ADD      R0,R8,#+44
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable13_19
        STR      R0,[SP, #+0]
        MOVW     R3,#+793
        MOV      R2,R10
        MOVS     R1,#+3
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
//  794     MBEDTLS_SSL_DEBUG_BUF( 4, "random bytes", handshake->randbytes, 64 );
        MOVS     R0,#+64
        STR      R0,[SP, #+8]
        ADDW     R0,R11,#+1116
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable13_23
        STR      R0,[SP, #+0]
        MOVW     R3,#+794
        MOV      R2,R10
        MOVS     R1,#+4
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
//  795     MBEDTLS_SSL_DEBUG_BUF( 4, "key block", keyblk, 256 );
        MOV      R0,#+256
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+60
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable13_24
        STR      R0,[SP, #+0]
        MOVW     R3,#+795
        MOV      R2,R10
        MOVS     R1,#+4
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
//  796 
//  797     mbedtls_platform_zeroize( handshake->randbytes,
//  798                               sizeof( handshake->randbytes ) );
        MOVS     R1,#+64
        ADDW     R0,R11,#+1116
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
//  799 
//  800     /*
//  801      * Determine the appropriate key, IV and MAC length.
//  802      */
//  803 
//  804     transform->keylen = cipher_info->key_bitlen / 8;
        LDR      R0,[R5, #+4]
        LSRS     R0,R0,#+3
        STR      R0,[R9, #+4]
//  805 
//  806     if( cipher_info->mode == MBEDTLS_MODE_GCM ||
//  807         cipher_info->mode == MBEDTLS_MODE_CCM ||
//  808         cipher_info->mode == MBEDTLS_MODE_CHACHAPOLY )
        LDRB     R0,[R5, #+1]
        CMP      R0,#+6
        BEQ.N    ??mbedtls_ssl_derive_keys_17
        CMP      R0,#+8
        BEQ.N    ??mbedtls_ssl_derive_keys_17
        CMP      R0,#+10
        BNE.N    ??mbedtls_ssl_derive_keys_18
//  809     {
//  810         size_t taglen, explicit_ivlen;
//  811 
//  812         transform->maclen = 0;
??mbedtls_ssl_derive_keys_17:
        MOVS     R0,#+0
        STR      R0,[R9, #+20]
//  813         mac_key_len = 0;
        MOV      R4,R0
//  814 
//  815         /* All modes haves 96-bit IVs;
//  816          * GCM and CCM has 4 implicit and 8 explicit bytes
//  817          * ChachaPoly has all 12 bytes implicit
//  818          */
//  819         transform->ivlen = 12;
        MOVS     R0,#+12
        STR      R0,[R9, #+12]
//  820         if( cipher_info->mode == MBEDTLS_MODE_CHACHAPOLY )
        LDRB     R0,[R5, #+1]
        CMP      R0,#+10
        BNE.N    ??mbedtls_ssl_derive_keys_19
//  821             transform->fixed_ivlen = 12;
        MOVS     R0,#+12
        STR      R0,[R9, #+16]
        B.N      ??mbedtls_ssl_derive_keys_20
//  822         else
//  823             transform->fixed_ivlen = 4;
??mbedtls_ssl_derive_keys_19:
        MOVS     R0,#+4
        STR      R0,[R9, #+16]
//  824 
//  825         /* All modes have 128-bit tags, except CCM_8 (ciphersuite flag) */
//  826         taglen = transform->ciphersuite_info->flags &
//  827                   MBEDTLS_CIPHERSUITE_SHORT_TAG ? 8 : 16;
??mbedtls_ssl_derive_keys_20:
        LDR      R0,[R9, #+0]
        LDRB     R0,[R0, #+28]
        LSLS     R0,R0,#+30
        BPL.N    ??mbedtls_ssl_derive_keys_21
        MOVS     R1,#+8
        B.N      ??mbedtls_ssl_derive_keys_22
??mbedtls_ssl_derive_keys_21:
        MOVS     R1,#+16
//  828 
//  829 
//  830         /* Minimum length of encrypted record */
//  831         explicit_ivlen = transform->ivlen - transform->fixed_ivlen;
//  832         transform->minlen = explicit_ivlen + taglen;
??mbedtls_ssl_derive_keys_22:
        MOVS     R2,#+12
        LDR      R0,[R9, #+16]
        SUBS     R2,R2,R0
        ADDS     R1,R1,R2
        STR      R1,[R9, #+8]
//  833     }
//  834     else
//  835     {
//  836         /* Initialize HMAC contexts */
//  837         if( ( ret = mbedtls_md_setup( &transform->md_ctx_enc, md_info, 1 ) ) != 0 ||
//  838             ( ret = mbedtls_md_setup( &transform->md_ctx_dec, md_info, 1 ) ) != 0 )
//  839         {
//  840             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_setup", ret );
//  841             return( ret );
//  842         }
//  843 
//  844         /* Get MAC length */
//  845         mac_key_len = mbedtls_md_get_size( md_info );
//  846         transform->maclen = mac_key_len;
//  847 
//  848 #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
//  849         /*
//  850          * If HMAC is to be truncated, we shall keep the leftmost bytes,
//  851          * (rfc 6066 page 13 or rfc 2104 section 4),
//  852          * so we only need to adjust the length here.
//  853          */
//  854         if( session->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )
//  855         {
//  856             transform->maclen = MBEDTLS_SSL_TRUNCATED_HMAC_LEN;
//  857 
//  858 #if defined(MBEDTLS_SSL_TRUNCATED_HMAC_COMPAT)
//  859             /* Fall back to old, non-compliant version of the truncated
//  860              * HMAC implementation which also truncates the key
//  861              * (Mbed TLS versions from 1.3 to 2.6.0) */
//  862             mac_key_len = transform->maclen;
//  863 #endif
//  864         }
//  865 #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
//  866 
//  867         /* IV length */
//  868         transform->ivlen = cipher_info->iv_size;
//  869 
//  870         /* Minimum length */
//  871         if( cipher_info->mode == MBEDTLS_MODE_STREAM )
//  872             transform->minlen = transform->maclen;
//  873         else
//  874         {
//  875             /*
//  876              * GenericBlockCipher:
//  877              * 1. if EtM is in use: one block plus MAC
//  878              *    otherwise: * first multiple of blocklen greater than maclen
//  879              * 2. IV except for SSL3 and TLS 1.0
//  880              */
//  881 #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
//  882             if( session->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED )
//  883             {
//  884                 transform->minlen = transform->maclen
//  885                                   + cipher_info->block_size;
//  886             }
//  887             else
//  888 #endif
//  889             {
//  890                 transform->minlen = transform->maclen
//  891                                   + cipher_info->block_size
//  892                                   - transform->maclen % cipher_info->block_size;
//  893             }
//  894 
//  895 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1)
//  896             if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ||
//  897                 ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_1 )
//  898                 ; /* No need to adjust minlen */
//  899             else
//  900 #endif
//  901 #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
//  902             if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_2 ||
//  903                 ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
//  904             {
//  905                 transform->minlen += transform->ivlen;
//  906             }
//  907             else
//  908 #endif
//  909             {
//  910                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
//  911                 return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
//  912             }
//  913         }
//  914     }
//  915 
//  916     MBEDTLS_SSL_DEBUG_MSG( 3, ( "keylen: %d, minlen: %d, ivlen: %d, maclen: %d",
//  917                    transform->keylen, transform->minlen, transform->ivlen,
//  918                    transform->maclen ) );
??mbedtls_ssl_derive_keys_23:
        LDR      R0,[R9, #+20]
        STR      R0,[SP, #+16]
        LDR      R0,[R9, #+12]
        STR      R0,[SP, #+12]
        LDR      R0,[R9, #+8]
        STR      R0,[SP, #+8]
        LDR      R0,[R9, #+4]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable14
        STR      R0,[SP, #+0]
        MOVW     R3,#+918
        MOV      R2,R10
        MOVS     R1,#+3
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
//  919 
//  920     /*
//  921      * Finally setup the cipher contexts, IVs and MAC secrets.
//  922      */
//  923 #if defined(MBEDTLS_SSL_CLI_C)
//  924     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
        LDR      R0,[R7, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        ADD      R0,SP,#+60
        ADD      R0,R0,R4, LSL #+1
        BMI.W    ??mbedtls_ssl_derive_keys_24
//  925     {
//  926         key1 = keyblk + mac_key_len * 2;
        STR      R0,[SP, #+8]
//  927         key2 = keyblk + mac_key_len * 2 + transform->keylen;
        ADD      R0,SP,#+60
        ADD      R0,R0,R4, LSL #+1
        LDR      R1,[R9, #+4]
        ADDS     R6,R0,R1
//  928 
//  929         mac_enc = keyblk;
        ADD      R0,SP,#+60
        STR      R0,[SP, #+4]
//  930         mac_dec = keyblk + mac_key_len;
        ADD      R0,R0,R4
        STR      R0,[SP, #+0]
//  931 
//  932         /*
//  933          * This is not used in TLS v1.1.
//  934          */
//  935         iv_copy_len = ( transform->fixed_ivlen ) ?
//  936                             transform->fixed_ivlen : transform->ivlen;
        LDR      R0,[R9, #+16]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_derive_keys_25
        MOV      R11,R0
        B.N      ??mbedtls_ssl_derive_keys_26
??mbedtls_ssl_derive_keys_18:
        MOVS     R2,#+1
        MOV      R1,R6
        ADD      R0,R9,#+56
          CFI FunCall mbedtls_md_setup
        BL       mbedtls_md_setup
        MOVS     R4,R0
        BNE.N    ??mbedtls_ssl_derive_keys_27
        MOVS     R2,#+1
        MOV      R1,R6
        ADD      R0,R9,#+68
          CFI FunCall mbedtls_md_setup
        BL       mbedtls_md_setup
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_derive_keys_28
??mbedtls_ssl_derive_keys_27:
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable14_1
        STR      R0,[SP, #+0]
        MOV      R3,#+840
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
        Nop      
        DATA
??mbedtls_ssl_derive_keys_0:
        DATA8
        DC8      "prf"
        THUMB
??mbedtls_ssl_derive_keys_28:
        MOV      R0,R6
          CFI FunCall mbedtls_md_get_size
        BL       mbedtls_md_get_size
        MOV      R4,R0
        STR      R4,[R9, #+20]
        LDR      R0,[R8, #+116]
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_derive_keys_29
        MOVS     R0,#+10
        STR      R0,[R9, #+20]
??mbedtls_ssl_derive_keys_29:
        LDR      R0,[R5, #+12]
        STR      R0,[R9, #+12]
        LDRB     R0,[R5, #+1]
        CMP      R0,#+7
        BNE.N    ??mbedtls_ssl_derive_keys_30
        LDR      R0,[R9, #+20]
        STR      R0,[R9, #+8]
        B.N      ??mbedtls_ssl_derive_keys_23
??mbedtls_ssl_derive_keys_30:
        LDR      R0,[R8, #+120]
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_derive_keys_31
        LDR      R1,[R9, #+20]
        LDR      R0,[R5, #+20]
        ADDS     R1,R0,R1
        STR      R1,[R9, #+8]
        B.N      ??mbedtls_ssl_derive_keys_32
??mbedtls_ssl_derive_keys_31:
        LDR      R0,[R5, #+20]
        MOV      R1,R0
        LDR      R2,[R9, #+20]
        UDIV     R2,R2,R0
        MLA      R0,R0,R2,R1
        STR      R0,[R9, #+8]
??mbedtls_ssl_derive_keys_32:
        LDR      R0,[R7, #+20]
        CMP      R0,#+0
        BEQ.W    ??mbedtls_ssl_derive_keys_23
        CMP      R0,#+1
        BEQ.W    ??mbedtls_ssl_derive_keys_23
        CMP      R0,#+2
        BEQ.N    ??mbedtls_ssl_derive_keys_33
        CMP      R0,#+3
        BNE.N    ??mbedtls_ssl_derive_keys_34
??mbedtls_ssl_derive_keys_33:
        LDR      R1,[R9, #+8]
        LDR      R0,[R9, #+12]
        ADDS     R1,R0,R1
        STR      R1,[R9, #+8]
        B.N      ??mbedtls_ssl_derive_keys_23
??mbedtls_ssl_derive_keys_34:
        LDR.W    R0,??DataTable13_16
        STR      R0,[SP, #+0]
        MOVW     R3,#+910
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.N    R0,??DataTable12_1  ;; 0xffff9400
        B.N      ??mbedtls_ssl_derive_keys_2
??mbedtls_ssl_derive_keys_25:
        LDR      R11,[R9, #+12]
//  937         memcpy( transform->iv_enc, key2 + transform->keylen,  iv_copy_len );
??mbedtls_ssl_derive_keys_26:
        MOV      R2,R11
        LDR      R0,[R9, #+4]
        ADDS     R1,R6,R0
        ADD      R0,R9,#+24
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  938         memcpy( transform->iv_dec, key2 + transform->keylen + iv_copy_len,
//  939                 iv_copy_len );
        MOV      R2,R11
        LDR      R0,[R9, #+4]
        ADD      R0,R6,R0
        ADD      R1,R0,R11
        ADD      R0,R9,#+40
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  940     }
        B.N      ??mbedtls_ssl_derive_keys_35
//  941     else
//  942 #endif /* MBEDTLS_SSL_CLI_C */
//  943 #if defined(MBEDTLS_SSL_SRV_C)
//  944     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
//  945     {
//  946         key1 = keyblk + mac_key_len * 2 + transform->keylen;
??mbedtls_ssl_derive_keys_24:
        LDR      R1,[R9, #+4]
        ADD      R0,R0,R1
        STR      R0,[SP, #+8]
//  947         key2 = keyblk + mac_key_len * 2;
        ADD      R0,SP,#+60
        ADD      R6,R0,R4, LSL #+1
//  948 
//  949         mac_enc = keyblk + mac_key_len;
        ADD      R0,R0,R4
        STR      R0,[SP, #+4]
//  950         mac_dec = keyblk;
        ADD      R0,SP,#+60
        STR      R0,[SP, #+0]
//  951 
//  952         /*
//  953          * This is not used in TLS v1.1.
//  954          */
//  955         iv_copy_len = ( transform->fixed_ivlen ) ?
//  956                             transform->fixed_ivlen : transform->ivlen;
        LDR      R0,[R9, #+16]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_derive_keys_36
        MOV      R11,R0
        B.N      ??mbedtls_ssl_derive_keys_37
??mbedtls_ssl_derive_keys_36:
        LDR      R11,[R9, #+12]
//  957         memcpy( transform->iv_dec, key1 + transform->keylen,  iv_copy_len );
??mbedtls_ssl_derive_keys_37:
        MOV      R2,R11
        LDR      R0,[SP, #+8]
        LDR      R1,[R9, #+4]
        ADD      R1,R0,R1
        ADD      R0,R9,#+40
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  958         memcpy( transform->iv_enc, key1 + transform->keylen + iv_copy_len,
//  959                 iv_copy_len );
        MOV      R2,R11
        LDR      R0,[SP, #+8]
        LDR      R1,[R9, #+4]
        ADD      R0,R0,R1
        ADD      R1,R0,R11
        ADD      R0,R9,#+24
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  960     }
//  961     else
//  962 #endif /* MBEDTLS_SSL_SRV_C */
//  963     {
//  964         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
//  965         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
//  966     }
//  967 
//  968 #if defined(MBEDTLS_SSL_PROTO_SSL3)
//  969     if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
//  970     {
//  971         if( mac_key_len > sizeof transform->mac_enc )
//  972         {
//  973             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
//  974             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
//  975         }
//  976 
//  977         memcpy( transform->mac_enc, mac_enc, mac_key_len );
//  978         memcpy( transform->mac_dec, mac_dec, mac_key_len );
//  979     }
//  980     else
//  981 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
//  982 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ 
//  983     defined(MBEDTLS_SSL_PROTO_TLS1_2)
//  984     if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 )
??mbedtls_ssl_derive_keys_35:
        LDR      R0,[R7, #+20]
        CMP      R0,#+1
        BLT.N    ??mbedtls_ssl_derive_keys_38
//  985     {
//  986         /* For HMAC-based ciphersuites, initialize the HMAC transforms.
//  987            For AEAD-based ciphersuites, there is nothing to do here. */
//  988         if( mac_key_len != 0 )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_derive_keys_39
//  989         {
//  990             mbedtls_md_hmac_starts( &transform->md_ctx_enc, mac_enc, mac_key_len );
        MOV      R2,R4
        LDR      R1,[SP, #+4]
        ADD      R0,R9,#+56
          CFI FunCall mbedtls_md_hmac_starts
        BL       mbedtls_md_hmac_starts
//  991             mbedtls_md_hmac_starts( &transform->md_ctx_dec, mac_dec, mac_key_len );
        MOV      R2,R4
        LDR      R1,[SP, #+0]
        ADD      R0,R9,#+68
          CFI FunCall mbedtls_md_hmac_starts
        BL       mbedtls_md_hmac_starts
//  992         }
//  993     }
//  994     else
//  995 #endif
//  996     {
//  997         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
//  998         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
//  999     }
// 1000 
// 1001 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
// 1002     if( mbedtls_ssl_hw_record_init != NULL )
// 1003     {
// 1004         int ret = 0;
// 1005 
// 1006         MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_init()" ) );
// 1007 
// 1008         if( ( ret = mbedtls_ssl_hw_record_init( ssl, key1, key2, transform->keylen,
// 1009                                         transform->iv_enc, transform->iv_dec,
// 1010                                         iv_copy_len,
// 1011                                         mac_enc, mac_dec,
// 1012                                         mac_key_len ) ) != 0 )
// 1013         {
// 1014             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_init", ret );
// 1015             return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
// 1016         }
// 1017     }
// 1018 #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
// 1019 
// 1020 #if defined(MBEDTLS_SSL_EXPORT_KEYS)
// 1021     if( ssl->conf->f_export_keys != NULL )
??mbedtls_ssl_derive_keys_39:
        LDR      R0,[R7, #+0]
        LDR      R0,[R0, #+92]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_derive_keys_40
// 1022     {
// 1023         ssl->conf->f_export_keys( ssl->conf->p_export_keys,
// 1024                                   session->master, keyblk,
// 1025                                   mac_key_len, transform->keylen,
// 1026                                   iv_copy_len );
        STR      R11,[SP, #+4]
        LDR      R0,[R9, #+4]
        STR      R0,[SP, #+0]
        MOV      R3,R4
        ADD      R2,SP,#+60
        ADD      R1,R8,#+44
        LDR      R0,[R7, #+0]
        LDR      R0,[R0, #+96]
        LDR      R4,[R7, #+0]
        LDR      R4,[R4, #+92]
          CFI FunCall
        BLX      R4
// 1027     }
// 1028 #endif
// 1029 
// 1030     if( ( ret = mbedtls_cipher_setup( &transform->cipher_ctx_enc,
// 1031                                  cipher_info ) ) != 0 )
??mbedtls_ssl_derive_keys_40:
        MOV      R1,R5
        ADD      R0,R9,#+80
          CFI FunCall mbedtls_cipher_setup
        BL       mbedtls_cipher_setup
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_derive_keys_41
// 1032     {
// 1033         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setup", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable14_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+1033
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 1034         return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
// 1035     }
??mbedtls_ssl_derive_keys_38:
        LDR.W    R0,??DataTable13_16
        STR      R0,[SP, #+0]
        MOVW     R3,#+997
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.N    R0,??DataTable12_1  ;; 0xffff9400
        B.N      ??mbedtls_ssl_derive_keys_2
// 1036 
// 1037     if( ( ret = mbedtls_cipher_setup( &transform->cipher_ctx_dec,
// 1038                                  cipher_info ) ) != 0 )
??mbedtls_ssl_derive_keys_41:
        MOV      R1,R5
        ADD      R0,R9,#+144
          CFI FunCall mbedtls_cipher_setup
        BL       mbedtls_cipher_setup
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_derive_keys_42
// 1039     {
// 1040         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setup", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable14_2
        STR      R0,[SP, #+0]
        MOV      R3,#+1040
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 1041         return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
// 1042     }
// 1043 
// 1044     if( ( ret = mbedtls_cipher_setkey( &transform->cipher_ctx_enc, key1,
// 1045                                cipher_info->key_bitlen,
// 1046                                MBEDTLS_ENCRYPT ) ) != 0 )
??mbedtls_ssl_derive_keys_42:
        MOVS     R3,#+1
        LDR      R2,[R5, #+4]
        LDR      R1,[SP, #+8]
        ADD      R0,R9,#+80
          CFI FunCall mbedtls_cipher_setkey
        BL       mbedtls_cipher_setkey
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_derive_keys_43
// 1047     {
// 1048         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setkey", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable14_3
        STR      R0,[SP, #+0]
        MOV      R3,#+1048
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 1049         return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
// 1050     }
// 1051 
// 1052     if( ( ret = mbedtls_cipher_setkey( &transform->cipher_ctx_dec, key2,
// 1053                                cipher_info->key_bitlen,
// 1054                                MBEDTLS_DECRYPT ) ) != 0 )
??mbedtls_ssl_derive_keys_43:
        MOVS     R3,#+0
        LDR      R2,[R5, #+4]
        MOV      R1,R6
        ADD      R0,R9,#+144
          CFI FunCall mbedtls_cipher_setkey
        BL       mbedtls_cipher_setkey
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_derive_keys_44
// 1055     {
// 1056         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setkey", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable14_3
        STR      R0,[SP, #+0]
        MOV      R3,#+1056
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 1057         return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
// 1058     }
// 1059 
// 1060 #if defined(MBEDTLS_CIPHER_MODE_CBC)
// 1061     if( cipher_info->mode == MBEDTLS_MODE_CBC )
??mbedtls_ssl_derive_keys_44:
        LDRB     R0,[R5, #+1]
        CMP      R0,#+2
        BNE.N    ??mbedtls_ssl_derive_keys_45
// 1062     {
// 1063         if( ( ret = mbedtls_cipher_set_padding_mode( &transform->cipher_ctx_enc,
// 1064                                              MBEDTLS_PADDING_NONE ) ) != 0 )
        MOVS     R1,#+4
        ADD      R0,R9,#+80
          CFI FunCall mbedtls_cipher_set_padding_mode
        BL       mbedtls_cipher_set_padding_mode
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_derive_keys_46
// 1065         {
// 1066             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_set_padding_mode", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable14_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+1066
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 1067             return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
// 1068         }
// 1069 
// 1070         if( ( ret = mbedtls_cipher_set_padding_mode( &transform->cipher_ctx_dec,
// 1071                                              MBEDTLS_PADDING_NONE ) ) != 0 )
??mbedtls_ssl_derive_keys_46:
        MOVS     R1,#+4
        ADD      R0,R9,#+144
          CFI FunCall mbedtls_cipher_set_padding_mode
        BL       mbedtls_cipher_set_padding_mode
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_derive_keys_45
// 1072         {
// 1073             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_set_padding_mode", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable14_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+1073
        MOV      R2,R10
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 1074             return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_derive_keys_2
// 1075         }
// 1076     }
// 1077 #endif /* MBEDTLS_CIPHER_MODE_CBC */
// 1078 
// 1079     mbedtls_platform_zeroize( keyblk, sizeof( keyblk ) );
??mbedtls_ssl_derive_keys_45:
        MOV      R1,#+256
        ADD      R0,SP,#+60
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 1080 
// 1081 #if defined(MBEDTLS_ZLIB_SUPPORT)
// 1082     // Initialize compression
// 1083     //
// 1084     if( session->compression == MBEDTLS_SSL_COMPRESS_DEFLATE )
// 1085     {
// 1086         if( ssl->compress_buf == NULL )
// 1087         {
// 1088             MBEDTLS_SSL_DEBUG_MSG( 3, ( "Allocating compression buffer" ) );
// 1089             ssl->compress_buf = mbedtls_calloc( 1, MBEDTLS_SSL_COMPRESS_BUFFER_LEN );
// 1090             if( ssl->compress_buf == NULL )
// 1091             {
// 1092                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed",
// 1093                                     MBEDTLS_SSL_COMPRESS_BUFFER_LEN ) );
// 1094                 return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
// 1095             }
// 1096         }
// 1097 
// 1098         MBEDTLS_SSL_DEBUG_MSG( 3, ( "Initializing zlib states" ) );
// 1099 
// 1100         memset( &transform->ctx_deflate, 0, sizeof( transform->ctx_deflate ) );
// 1101         memset( &transform->ctx_inflate, 0, sizeof( transform->ctx_inflate ) );
// 1102 
// 1103         if( deflateInit( &transform->ctx_deflate,
// 1104                          Z_DEFAULT_COMPRESSION )   != Z_OK ||
// 1105             inflateInit( &transform->ctx_inflate ) != Z_OK )
// 1106         {
// 1107             MBEDTLS_SSL_DEBUG_MSG( 1, ( "Failed to initialize compression" ) );
// 1108             return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
// 1109         }
// 1110     }
// 1111 #endif /* MBEDTLS_ZLIB_SUPPORT */
// 1112 
// 1113     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= derive keys" ) );
        LDR.W    R0,??DataTable14_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+1113
        MOV      R2,R10
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1114 
// 1115     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_derive_keys_2:
        ADD      SP,SP,#+380
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
// 1116 }
          CFI EndBlock cfiBlock22
// 1117 
// 1118 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 1119 void ssl_calc_verify_ssl( mbedtls_ssl_context *ssl, unsigned char hash[36] )
// 1120 {
// 1121     mbedtls_md5_context md5;
// 1122     mbedtls_sha1_context sha1;
// 1123     unsigned char pad_1[48];
// 1124     unsigned char pad_2[48];
// 1125 
// 1126     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify ssl" ) );
// 1127 
// 1128     mbedtls_md5_init( &md5 );
// 1129     mbedtls_sha1_init( &sha1 );
// 1130 
// 1131     mbedtls_md5_clone( &md5, &ssl->handshake->fin_md5 );
// 1132     mbedtls_sha1_clone( &sha1, &ssl->handshake->fin_sha1 );
// 1133 
// 1134     memset( pad_1, 0x36, 48 );
// 1135     memset( pad_2, 0x5C, 48 );
// 1136 
// 1137     mbedtls_md5_update_ret( &md5, ssl->session_negotiate->master, 48 );
// 1138     mbedtls_md5_update_ret( &md5, pad_1, 48 );
// 1139     mbedtls_md5_finish_ret( &md5, hash );
// 1140 
// 1141     mbedtls_md5_starts_ret( &md5 );
// 1142     mbedtls_md5_update_ret( &md5, ssl->session_negotiate->master, 48 );
// 1143     mbedtls_md5_update_ret( &md5, pad_2, 48 );
// 1144     mbedtls_md5_update_ret( &md5, hash,  16 );
// 1145     mbedtls_md5_finish_ret( &md5, hash );
// 1146 
// 1147     mbedtls_sha1_update_ret( &sha1, ssl->session_negotiate->master, 48 );
// 1148     mbedtls_sha1_update_ret( &sha1, pad_1, 40 );
// 1149     mbedtls_sha1_finish_ret( &sha1, hash + 16 );
// 1150 
// 1151     mbedtls_sha1_starts_ret( &sha1 );
// 1152     mbedtls_sha1_update_ret( &sha1, ssl->session_negotiate->master, 48 );
// 1153     mbedtls_sha1_update_ret( &sha1, pad_2, 40 );
// 1154     mbedtls_sha1_update_ret( &sha1, hash + 16, 20 );
// 1155     mbedtls_sha1_finish_ret( &sha1, hash + 16 );
// 1156 
// 1157     MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 36 );
// 1158     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
// 1159 
// 1160     mbedtls_md5_free(  &md5  );
// 1161     mbedtls_sha1_free( &sha1 );
// 1162 
// 1163     return;
// 1164 }
// 1165 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
// 1166 
// 1167 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function ssl_calc_verify_tls
        THUMB
// 1168 void ssl_calc_verify_tls( mbedtls_ssl_context *ssl, unsigned char hash[36] )
// 1169 {
ssl_calc_verify_tls:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+192
          CFI CFA R13+208
        MOV      R4,R0
        MOV      R6,R1
// 1170     mbedtls_md5_context md5;
// 1171     mbedtls_sha1_context sha1;
// 1172 
// 1173     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify tls" ) );
        LDR.N    R5,??DataTable12
        LDR.W    R0,??DataTable14_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+1173
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1174 
// 1175     mbedtls_md5_init( &md5 );
        ADD      R0,SP,#+104
          CFI FunCall mbedtls_md5_init
        BL       mbedtls_md5_init
// 1176     mbedtls_sha1_init( &sha1 );
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_sha1_init
        BL       mbedtls_sha1_init
// 1177 
// 1178     mbedtls_md5_clone( &md5, &ssl->handshake->fin_md5 );
        LDR      R0,[R4, #+60]
        ADD      R1,R0,#+592
        ADD      R0,SP,#+104
          CFI FunCall mbedtls_md5_clone
        BL       mbedtls_md5_clone
// 1179     mbedtls_sha1_clone( &sha1, &ssl->handshake->fin_sha1 );
        LDR      R0,[R4, #+60]
        ADD      R1,R0,#+680
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_sha1_clone
        BL       mbedtls_sha1_clone
// 1180 
// 1181      mbedtls_md5_finish_ret( &md5,  hash );
        MOV      R1,R6
        ADD      R0,SP,#+104
          CFI FunCall mbedtls_md5_finish_ret
        BL       mbedtls_md5_finish_ret
// 1182     mbedtls_sha1_finish_ret( &sha1, hash + 16 );
        ADD      R1,R6,#+16
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_sha1_finish_ret
        BL       mbedtls_sha1_finish_ret
// 1183 
// 1184     MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 36 );
        MOVS     R0,#+36
        STR      R0,[SP, #+8]
        STR      R6,[SP, #+4]
        LDR.W    R0,??DataTable14_7
        STR      R0,[SP, #+0]
        MOV      R3,#+1184
        MOV      R2,R5
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1185     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
        LDR.W    R0,??DataTable14_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+1185
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1186 
// 1187     mbedtls_md5_free(  &md5  );
        ADD      R0,SP,#+104
          CFI FunCall mbedtls_md5_free
        BL       mbedtls_md5_free
// 1188     mbedtls_sha1_free( &sha1 );
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_sha1_free
        BL       mbedtls_sha1_free
// 1189 
// 1190     return;
        ADD      SP,SP,#+192
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
// 1191 }
          CFI EndBlock cfiBlock23

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10:
        DATA32
        DC32     ?_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_1:
        DATA32
        DC32     ?_2
// 1192 #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 */
// 1193 
// 1194 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 1195 #if defined(MBEDTLS_SHA256_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function ssl_calc_verify_tls_sha256
        THUMB
// 1196 void ssl_calc_verify_tls_sha256( mbedtls_ssl_context *ssl, unsigned char hash[32] )
// 1197 {
ssl_calc_verify_tls_sha256:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+120
          CFI CFA R13+136
        MOV      R4,R0
        MOV      R5,R1
// 1198     mbedtls_sha256_context sha256;
// 1199 
// 1200     mbedtls_sha256_init( &sha256 );
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_sha256_init
        BL       mbedtls_sha256_init
// 1201 
// 1202     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify sha256" ) );
        LDR.N    R6,??DataTable12
        LDR.W    R0,??DataTable14_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+1202
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1203 
// 1204     mbedtls_sha256_clone( &sha256, &ssl->handshake->fin_sha256 );
        LDR      R0,[R4, #+60]
        ADD      R1,R0,#+772
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_sha256_clone
        BL       mbedtls_sha256_clone
// 1205     mbedtls_sha256_finish_ret( &sha256, hash );
        MOV      R1,R5
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_sha256_finish_ret
        BL       mbedtls_sha256_finish_ret
// 1206 
// 1207     MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 32 );
        MOVS     R0,#+32
        STR      R0,[SP, #+8]
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable14_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+1207
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1208     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
        LDR.W    R0,??DataTable14_8
        STR      R0,[SP, #+0]
        MOV      R3,#+1208
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1209 
// 1210     mbedtls_sha256_free( &sha256 );
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_sha256_free
        BL       mbedtls_sha256_free
// 1211 
// 1212     return;
        ADD      SP,SP,#+120
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
// 1213 }
          CFI EndBlock cfiBlock24
// 1214 #endif /* MBEDTLS_SHA256_C */
// 1215 
// 1216 #if defined(MBEDTLS_SHA512_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function ssl_calc_verify_tls_sha384
        THUMB
// 1217 void ssl_calc_verify_tls_sha384( mbedtls_ssl_context *ssl, unsigned char hash[48] )
// 1218 {
ssl_calc_verify_tls_sha384:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+232
          CFI CFA R13+248
        MOV      R4,R0
        MOV      R5,R1
// 1219     mbedtls_sha512_context sha512;
// 1220 
// 1221     mbedtls_sha512_init( &sha512 );
        ADD      R0,SP,#+16
          CFI FunCall mbedtls_sha512_init
        BL       mbedtls_sha512_init
// 1222 
// 1223     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify sha384" ) );
        LDR.N    R6,??DataTable12
        LDR.W    R0,??DataTable14_10
        STR      R0,[SP, #+0]
        MOVW     R3,#+1223
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1224 
// 1225     mbedtls_sha512_clone( &sha512, &ssl->handshake->fin_sha512 );
        LDR      R0,[R4, #+60]
        ADD      R1,R0,#+880
        ADD      R0,SP,#+16
          CFI FunCall mbedtls_sha512_clone
        BL       mbedtls_sha512_clone
// 1226     mbedtls_sha512_finish_ret( &sha512, hash );
        MOV      R1,R5
        ADD      R0,SP,#+16
          CFI FunCall mbedtls_sha512_finish_ret
        BL       mbedtls_sha512_finish_ret
// 1227 
// 1228     MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 48 );
        MOVS     R0,#+48
        STR      R0,[SP, #+8]
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable14_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+1228
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1229     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
        LDR.W    R0,??DataTable14_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+1229
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1230 
// 1231     mbedtls_sha512_free( &sha512 );
        ADD      R0,SP,#+16
          CFI FunCall mbedtls_sha512_free
        BL       mbedtls_sha512_free
// 1232 
// 1233     return;
        ADD      SP,SP,#+232
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
// 1234 }
          CFI EndBlock cfiBlock25

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable12:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable12_1:
        DATA32
        DC32     0xffff9400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable12_2:
        DATA32
        DC32     ?_3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable12_3:
        DATA32
        DC32     0xffff8f00
// 1235 #endif /* MBEDTLS_SHA512_C */
// 1236 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 1237 
// 1238 #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function mbedtls_ssl_psk_derive_premaster
        THUMB
// 1239 int mbedtls_ssl_psk_derive_premaster( mbedtls_ssl_context *ssl, mbedtls_key_exchange_type_t key_ex )
// 1240 {
mbedtls_ssl_psk_derive_premaster:
        PUSH     {R1-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+40
        MOV      R5,R0
// 1241     unsigned char *p = ssl->handshake->premaster;
        LDR      R0,[R5, #+60]
        ADDW     R6,R0,#+1180
// 1242     unsigned char *end = p + sizeof( ssl->handshake->premaster );
        ADD      R7,R6,#+548
// 1243     const unsigned char *psk = ssl->conf->psk;
        LDR      R0,[R5, #+0]
        LDR      R8,[R0, #+148]
// 1244     size_t psk_len = ssl->conf->psk_len;
        LDR      R9,[R0, #+152]
// 1245 
// 1246     /* If the psk callback was called, use its result */
// 1247     if( ssl->handshake->psk != NULL )
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+440]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_psk_derive_premaster_0
// 1248     {
// 1249         psk = ssl->handshake->psk;
        LDR      R0,[R5, #+60]
        LDR      R8,[R0, #+440]
// 1250         psk_len = ssl->handshake->psk_len;
        LDR      R9,[R0, #+444]
// 1251     }
// 1252 
// 1253     /*
// 1254      * PMS = struct {
// 1255      *     opaque other_secret<0..2^16-1>;
// 1256      *     opaque psk<0..2^16-1>;
// 1257      * };
// 1258      * with "other_secret" depending on the particular key exchange
// 1259      */
// 1260 #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
// 1261     if( key_ex == MBEDTLS_KEY_EXCHANGE_PSK )
??mbedtls_ssl_psk_derive_premaster_0:
        MOV      R0,R1
        CMP      R0,#+5
        BNE.N    ??mbedtls_ssl_psk_derive_premaster_1
// 1262     {
// 1263         if( end - p < 2 )
        SUBS     R0,R7,R6
        CMP      R0,#+2
        BLT.N    ??mbedtls_ssl_psk_derive_premaster_2
// 1264             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 1265 
// 1266         *(p++) = (unsigned char)( psk_len >> 8 );
        MOV      R0,R9
        LSRS     R0,R0,#+8
        STRB     R0,[R6, #+0]
// 1267         *(p++) = (unsigned char)( psk_len      );
        STRB     R9,[R6, #+1]
        ADDS     R4,R6,#+2
// 1268 
// 1269         if( end < p || (size_t)( end - p ) < psk_len )
        CMP      R7,R4
        BCC.N    ??mbedtls_ssl_psk_derive_premaster_2
        SUBS     R0,R7,R4
        CMP      R0,R9
        BCC.N    ??mbedtls_ssl_psk_derive_premaster_2
// 1270             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 1271 
// 1272         memset( p, 0, psk_len );
        MOVS     R2,#+0
        MOV      R1,R9
        MOV      R0,R4
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 1273         p += psk_len;
        ADD      R4,R4,R9
// 1274     }
// 1275     else
// 1276 #endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */
// 1277 #if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
// 1278     if( key_ex == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
// 1279     {
// 1280         /*
// 1281          * other_secret already set by the ClientKeyExchange message,
// 1282          * and is 48 bytes long
// 1283          */
// 1284         if( end - p < 2 )
// 1285             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 1286 
// 1287         *p++ = 0;
// 1288         *p++ = 48;
// 1289         p += 48;
// 1290     }
// 1291     else
// 1292 #endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
// 1293 #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
// 1294     if( key_ex == MBEDTLS_KEY_EXCHANGE_DHE_PSK )
// 1295     {
// 1296         int ret;
// 1297         size_t len;
// 1298 
// 1299         /* Write length only when we know the actual value */
// 1300         if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,
// 1301                                       p + 2, end - ( p + 2 ), &len,
// 1302                                       ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
// 1303         {
// 1304             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_calc_secret", ret );
// 1305             return( ret );
// 1306         }
// 1307         *(p++) = (unsigned char)( len >> 8 );
// 1308         *(p++) = (unsigned char)( len );
// 1309         p += len;
// 1310 
// 1311         MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: K ", &ssl->handshake->dhm_ctx.K  );
// 1312     }
// 1313     else
// 1314 #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
// 1315 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
// 1316     if( key_ex == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
// 1317     {
// 1318         int ret;
// 1319         size_t zlen;
// 1320 
// 1321         if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx, &zlen,
// 1322                                        p + 2, end - ( p + 2 ),
// 1323                                        ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
// 1324         {
// 1325             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_calc_secret", ret );
// 1326             return( ret );
// 1327         }
// 1328 
// 1329         *(p++) = (unsigned char)( zlen >> 8 );
// 1330         *(p++) = (unsigned char)( zlen      );
// 1331         p += zlen;
// 1332 
// 1333         MBEDTLS_SSL_DEBUG_MPI( 3, "ECDH: z", &ssl->handshake->ecdh_ctx.z );
// 1334     }
// 1335     else
// 1336 #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
// 1337     {
// 1338         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 1339         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 1340     }
// 1341 
// 1342     /* opaque psk<0..2^16-1>; */
// 1343     if( end - p < 2 )
??mbedtls_ssl_psk_derive_premaster_3:
        SUBS     R0,R7,R4
        CMP      R0,#+2
        BLT.N    ??mbedtls_ssl_psk_derive_premaster_2
// 1344         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 1345 
// 1346     *(p++) = (unsigned char)( psk_len >> 8 );
        MOV      R0,R9
        LSRS     R0,R0,#+8
        STRB     R0,[R4, #+0]
// 1347     *(p++) = (unsigned char)( psk_len      );
        STRB     R9,[R4, #+1]
        ADDS     R4,R4,#+2
// 1348 
// 1349     if( end < p || (size_t)( end - p ) < psk_len )
        CMP      R7,R4
        BCC.N    ??mbedtls_ssl_psk_derive_premaster_2
        SUBS     R7,R7,R4
        CMP      R7,R9
        BCS.W    ??mbedtls_ssl_psk_derive_premaster_4
// 1350         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_psk_derive_premaster_2:
        LDR.W    R0,??DataTable14_11  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_psk_derive_premaster_5
??mbedtls_ssl_psk_derive_premaster_1:
        CMP      R0,#+7
        BNE.N    ??mbedtls_ssl_psk_derive_premaster_6
        SUBS     R0,R7,R6
        CMP      R0,#+2
        BLT.N    ??mbedtls_ssl_psk_derive_premaster_2
        MOVS     R0,#+0
        STRB     R0,[R6, #+0]
        MOVS     R0,#+48
        STRB     R0,[R6, #+1]
        ADD      R4,R6,#+50
        B.N      ??mbedtls_ssl_psk_derive_premaster_3
??mbedtls_ssl_psk_derive_premaster_6:
        CMP      R0,#+6
        BNE.N    ??mbedtls_ssl_psk_derive_premaster_7
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+28]
        STR      R0,[SP, #+4]
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+24]
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+8
        ADDS     R2,R6,#+2
        SUBS     R2,R7,R2
        ADDS     R1,R6,#+2
        LDR      R0,[R5, #+60]
        ADDS     R0,R0,#+4
          CFI FunCall mbedtls_dhm_calc_secret
        BL       mbedtls_dhm_calc_secret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_psk_derive_premaster_8
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable14_12
        STR      R0,[SP, #+0]
        MOV      R3,#+1304
        LDR.N    R2,??DataTable13_25
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
        MOV      R0,R4
        B.N      ??mbedtls_ssl_psk_derive_premaster_5
??mbedtls_ssl_psk_derive_premaster_8:
        LDR      R0,[SP, #+8]
        LSRS     R0,R0,#+8
        STRB     R0,[R6, #+0]
        LDR      R0,[SP, #+8]
        STRB     R0,[R6, #+1]
        LDR      R0,[SP, #+8]
        ADD      R0,R6,R0
        ADDS     R4,R0,#+2
        LDR      R0,[R5, #+60]
        ADDS     R0,R0,#+68
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable14_13
        STR      R0,[SP, #+0]
        MOVW     R3,#+1311
        LDR.N    R2,??DataTable13_25
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_mpi
        BL       mbedtls_debug_print_mpi
        B.N      ??mbedtls_ssl_psk_derive_premaster_3
??mbedtls_ssl_psk_derive_premaster_7:
        CMP      R1,#+8
        BNE.N    ??mbedtls_ssl_psk_derive_premaster_9
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+28]
        STR      R0,[SP, #+4]
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+24]
        STR      R0,[SP, #+0]
        ADDS     R3,R6,#+2
        SUBS     R3,R7,R3
        ADDS     R2,R6,#+2
        ADD      R1,SP,#+8
        LDR      R0,[R5, #+60]
        ADDS     R0,R0,#+128
          CFI FunCall mbedtls_ecdh_calc_secret
        BL       mbedtls_ecdh_calc_secret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_psk_derive_premaster_10
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable14_14
        STR      R0,[SP, #+0]
        MOVW     R3,#+1325
        LDR.N    R2,??DataTable13_25
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
        MOV      R0,R4
        B.N      ??mbedtls_ssl_psk_derive_premaster_5
??mbedtls_ssl_psk_derive_premaster_10:
        LDR      R0,[SP, #+8]
        LSRS     R0,R0,#+8
        STRB     R0,[R6, #+0]
        LDR      R0,[SP, #+8]
        STRB     R0,[R6, #+1]
        LDR      R0,[SP, #+8]
        ADD      R0,R6,R0
        ADDS     R4,R0,#+2
        LDR      R0,[R5, #+60]
        ADD      R0,R0,#+336
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable14_15
        STR      R0,[SP, #+0]
        MOVW     R3,#+1333
        LDR.N    R2,??DataTable13_25
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_mpi
        BL       mbedtls_debug_print_mpi
        B.N      ??mbedtls_ssl_psk_derive_premaster_3
??mbedtls_ssl_psk_derive_premaster_9:
        LDR.N    R0,??DataTable13_16
        STR      R0,[SP, #+0]
        MOVW     R3,#+1338
        LDR.N    R2,??DataTable13_25
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable14_16  ;; 0xffff9400
        B.N      ??mbedtls_ssl_psk_derive_premaster_5
// 1351 
// 1352     memcpy( p, psk, psk_len );
??mbedtls_ssl_psk_derive_premaster_4:
        MOV      R2,R9
        MOV      R1,R8
        MOV      R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1353     p += psk_len;
// 1354 
// 1355     ssl->handshake->pmslen = p - ssl->handshake->premaster;
        ADD      R1,R4,R9
        LDR      R0,[R5, #+60]
        ADDW     R0,R0,#+1180
        SUBS     R1,R1,R0
        LDR      R0,[R5, #+60]
        STR      R1,[R0, #+1112]
// 1356 
// 1357     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_psk_derive_premaster_5:
        POP      {R1-R9,PC}       ;; return
// 1358 }
          CFI EndBlock cfiBlock26

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13:
        DATA32
        DC32     0xffff8100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_1:
        DATA32
        DC32     0xffff9400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_2:
        DATA32
        DC32     ?_4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_3:
        DATA32
        DC32     ?_5

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_4:
        DATA32
        DC32     ?_6

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_5:
        DATA32
        DC32     tls1_prf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_6:
        DATA32
        DC32     ssl_calc_verify_tls

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_7:
        DATA32
        DC32     ssl_calc_finished_tls

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_8:
        DATA32
        DC32     ?_8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_9:
        DATA32
        DC32     ?_9

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_10:
        DATA32
        DC32     tls_prf_sha384

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_11:
        DATA32
        DC32     ssl_calc_verify_tls_sha384

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_12:
        DATA32
        DC32     ssl_calc_finished_tls_sha384

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_13:
        DATA32
        DC32     tls_prf_sha256

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_14:
        DATA32
        DC32     ssl_calc_verify_tls_sha256

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_15:
        DATA32
        DC32     ssl_calc_finished_tls_sha256

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_16:
        DATA32
        DC32     ?_7

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_17:
        DATA32
        DC32     ?_10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_18:
        DATA32
        DC32     ?_11

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_19:
        DATA32
        DC32     ?_13

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_20:
        DATA32
        DC32     ?_14

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_21:
        DATA32
        DC32     ?_15

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_22:
        DATA32
        DC32     ?_16

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_23:
        DATA32
        DC32     ?_17

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_24:
        DATA32
        DC32     ?_18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_25:
        DATA32
        DC32     ?_0
// 1359 #endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */
// 1360 
// 1361 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 1362 /*
// 1363  * SSLv3.0 MAC functions
// 1364  */
// 1365 #define SSL_MAC_MAX_BYTES   20  /* MD-5 or SHA-1 */
// 1366 static void ssl_mac( mbedtls_md_context_t *md_ctx,
// 1367                      const unsigned char *secret,
// 1368                      const unsigned char *buf, size_t len,
// 1369                      const unsigned char *ctr, int type,
// 1370                      unsigned char out[SSL_MAC_MAX_BYTES] )
// 1371 {
// 1372     unsigned char header[11];
// 1373     unsigned char padding[48];
// 1374     int padlen;
// 1375     int md_size = mbedtls_md_get_size( md_ctx->md_info );
// 1376     int md_type = mbedtls_md_get_type( md_ctx->md_info );
// 1377 
// 1378     /* Only MD5 and SHA-1 supported */
// 1379     if( md_type == MBEDTLS_MD_MD5 )
// 1380         padlen = 48;
// 1381     else
// 1382         padlen = 40;
// 1383 
// 1384     memcpy( header, ctr, 8 );
// 1385     header[ 8] = (unsigned char)  type;
// 1386     header[ 9] = (unsigned char)( len >> 8 );
// 1387     header[10] = (unsigned char)( len      );
// 1388 
// 1389     memset( padding, 0x36, padlen );
// 1390     mbedtls_md_starts( md_ctx );
// 1391     mbedtls_md_update( md_ctx, secret,  md_size );
// 1392     mbedtls_md_update( md_ctx, padding, padlen  );
// 1393     mbedtls_md_update( md_ctx, header,  11      );
// 1394     mbedtls_md_update( md_ctx, buf,     len     );
// 1395     mbedtls_md_finish( md_ctx, out              );
// 1396 
// 1397     memset( padding, 0x5C, padlen );
// 1398     mbedtls_md_starts( md_ctx );
// 1399     mbedtls_md_update( md_ctx, secret,    md_size );
// 1400     mbedtls_md_update( md_ctx, padding,   padlen  );
// 1401     mbedtls_md_update( md_ctx, out,       md_size );
// 1402     mbedtls_md_finish( md_ctx, out                );
// 1403 }
// 1404 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
// 1405 
// 1406 #if defined(MBEDTLS_ARC4_C) || defined(MBEDTLS_CIPHER_NULL_CIPHER) ||     \ 
// 1407     ( defined(MBEDTLS_CIPHER_MODE_CBC) &&                                  \ 
// 1408       ( defined(MBEDTLS_AES_C) || defined(MBEDTLS_CAMELLIA_C) || defined(MBEDTLS_ARIA_C)) )
// 1409 #define SSL_SOME_MODES_USE_MAC
// 1410 #endif
// 1411 
// 1412 /* The function below is only used in the Lucky 13 counter-measure in
// 1413  * ssl_decrypt_buf(). These are the defines that guard the call site. */
// 1414 #if defined(SSL_SOME_MODES_USE_MAC) && \ 
// 1415     ( defined(MBEDTLS_SSL_PROTO_TLS1) || \ 
// 1416       defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ 
// 1417       defined(MBEDTLS_SSL_PROTO_TLS1_2) )
// 1418 /* This function makes sure every byte in the memory region is accessed
// 1419  * (in ascending addresses order) */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function ssl_read_memory
          CFI NoCalls
        THUMB
// 1420 static void ssl_read_memory( unsigned char *p, size_t len )
// 1421 {
ssl_read_memory:
        SUB      SP,SP,#+4
          CFI CFA R13+4
// 1422     unsigned char acc = 0;
        MOVS     R2,#+0
        CMP      R1,#+0
        B.N      ??ssl_read_memory_0
// 1423     volatile unsigned char force;
// 1424 
// 1425     for( ; len != 0; p++, len-- )
// 1426         acc ^= *p;
??ssl_read_memory_1:
        LDRB     R3,[R0], #+1
        EORS     R2,R3,R2
        SUBS     R1,R1,#+1
??ssl_read_memory_0:
        BNE.N    ??ssl_read_memory_1
// 1427 
// 1428     force = acc;
        STRB     R2,[SP, #+0]
// 1429     (void) force;
        LDRB     R0,[SP, #+0]
// 1430 }
        ADD      SP,SP,#+4
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock27
// 1431 #endif /* SSL_SOME_MODES_USE_MAC && ( TLS1 || TLS1_1 || TLS1_2 ) */
// 1432 
// 1433 /*
// 1434  * Encryption/decryption functions
// 1435  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function ssl_encrypt_buf
        THUMB
// 1436 static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
// 1437 {
ssl_encrypt_buf:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+84
          CFI CFA R13+120
        MOV      R4,R0
// 1438     mbedtls_cipher_mode_t mode;
// 1439     int auth_done = 0;
        MOVS     R5,#+0
// 1440 
// 1441     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> encrypt buf" ) );
        LDR.W    R6,??DataTable14_17
        LDR.W    R0,??DataTable14_18
        STR      R0,[SP, #+0]
        MOVW     R3,#+1441
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1442 
// 1443     if( ssl->session_out == NULL || ssl->transform_out == NULL )
        LDR      R0,[R4, #+48]
        CMP      R0,#+0
        BEQ.N    ??ssl_encrypt_buf_0
        LDR      R0,[R4, #+68]
        CMP      R0,#+0
        BNE.N    ??ssl_encrypt_buf_1
// 1444     {
// 1445         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
??ssl_encrypt_buf_0:
        LDR.W    R0,??DataTable14_19
        STR      R0,[SP, #+0]
        MOVW     R3,#+1445
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1446         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable14_16  ;; 0xffff9400
        B.N      ??ssl_encrypt_buf_2
// 1447     }
// 1448 
// 1449     mode = mbedtls_cipher_get_cipher_mode( &ssl->transform_out->cipher_ctx_enc );
??ssl_encrypt_buf_1:
        ADDS     R0,R0,#+80
          CFI FunCall mbedtls_cipher_get_cipher_mode
        BL       mbedtls_cipher_get_cipher_mode
        MOV      R7,R0
// 1450 
// 1451     MBEDTLS_SSL_DEBUG_BUF( 4, "before encrypt: output payload",
// 1452                       ssl->out_msg, ssl->out_msglen );
        LDR      R0,[R4, #+204]
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+196]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable14_20
        STR      R0,[SP, #+0]
        MOVW     R3,#+1452
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1453 
// 1454     /*
// 1455      * Add MAC before if needed
// 1456      */
// 1457 #if defined(SSL_SOME_MODES_USE_MAC)
// 1458     if( mode == MBEDTLS_MODE_STREAM ||
// 1459         ( mode == MBEDTLS_MODE_CBC
// 1460 #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
// 1461           && ssl->session_out->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED
// 1462 #endif
// 1463         ) )
        CMP      R7,#+7
        BEQ.N    ??ssl_encrypt_buf_3
        CMP      R7,#+2
        BNE.N    ??ssl_encrypt_buf_4
        LDR      R0,[R4, #+48]
        LDR      R0,[R0, #+120]
        CMP      R0,#+0
        BNE.N    ??ssl_encrypt_buf_4
// 1464     {
// 1465 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 1466         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
// 1467         {
// 1468             unsigned char mac[SSL_MAC_MAX_BYTES];
// 1469 
// 1470             ssl_mac( &ssl->transform_out->md_ctx_enc,
// 1471                       ssl->transform_out->mac_enc,
// 1472                       ssl->out_msg, ssl->out_msglen,
// 1473                       ssl->out_ctr, ssl->out_msgtype,
// 1474                       mac );
// 1475 
// 1476             memcpy( ssl->out_msg + ssl->out_msglen, mac, ssl->transform_out->maclen );
// 1477         }
// 1478         else
// 1479 #endif
// 1480 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ 
// 1481         defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 1482         if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 )
??ssl_encrypt_buf_3:
        LDR      R0,[R4, #+20]
        CMP      R0,#+1
        BLT.N    ??ssl_encrypt_buf_5
// 1483         {
// 1484             unsigned char mac[MBEDTLS_SSL_MAC_ADD];
// 1485 
// 1486             mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_ctr, 8 );
        MOVS     R2,#+8
        LDR      R1,[R4, #+180]
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 1487             mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_hdr, 3 );
        MOVS     R2,#+3
        LDR      R1,[R4, #+184]
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 1488             mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_len, 2 );
        MOVS     R2,#+2
        LDR      R1,[R4, #+188]
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 1489             mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc,
// 1490                              ssl->out_msg, ssl->out_msglen );
        LDR      R2,[R4, #+204]
        LDR      R1,[R4, #+196]
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 1491             mbedtls_md_hmac_finish( &ssl->transform_out->md_ctx_enc, mac );
        MOV      R1,SP
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
// 1492             mbedtls_md_hmac_reset( &ssl->transform_out->md_ctx_enc );
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
// 1493 
// 1494             memcpy( ssl->out_msg + ssl->out_msglen, mac, ssl->transform_out->maclen );
        LDR      R0,[R4, #+68]
        LDR      R2,[R0, #+20]
        MOV      R1,SP
        LDR      R0,[R4, #+196]
        LDR      R3,[R4, #+204]
        ADD      R0,R0,R3
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1495         }
// 1496         else
// 1497 #endif
// 1498         {
// 1499             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 1500             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 1501         }
// 1502 
// 1503         MBEDTLS_SSL_DEBUG_BUF( 4, "computed mac",
// 1504                        ssl->out_msg + ssl->out_msglen,
// 1505                        ssl->transform_out->maclen );
        LDR      R0,[R4, #+68]
        LDR      R0,[R0, #+20]
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+196]
        LDR      R1,[R4, #+204]
        ADD      R0,R0,R1
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable15
        STR      R0,[SP, #+0]
        MOVW     R3,#+1505
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1506 
// 1507         ssl->out_msglen += ssl->transform_out->maclen;
        LDR      R1,[R4, #+204]
        LDR      R0,[R4, #+68]
        LDR      R0,[R0, #+20]
        ADDS     R1,R0,R1
        STR      R1,[R4, #+204]
// 1508         auth_done++;
        MOVS     R5,#+1
// 1509     }
// 1510 #endif /* AEAD not the only option */
// 1511 
// 1512     /*
// 1513      * Encrypt
// 1514      */
// 1515 #if defined(MBEDTLS_ARC4_C) || defined(MBEDTLS_CIPHER_NULL_CIPHER)
// 1516     if( mode == MBEDTLS_MODE_STREAM )
// 1517     {
// 1518         int ret;
// 1519         size_t olen = 0;
// 1520 
// 1521         MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
// 1522                             "including %d bytes of padding",
// 1523                        ssl->out_msglen, 0 ) );
// 1524 
// 1525         if( ( ret = mbedtls_cipher_crypt( &ssl->transform_out->cipher_ctx_enc,
// 1526                                    ssl->transform_out->iv_enc,
// 1527                                    ssl->transform_out->ivlen,
// 1528                                    ssl->out_msg, ssl->out_msglen,
// 1529                                    ssl->out_msg, &olen ) ) != 0 )
// 1530         {
// 1531             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
// 1532             return( ret );
// 1533         }
// 1534 
// 1535         if( ssl->out_msglen != olen )
// 1536         {
// 1537             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 1538             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 1539         }
// 1540     }
// 1541     else
// 1542 #endif /* MBEDTLS_ARC4_C || MBEDTLS_CIPHER_NULL_CIPHER */
// 1543 #if defined(MBEDTLS_GCM_C) || \ 
// 1544     defined(MBEDTLS_CCM_C) || \ 
// 1545     defined(MBEDTLS_CHACHAPOLY_C)
// 1546     if( mode == MBEDTLS_MODE_GCM ||
// 1547         mode == MBEDTLS_MODE_CCM ||
// 1548         mode == MBEDTLS_MODE_CHACHAPOLY )
??ssl_encrypt_buf_4:
        CMP      R7,#+6
        BEQ.N    ??ssl_encrypt_buf_6
        CMP      R7,#+8
        BEQ.N    ??ssl_encrypt_buf_6
        CMP      R7,#+10
        BNE.W    ??ssl_encrypt_buf_7
// 1549     {
// 1550         int ret;
// 1551         size_t enc_msglen, olen;
// 1552         unsigned char *enc_msg;
// 1553         unsigned char add_data[13];
// 1554         unsigned char iv[12];
// 1555         mbedtls_ssl_transform *transform = ssl->transform_out;
??ssl_encrypt_buf_6:
        LDR      R7,[R4, #+68]
// 1556         unsigned char taglen = transform->ciphersuite_info->flags &
// 1557                                MBEDTLS_CIPHERSUITE_SHORT_TAG ? 8 : 16;
        LDR      R0,[R7, #+0]
        LDRB     R0,[R0, #+28]
        LSLS     R0,R0,#+30
        BPL.N    ??ssl_encrypt_buf_8
        MOV      R8,#+8
        B.N      ??ssl_encrypt_buf_9
??ssl_encrypt_buf_5:
        LDR.W    R0,??DataTable14_19
        STR      R0,[SP, #+0]
        MOVW     R3,#+1499
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable14_16  ;; 0xffff9400
        B.N      ??ssl_encrypt_buf_2
??ssl_encrypt_buf_8:
        MOV      R8,#+16
// 1558         size_t explicit_ivlen = transform->ivlen - transform->fixed_ivlen;
??ssl_encrypt_buf_9:
        LDR      R0,[R7, #+12]
        LDR      R9,[R7, #+16]
        SUB      R9,R0,R9
// 1559 
// 1560         /*
// 1561          * Prepare additional authenticated data
// 1562          */
// 1563         memcpy( add_data, ssl->out_ctr, 8 );
        MOVS     R2,#+8
        LDR      R1,[R4, #+180]
        ADD      R0,SP,#+44
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1564         add_data[8]  = ssl->out_msgtype;
        ADD      R10,SP,#+44
        LDR      R0,[R4, #+200]
        STRB     R0,[R10, #+8]
// 1565         mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
// 1566                            ssl->conf->transport, add_data + 9 );
        ADD      R3,SP,#+53
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R2,R0,#+1,#+1
        LDR      R1,[R4, #+20]
        LDR      R0,[R4, #+16]
          CFI FunCall mbedtls_ssl_write_version
        BL       mbedtls_ssl_write_version
// 1567         add_data[11] = ( ssl->out_msglen >> 8 ) & 0xFF;
        LDR      R0,[R4, #+204]
        LSRS     R0,R0,#+8
        STRB     R0,[R10, #+11]
// 1568         add_data[12] = ssl->out_msglen & 0xFF;
        LDR      R0,[R4, #+204]
        STRB     R0,[R10, #+12]
// 1569 
// 1570         MBEDTLS_SSL_DEBUG_BUF( 4, "additional data for AEAD", add_data, 13 );
        MOVS     R0,#+13
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+44
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable16
        STR      R0,[SP, #+0]
        MOVW     R3,#+1570
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1571 
// 1572         /*
// 1573          * Generate IV
// 1574          */
// 1575         if( transform->ivlen == 12 && transform->fixed_ivlen == 4 )
        LDR      R0,[R7, #+12]
        CMP      R0,#+12
        BNE.N    ??ssl_encrypt_buf_10
        LDR      R0,[R7, #+16]
        CMP      R0,#+4
        BNE.N    ??ssl_encrypt_buf_10
// 1576         {
// 1577             /* GCM and CCM: fixed || explicit (=seqnum) */
// 1578             memcpy( iv, transform->iv_enc, transform->fixed_ivlen );
        MOV      R2,R0
        ADD      R1,R7,#+24
        ADD      R0,SP,#+32
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 1579             memcpy( iv + transform->fixed_ivlen, ssl->out_ctr, 8 );
        MOVS     R2,#+8
        LDR      R1,[R4, #+180]
        ADD      R0,SP,#+32
        LDR      R3,[R7, #+16]
        ADD      R0,R0,R3
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1580             memcpy( ssl->out_iv, ssl->out_ctr, 8 );
        MOVS     R2,#+8
        LDR      R1,[R4, #+180]
        LDR      R0,[R4, #+192]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1581 
// 1582         }
// 1583         else if( transform->ivlen == 12 && transform->fixed_ivlen == 12 )
// 1584         {
// 1585             /* ChachaPoly: fixed XOR sequence number */
// 1586             unsigned char i;
// 1587 
// 1588             memcpy( iv, transform->iv_enc, transform->fixed_ivlen );
// 1589 
// 1590             for( i = 0; i < 8; i++ )
// 1591                 iv[i+4] ^= ssl->out_ctr[i];
// 1592         }
// 1593         else
// 1594         {
// 1595             /* Reminder if we ever add an AEAD mode with a different size */
// 1596             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 1597             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 1598         }
// 1599 
// 1600         MBEDTLS_SSL_DEBUG_BUF( 4, "IV used (internal)",
// 1601                                   iv, transform->ivlen );
??ssl_encrypt_buf_11:
        LDR      R0,[R7, #+12]
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+32
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable16_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+1601
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1602         MBEDTLS_SSL_DEBUG_BUF( 4, "IV used (transmitted)",
// 1603                                   ssl->out_iv, explicit_ivlen );
        STR      R9,[SP, #+8]
        LDR      R0,[R4, #+192]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable16_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+1603
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1604 
// 1605         /*
// 1606          * Fix message length with added IV
// 1607          */
// 1608         enc_msg = ssl->out_msg;
        LDR      R10,[R4, #+196]
// 1609         enc_msglen = ssl->out_msglen;
        LDR      R11,[R4, #+204]
// 1610         ssl->out_msglen += explicit_ivlen;
        MOV      R0,R11
        ADD      R9,R9,R0
        STR      R9,[R4, #+204]
// 1611 
// 1612         MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
// 1613                                     "including 0 bytes of padding",
// 1614                                     ssl->out_msglen ) );
        MOV      R0,R9
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable16_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+1614
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1615 
// 1616         /*
// 1617          * Encrypt and authenticate
// 1618          */
// 1619         if( ( ret = mbedtls_cipher_auth_encrypt( &transform->cipher_ctx_enc,
// 1620                                          iv, transform->ivlen,
// 1621                                          add_data, 13,
// 1622                                          enc_msg, enc_msglen,
// 1623                                          enc_msg, &olen,
// 1624                                          enc_msg + enc_msglen, taglen ) ) != 0 )
        STR      R8,[SP, #+24]
        ADD      R0,R10,R11
        STR      R0,[SP, #+20]
        ADD      R0,SP,#+28
        STR      R0,[SP, #+16]
        STR      R10,[SP, #+12]
        STR      R11,[SP, #+8]
        STR      R10,[SP, #+4]
        MOVS     R0,#+13
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+44
        LDR      R2,[R7, #+12]
        ADD      R1,SP,#+32
        ADD      R0,R7,#+80
          CFI FunCall mbedtls_cipher_auth_encrypt
        BL       mbedtls_cipher_auth_encrypt
        MOVS     R7,R0
        BEQ.N    ??ssl_encrypt_buf_12
// 1625         {
// 1626             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_auth_encrypt", ret );
        STR      R7,[SP, #+4]
        LDR.W    R0,??DataTable16_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+1626
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 1627             return( ret );
        MOV      R0,R7
        B.N      ??ssl_encrypt_buf_2
// 1628         }
??ssl_encrypt_buf_10:
        LDR      R0,[R7, #+12]
        CMP      R0,#+12
        BNE.N    ??ssl_encrypt_buf_13
        LDR      R0,[R7, #+16]
        CMP      R0,#+12
        BNE.N    ??ssl_encrypt_buf_13
        MOV      R2,R0
        ADD      R1,R7,#+24
        ADD      R0,SP,#+32
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R0,#+0
??ssl_encrypt_buf_14:
        CMP      R0,#+8
        BGE.N    ??ssl_encrypt_buf_11
        ADD      R1,SP,#+32
        ADD      R1,R1,R0
        LDRB     R1,[R1, #+4]
        LDR      R2,[R4, #+180]
        LDRB     R2,[R2, R0]
        EORS     R1,R2,R1
        ADD      R2,SP,#+32
        ADD      R2,R2,R0
        STRB     R1,[R2, #+4]
        ADDS     R0,R0,#+1
        B.N      ??ssl_encrypt_buf_14
??ssl_encrypt_buf_13:
        LDR.N    R0,??DataTable14_19
        STR      R0,[SP, #+0]
        MOVW     R3,#+1596
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.N    R0,??DataTable14_16  ;; 0xffff9400
        B.N      ??ssl_encrypt_buf_2
// 1629 
// 1630         if( olen != enc_msglen )
??ssl_encrypt_buf_12:
        LDR      R0,[SP, #+28]
        CMP      R0,R11
        BEQ.N    ??ssl_encrypt_buf_15
// 1631         {
// 1632             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.N    R0,??DataTable14_19
        STR      R0,[SP, #+0]
        MOV      R3,#+1632
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1633             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.N    R0,??DataTable14_16  ;; 0xffff9400
        B.N      ??ssl_encrypt_buf_2
// 1634         }
// 1635 
// 1636         ssl->out_msglen += taglen;
??ssl_encrypt_buf_15:
        LDR      R0,[R4, #+204]
        ADD      R0,R8,R0
        STR      R0,[R4, #+204]
// 1637         auth_done++;
        ADDS     R5,R5,#+1
// 1638 
// 1639         MBEDTLS_SSL_DEBUG_BUF( 4, "after encrypt: tag", enc_msg + enc_msglen, taglen );
        STR      R8,[SP, #+8]
        ADD      R0,R10,R11
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable16_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+1639
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1640     }
// 1641     else
// 1642 #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C */
// 1643 #if defined(MBEDTLS_CIPHER_MODE_CBC) &&                                    \ 
// 1644     ( defined(MBEDTLS_AES_C) || defined(MBEDTLS_CAMELLIA_C) || defined(MBEDTLS_ARIA_C) )
// 1645     if( mode == MBEDTLS_MODE_CBC )
// 1646     {
// 1647         int ret;
// 1648         unsigned char *enc_msg;
// 1649         size_t enc_msglen, padlen, olen = 0, i;
// 1650 
// 1651         padlen = ssl->transform_out->ivlen - ( ssl->out_msglen + 1 ) %
// 1652                  ssl->transform_out->ivlen;
// 1653         if( padlen == ssl->transform_out->ivlen )
// 1654             padlen = 0;
// 1655 
// 1656         for( i = 0; i <= padlen; i++ )
// 1657             ssl->out_msg[ssl->out_msglen + i] = (unsigned char) padlen;
// 1658 
// 1659         ssl->out_msglen += padlen + 1;
// 1660 
// 1661         enc_msglen = ssl->out_msglen;
// 1662         enc_msg = ssl->out_msg;
// 1663 
// 1664 #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 1665         /*
// 1666          * Prepend per-record IV for block cipher in TLS v1.1 and up as per
// 1667          * Method 1 (6.2.3.2. in RFC4346 and RFC5246)
// 1668          */
// 1669         if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
// 1670         {
// 1671             /*
// 1672              * Generate IV
// 1673              */
// 1674             ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->transform_out->iv_enc,
// 1675                                   ssl->transform_out->ivlen );
// 1676             if( ret != 0 )
// 1677                 return( ret );
// 1678 
// 1679             memcpy( ssl->out_iv, ssl->transform_out->iv_enc,
// 1680                     ssl->transform_out->ivlen );
// 1681 
// 1682             /*
// 1683              * Fix pointer positions and message length with added IV
// 1684              */
// 1685             enc_msg = ssl->out_msg;
// 1686             enc_msglen = ssl->out_msglen;
// 1687             ssl->out_msglen += ssl->transform_out->ivlen;
// 1688         }
// 1689 #endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */
// 1690 
// 1691         MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
// 1692                             "including %d bytes of IV and %d bytes of padding",
// 1693                             ssl->out_msglen, ssl->transform_out->ivlen,
// 1694                             padlen + 1 ) );
// 1695 
// 1696         if( ( ret = mbedtls_cipher_crypt( &ssl->transform_out->cipher_ctx_enc,
// 1697                                    ssl->transform_out->iv_enc,
// 1698                                    ssl->transform_out->ivlen,
// 1699                                    enc_msg, enc_msglen,
// 1700                                    enc_msg, &olen ) ) != 0 )
// 1701         {
// 1702             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
// 1703             return( ret );
// 1704         }
// 1705 
// 1706         if( enc_msglen != olen )
// 1707         {
// 1708             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 1709             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 1710         }
// 1711 
// 1712 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1)
// 1713         if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_2 )
// 1714         {
// 1715             /*
// 1716              * Save IV in SSL3 and TLS1
// 1717              */
// 1718             memcpy( ssl->transform_out->iv_enc,
// 1719                     ssl->transform_out->cipher_ctx_enc.iv,
// 1720                     ssl->transform_out->ivlen );
// 1721         }
// 1722 #endif
// 1723 
// 1724 #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
// 1725         if( auth_done == 0 )
// 1726         {
// 1727             unsigned char mac[MBEDTLS_SSL_MAC_ADD];
// 1728 
// 1729             /*
// 1730              * MAC(MAC_write_key, seq_num +
// 1731              *     TLSCipherText.type +
// 1732              *     TLSCipherText.version +
// 1733              *     length_of( (IV +) ENC(...) ) +
// 1734              *     IV + // except for TLS 1.0
// 1735              *     ENC(content + padding + padding_length));
// 1736              */
// 1737             unsigned char pseudo_hdr[13];
// 1738 
// 1739             MBEDTLS_SSL_DEBUG_MSG( 3, ( "using encrypt then mac" ) );
// 1740 
// 1741             memcpy( pseudo_hdr +  0, ssl->out_ctr, 8 );
// 1742             memcpy( pseudo_hdr +  8, ssl->out_hdr, 3 );
// 1743             pseudo_hdr[11] = (unsigned char)( ( ssl->out_msglen >> 8 ) & 0xFF );
// 1744             pseudo_hdr[12] = (unsigned char)( ( ssl->out_msglen      ) & 0xFF );
// 1745 
// 1746             MBEDTLS_SSL_DEBUG_BUF( 4, "MAC'd meta-data", pseudo_hdr, 13 );
// 1747 
// 1748             mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, pseudo_hdr, 13 );
// 1749             mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc,
// 1750                              ssl->out_iv, ssl->out_msglen );
// 1751             mbedtls_md_hmac_finish( &ssl->transform_out->md_ctx_enc, mac );
// 1752             mbedtls_md_hmac_reset( &ssl->transform_out->md_ctx_enc );
// 1753 
// 1754             memcpy( ssl->out_iv + ssl->out_msglen, mac,
// 1755                     ssl->transform_out->maclen );
// 1756 
// 1757             ssl->out_msglen += ssl->transform_out->maclen;
// 1758             auth_done++;
// 1759         }
// 1760 #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
// 1761     }
// 1762     else
// 1763 #endif /* MBEDTLS_CIPHER_MODE_CBC &&
// 1764           ( MBEDTLS_AES_C || MBEDTLS_CAMELLIA_C || MBEDTLS_ARIA_C ) */
// 1765     {
// 1766         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 1767         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 1768     }
// 1769 
// 1770     /* Make extra sure authentication was performed, exactly once */
// 1771     if( auth_done != 1 )
??ssl_encrypt_buf_16:
        CMP      R5,#+1
        BEQ.W    ??ssl_encrypt_buf_17
// 1772     {
// 1773         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.N    R0,??DataTable14_19
        STR      R0,[SP, #+0]
        MOVW     R3,#+1773
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1774         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.N    R0,??DataTable14_16  ;; 0xffff9400
        B.N      ??ssl_encrypt_buf_2
// 1775     }
??ssl_encrypt_buf_7:
        CMP      R7,#+2
        BNE.W    ??ssl_encrypt_buf_18
        MOVS     R0,#+0
        STR      R0,[SP, #+16]
        LDR      R0,[R4, #+204]
        ADDS     R0,R0,#+1
        LDR      R1,[R4, #+68]
        LDR      R1,[R1, #+12]
        MOV      R2,R1
        SUBS     R2,R2,R0
        UDIV     R7,R0,R1
        MLA      R7,R1,R7,R2
        MOV      R0,R1
        CMP      R7,R0
        BNE.N    ??ssl_encrypt_buf_19
        MOVS     R7,#+0
??ssl_encrypt_buf_19:
        MOVS     R0,#+0
        B.N      ??ssl_encrypt_buf_20
??ssl_encrypt_buf_21:
        LDR      R1,[R4, #+196]
        LDR      R2,[R4, #+204]
        ADDS     R2,R0,R2
        STRB     R7,[R1, R2]
        ADDS     R0,R0,#+1
??ssl_encrypt_buf_20:
        CMP      R7,R0
        BCS.N    ??ssl_encrypt_buf_21
        LDR      R1,[R4, #+204]
        ADDS     R0,R7,#+1
        ADDS     R1,R0,R1
        STR      R1,[R4, #+204]
        MOV      R8,R1
        LDR      R9,[R4, #+196]
        LDR      R0,[R4, #+20]
        CMP      R0,#+2
        BLT.N    ??ssl_encrypt_buf_22
        LDR      R0,[R4, #+68]
        LDR      R2,[R0, #+12]
        ADD      R1,R0,#+24
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+28]
        LDR      R3,[R4, #+0]
        LDR      R3,[R3, #+24]
          CFI FunCall
        BLX      R3
        CMP      R0,#+0
        BNE.W    ??ssl_encrypt_buf_2
        LDR      R0,[R4, #+68]
        LDR      R2,[R0, #+12]
        ADD      R1,R0,#+24
        LDR      R0,[R4, #+192]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR      R9,[R4, #+196]
        LDR      R8,[R4, #+204]
        MOV      R1,R8
        LDR      R0,[R4, #+68]
        LDR      R0,[R0, #+12]
        ADDS     R1,R0,R1
        STR      R1,[R4, #+204]
??ssl_encrypt_buf_22:
        ADDS     R7,R7,#+1
        STR      R7,[SP, #+12]
        LDR      R0,[R4, #+68]
        LDR      R0,[R0, #+12]
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+204]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable16_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+1694
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        ADD      R0,SP,#+16
        STR      R0,[SP, #+8]
        STR      R9,[SP, #+4]
        STR      R8,[SP, #+0]
        MOV      R3,R9
        LDR      R0,[R4, #+68]
        LDR      R2,[R0, #+12]
        ADD      R1,R0,#+24
        ADDS     R0,R0,#+80
          CFI FunCall mbedtls_cipher_crypt
        BL       mbedtls_cipher_crypt
        MOVS     R7,R0
        BEQ.N    ??ssl_encrypt_buf_23
        STR      R7,[SP, #+4]
        LDR.W    R0,??DataTable16_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+1702
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
        MOV      R0,R7
        B.N      ??ssl_encrypt_buf_2
??ssl_encrypt_buf_23:
        LDR      R0,[SP, #+16]
        CMP      R8,R0
        BEQ.N    ??ssl_encrypt_buf_24
        LDR.N    R0,??DataTable14_19
        STR      R0,[SP, #+0]
        MOVW     R3,#+1708
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.N    R0,??DataTable14_16  ;; 0xffff9400
        B.N      ??ssl_encrypt_buf_2
??ssl_encrypt_buf_24:
        LDR      R0,[R4, #+20]
        CMP      R0,#+2
        BGE.N    ??ssl_encrypt_buf_25
        LDR      R0,[R4, #+68]
        LDR      R2,[R0, #+12]
        ADD      R1,R0,#+120
        ADDS     R0,R0,#+24
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
??ssl_encrypt_buf_25:
        CMP      R5,#+0
        BNE.W    ??ssl_encrypt_buf_16
        LDR.W    R0,??DataTable16_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+1739
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        MOVS     R2,#+8
        LDR      R1,[R4, #+180]
        ADD      R0,SP,#+20
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+3
        LDR      R1,[R4, #+184]
        ADD      R0,SP,#+28
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        ADD      R0,SP,#+20
        LDR      R1,[R4, #+204]
        LSRS     R1,R1,#+8
        STRB     R1,[R0, #+11]
        LDR      R1,[R4, #+204]
        STRB     R1,[R0, #+12]
        MOVS     R0,#+13
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+20
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable16_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+1746
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
        MOVS     R2,#+13
        ADD      R1,SP,#+20
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
        LDR      R2,[R4, #+204]
        LDR      R1,[R4, #+192]
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
        ADD      R1,SP,#+36
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+56
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
        LDR      R0,[R4, #+68]
        LDR      R2,[R0, #+20]
        ADD      R1,SP,#+36
        LDR      R0,[R4, #+192]
        LDR      R3,[R4, #+204]
        ADD      R0,R0,R3
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR      R1,[R4, #+204]
        LDR      R0,[R4, #+68]
        LDR      R0,[R0, #+20]
        ADDS     R1,R0,R1
        STR      R1,[R4, #+204]
        MOVS     R5,#+1
        B.N      ??ssl_encrypt_buf_16
??ssl_encrypt_buf_18:
        LDR.N    R0,??DataTable14_19
        STR      R0,[SP, #+0]
        MOVW     R3,#+1766
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.N    R0,??DataTable14_16  ;; 0xffff9400
        B.N      ??ssl_encrypt_buf_2
// 1776 
// 1777     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= encrypt buf" ) );
??ssl_encrypt_buf_17:
        LDR.W    R0,??DataTable17
        STR      R0,[SP, #+0]
        MOVW     R3,#+1777
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1778 
// 1779     return( 0 );
        MOVS     R0,#+0
??ssl_encrypt_buf_2:
        ADD      SP,SP,#+84
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
// 1780 }
          CFI EndBlock cfiBlock28

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14:
        DATA32
        DC32     ?_20

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_1:
        DATA32
        DC32     ?_19

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_2:
        DATA32
        DC32     ?_21

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_3:
        DATA32
        DC32     ?_22

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_4:
        DATA32
        DC32     ?_23

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_5:
        DATA32
        DC32     ?_24

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_6:
        DATA32
        DC32     ?_25

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_7:
        DATA32
        DC32     ?_26

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_8:
        DATA32
        DC32     ?_27

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_9:
        DATA32
        DC32     ?_28

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_10:
        DATA32
        DC32     ?_29

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_11:
        DATA32
        DC32     0xffff8f00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_12:
        DATA32
        DC32     ?_30

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_13:
        DATA32
        DC32     ?_31

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_14:
        DATA32
        DC32     ?_32

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_15:
        DATA32
        DC32     ?_33

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_16:
        DATA32
        DC32     0xffff9400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_17:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_18:
        DATA32
        DC32     ?_34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_19:
        DATA32
        DC32     ?_7

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_20:
        DATA32
        DC32     ?_35
// 1781 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function ssl_decrypt_buf
        THUMB
// 1782 static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
// 1783 {
ssl_decrypt_buf:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+84
          CFI CFA R13+120
        MOV      R5,R0
// 1784     mbedtls_cipher_mode_t mode;
// 1785     int auth_done = 0;
        MOVS     R4,#+0
// 1786 #if defined(SSL_SOME_MODES_USE_MAC)
// 1787     size_t padlen = 0, correct = 1;
        MOV      R9,R4
        MOVS     R7,#+1
// 1788 #endif
// 1789 
// 1790     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> decrypt buf" ) );
        LDR.W    R8,??DataTable18
        LDR.W    R0,??DataTable17_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+1790
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1791 
// 1792     if( ssl->session_in == NULL || ssl->transform_in == NULL )
        LDR      R0,[R5, #+44]
        CMP      R0,#+0
        BEQ.N    ??ssl_decrypt_buf_0
        LDR      R0,[R5, #+64]
        CMP      R0,#+0
        BNE.N    ??ssl_decrypt_buf_1
// 1793     {
// 1794         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
??ssl_decrypt_buf_0:
        LDR.W    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+1794
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1795         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??ssl_decrypt_buf_2
// 1796     }
// 1797 
// 1798     mode = mbedtls_cipher_get_cipher_mode( &ssl->transform_in->cipher_ctx_dec );
??ssl_decrypt_buf_1:
        ADDS     R0,R0,#+144
          CFI FunCall mbedtls_cipher_get_cipher_mode
        BL       mbedtls_cipher_get_cipher_mode
// 1799 
// 1800     if( ssl->in_msglen < ssl->transform_in->minlen )
        LDR      R1,[R5, #+124]
        LDR      R2,[R5, #+64]
        LDR      R2,[R2, #+8]
        CMP      R1,R2
        BCS.N    ??ssl_decrypt_buf_3
// 1801     {
// 1802         MBEDTLS_SSL_DEBUG_MSG( 1, ( "in_msglen (%d) < minlen (%d)",
// 1803                        ssl->in_msglen, ssl->transform_in->minlen ) );
        MOV      R0,R2
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+124]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable17_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+1803
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1804         return( MBEDTLS_ERR_SSL_INVALID_MAC );
        LDR.W    R0,??DataTable17_4  ;; 0xffff8e80
        B.N      ??ssl_decrypt_buf_2
// 1805     }
// 1806 
// 1807 #if defined(MBEDTLS_ARC4_C) || defined(MBEDTLS_CIPHER_NULL_CIPHER)
// 1808     if( mode == MBEDTLS_MODE_STREAM )
// 1809     {
// 1810         int ret;
// 1811         size_t olen = 0;
// 1812 
// 1813         padlen = 0;
// 1814 
// 1815         if( ( ret = mbedtls_cipher_crypt( &ssl->transform_in->cipher_ctx_dec,
// 1816                                    ssl->transform_in->iv_dec,
// 1817                                    ssl->transform_in->ivlen,
// 1818                                    ssl->in_msg, ssl->in_msglen,
// 1819                                    ssl->in_msg, &olen ) ) != 0 )
// 1820         {
// 1821             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
// 1822             return( ret );
// 1823         }
// 1824 
// 1825         if( ssl->in_msglen != olen )
// 1826         {
// 1827             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 1828             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 1829         }
// 1830     }
// 1831     else
// 1832 #endif /* MBEDTLS_ARC4_C || MBEDTLS_CIPHER_NULL_CIPHER */
// 1833 #if defined(MBEDTLS_GCM_C) || \ 
// 1834     defined(MBEDTLS_CCM_C) || \ 
// 1835     defined(MBEDTLS_CHACHAPOLY_C)
// 1836     if( mode == MBEDTLS_MODE_GCM ||
// 1837         mode == MBEDTLS_MODE_CCM ||
// 1838         mode == MBEDTLS_MODE_CHACHAPOLY )
??ssl_decrypt_buf_3:
        CMP      R0,#+6
        BEQ.N    ??ssl_decrypt_buf_4
        CMP      R0,#+8
        BEQ.N    ??ssl_decrypt_buf_4
        CMP      R0,#+10
        BNE.W    ??ssl_decrypt_buf_5
// 1839     {
// 1840         int ret;
// 1841         size_t dec_msglen, olen;
// 1842         unsigned char *dec_msg;
// 1843         unsigned char *dec_msg_result;
// 1844         unsigned char add_data[13];
// 1845         unsigned char iv[12];
// 1846         mbedtls_ssl_transform *transform = ssl->transform_in;
??ssl_decrypt_buf_4:
        LDR      R10,[R5, #+64]
// 1847         unsigned char taglen = transform->ciphersuite_info->flags &
// 1848                                MBEDTLS_CIPHERSUITE_SHORT_TAG ? 8 : 16;
        LDR      R0,[R10, #+0]
        LDRB     R0,[R0, #+28]
        LSLS     R0,R0,#+30
        BPL.N    ??ssl_decrypt_buf_6
        MOV      R11,#+8
        B.N      ??ssl_decrypt_buf_7
??ssl_decrypt_buf_6:
        MOV      R11,#+16
// 1849         size_t explicit_iv_len = transform->ivlen - transform->fixed_ivlen;
??ssl_decrypt_buf_7:
        LDR      R1,[R10, #+12]
        LDR      R0,[R10, #+16]
        SUBS     R0,R1,R0
// 1850 
// 1851         /*
// 1852          * Compute and update sizes
// 1853          */
// 1854         if( ssl->in_msglen < explicit_iv_len + taglen )
        LDR      R1,[R5, #+124]
        ADD      R2,R11,R0
        CMP      R1,R2
        BCS.N    ??ssl_decrypt_buf_8
// 1855         {
// 1856             MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < explicit_iv_len (%d) "
// 1857                                 "+ taglen (%d)", ssl->in_msglen,
// 1858                                 explicit_iv_len, taglen ) );
        STR      R11,[SP, #+12]
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+124]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable17_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+1858
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1859             return( MBEDTLS_ERR_SSL_INVALID_MAC );
        LDR.W    R0,??DataTable17_4  ;; 0xffff8e80
        B.N      ??ssl_decrypt_buf_2
// 1860         }
// 1861         dec_msglen = ssl->in_msglen - explicit_iv_len - taglen;
??ssl_decrypt_buf_8:
        SUBS     R0,R1,R0
        SUB      R0,R0,R11
        STR      R0,[SP, #+32]
// 1862 
// 1863         dec_msg = ssl->in_msg;
        LDR      R0,[R5, #+112]
        STR      R0,[SP, #+36]
// 1864         dec_msg_result = ssl->in_msg;
        LDR      R0,[R5, #+112]
        STR      R0,[SP, #+68]
// 1865         ssl->in_msglen = dec_msglen;
        LDR      R0,[SP, #+32]
        STR      R0,[R5, #+124]
// 1866 
// 1867         /*
// 1868          * Prepare additional authenticated data
// 1869          */
// 1870         memcpy( add_data, ssl->in_ctr, 8 );
        MOVS     R2,#+8
        LDR      R1,[R5, #+96]
        ADD      R0,SP,#+52
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1871         add_data[8]  = ssl->in_msgtype;
        ADD      R4,SP,#+52
        LDR      R0,[R5, #+120]
        STRB     R0,[R4, #+8]
// 1872         mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
// 1873                            ssl->conf->transport, add_data + 9 );
        ADD      R3,SP,#+61
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R2,R0,#+1,#+1
        LDR      R1,[R5, #+20]
        LDR      R0,[R5, #+16]
          CFI FunCall mbedtls_ssl_write_version
        BL       mbedtls_ssl_write_version
// 1874         add_data[11] = ( ssl->in_msglen >> 8 ) & 0xFF;
        LDR      R0,[R5, #+124]
        LSRS     R0,R0,#+8
        STRB     R0,[R4, #+11]
// 1875         add_data[12] = ssl->in_msglen & 0xFF;
        LDR      R0,[R5, #+124]
        STRB     R0,[R4, #+12]
// 1876 
// 1877         MBEDTLS_SSL_DEBUG_BUF( 4, "additional data for AEAD", add_data, 13 );
        MOVS     R0,#+13
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+52
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable16
        STR      R0,[SP, #+0]
        MOVW     R3,#+1877
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1878 
// 1879         /*
// 1880          * Prepare IV
// 1881          */
// 1882         if( transform->ivlen == 12 && transform->fixed_ivlen == 4 )
        LDR      R0,[R10, #+12]
        CMP      R0,#+12
        BNE.N    ??ssl_decrypt_buf_9
        LDR      R0,[R10, #+16]
        CMP      R0,#+4
        BNE.N    ??ssl_decrypt_buf_9
// 1883         {
// 1884             /* GCM and CCM: fixed || explicit (transmitted) */
// 1885             memcpy( iv, transform->iv_dec, transform->fixed_ivlen );
        MOV      R2,R0
        ADD      R1,R10,#+40
        ADD      R0,SP,#+40
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 1886             memcpy( iv + transform->fixed_ivlen, ssl->in_iv, 8 );
        MOVS     R2,#+8
        LDR      R1,[R5, #+108]
        ADD      R0,SP,#+40
        LDR      R3,[R10, #+16]
        ADD      R0,R0,R3
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1887 
// 1888         }
// 1889         else if( transform->ivlen == 12 && transform->fixed_ivlen == 12 )
// 1890         {
// 1891             /* ChachaPoly: fixed XOR sequence number */
// 1892             unsigned char i;
// 1893 
// 1894             memcpy( iv, transform->iv_dec, transform->fixed_ivlen );
// 1895 
// 1896             for( i = 0; i < 8; i++ )
// 1897                 iv[i+4] ^= ssl->in_ctr[i];
// 1898         }
// 1899         else
// 1900         {
// 1901             /* Reminder if we ever add an AEAD mode with a different size */
// 1902             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 1903             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 1904         }
// 1905 
// 1906         MBEDTLS_SSL_DEBUG_BUF( 4, "IV used", iv, transform->ivlen );
??ssl_decrypt_buf_10:
        LDR      R0,[R10, #+12]
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+40
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable18_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+1906
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1907         MBEDTLS_SSL_DEBUG_BUF( 4, "TAG used", dec_msg + dec_msglen, taglen );
        STR      R11,[SP, #+8]
        LDR      R0,[SP, #+36]
        LDR      R1,[SP, #+32]
        ADD      R0,R0,R1
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable18_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+1907
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1908 
// 1909         /*
// 1910          * Decrypt and authenticate
// 1911          */
// 1912         if( ( ret = mbedtls_cipher_auth_decrypt( &ssl->transform_in->cipher_ctx_dec,
// 1913                                          iv, transform->ivlen,
// 1914                                          add_data, 13,
// 1915                                          dec_msg, dec_msglen,
// 1916                                          dec_msg_result, &olen,
// 1917                                          dec_msg + dec_msglen, taglen ) ) != 0 )
        STR      R11,[SP, #+24]
        LDR      R0,[SP, #+36]
        LDR      R1,[SP, #+32]
        ADD      R0,R0,R1
        STR      R0,[SP, #+20]
        ADD      R0,SP,#+28
        STR      R0,[SP, #+16]
        LDR      R0,[SP, #+68]
        STR      R0,[SP, #+12]
        LDR      R0,[SP, #+32]
        STR      R0,[SP, #+8]
        LDR      R0,[SP, #+36]
        STR      R0,[SP, #+4]
        MOVS     R0,#+13
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+52
        LDR      R2,[R10, #+12]
        ADD      R1,SP,#+40
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+144
          CFI FunCall mbedtls_cipher_auth_decrypt
        BL       mbedtls_cipher_auth_decrypt
        MOVS     R4,R0
        BEQ.N    ??ssl_decrypt_buf_11
// 1918         {
// 1919             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_auth_decrypt", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable18_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+1919
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 1920 
// 1921             if( ret == MBEDTLS_ERR_CIPHER_AUTH_FAILED )
        CMN      R4,#+25344
        BNE.N    ??ssl_decrypt_buf_12
// 1922                 return( MBEDTLS_ERR_SSL_INVALID_MAC );
        LDR.W    R0,??DataTable17_4  ;; 0xffff8e80
        B.N      ??ssl_decrypt_buf_2
??ssl_decrypt_buf_9:
        LDR      R0,[R10, #+12]
        CMP      R0,#+12
        BNE.N    ??ssl_decrypt_buf_13
        LDR      R0,[R10, #+16]
        CMP      R0,#+12
        BNE.N    ??ssl_decrypt_buf_13
        MOV      R2,R0
        ADD      R1,R10,#+40
        ADD      R0,SP,#+40
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOV      R0,R9
??ssl_decrypt_buf_14:
        CMP      R0,#+8
        BGE.N    ??ssl_decrypt_buf_10
        ADD      R1,SP,#+40
        ADD      R1,R1,R0
        LDRB     R1,[R1, #+4]
        LDR      R2,[R5, #+96]
        LDRB     R2,[R2, R0]
        EORS     R1,R2,R1
        ADD      R2,SP,#+40
        ADD      R2,R2,R0
        STRB     R1,[R2, #+4]
        ADDS     R0,R0,#+1
        B.N      ??ssl_decrypt_buf_14
??ssl_decrypt_buf_13:
        LDR.W    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+1902
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??ssl_decrypt_buf_2
// 1923 
// 1924             return( ret );
??ssl_decrypt_buf_12:
        MOV      R0,R4
        B.N      ??ssl_decrypt_buf_2
// 1925         }
// 1926         auth_done++;
??ssl_decrypt_buf_11:
        MOV      R4,R7
// 1927 
// 1928         if( olen != dec_msglen )
        LDR      R0,[SP, #+28]
        LDR      R1,[SP, #+32]
        CMP      R0,R1
        BEQ.W    ??ssl_decrypt_buf_15
// 1929         {
// 1930             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+1930
        MOV      R2,R8
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1931             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??ssl_decrypt_buf_2
// 1932         }
// 1933     }
// 1934     else
// 1935 #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C */
// 1936 #if defined(MBEDTLS_CIPHER_MODE_CBC) &&                                    \ 
// 1937     ( defined(MBEDTLS_AES_C) || defined(MBEDTLS_CAMELLIA_C) || defined(MBEDTLS_ARIA_C) )
// 1938     if( mode == MBEDTLS_MODE_CBC )
??ssl_decrypt_buf_5:
        CMP      R0,#+2
        BNE.W    ??ssl_decrypt_buf_16
// 1939     {
// 1940         /*
// 1941          * Decrypt and check the padding
// 1942          */
// 1943         int ret;
// 1944         unsigned char *dec_msg;
// 1945         unsigned char *dec_msg_result;
// 1946         size_t dec_msglen;
// 1947         size_t minlen = 0;
        MOV      R1,R4
// 1948         size_t olen = 0;
        MOV      R0,R1
        STR      R0,[SP, #+16]
// 1949 
// 1950         /*
// 1951          * Check immediate ciphertext sanity
// 1952          */
// 1953 #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 1954         if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
        LDR      R0,[R5, #+20]
        CMP      R0,#+2
        BLT.N    ??ssl_decrypt_buf_17
// 1955             minlen += ssl->transform_in->ivlen;
        LDR      R0,[R5, #+64]
        LDR      R1,[R0, #+12]
// 1956 #endif
// 1957 
// 1958         if( ssl->in_msglen < minlen + ssl->transform_in->ivlen ||
// 1959             ssl->in_msglen < minlen + ssl->transform_in->maclen + 1 )
??ssl_decrypt_buf_17:
        LDR      R0,[R5, #+124]
        LDR      R2,[R5, #+64]
        LDR      R2,[R2, #+12]
        ADDS     R2,R2,R1
        CMP      R0,R2
        BCC.N    ??ssl_decrypt_buf_18
        MOV      R2,R0
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+20]
        ADDS     R1,R0,R1
        ADDS     R1,R1,#+1
        CMP      R2,R1
        BCS.N    ??ssl_decrypt_buf_19
// 1960         {
// 1961             MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < max( ivlen(%d), maclen (%d) "
// 1962                                 "+ 1 ) ( + expl IV )", ssl->in_msglen,
// 1963                                 ssl->transform_in->ivlen,
// 1964                                 ssl->transform_in->maclen ) );
??ssl_decrypt_buf_18:
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+20]
        STR      R0,[SP, #+12]
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+12]
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+124]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable20
        STR      R0,[SP, #+0]
        MOVW     R3,#+1964
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1965             return( MBEDTLS_ERR_SSL_INVALID_MAC );
        LDR.W    R0,??DataTable17_4  ;; 0xffff8e80
        B.N      ??ssl_decrypt_buf_2
// 1966         }
// 1967 
// 1968         dec_msglen = ssl->in_msglen;
??ssl_decrypt_buf_19:
        MOV      R9,R2
// 1969         dec_msg = ssl->in_msg;
        LDR      R6,[R5, #+112]
// 1970         dec_msg_result = ssl->in_msg;
        MOV      R10,R6
// 1971 
// 1972         /*
// 1973          * Authenticate before decrypt if enabled
// 1974          */
// 1975 #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
// 1976         if( ssl->session_in->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED )
        LDR      R0,[R5, #+44]
        LDR      R0,[R0, #+120]
        CMP      R0,#+1
        BNE.N    ??ssl_decrypt_buf_20
// 1977         {
// 1978             unsigned char mac_expect[MBEDTLS_SSL_MAC_ADD];
// 1979             unsigned char pseudo_hdr[13];
// 1980 
// 1981             MBEDTLS_SSL_DEBUG_MSG( 3, ( "using encrypt then mac" ) );
        LDR.W    R0,??DataTable16_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+1981
        MOV      R2,R8
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 1982 
// 1983             dec_msglen -= ssl->transform_in->maclen;
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+20]
        SUB      R9,R9,R0
// 1984             ssl->in_msglen -= ssl->transform_in->maclen;
        LDR      R1,[R5, #+124]
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+20]
        SUBS     R1,R1,R0
        STR      R1,[R5, #+124]
// 1985 
// 1986             memcpy( pseudo_hdr +  0, ssl->in_ctr, 8 );
        MOVS     R2,#+8
        LDR      R1,[R5, #+96]
        ADD      R0,SP,#+20
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1987             memcpy( pseudo_hdr +  8, ssl->in_hdr, 3 );
        MOVS     R2,#+3
        LDR      R1,[R5, #+100]
        ADD      R0,SP,#+28
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1988             pseudo_hdr[11] = (unsigned char)( ( ssl->in_msglen >> 8 ) & 0xFF );
        ADD      R0,SP,#+20
        LDR      R1,[R5, #+124]
        LSRS     R1,R1,#+8
        STRB     R1,[R0, #+11]
// 1989             pseudo_hdr[12] = (unsigned char)( ( ssl->in_msglen      ) & 0xFF );
        LDR      R1,[R5, #+124]
        STRB     R1,[R0, #+12]
// 1990 
// 1991             MBEDTLS_SSL_DEBUG_BUF( 4, "MAC'd meta-data", pseudo_hdr, 13 );
        MOVS     R0,#+13
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+20
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable16_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+1991
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 1992 
// 1993             mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, pseudo_hdr, 13 );
        MOVS     R2,#+13
        ADD      R1,SP,#+20
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 1994             mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec,
// 1995                              ssl->in_iv, ssl->in_msglen );
        LDR      R2,[R5, #+124]
        LDR      R1,[R5, #+108]
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 1996             mbedtls_md_hmac_finish( &ssl->transform_in->md_ctx_dec, mac_expect );
        ADD      R1,SP,#+36
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
// 1997             mbedtls_md_hmac_reset( &ssl->transform_in->md_ctx_dec );
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
// 1998 
// 1999             MBEDTLS_SSL_DEBUG_BUF( 4, "message  mac", ssl->in_iv + ssl->in_msglen,
// 2000                                               ssl->transform_in->maclen );
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+20]
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+108]
        LDR      R1,[R5, #+124]
        ADD      R0,R0,R1
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable21
        STR      R0,[SP, #+0]
        MOV      R3,#+2000
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 2001             MBEDTLS_SSL_DEBUG_BUF( 4, "expected mac", mac_expect,
// 2002                                               ssl->transform_in->maclen );
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+20]
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+36
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable21_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+2002
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 2003 
// 2004             if( mbedtls_ssl_safer_memcmp( ssl->in_iv + ssl->in_msglen, mac_expect,
// 2005                                           ssl->transform_in->maclen ) != 0 )
        LDR      R0,[R5, #+64]
        LDR      R2,[R0, #+20]
        ADD      R1,SP,#+36
        LDR      R0,[R5, #+108]
        LDR      R3,[R5, #+124]
        ADD      R0,R0,R3
          CFI FunCall mbedtls_ssl_safer_memcmp
        BL       mbedtls_ssl_safer_memcmp
        CMP      R0,#+0
        BEQ.N    ??ssl_decrypt_buf_21
// 2006             {
// 2007                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "message mac does not match" ) );
        LDR.W    R0,??DataTable21_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2007
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2008 
// 2009                 return( MBEDTLS_ERR_SSL_INVALID_MAC );
        LDR.W    R0,??DataTable17_4  ;; 0xffff8e80
        B.N      ??ssl_decrypt_buf_2
// 2010             }
// 2011             auth_done++;
??ssl_decrypt_buf_21:
        MOV      R4,R7
// 2012         }
// 2013 #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
// 2014 
// 2015         /*
// 2016          * Check length sanity
// 2017          */
// 2018         if( ssl->in_msglen % ssl->transform_in->ivlen != 0 )
??ssl_decrypt_buf_20:
        LDR      R0,[R5, #+124]
        LDR      R1,[R5, #+64]
        LDR      R1,[R1, #+12]
        UDIV     R2,R0,R1
        MLS      R0,R1,R2,R0
        CMP      R0,#+0
        BEQ.N    ??ssl_decrypt_buf_22
// 2019         {
// 2020             MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) %% ivlen (%d) != 0",
// 2021                            ssl->in_msglen, ssl->transform_in->ivlen ) );
        MOV      R0,R1
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+124]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable21_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+2021
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2022             return( MBEDTLS_ERR_SSL_INVALID_MAC );
        LDR.W    R0,??DataTable17_4  ;; 0xffff8e80
        B.N      ??ssl_decrypt_buf_2
// 2023         }
// 2024 
// 2025 #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 2026         /*
// 2027          * Initialize for prepended IV for block cipher in TLS v1.1 and up
// 2028          */
// 2029         if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
??ssl_decrypt_buf_22:
        LDR      R0,[R5, #+20]
        CMP      R0,#+2
        BLT.N    ??ssl_decrypt_buf_23
// 2030         {
// 2031             unsigned char i;
// 2032             dec_msglen -= ssl->transform_in->ivlen;
        MOV      R0,R1
        SUB      R9,R9,R0
// 2033             ssl->in_msglen -= ssl->transform_in->ivlen;
        LDR      R1,[R5, #+124]
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+12]
        SUBS     R1,R1,R0
        STR      R1,[R5, #+124]
// 2034 
// 2035             for( i = 0; i < ssl->transform_in->ivlen; i++ )
        MOVS     R0,#+0
        B.N      ??ssl_decrypt_buf_24
// 2036                 ssl->transform_in->iv_dec[i] = ssl->in_iv[i];
??ssl_decrypt_buf_25:
        LDR      R1,[R5, #+108]
        LDRB     R1,[R1, R0]
        LDR      R2,[R5, #+64]
        ADD      R2,R2,R0
        STRB     R1,[R2, #+40]
        ADDS     R0,R0,#+1
        UXTB     R0,R0
??ssl_decrypt_buf_24:
        LDR      R1,[R5, #+64]
        LDR      R1,[R1, #+12]
        CMP      R0,R1
        BCC.N    ??ssl_decrypt_buf_25
// 2037         }
// 2038 #endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */
// 2039 
// 2040         if( ( ret = mbedtls_cipher_crypt( &ssl->transform_in->cipher_ctx_dec,
// 2041                                    ssl->transform_in->iv_dec,
// 2042                                    ssl->transform_in->ivlen,
// 2043                                    dec_msg, dec_msglen,
// 2044                                    dec_msg_result, &olen ) ) != 0 )
??ssl_decrypt_buf_23:
        ADD      R0,SP,#+16
        STR      R0,[SP, #+8]
        STR      R10,[SP, #+4]
        STR      R9,[SP, #+0]
        MOV      R3,R6
        LDR      R0,[R5, #+64]
        LDR      R2,[R0, #+12]
        ADD      R1,R0,#+40
        ADDS     R0,R0,#+144
          CFI FunCall mbedtls_cipher_crypt
        BL       mbedtls_cipher_crypt
        MOVS     R6,R0
        BEQ.N    ??ssl_decrypt_buf_26
// 2045         {
// 2046             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
        STR      R6,[SP, #+4]
        LDR.W    R0,??DataTable16_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+2046
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 2047             return( ret );
        MOV      R0,R6
        B.N      ??ssl_decrypt_buf_2
// 2048         }
// 2049 
// 2050         if( dec_msglen != olen )
??ssl_decrypt_buf_26:
        LDR      R0,[SP, #+16]
        CMP      R9,R0
        BEQ.N    ??ssl_decrypt_buf_27
// 2051         {
// 2052             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2052
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2053             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??ssl_decrypt_buf_2
// 2054         }
// 2055 
// 2056 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1)
// 2057         if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_2 )
??ssl_decrypt_buf_27:
        LDR      R0,[R5, #+20]
        CMP      R0,#+2
        BGE.N    ??ssl_decrypt_buf_28
// 2058         {
// 2059             /*
// 2060              * Save IV in SSL3 and TLS1
// 2061              */
// 2062             memcpy( ssl->transform_in->iv_dec,
// 2063                     ssl->transform_in->cipher_ctx_dec.iv,
// 2064                     ssl->transform_in->ivlen );
        LDR      R0,[R5, #+64]
        LDR      R2,[R0, #+12]
        ADD      R1,R0,#+184
        ADDS     R0,R0,#+40
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 2065         }
// 2066 #endif
// 2067 
// 2068         padlen = 1 + ssl->in_msg[ssl->in_msglen - 1];
??ssl_decrypt_buf_28:
        LDR      R0,[R5, #+112]
        LDR      R1,[R5, #+124]
        ADD      R0,R0,R1
        LDRB     R1,[R0, #-1]
        ADDS     R1,R1,#+1
// 2069 
// 2070         if( ssl->in_msglen < ssl->transform_in->maclen + padlen &&
// 2071             auth_done == 0 )
        LDR      R0,[R5, #+124]
        LDR      R2,[R5, #+64]
        LDR      R2,[R2, #+20]
        ADDS     R2,R1,R2
        CMP      R0,R2
        BCS.N    ??ssl_decrypt_buf_29
        CMP      R4,#+0
        BNE.N    ??ssl_decrypt_buf_29
// 2072         {
// 2073 #if defined(MBEDTLS_SSL_DEBUG_ALL)
// 2074             MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < maclen (%d) + padlen (%d)",
// 2075                         ssl->in_msglen, ssl->transform_in->maclen, padlen ) );
// 2076 #endif
// 2077             padlen = 0;
        MOVS     R1,#+0
// 2078             correct = 0;
        MOV      R7,R1
// 2079         }
// 2080 
// 2081 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 2082         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
// 2083         {
// 2084             if( padlen > ssl->transform_in->ivlen )
// 2085             {
// 2086 #if defined(MBEDTLS_SSL_DEBUG_ALL)
// 2087                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad padding length: is %d, "
// 2088                                     "should be no more than %d",
// 2089                                padlen, ssl->transform_in->ivlen ) );
// 2090 #endif
// 2091                 correct = 0;
// 2092             }
// 2093         }
// 2094         else
// 2095 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
// 2096 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ 
// 2097     defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 2098         if( ssl->minor_ver > MBEDTLS_SSL_MINOR_VERSION_0 )
??ssl_decrypt_buf_29:
        LDR      R0,[R5, #+20]
        CMP      R0,#+1
        BLT.N    ??ssl_decrypt_buf_30
// 2099         {
// 2100             /*
// 2101              * TLSv1+: always check the padding up to the first failure
// 2102              * and fake check up to 256 bytes of padding
// 2103              */
// 2104             size_t pad_count = 0, real_count = 1;
        MOVS     R2,#+0
        MOVS     R3,#+1
// 2105             size_t padding_idx = ssl->in_msglen - padlen;
        LDR      R6,[R5, #+124]
        SUBS     R6,R6,R1
// 2106             size_t i;
// 2107 
// 2108             /*
// 2109              * Padding is guaranteed to be incorrect if:
// 2110              *   1. padlen > ssl->in_msglen
// 2111              *
// 2112              *   2. padding_idx > MBEDTLS_SSL_IN_CONTENT_LEN +
// 2113              *                     ssl->transform_in->maclen
// 2114              *
// 2115              * In both cases we reset padding_idx to a safe value (0) to
// 2116              * prevent out-of-buffer reads.
// 2117              */
// 2118             correct &= ( padlen <= ssl->in_msglen );
        LDR      R0,[R5, #+124]
        SBCS     R0,R0,R0
        MVNS     R0,R0
        ANDS     R7,R7,R0, LSR #+31
// 2119             correct &= ( padding_idx <= MBEDTLS_SSL_IN_CONTENT_LEN +
// 2120                                        ssl->transform_in->maclen );
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+20]
        ADD      R0,R0,#+10240
        CMP      R0,R6
        SBCS     R0,R0,R0
        MVNS     R0,R0
        ANDS     R7,R7,R0, LSR #+31
        STR      R7,[SP, #+0]
// 2121 
// 2122             padding_idx *= correct;
        LDR      R0,[SP, #+0]
        MULS     R6,R0,R6
// 2123 
// 2124             for( i = 0; i < 256; i++ )
        MOV      R0,R2
??ssl_decrypt_buf_31:
        CMP      R0,#+256
        BCS.W    ??ssl_decrypt_buf_32
// 2125             {
// 2126                 real_count &= ( i < padlen );
        CMP      R0,R1
        SBCS     R7,R7,R7
        ANDS     R3,R3,R7, LSR #+31
// 2127                 pad_count += real_count *
// 2128                              ( ssl->in_msg[padding_idx + i] == padlen - 1 );
        LDR      R7,[R5, #+112]
        ADD      R12,R0,R6
        LDRB     R7,[R7, R12]
        SUB      R12,R1,#+1
        CMP      R7,R12
        BEQ.N    ??ssl_decrypt_buf_33
        MOVS     R7,#+0
        B.N      ??ssl_decrypt_buf_34
??ssl_decrypt_buf_33:
        MOVS     R7,#+1
??ssl_decrypt_buf_34:
        SMLABB   R2,R7,R3,R2
// 2129             }
        ADDS     R0,R0,#+1
        B.N      ??ssl_decrypt_buf_31
// 2130 
// 2131             correct &= ( pad_count == padlen ); /* Only 1 on correct padding */
??ssl_decrypt_buf_35:
        MOVS     R0,#+0
??ssl_decrypt_buf_36:
        LDR      R7,[SP, #+0]
        ANDS     R7,R0,R7
// 2132 
// 2133 #if defined(MBEDTLS_SSL_DEBUG_ALL)
// 2134             if( padlen > 0 && correct == 0 )
// 2135                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad padding byte detected" ) );
// 2136 #endif
// 2137             padlen &= correct * 0x1FF;
        MOV      R9,R1
        RSB      R0,R7,R7, LSL #+9
        AND      R9,R0,R9
// 2138         }
// 2139         else
// 2140 #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \ 
// 2141           MBEDTLS_SSL_PROTO_TLS1_2 */
// 2142         {
// 2143             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 2144             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 2145         }
// 2146 
// 2147         ssl->in_msglen -= padlen;
        LDR      R0,[R5, #+124]
        SUB      R0,R0,R9
        STR      R0,[R5, #+124]
// 2148     }
// 2149     else
// 2150 #endif /* MBEDTLS_CIPHER_MODE_CBC &&
// 2151           ( MBEDTLS_AES_C || MBEDTLS_CAMELLIA_C || MBEDTLS_ARIA_C ) */
// 2152     {
// 2153         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 2154         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 2155     }
// 2156 
// 2157 #if defined(MBEDTLS_SSL_DEBUG_ALL)
// 2158     MBEDTLS_SSL_DEBUG_BUF( 4, "raw buffer after decryption",
// 2159                    ssl->in_msg, ssl->in_msglen );
// 2160 #endif
// 2161 
// 2162     /*
// 2163      * Authenticate if not done yet.
// 2164      * Compute the MAC regardless of the padding result (RFC4346, CBCTIME).
// 2165      */
// 2166 #if defined(SSL_SOME_MODES_USE_MAC)
// 2167     if( auth_done == 0 )
??ssl_decrypt_buf_15:
        CMP      R4,#+0
        BNE.W    ??ssl_decrypt_buf_37
// 2168     {
// 2169         unsigned char mac_expect[MBEDTLS_SSL_MAC_ADD];
// 2170 
// 2171         ssl->in_msglen -= ssl->transform_in->maclen;
        LDR      R1,[R5, #+124]
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+20]
        SUBS     R1,R1,R0
        STR      R1,[R5, #+124]
// 2172 
// 2173         ssl->in_len[0] = (unsigned char)( ssl->in_msglen >> 8 );
        MOV      R0,R1
        LSRS     R0,R0,#+8
        LDR      R1,[R5, #+104]
        STRB     R0,[R1, #+0]
// 2174         ssl->in_len[1] = (unsigned char)( ssl->in_msglen      );
        LDR      R0,[R5, #+124]
        LDR      R1,[R5, #+104]
        STRB     R0,[R1, #+1]
// 2175 
// 2176 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 2177         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
// 2178         {
// 2179             ssl_mac( &ssl->transform_in->md_ctx_dec,
// 2180                       ssl->transform_in->mac_dec,
// 2181                       ssl->in_msg, ssl->in_msglen,
// 2182                       ssl->in_ctr, ssl->in_msgtype,
// 2183                       mac_expect );
// 2184         }
// 2185         else
// 2186 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
// 2187 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ 
// 2188         defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 2189         if( ssl->minor_ver > MBEDTLS_SSL_MINOR_VERSION_0 )
        LDR      R0,[R5, #+20]
        CMP      R0,#+1
        BLT.W    ??ssl_decrypt_buf_38
// 2190         {
// 2191             /*
// 2192              * Process MAC and always update for padlen afterwards to make
// 2193              * total time independent of padlen.
// 2194              *
// 2195              * Known timing attacks:
// 2196              *  - Lucky Thirteen (http://www.isg.rhul.ac.uk/tls/TLStiming.pdf)
// 2197              *
// 2198              * To compensate for different timings for the MAC calculation
// 2199              * depending on how much padding was removed (which is determined
// 2200              * by padlen), process extra_run more blocks through the hash
// 2201              * function.
// 2202              *
// 2203              * The formula in the paper is
// 2204              *   extra_run = ceil( (L1-55) / 64 ) - ceil( (L2-55) / 64 )
// 2205              * where L1 is the size of the header plus the decrypted message
// 2206              * plus CBC padding and L2 is the size of the header plus the
// 2207              * decrypted message. This is for an underlying hash function
// 2208              * with 64-byte blocks.
// 2209              * We use ( (Lx+8) / 64 ) to handle 'negative Lx' values
// 2210              * correctly. We round down instead of up, so -56 is the correct
// 2211              * value for our calculations instead of -55.
// 2212              *
// 2213              * Repeat the formula rather than defining a block_size variable.
// 2214              * This avoids requiring division by a variable at runtime
// 2215              * (which would be marginally less efficient and would require
// 2216              * linking an extra division function in some builds).
// 2217              */
// 2218             size_t j, extra_run = 0;
// 2219 
// 2220             /*
// 2221              * The next two sizes are the minimum and maximum values of
// 2222              * in_msglen over all padlen values.
// 2223              *
// 2224              * They're independent of padlen, since we previously did
// 2225              * in_msglen -= padlen.
// 2226              *
// 2227              * Note that max_len + maclen is never more than the buffer
// 2228              * length, as we previously did in_msglen -= maclen too.
// 2229              */
// 2230             const size_t max_len = ssl->in_msglen + padlen;
        LDR      R4,[R5, #+124]
        ADD      R4,R9,R4
// 2231             const size_t min_len = ( max_len > 256 ) ? max_len - 256 : 0;
        MOVW     R0,#+257
        CMP      R4,R0
        BCC.N    ??ssl_decrypt_buf_39
        SUB      R6,R4,#+256
        B.N      ??ssl_decrypt_buf_40
??ssl_decrypt_buf_30:
        LDR.W    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2143
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??ssl_decrypt_buf_2
??ssl_decrypt_buf_16:
        LDR.W    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2153
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??ssl_decrypt_buf_2
??ssl_decrypt_buf_39:
        MOVS     R6,#+0
// 2232 
// 2233             switch( ssl->transform_in->ciphersuite_info->mac )
??ssl_decrypt_buf_40:
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+0]
        LDRB     R0,[R0, #+9]
        CMP      R0,#+3
        BEQ.N    ??ssl_decrypt_buf_41
        CMP      R0,#+4
        BEQ.N    ??ssl_decrypt_buf_41
        CMP      R0,#+6
        BEQ.N    ??ssl_decrypt_buf_41
        CMP      R0,#+7
        BEQ.N    ??ssl_decrypt_buf_42
        B.N      ??ssl_decrypt_buf_43
// 2234             {
// 2235 #if defined(MBEDTLS_MD5_C) || defined(MBEDTLS_SHA1_C) || \ 
// 2236     defined(MBEDTLS_SHA256_C)
// 2237                 case MBEDTLS_MD_MD5:
// 2238                 case MBEDTLS_MD_SHA1:
// 2239                 case MBEDTLS_MD_SHA256:
// 2240                     /* 8 bytes of message size, 64-byte compression blocks */
// 2241                     extra_run = ( 13 + ssl->in_msglen + padlen + 8 ) / 64 -
// 2242                                 ( 13 + ssl->in_msglen          + 8 ) / 64;
??ssl_decrypt_buf_41:
        LDR      R10,[R5, #+124]
        ADD      R10,R9,R10
        ADD      R10,R10,#+21
        LSR      R10,R10,#+6
        LDR      R0,[R5, #+124]
        ADDS     R0,R0,#+21
        SUB      R10,R10,R0, LSR #+6
// 2243                     break;
// 2244 #endif
// 2245 #if defined(MBEDTLS_SHA512_C)
// 2246                 case MBEDTLS_MD_SHA384:
// 2247                     /* 16 bytes of message size, 128-byte compression blocks */
// 2248                     extra_run = ( 13 + ssl->in_msglen + padlen + 16 ) / 128 -
// 2249                                 ( 13 + ssl->in_msglen          + 16 ) / 128;
// 2250                     break;
// 2251 #endif
// 2252                 default:
// 2253                     MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 2254                     return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 2255             }
// 2256 
// 2257             extra_run &= correct * 0xFF;
??ssl_decrypt_buf_44:
        RSB      R0,R7,R7, LSL #+8
        AND      R10,R0,R10
// 2258 
// 2259             mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_ctr, 8 );
        MOVS     R2,#+8
        LDR      R1,[R5, #+96]
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 2260             mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_hdr, 3 );
        MOVS     R2,#+3
        LDR      R1,[R5, #+100]
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 2261             mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_len, 2 );
        MOVS     R2,#+2
        LDR      R1,[R5, #+104]
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 2262             mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_msg,
// 2263                              ssl->in_msglen );
        LDR      R2,[R5, #+124]
        LDR      R1,[R5, #+112]
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_update
        BL       mbedtls_md_hmac_update
// 2264             /* Make sure we access everything even when padlen > 0. This
// 2265              * makes the synchronisation requirements for just-in-time
// 2266              * Prime+Probe attacks much tighter and hopefully impractical. */
// 2267             ssl_read_memory( ssl->in_msg + ssl->in_msglen, padlen );
        MOV      R1,R9
        LDR      R0,[R5, #+112]
        LDR      R2,[R5, #+124]
        ADD      R0,R0,R2
          CFI FunCall ssl_read_memory
        BL       ssl_read_memory
// 2268             mbedtls_md_hmac_finish( &ssl->transform_in->md_ctx_dec, mac_expect );
        ADD      R1,SP,#+4
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_finish
        BL       mbedtls_md_hmac_finish
// 2269 
// 2270             /* Call mbedtls_md_process at least once due to cache attacks
// 2271              * that observe whether md_process() was called of not */
// 2272             for( j = 0; j < extra_run + 1; j++ )
        MOVS     R0,#+0
        MOV      R9,R10
        MOV      R10,R0
        B.N      ??ssl_decrypt_buf_45
??ssl_decrypt_buf_42:
        LDR      R10,[R5, #+124]
        ADD      R10,R9,R10
        ADD      R10,R10,#+29
        LSR      R10,R10,#+7
        LDR      R0,[R5, #+124]
        ADDS     R0,R0,#+29
        SUB      R10,R10,R0, LSR #+7
        B.N      ??ssl_decrypt_buf_44
??ssl_decrypt_buf_43:
        LDR.W    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2253
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??ssl_decrypt_buf_2
// 2273                 mbedtls_md_process( &ssl->transform_in->md_ctx_dec, ssl->in_msg );
??ssl_decrypt_buf_46:
        LDR      R1,[R5, #+112]
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_process
        BL       mbedtls_md_process
        ADD      R10,R10,#+1
??ssl_decrypt_buf_45:
        ADD      R0,R9,#+1
        CMP      R10,R0
        BCC.N    ??ssl_decrypt_buf_46
// 2274 
// 2275             mbedtls_md_hmac_reset( &ssl->transform_in->md_ctx_dec );
        LDR      R0,[R5, #+64]
        ADDS     R0,R0,#+68
          CFI FunCall mbedtls_md_hmac_reset
        BL       mbedtls_md_hmac_reset
// 2276 
// 2277             /* Make sure we access all the memory that could contain the MAC,
// 2278              * before we check it in the next code block. This makes the
// 2279              * synchronisation requirements for just-in-time Prime+Probe
// 2280              * attacks much tighter and hopefully impractical. */
// 2281             ssl_read_memory( ssl->in_msg + min_len,
// 2282                                  max_len - min_len + ssl->transform_in->maclen );
        SUBS     R4,R4,R6
        LDR      R0,[R5, #+64]
        LDR      R0,[R0, #+20]
        ADDS     R4,R0,R4
        MOV      R1,R4
        LDR      R0,[R5, #+112]
        ADD      R0,R0,R6
          CFI FunCall ssl_read_memory
        BL       ssl_read_memory
// 2283         }
// 2284         else
// 2285 #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \ 
// 2286               MBEDTLS_SSL_PROTO_TLS1_2 */
// 2287         {
// 2288             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 2289             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 2290         }
// 2291 
// 2292 #if defined(MBEDTLS_SSL_DEBUG_ALL)
// 2293         MBEDTLS_SSL_DEBUG_BUF( 4, "expected mac", mac_expect, ssl->transform_in->maclen );
// 2294         MBEDTLS_SSL_DEBUG_BUF( 4, "message  mac", ssl->in_msg + ssl->in_msglen,
// 2295                                ssl->transform_in->maclen );
// 2296 #endif
// 2297 
// 2298         if( mbedtls_ssl_safer_memcmp( ssl->in_msg + ssl->in_msglen, mac_expect,
// 2299                                       ssl->transform_in->maclen ) != 0 )
        LDR      R0,[R5, #+64]
        LDR      R2,[R0, #+20]
        ADD      R1,SP,#+4
        LDR      R0,[R5, #+112]
        LDR      R3,[R5, #+124]
        ADD      R0,R0,R3
          CFI FunCall mbedtls_ssl_safer_memcmp
        BL       mbedtls_ssl_safer_memcmp
        CMP      R0,#+0
        BEQ.N    ??ssl_decrypt_buf_47
// 2300         {
// 2301 #if defined(MBEDTLS_SSL_DEBUG_ALL)
// 2302             MBEDTLS_SSL_DEBUG_MSG( 1, ( "message mac does not match" ) );
// 2303 #endif
// 2304             correct = 0;
        MOVS     R0,#+0
        MOV      R7,R0
// 2305         }
// 2306         auth_done++;
??ssl_decrypt_buf_47:
        MOVS     R4,#+1
// 2307 
// 2308         /*
// 2309          * Finally check the correct flag
// 2310          */
// 2311         if( correct == 0 )
        CMP      R7,#+0
        BNE.N    ??ssl_decrypt_buf_37
// 2312             return( MBEDTLS_ERR_SSL_INVALID_MAC );
        LDR.W    R0,??DataTable17_4  ;; 0xffff8e80
        B.N      ??ssl_decrypt_buf_2
??ssl_decrypt_buf_38:
        LDR.W    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOV      R3,#+2288
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??ssl_decrypt_buf_2
// 2313     }
// 2314 #endif /* SSL_SOME_MODES_USE_MAC */
// 2315 
// 2316     /* Make extra sure authentication was performed, exactly once */
// 2317     if( auth_done != 1 )
??ssl_decrypt_buf_37:
        CMP      R4,#+1
        BEQ.N    ??ssl_decrypt_buf_48
// 2318     {
// 2319         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2319
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2320         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??ssl_decrypt_buf_2
// 2321     }
// 2322 
// 2323     if( ssl->in_msglen == 0 )
??ssl_decrypt_buf_48:
        LDR      R0,[R5, #+124]
        CMP      R0,#+0
        BNE.N    ??ssl_decrypt_buf_49
// 2324     {
// 2325 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 2326         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3
// 2327             && ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
        LDR      R0,[R5, #+20]
        CMP      R0,#+3
        BNE.N    ??ssl_decrypt_buf_50
        LDR      R0,[R5, #+120]
        CMP      R0,#+23
        BEQ.N    ??ssl_decrypt_buf_50
// 2328         {
// 2329             /* TLS v1.2 explicitly disallows zero-length messages which are not application data */
// 2330             MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid zero-length message type: %d", ssl->in_msgtype ) );
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable22
        STR      R0,[SP, #+0]
        MOVW     R3,#+2330
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2331             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable22_1  ;; 0xffff8e00
        B.N      ??ssl_decrypt_buf_2
// 2332         }
// 2333 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 2334 
// 2335         ssl->nb_zero++;
??ssl_decrypt_buf_50:
        LDR      R0,[R5, #+164]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+164]
// 2336 
// 2337         /*
// 2338          * Three or more empty messages may be a DoS attack
// 2339          * (excessive CPU consumption).
// 2340          */
// 2341         if( ssl->nb_zero > 3 )
        CMP      R0,#+4
        BLT.N    ??ssl_decrypt_buf_51
// 2342         {
// 2343             MBEDTLS_SSL_DEBUG_MSG( 1, ( "received four consecutive empty "
// 2344                                 "messages, possible DoS attack" ) );
        LDR.W    R0,??DataTable22_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2344
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2345             return( MBEDTLS_ERR_SSL_INVALID_MAC );
        LDR.W    R0,??DataTable17_4  ;; 0xffff8e80
        B.N      ??ssl_decrypt_buf_2
// 2346         }
// 2347     }
// 2348     else
// 2349         ssl->nb_zero = 0;
??ssl_decrypt_buf_49:
        MOVS     R0,#+0
        STR      R0,[R5, #+164]
// 2350 
// 2351 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 2352     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
??ssl_decrypt_buf_51:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BNE.N    ??ssl_decrypt_buf_52
// 2353     {
// 2354         ; /* in_ctr read from peer, not maintained internally */
// 2355     }
// 2356     else
// 2357 #endif
// 2358     {
// 2359         unsigned char i;
// 2360         for( i = 8; i > ssl_ep_len( ssl ); i-- )
        MOVS     R6,#+8
??ssl_decrypt_buf_53:
        MOV      R0,R5
          CFI FunCall ssl_ep_len
        BL       ssl_ep_len
        CMP      R0,R6
        BCS.N    ??ssl_decrypt_buf_54
// 2361             if( ++ssl->in_ctr[i - 1] != 0 )
        LDR      R0,[R5, #+96]
        ADD      R0,R0,R6
        LDRB     R0,[R0, #-1]
        ADDS     R0,R0,#+1
        LDR      R1,[R5, #+96]
        ADD      R1,R1,R6
        STRB     R0,[R1, #-1]
        LDR      R0,[R5, #+96]
        ADD      R0,R0,R6
        LDRB     R0,[R0, #-1]
        CMP      R0,#+0
        BNE.N    ??ssl_decrypt_buf_54
        SUBS     R6,R6,#+1
        UXTB     R6,R6
        B.N      ??ssl_decrypt_buf_53
// 2362                 break;
// 2363 
// 2364         /* The loop goes to its end iff the counter is wrapping */
// 2365         if( i == ssl_ep_len( ssl ) )
// 2366         {
// 2367             MBEDTLS_SSL_DEBUG_MSG( 1, ( "incoming message counter would wrap" ) );
// 2368             return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
// 2369         }
// 2370     }
// 2371 
// 2372     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= decrypt buf" ) );
??ssl_decrypt_buf_52:
        LDR.W    R0,??DataTable22_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+2372
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2373 
// 2374     return( 0 );
        MOVS     R0,#+0
??ssl_decrypt_buf_2:
        ADD      SP,SP,#+84
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+120
??ssl_decrypt_buf_32:
        CMP      R2,R1
        BNE.W    ??ssl_decrypt_buf_35
        MOVS     R0,#+1
        B.N      ??ssl_decrypt_buf_36
??ssl_decrypt_buf_54:
        MOV      R0,R5
          CFI FunCall ssl_ep_len
        BL       ssl_ep_len
        CMP      R6,R0
        BNE.N    ??ssl_decrypt_buf_52
        LDR.W    R0,??DataTable22_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+2367
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable23  ;; 0xffff9480
        B.N      ??ssl_decrypt_buf_2
// 2375 }
          CFI EndBlock cfiBlock29

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15:
        DATA32
        DC32     ?_36
// 2376 
// 2377 #undef MAC_NONE
// 2378 #undef MAC_PLAINTEXT
// 2379 #undef MAC_CIPHERTEXT
// 2380 
// 2381 #if defined(MBEDTLS_ZLIB_SUPPORT)
// 2382 /*
// 2383  * Compression/decompression functions
// 2384  */
// 2385 static int ssl_compress_buf( mbedtls_ssl_context *ssl )
// 2386 {
// 2387     int ret;
// 2388     unsigned char *msg_post = ssl->out_msg;
// 2389     ptrdiff_t bytes_written = ssl->out_msg - ssl->out_buf;
// 2390     size_t len_pre = ssl->out_msglen;
// 2391     unsigned char *msg_pre = ssl->compress_buf;
// 2392 
// 2393     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> compress buf" ) );
// 2394 
// 2395     if( len_pre == 0 )
// 2396         return( 0 );
// 2397 
// 2398     memcpy( msg_pre, ssl->out_msg, len_pre );
// 2399 
// 2400     MBEDTLS_SSL_DEBUG_MSG( 3, ( "before compression: msglen = %d, ",
// 2401                    ssl->out_msglen ) );
// 2402 
// 2403     MBEDTLS_SSL_DEBUG_BUF( 4, "before compression: output payload",
// 2404                    ssl->out_msg, ssl->out_msglen );
// 2405 
// 2406     ssl->transform_out->ctx_deflate.next_in = msg_pre;
// 2407     ssl->transform_out->ctx_deflate.avail_in = len_pre;
// 2408     ssl->transform_out->ctx_deflate.next_out = msg_post;
// 2409     ssl->transform_out->ctx_deflate.avail_out = MBEDTLS_SSL_OUT_BUFFER_LEN - bytes_written;
// 2410 
// 2411     ret = deflate( &ssl->transform_out->ctx_deflate, Z_SYNC_FLUSH );
// 2412     if( ret != Z_OK )
// 2413     {
// 2414         MBEDTLS_SSL_DEBUG_MSG( 1, ( "failed to perform compression (%d)", ret ) );
// 2415         return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
// 2416     }
// 2417 
// 2418     ssl->out_msglen = MBEDTLS_SSL_OUT_BUFFER_LEN -
// 2419                       ssl->transform_out->ctx_deflate.avail_out - bytes_written;
// 2420 
// 2421     MBEDTLS_SSL_DEBUG_MSG( 3, ( "after compression: msglen = %d, ",
// 2422                    ssl->out_msglen ) );
// 2423 
// 2424     MBEDTLS_SSL_DEBUG_BUF( 4, "after compression: output payload",
// 2425                    ssl->out_msg, ssl->out_msglen );
// 2426 
// 2427     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= compress buf" ) );
// 2428 
// 2429     return( 0 );
// 2430 }
// 2431 
// 2432 static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
// 2433 {
// 2434     int ret;
// 2435     unsigned char *msg_post = ssl->in_msg;
// 2436     ptrdiff_t header_bytes = ssl->in_msg - ssl->in_buf;
// 2437     size_t len_pre = ssl->in_msglen;
// 2438     unsigned char *msg_pre = ssl->compress_buf;
// 2439 
// 2440     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> decompress buf" ) );
// 2441 
// 2442     if( len_pre == 0 )
// 2443         return( 0 );
// 2444 
// 2445     memcpy( msg_pre, ssl->in_msg, len_pre );
// 2446 
// 2447     MBEDTLS_SSL_DEBUG_MSG( 3, ( "before decompression: msglen = %d, ",
// 2448                    ssl->in_msglen ) );
// 2449 
// 2450     MBEDTLS_SSL_DEBUG_BUF( 4, "before decompression: input payload",
// 2451                    ssl->in_msg, ssl->in_msglen );
// 2452 
// 2453     ssl->transform_in->ctx_inflate.next_in = msg_pre;
// 2454     ssl->transform_in->ctx_inflate.avail_in = len_pre;
// 2455     ssl->transform_in->ctx_inflate.next_out = msg_post;
// 2456     ssl->transform_in->ctx_inflate.avail_out = MBEDTLS_SSL_IN_BUFFER_LEN -
// 2457                                                header_bytes;
// 2458 
// 2459     ret = inflate( &ssl->transform_in->ctx_inflate, Z_SYNC_FLUSH );
// 2460     if( ret != Z_OK )
// 2461     {
// 2462         MBEDTLS_SSL_DEBUG_MSG( 1, ( "failed to perform decompression (%d)", ret ) );
// 2463         return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
// 2464     }
// 2465 
// 2466     ssl->in_msglen = MBEDTLS_SSL_IN_BUFFER_LEN -
// 2467                      ssl->transform_in->ctx_inflate.avail_out - header_bytes;
// 2468 
// 2469     MBEDTLS_SSL_DEBUG_MSG( 3, ( "after decompression: msglen = %d, ",
// 2470                    ssl->in_msglen ) );
// 2471 
// 2472     MBEDTLS_SSL_DEBUG_BUF( 4, "after decompression: input payload",
// 2473                    ssl->in_msg, ssl->in_msglen );
// 2474 
// 2475     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= decompress buf" ) );
// 2476 
// 2477     return( 0 );
// 2478 }
// 2479 #endif /* MBEDTLS_ZLIB_SUPPORT */
// 2480 
// 2481 #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_RENEGOTIATION)
// 2482 static int ssl_write_hello_request( mbedtls_ssl_context *ssl );
// 2483 
// 2484 #if defined(MBEDTLS_SSL_PROTO_DTLS)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function ssl_resend_hello_request
        THUMB
// 2485 static int ssl_resend_hello_request( mbedtls_ssl_context *ssl )
// 2486 {
ssl_resend_hello_request:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 2487     /* If renegotiation is not enforced, retransmit until we would reach max
// 2488      * timeout if we were using the usual handshake doubling scheme */
// 2489     if( ssl->conf->renego_max_records < 0 )
        LDR      R1,[R0, #+0]
        LDR      R1,[R1, #+180]
        CMP      R1,#+0
        BPL.N    ??ssl_resend_hello_request_0
// 2490     {
// 2491         uint32_t ratio = ssl->conf->hs_timeout_max / ssl->conf->hs_timeout_min + 1;
        LDR      R1,[R0, #+0]
        LDR      R1,[R1, #+176]
        LDR      R2,[R0, #+0]
        LDR      R2,[R2, #+172]
        UDIV     R1,R1,R2
        ADDS     R1,R1,#+1
// 2492         unsigned char doublings = 1;
        MOVS     R2,#+1
        CMP      R1,#+0
        B.N      ??ssl_resend_hello_request_1
// 2493 
// 2494         while( ratio != 0 )
// 2495         {
// 2496             ++doublings;
??ssl_resend_hello_request_2:
        ADDS     R2,R2,#+1
// 2497             ratio >>= 1;
        LSRS     R1,R1,#+1
// 2498         }
??ssl_resend_hello_request_1:
        BNE.N    ??ssl_resend_hello_request_2
// 2499 
// 2500         if( ++ssl->renego_records_seen > doublings )
        LDR      R1,[R0, #+12]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+12]
        UXTB     R2,R2
        CMP      R2,R1
        BGE.N    ??ssl_resend_hello_request_0
// 2501         {
// 2502             MBEDTLS_SSL_DEBUG_MSG( 2, ( "no longer retransmitting hello request" ) );
        LDR.W    R1,??DataTable22_5
        STR      R1,[SP, #+0]
        MOVW     R3,#+2502
        LDR.W    R2,??DataTable18
        MOVS     R1,#+2
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2503             return( 0 );
        MOVS     R0,#+0
        POP      {R1,PC}
// 2504         }
// 2505     }
// 2506 
// 2507     return( ssl_write_hello_request( ssl ) );
??ssl_resend_hello_request_0:
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall ssl_write_hello_request
        B.W      ssl_write_hello_request
// 2508 }
          CFI EndBlock cfiBlock30

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16:
        DATA32
        DC32     ?_37

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_1:
        DATA32
        DC32     ?_38

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_2:
        DATA32
        DC32     ?_39

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_3:
        DATA32
        DC32     ?_40

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_4:
        DATA32
        DC32     ?_41

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_5:
        DATA32
        DC32     ?_42

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_6:
        DATA32
        DC32     ?_43

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_7:
        DATA32
        DC32     ?_44

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_8:
        DATA32
        DC32     ?_45

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_9:
        DATA32
        DC32     ?_46
// 2509 #endif
// 2510 #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_RENEGOTIATION */
// 2511 
// 2512 /*
// 2513  * Fill the input message buffer by appending data to it.
// 2514  * The amount of data already fetched is in ssl->in_left.
// 2515  *
// 2516  * If we return 0, is it guaranteed that (at least) nb_want bytes are
// 2517  * available (from this read and/or a previous one). Otherwise, an error code
// 2518  * is returned (possibly EOF or WANT_READ).
// 2519  *
// 2520  * With stream transport (TLS) on success ssl->in_left == nb_want, but
// 2521  * with datagram transport (DTLS) on success ssl->in_left >= nb_want,
// 2522  * since we always read a whole datagram at once.
// 2523  *
// 2524  * For DTLS, it is up to the caller to set ssl->next_record_offset when
// 2525  * they're done reading a record.
// 2526  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function mbedtls_ssl_fetch_input
        THUMB
// 2527 int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
// 2528 {
mbedtls_ssl_fetch_input:
        PUSH     {R1-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+40
        MOV      R5,R0
        MOV      R8,R1
// 2529     int ret;
// 2530     size_t len;
// 2531 
// 2532     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> fetch input" ) );
        LDR.W    R7,??DataTable18
        LDR.W    R0,??DataTable22_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+2532
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2533 
// 2534     if( ssl->f_recv == NULL && ssl->f_recv_timeout == NULL )
        LDR      R0,[R5, #+32]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_fetch_input_0
        LDR      R0,[R5, #+36]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_fetch_input_0
// 2535     {
// 2536         MBEDTLS_SSL_DEBUG_MSG( 1, ( "Bad usage of mbedtls_ssl_set_bio() "
// 2537                             "or mbedtls_ssl_set_bio()" ) );
        LDR.W    R0,??DataTable23_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+2537
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2538         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable23_2  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_fetch_input_1
// 2539     }
// 2540 
// 2541     if( nb_want > MBEDTLS_SSL_IN_BUFFER_LEN - (size_t)( ssl->in_hdr - ssl->in_buf ) )
??mbedtls_ssl_fetch_input_0:
        MOVW     R4,#+10573
        LDR      R1,[R5, #+100]
        SUBS     R1,R4,R1
        LDR      R0,[R5, #+92]
        ADDS     R1,R0,R1
        CMP      R1,R8
        BCS.N    ??mbedtls_ssl_fetch_input_2
// 2542     {
// 2543         MBEDTLS_SSL_DEBUG_MSG( 1, ( "requesting more data than fits" ) );
        LDR.W    R0,??DataTable23_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+2543
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2544         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable23_2  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_fetch_input_1
// 2545     }
// 2546 
// 2547 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 2548     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
??mbedtls_ssl_fetch_input_2:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.W    ??mbedtls_ssl_fetch_input_3
// 2549     {
// 2550         uint32_t timeout;
// 2551 
// 2552         /* Just to be sure */
// 2553         if( ssl->f_set_timer == NULL || ssl->f_get_timer == NULL )
        LDR      R0,[R5, #+84]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_fetch_input_4
        LDR      R0,[R5, #+88]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_fetch_input_5
// 2554         {
// 2555             MBEDTLS_SSL_DEBUG_MSG( 1, ( "You must use "
// 2556                         "mbedtls_ssl_set_timer_cb() for DTLS" ) );
??mbedtls_ssl_fetch_input_4:
        LDR.W    R0,??DataTable23_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+2556
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2557             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable23_2  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_fetch_input_1
// 2558         }
// 2559 
// 2560         /*
// 2561          * The point is, we need to always read a full datagram at once, so we
// 2562          * sometimes read more then requested, and handle the additional data.
// 2563          * It could be the rest of the current record (while fetching the
// 2564          * header) and/or some other records in the same datagram.
// 2565          */
// 2566 
// 2567         /*
// 2568          * Move to the next record in the already read datagram if applicable
// 2569          */
// 2570         if( ssl->next_record_offset != 0 )
??mbedtls_ssl_fetch_input_5:
        LDR      R0,[R5, #+136]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_fetch_input_6
// 2571         {
// 2572             if( ssl->in_left < ssl->next_record_offset )
        LDR      R0,[R5, #+128]
        LDR      R1,[R5, #+136]
        CMP      R0,R1
        BCS.N    ??mbedtls_ssl_fetch_input_7
// 2573             {
// 2574                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.N    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2574
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2575                 return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??mbedtls_ssl_fetch_input_1
// 2576             }
// 2577 
// 2578             ssl->in_left -= ssl->next_record_offset;
??mbedtls_ssl_fetch_input_7:
        MOV      R1,R0
        LDR      R0,[R5, #+136]
        SUBS     R1,R1,R0
        STR      R1,[R5, #+128]
// 2579 
// 2580             if( ssl->in_left != 0 )
        BEQ.N    ??mbedtls_ssl_fetch_input_8
// 2581             {
// 2582                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "next record in same datagram, offset: %d",
// 2583                                     ssl->next_record_offset ) );
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable23_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+2583
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2584                 memmove( ssl->in_hdr,
// 2585                          ssl->in_hdr + ssl->next_record_offset,
// 2586                          ssl->in_left );
        LDR      R2,[R5, #+128]
        LDR      R0,[R5, #+100]
        LDR      R1,[R5, #+136]
        ADD      R1,R0,R1
          CFI FunCall __aeabi_memmove
        BL       __aeabi_memmove
// 2587             }
// 2588 
// 2589             ssl->next_record_offset = 0;
??mbedtls_ssl_fetch_input_8:
        MOVS     R0,#+0
        STR      R0,[R5, #+136]
// 2590         }
// 2591 
// 2592         MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
// 2593                        ssl->in_left, nb_want ) );
??mbedtls_ssl_fetch_input_6:
        STR      R8,[SP, #+8]
        LDR      R0,[R5, #+128]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable23_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+2593
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2594 
// 2595         /*
// 2596          * Done if we already have enough data.
// 2597          */
// 2598         if( nb_want <= ssl->in_left)
        LDR      R0,[R5, #+128]
        CMP      R0,R8
        BCC.N    ??mbedtls_ssl_fetch_input_9
// 2599         {
// 2600             MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= fetch input" ) );
        LDR.W    R0,??DataTable23_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+2600
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2601             return( 0 );
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_fetch_input_1
// 2602         }
// 2603 
// 2604         /*
// 2605          * A record can't be split accross datagrams. If we need to read but
// 2606          * are not at the beginning of a new record, the caller did something
// 2607          * wrong.
// 2608          */
// 2609         if( ssl->in_left != 0 )
??mbedtls_ssl_fetch_input_9:
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_fetch_input_10
// 2610         {
// 2611             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.N    R0,??DataTable17_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2611
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2612             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??mbedtls_ssl_fetch_input_1
// 2613         }
// 2614 
// 2615         /*
// 2616          * Don't even try to read if time's out already.
// 2617          * This avoids by-passing the timer when repeatedly receiving messages
// 2618          * that will end up being dropped.
// 2619          */
// 2620         if( ssl_check_timer( ssl ) != 0 )
??mbedtls_ssl_fetch_input_10:
        MOV      R0,R5
          CFI FunCall ssl_check_timer
        BL       ssl_check_timer
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_fetch_input_11
// 2621         {
// 2622             MBEDTLS_SSL_DEBUG_MSG( 2, ( "timer has expired" ) );
        LDR.W    R0,??DataTable23_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+2622
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2623             ret = MBEDTLS_ERR_SSL_TIMEOUT;
        LDR.W    R4,??DataTable23_9  ;; 0xffff9800
        B.N      ??mbedtls_ssl_fetch_input_12
// 2624         }
// 2625         else
// 2626         {
// 2627             len = MBEDTLS_SSL_IN_BUFFER_LEN - ( ssl->in_hdr - ssl->in_buf );
??mbedtls_ssl_fetch_input_11:
        LDR      R0,[R5, #+100]
        SUBS     R4,R4,R0
        LDR      R0,[R5, #+92]
        ADDS     R4,R0,R4
// 2628 
// 2629             if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BEQ.N    ??mbedtls_ssl_fetch_input_13
// 2630                 timeout = ssl->handshake->retransmit_timeout;
        LDR      R0,[R5, #+60]
        LDR      R6,[R0, #+484]
        B.N      ??mbedtls_ssl_fetch_input_14
// 2631             else
// 2632                 timeout = ssl->conf->read_timeout;
??mbedtls_ssl_fetch_input_13:
        LDR      R0,[R5, #+0]
        LDR      R6,[R0, #+168]
// 2633 
// 2634             MBEDTLS_SSL_DEBUG_MSG( 3, ( "f_recv_timeout: %u ms", timeout ) );
??mbedtls_ssl_fetch_input_14:
        STR      R6,[SP, #+4]
        LDR.W    R0,??DataTable23_10
        STR      R0,[SP, #+0]
        MOVW     R3,#+2634
        MOV      R2,R7
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2635 
// 2636             if( ssl->f_recv_timeout != NULL )
        LDR      R0,[R5, #+36]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_fetch_input_15
// 2637                 ret = ssl->f_recv_timeout( ssl->p_bio, ssl->in_hdr, len,
// 2638                                                                     timeout );
        MOV      R3,R6
        MOV      R2,R4
        LDR      R1,[R5, #+100]
        LDR      R0,[R5, #+40]
        LDR      R4,[R5, #+36]
          CFI FunCall
        BLX      R4
        MOV      R4,R0
        B.N      ??mbedtls_ssl_fetch_input_16
// 2639             else
// 2640                 ret = ssl->f_recv( ssl->p_bio, ssl->in_hdr, len );
??mbedtls_ssl_fetch_input_15:
        MOV      R2,R4
        LDR      R1,[R5, #+100]
        LDR      R0,[R5, #+40]
        LDR      R3,[R5, #+32]
          CFI FunCall
        BLX      R3
        MOV      R4,R0
// 2641 
// 2642             MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_recv(_timeout)", ret );
??mbedtls_ssl_fetch_input_16:
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable23_11
        STR      R0,[SP, #+0]
        MOVW     R3,#+2642
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 2643 
// 2644             if( ret == 0 )
        CMP      R4,#+0
        BEQ.W    ??mbedtls_ssl_fetch_input_17
// 2645                 return( MBEDTLS_ERR_SSL_CONN_EOF );
// 2646         }
// 2647 
// 2648         if( ret == MBEDTLS_ERR_SSL_TIMEOUT )
??mbedtls_ssl_fetch_input_12:
        LDR.W    R6,??DataTable23_9  ;; 0xffff9800
        CMP      R4,R6
        BNE.N    ??mbedtls_ssl_fetch_input_18
// 2649         {
// 2650             MBEDTLS_SSL_DEBUG_MSG( 2, ( "timeout" ) );
        LDR.W    R0,??DataTable23_12
        STR      R0,[SP, #+0]
        MOVW     R3,#+2650
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2651             ssl_set_timer( ssl, 0 );
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall ssl_set_timer
        BL       ssl_set_timer
// 2652 
// 2653             if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BEQ.N    ??mbedtls_ssl_fetch_input_19
// 2654             {
// 2655                 if( ssl_double_retransmit_timeout( ssl ) != 0 )
        MOV      R0,R5
          CFI FunCall ssl_double_retransmit_timeout
        BL       ssl_double_retransmit_timeout
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_fetch_input_20
// 2656                 {
// 2657                     MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake timeout" ) );
        LDR.W    R0,??DataTable23_13
        STR      R0,[SP, #+0]
        MOVW     R3,#+2657
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2658                     return( MBEDTLS_ERR_SSL_TIMEOUT );
        MOV      R0,R6
        B.N      ??mbedtls_ssl_fetch_input_1
// 2659                 }
// 2660 
// 2661                 if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
??mbedtls_ssl_fetch_input_20:
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_resend
        BL       mbedtls_ssl_resend
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_fetch_input_21
// 2662                 {
// 2663                     MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_resend", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable23_14
        STR      R0,[SP, #+0]
        MOVW     R3,#+2663
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 2664                     return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_fetch_input_1
// 2665                 }
// 2666 
// 2667                 return( MBEDTLS_ERR_SSL_WANT_READ );
??mbedtls_ssl_fetch_input_21:
        LDR.W    R0,??DataTable23_15  ;; 0xffff9700
        B.N      ??mbedtls_ssl_fetch_input_1
// 2668             }
// 2669 #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_RENEGOTIATION)
// 2670             else if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
// 2671                      ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )
??mbedtls_ssl_fetch_input_19:
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_fetch_input_18
        LDR      R0,[R5, #+8]
        CMP      R0,#+3
        BNE.N    ??mbedtls_ssl_fetch_input_18
// 2672             {
// 2673                 if( ( ret = ssl_resend_hello_request( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall ssl_resend_hello_request
        BL       ssl_resend_hello_request
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_fetch_input_22
// 2674                 {
// 2675                     MBEDTLS_SSL_DEBUG_RET( 1, "ssl_resend_hello_request", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable24
        STR      R0,[SP, #+0]
        MOVW     R3,#+2675
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 2676                     return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_fetch_input_1
// 2677                 }
// 2678 
// 2679                 return( MBEDTLS_ERR_SSL_WANT_READ );
??mbedtls_ssl_fetch_input_22:
        LDR.W    R0,??DataTable23_15  ;; 0xffff9700
        B.N      ??mbedtls_ssl_fetch_input_1
// 2680             }
// 2681 #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_RENEGOTIATION */
// 2682         }
// 2683 
// 2684         if( ret < 0 )
??mbedtls_ssl_fetch_input_18:
        CMP      R4,#+0
        BPL.N    ??mbedtls_ssl_fetch_input_23
// 2685             return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_fetch_input_1
// 2686 
// 2687         ssl->in_left = ret;
??mbedtls_ssl_fetch_input_23:
        STR      R4,[R5, #+128]
// 2688     }
// 2689     else
// 2690 #endif
// 2691     {
// 2692         MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
// 2693                        ssl->in_left, nb_want ) );
// 2694 
// 2695         while( ssl->in_left < nb_want )
// 2696         {
// 2697             len = nb_want - ssl->in_left;
// 2698 
// 2699             if( ssl_check_timer( ssl ) != 0 )
// 2700                 ret = MBEDTLS_ERR_SSL_TIMEOUT;
// 2701             else
// 2702             {
// 2703                 if( ssl->f_recv_timeout != NULL )
// 2704                 {
// 2705                     ret = ssl->f_recv_timeout( ssl->p_bio,
// 2706                                                ssl->in_hdr + ssl->in_left, len,
// 2707                                                ssl->conf->read_timeout );
// 2708                 }
// 2709                 else
// 2710                 {
// 2711                     ret = ssl->f_recv( ssl->p_bio,
// 2712                                        ssl->in_hdr + ssl->in_left, len );
// 2713                 }
// 2714             }
// 2715 
// 2716             MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
// 2717                                         ssl->in_left, nb_want ) );
// 2718             MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_recv(_timeout)", ret );
// 2719 
// 2720             if( ret == 0 )
// 2721                 return( MBEDTLS_ERR_SSL_CONN_EOF );
// 2722 
// 2723             if( ret < 0 )
// 2724                 return( ret );
// 2725 
// 2726             if ( (size_t)ret > len || ( INT_MAX > SIZE_MAX && ret > SIZE_MAX ) )
// 2727             {
// 2728                 MBEDTLS_SSL_DEBUG_MSG( 1,
// 2729                     ( "f_recv returned %d bytes but only %lu were requested",
// 2730                     ret, (unsigned long)len ) );
// 2731                 return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 2732             }
// 2733 
// 2734             ssl->in_left += ret;
// 2735         }
// 2736     }
// 2737 
// 2738     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= fetch input" ) );
??mbedtls_ssl_fetch_input_24:
        LDR.W    R0,??DataTable23_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+2738
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2739 
// 2740     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_fetch_input_1:
        POP      {R1-R9,PC}       ;; return
??mbedtls_ssl_fetch_input_3:
        LDR.W    R9,??DataTable23_6
        STR      R8,[SP, #+8]
        LDR      R0,[R5, #+128]
        STR      R0,[SP, #+4]
        STR      R9,[SP, #+0]
        MOVW     R3,#+2693
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        B.N      ??mbedtls_ssl_fetch_input_25
??mbedtls_ssl_fetch_input_26:
        BMI.N    ??mbedtls_ssl_fetch_input_27
        CMP      R6,R4
        BCC.N    ??mbedtls_ssl_fetch_input_28
        LDR      R0,[R5, #+128]
        ADDS     R4,R4,R0
        STR      R4,[R5, #+128]
??mbedtls_ssl_fetch_input_25:
        LDR      R0,[R5, #+128]
        CMP      R0,R8
        BCS.N    ??mbedtls_ssl_fetch_input_24
        MOV      R6,R0
        SUB      R6,R8,R6
        MOV      R0,R5
          CFI FunCall ssl_check_timer
        BL       ssl_check_timer
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_fetch_input_29
        LDR.W    R4,??DataTable23_9  ;; 0xffff9800
        B.N      ??mbedtls_ssl_fetch_input_30
??mbedtls_ssl_fetch_input_29:
        LDR      R0,[R5, #+36]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_fetch_input_31
        LDR      R0,[R5, #+0]
        LDR      R3,[R0, #+168]
        MOV      R2,R6
        LDR      R0,[R5, #+100]
        LDR      R1,[R5, #+128]
        ADD      R1,R0,R1
        LDR      R0,[R5, #+40]
        LDR      R4,[R5, #+36]
          CFI FunCall
        BLX      R4
        MOV      R4,R0
        B.N      ??mbedtls_ssl_fetch_input_30
??mbedtls_ssl_fetch_input_31:
        MOV      R2,R6
        LDR      R0,[R5, #+100]
        LDR      R1,[R5, #+128]
        ADD      R1,R0,R1
        LDR      R0,[R5, #+40]
        LDR      R3,[R5, #+32]
          CFI FunCall
        BLX      R3
        MOV      R4,R0
??mbedtls_ssl_fetch_input_30:
        STR      R8,[SP, #+8]
        LDR      R0,[R5, #+128]
        STR      R0,[SP, #+4]
        STR      R9,[SP, #+0]
        MOVW     R3,#+2717
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable23_11
        STR      R0,[SP, #+0]
        MOVW     R3,#+2718
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
        CMP      R4,#+0
        BNE.N    ??mbedtls_ssl_fetch_input_26
??mbedtls_ssl_fetch_input_17:
        LDR.W    R0,??DataTable25  ;; 0xffff8d80
        B.N      ??mbedtls_ssl_fetch_input_1
??mbedtls_ssl_fetch_input_27:
        MOV      R0,R4
        B.N      ??mbedtls_ssl_fetch_input_1
??mbedtls_ssl_fetch_input_28:
        STR      R6,[SP, #+8]
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable25_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+2730
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.N    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??mbedtls_ssl_fetch_input_1
// 2741 }
          CFI EndBlock cfiBlock31

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17:
        DATA32
        DC32     ?_47

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_1:
        DATA32
        DC32     ?_48

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_2:
        DATA32
        DC32     ?_7

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_3:
        DATA32
        DC32     ?_49

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_4:
        DATA32
        DC32     0xffff8e80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17_5:
        DATA32
        DC32     ?_50
// 2742 
// 2743 /*
// 2744  * Flush any data not yet written
// 2745  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function mbedtls_ssl_flush_output
        THUMB
// 2746 int mbedtls_ssl_flush_output( mbedtls_ssl_context *ssl )
// 2747 {
mbedtls_ssl_flush_output:
        PUSH     {R0-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+32
        MOV      R4,R0
// 2748     int ret;
// 2749     unsigned char *buf;
// 2750 
// 2751     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> flush output" ) );
        LDR.N    R5,??DataTable18
        LDR.W    R0,??DataTable25_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2751
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2752 
// 2753     if( ssl->f_send == NULL )
        LDR      R0,[R4, #+28]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_flush_output_0
// 2754     {
// 2755         MBEDTLS_SSL_DEBUG_MSG( 1, ( "Bad usage of mbedtls_ssl_set_bio() "
// 2756                             "or mbedtls_ssl_set_bio()" ) );
        LDR.W    R0,??DataTable23_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+2756
        MOV      R2,R5
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2757         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable23_2  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_flush_output_1
// 2758     }
// 2759 
// 2760     /* Avoid incrementing counter if data is flushed */
// 2761     if( ssl->out_left == 0 )
??mbedtls_ssl_flush_output_0:
        LDR      R0,[R4, #+208]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_flush_output_2
// 2762     {
// 2763         MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= flush output" ) );
        LDR.W    R0,??DataTable25_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+2763
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2764         return( 0 );
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_flush_output_1
// 2765     }
// 2766 
// 2767     while( ssl->out_left > 0 )
// 2768     {
// 2769         MBEDTLS_SSL_DEBUG_MSG( 2, ( "message length: %d, out_left: %d",
// 2770                        mbedtls_ssl_hdr_len( ssl ) + ssl->out_msglen, ssl->out_left ) );
// 2771 
// 2772         buf = ssl->out_hdr - ssl->out_left;
// 2773         ret = ssl->f_send( ssl->p_bio, buf, ssl->out_left );
// 2774 
// 2775         MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_send", ret );
// 2776 
// 2777         if( ret <= 0 )
// 2778             return( ret );
// 2779 
// 2780         if( (size_t)ret > ssl->out_left || ( INT_MAX > SIZE_MAX && ret > SIZE_MAX ) )
??mbedtls_ssl_flush_output_3:
        LDR      R0,[R4, #+208]
        CMP      R0,R6
        BCC.N    ??mbedtls_ssl_flush_output_4
// 2781         {
// 2782             MBEDTLS_SSL_DEBUG_MSG( 1,
// 2783                 ( "f_send returned %d bytes but only %lu bytes were sent",
// 2784                 ret, (unsigned long)ssl->out_left ) );
// 2785             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 2786         }
// 2787 
// 2788         ssl->out_left -= ret;
        SUBS     R6,R0,R6
        STR      R6,[R4, #+208]
??mbedtls_ssl_flush_output_2:
        LDR      R0,[R4, #+208]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_flush_output_5
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_hdr_len
        BL       mbedtls_ssl_hdr_len
        LDR      R1,[R4, #+208]
        STR      R1,[SP, #+8]
        LDR      R1,[R4, #+204]
        ADDS     R0,R1,R0
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable25_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+2770
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR      R2,[R4, #+208]
        LDR      R0,[R4, #+184]
        MOV      R1,R2
        RSBS     R1,R1,#+0
        ADD      R1,R0,R1
        LDR      R0,[R4, #+40]
        LDR      R3,[R4, #+28]
          CFI FunCall
        BLX      R3
        MOV      R6,R0
        STR      R6,[SP, #+4]
        LDR.W    R0,??DataTable25_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+2775
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
        CMP      R6,#+1
        BGE.N    ??mbedtls_ssl_flush_output_3
        MOV      R0,R6
        B.N      ??mbedtls_ssl_flush_output_1
??mbedtls_ssl_flush_output_4:
        STR      R0,[SP, #+8]
        STR      R6,[SP, #+4]
        LDR.W    R0,??DataTable25_6
        STR      R0,[SP, #+0]
        MOV      R3,#+2784
        MOV      R2,R5
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.N    R0,??DataTable18_1  ;; 0xffff9400
        B.N      ??mbedtls_ssl_flush_output_1
// 2789     }
// 2790 
// 2791 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 2792     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
// 2793     {
// 2794         ssl->out_hdr = ssl->out_buf;
// 2795     }
// 2796     else
// 2797 #endif
// 2798     {
// 2799         ssl->out_hdr = ssl->out_buf + 8;
??mbedtls_ssl_flush_output_6:
        ADDS     R0,R0,#+8
        STR      R0,[R4, #+184]
// 2800     }
// 2801     ssl_update_out_pointers( ssl, ssl->transform_out );
??mbedtls_ssl_flush_output_7:
        LDR      R1,[R4, #+68]
        MOV      R0,R4
          CFI FunCall ssl_update_out_pointers
        BL       ssl_update_out_pointers
// 2802 
// 2803     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= flush output" ) );
        LDR.W    R0,??DataTable25_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+2803
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2804 
// 2805     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_flush_output_1:
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI CFA R13+32
??mbedtls_ssl_flush_output_5:
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        LDR      R0,[R4, #+176]
        BEQ.N    ??mbedtls_ssl_flush_output_6
        STR      R0,[R4, #+184]
        B.N      ??mbedtls_ssl_flush_output_7
// 2806 }
          CFI EndBlock cfiBlock32

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable18:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable18_1:
        DATA32
        DC32     0xffff9400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable18_2:
        DATA32
        DC32     ?_51

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable18_3:
        DATA32
        DC32     ?_52

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable18_4:
        DATA32
        DC32     ?_53
// 2807 
// 2808 /*
// 2809  * Functions to handle the DTLS retransmission state machine
// 2810  */
// 2811 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 2812 /*
// 2813  * Append current handshake message to current outgoing flight
// 2814  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function ssl_flight_append
        THUMB
// 2815 static int ssl_flight_append( mbedtls_ssl_context *ssl )
// 2816 {
ssl_flight_append:
        PUSH     {R0-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+32
        MOV      R5,R0
// 2817     mbedtls_ssl_flight_item *msg;
// 2818     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> ssl_flight_append" ) );
        LDR.W    R6,??DataTable25_8
        LDR.W    R0,??DataTable25_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+2818
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2819     MBEDTLS_SSL_DEBUG_BUF( 4, "message appended to flight",
// 2820                            ssl->out_msg, ssl->out_msglen );
        LDR      R0,[R5, #+204]
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+196]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable25_10
        STR      R0,[SP, #+0]
        MOVW     R3,#+2820
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 2821 
// 2822     /* Allocate space for current message */
// 2823     if( ( msg = mbedtls_calloc( 1, sizeof(  mbedtls_ssl_flight_item ) ) ) == NULL )
        MOVS     R1,#+16
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        MOVS     R4,R0
        BNE.N    ??ssl_flight_append_0
// 2824     {
// 2825         MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc %d bytes failed",
// 2826                             sizeof( mbedtls_ssl_flight_item ) ) );
        MOVS     R0,#+16
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable25_11
        STR      R0,[SP, #+0]
        MOVW     R3,#+2826
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2827         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        LDR.W    R0,??DataTable25_12  ;; 0xffff8100
        B.N      ??ssl_flight_append_1
// 2828     }
// 2829 
// 2830     if( ( msg->p = mbedtls_calloc( 1, ssl->out_msglen ) ) == NULL )
??ssl_flight_append_0:
        LDR      R1,[R5, #+204]
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R4, #+0]
        CMP      R0,#+0
        BNE.N    ??ssl_flight_append_2
// 2831     {
// 2832         MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc %d bytes failed", ssl->out_msglen ) );
        LDR      R0,[R5, #+204]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable25_11
        STR      R0,[SP, #+0]
        MOV      R3,#+2832
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2833         mbedtls_free( msg );
        MOV      R0,R4
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 2834         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        LDR.W    R0,??DataTable25_12  ;; 0xffff8100
        B.N      ??ssl_flight_append_1
// 2835     }
// 2836 
// 2837     /* Copy current handshake message with headers */
// 2838     memcpy( msg->p, ssl->out_msg, ssl->out_msglen );
??ssl_flight_append_2:
        LDR      R2,[R5, #+204]
        LDR      R1,[R5, #+196]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 2839     msg->len = ssl->out_msglen;
        LDR      R0,[R5, #+204]
        STR      R0,[R4, #+4]
// 2840     msg->type = ssl->out_msgtype;
        LDR      R0,[R5, #+200]
        STRB     R0,[R4, #+8]
// 2841     msg->next = NULL;
        MOVS     R0,#+0
        STR      R0,[R4, #+12]
// 2842 
// 2843     /* Append to the current flight */
// 2844     if( ssl->handshake->flight == NULL )
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+492]
        CMP      R0,#+0
        LDR      R0,[R5, #+60]
        BNE.N    ??ssl_flight_append_3
// 2845         ssl->handshake->flight = msg;
        STR      R4,[R0, #+492]
        B.N      ??ssl_flight_append_4
// 2846     else
// 2847     {
// 2848         mbedtls_ssl_flight_item *cur = ssl->handshake->flight;
??ssl_flight_append_3:
        LDR      R1,[R0, #+492]
        B.N      ??ssl_flight_append_5
// 2849         while( cur->next != NULL )
// 2850             cur = cur->next;
??ssl_flight_append_6:
        MOV      R1,R0
??ssl_flight_append_5:
        LDR      R0,[R1, #+12]
        CMP      R0,#+0
        BNE.N    ??ssl_flight_append_6
// 2851         cur->next = msg;
        STR      R4,[R1, #+12]
// 2852     }
// 2853 
// 2854     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= ssl_flight_append" ) );
??ssl_flight_append_4:
        LDR.W    R0,??DataTable26
        STR      R0,[SP, #+0]
        MOVW     R3,#+2854
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2855     return( 0 );
        MOVS     R0,#+0
??ssl_flight_append_1:
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
// 2856 }
          CFI EndBlock cfiBlock33
// 2857 
// 2858 /*
// 2859  * Free the current flight of handshake messages
// 2860  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function ssl_flight_free
        THUMB
// 2861 static void ssl_flight_free( mbedtls_ssl_flight_item *flight )
// 2862 {
ssl_flight_free:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
// 2863     mbedtls_ssl_flight_item *cur = flight;
        B.N      ??ssl_flight_free_0
// 2864     mbedtls_ssl_flight_item *next;
// 2865 
// 2866     while( cur != NULL )
// 2867     {
// 2868         next = cur->next;
??ssl_flight_free_1:
        LDR      R5,[R4, #+12]
// 2869 
// 2870         mbedtls_free( cur->p );
        LDR      R0,[R4, #+0]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 2871         mbedtls_free( cur );
        MOV      R0,R4
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 2872 
// 2873         cur = next;
        MOVS     R4,R5
// 2874     }
??ssl_flight_free_0:
        BNE.N    ??ssl_flight_free_1
// 2875 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock34
// 2876 
// 2877 #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
// 2878 static void ssl_dtls_replay_reset( mbedtls_ssl_context *ssl );
// 2879 #endif
// 2880 
// 2881 /*
// 2882  * Swap transform_out and out_ctr with the alternative ones
// 2883  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function ssl_swap_epochs
        THUMB
// 2884 static void ssl_swap_epochs( mbedtls_ssl_context *ssl )
// 2885 {
ssl_swap_epochs:
        PUSH     {R0-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+24
        MOV      R4,R0
// 2886     mbedtls_ssl_transform *tmp_transform;
// 2887     unsigned char tmp_out_ctr[8];
// 2888 
// 2889     if( ssl->transform_out == ssl->handshake->alt_transform_out )
        LDR      R0,[R4, #+68]
        LDR      R1,[R4, #+60]
        LDR      R1,[R1, #+508]
        CMP      R0,R1
        BNE.N    ??ssl_swap_epochs_0
// 2890     {
// 2891         MBEDTLS_SSL_DEBUG_MSG( 3, ( "skip swap epochs" ) );
        LDR.W    R0,??DataTable26_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+2891
        LDR.W    R2,??DataTable25_8
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2892         return;
        POP      {R0-R4,PC}
// 2893     }
// 2894 
// 2895     MBEDTLS_SSL_DEBUG_MSG( 3, ( "swap epochs" ) );
??ssl_swap_epochs_0:
        LDR.W    R0,??DataTable26_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+2895
        LDR.W    R2,??DataTable25_8
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2896 
// 2897     /* Swap transforms */
// 2898     tmp_transform                     = ssl->transform_out;
        LDR      R0,[R4, #+68]
// 2899     ssl->transform_out                = ssl->handshake->alt_transform_out;
        LDR      R1,[R4, #+60]
        LDR      R1,[R1, #+508]
        STR      R1,[R4, #+68]
// 2900     ssl->handshake->alt_transform_out = tmp_transform;
        LDR      R1,[R4, #+60]
        STR      R0,[R1, #+508]
// 2901 
// 2902     /* Swap epoch + sequence_number */
// 2903     memcpy( tmp_out_ctr,                 ssl->cur_out_ctr,            8 );
        MOVS     R2,#+8
        ADD      R1,R4,#+212
        ADD      R0,SP,#+4
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 2904     memcpy( ssl->cur_out_ctr,            ssl->handshake->alt_out_ctr, 8 );
        MOVS     R2,#+8
        LDR      R0,[R4, #+60]
        ADD      R1,R0,#+512
        ADD      R0,R4,#+212
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 2905     memcpy( ssl->handshake->alt_out_ctr, tmp_out_ctr,                 8 );
        MOVS     R2,#+8
        ADD      R1,SP,#+4
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+512
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 2906 
// 2907     /* Adjust to the newly activated transform */
// 2908     ssl_update_out_pointers( ssl, ssl->transform_out );
        LDR      R1,[R4, #+68]
        MOV      R0,R4
          CFI FunCall ssl_update_out_pointers
        BL       ssl_update_out_pointers
// 2909 
// 2910 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
// 2911     if( mbedtls_ssl_hw_record_activate != NULL )
// 2912     {
// 2913         if( ( ret = mbedtls_ssl_hw_record_activate( ssl, MBEDTLS_SSL_CHANNEL_OUTBOUND ) ) != 0 )
// 2914         {
// 2915             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_activate", ret );
// 2916             return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
// 2917         }
// 2918     }
// 2919 #endif
// 2920 }
        POP      {R0-R4,PC}       ;; return
          CFI EndBlock cfiBlock35

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20:
        DATA32
        DC32     ?_54
// 2921 
// 2922 /*
// 2923  * Retransmit the current flight of messages.
// 2924  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function mbedtls_ssl_resend
        THUMB
// 2925 int mbedtls_ssl_resend( mbedtls_ssl_context *ssl )
// 2926 {
mbedtls_ssl_resend:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
// 2927     int ret = 0;
// 2928 
// 2929     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> mbedtls_ssl_resend" ) );
        LDR.W    R5,??DataTable25_8
        LDR.W    R0,??DataTable26_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+2929
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2930 
// 2931     ret = mbedtls_ssl_flight_transmit( ssl );
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_flight_transmit
        BL       mbedtls_ssl_flight_transmit
        MOV      R6,R0
// 2932 
// 2933     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= mbedtls_ssl_resend" ) );
        LDR.W    R0,??DataTable26_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+2933
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2934 
// 2935     return( ret );
        MOV      R0,R6
        POP      {R1,R2,R4-R6,PC}  ;; return
// 2936 }
          CFI EndBlock cfiBlock36

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable21:
        DATA32
        DC32     ?_55

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable21_1:
        DATA32
        DC32     ?_56

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable21_2:
        DATA32
        DC32     ?_57

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable21_3:
        DATA32
        DC32     ?_58
// 2937 
// 2938 /*
// 2939  * Transmit or retransmit the current flight of messages.
// 2940  *
// 2941  * Need to remember the current message in case flush_output returns
// 2942  * WANT_WRITE, causing us to exit this function and come back later.
// 2943  * This function must be called until state is no longer SENDING.
// 2944  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function mbedtls_ssl_flight_transmit
        THUMB
// 2945 int mbedtls_ssl_flight_transmit( mbedtls_ssl_context *ssl )
// 2946 {
mbedtls_ssl_flight_transmit:
        PUSH     {R0-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+48
        MOV      R6,R0
// 2947     int ret;
// 2948     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> mbedtls_ssl_flight_transmit" ) );
        LDR.W    R7,??DataTable25_8
        LDR.W    R0,??DataTable26_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+2948
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2949 
// 2950     if( ssl->handshake->retransmit_state != MBEDTLS_SSL_RETRANS_SENDING )
        LDR      R0,[R6, #+60]
        LDRB     R0,[R0, #+488]
        CMP      R0,#+1
        BEQ.N    ??mbedtls_ssl_flight_transmit_0
// 2951     {
// 2952         MBEDTLS_SSL_DEBUG_MSG( 2, ( "initialise flight transmission" ) );
        LDR.W    R0,??DataTable26_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+2952
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2953 
// 2954         ssl->handshake->cur_msg = ssl->handshake->flight;
        LDR      R0,[R6, #+60]
        LDR      R0,[R0, #+492]
        LDR      R1,[R6, #+60]
        STR      R0,[R1, #+496]
// 2955         ssl->handshake->cur_msg_p = ssl->handshake->flight->p + 12;
        LDR      R0,[R6, #+60]
        LDR      R0,[R0, #+492]
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+12
        LDR      R1,[R6, #+60]
        STR      R0,[R1, #+500]
// 2956         ssl_swap_epochs( ssl );
        MOV      R0,R6
          CFI FunCall ssl_swap_epochs
        BL       ssl_swap_epochs
// 2957 
// 2958         ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_SENDING;
        MOVS     R0,#+1
        LDR      R1,[R6, #+60]
        STRB     R0,[R1, #+488]
// 2959     }
// 2960 
// 2961     while( ssl->handshake->cur_msg != NULL )
??mbedtls_ssl_flight_transmit_0:
        LDR      R0,[R6, #+60]
        LDR      R0,[R0, #+496]
        CMP      R0,#+0
        BEQ.W    ??mbedtls_ssl_flight_transmit_1
// 2962     {
// 2963         size_t max_frag_len;
// 2964         const mbedtls_ssl_flight_item * const cur = ssl->handshake->cur_msg;
        LDR      R0,[R6, #+60]
        LDR      R8,[R0, #+496]
// 2965 
// 2966         int const is_finished =
// 2967             ( cur->type == MBEDTLS_SSL_MSG_HANDSHAKE &&
// 2968               cur->p[0] == MBEDTLS_SSL_HS_FINISHED );
        LDRB     R0,[R8, #+8]
        CMP      R0,#+22
        BNE.N    ??mbedtls_ssl_flight_transmit_2
        LDR      R0,[R8, #+0]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+20
        BNE.N    ??mbedtls_ssl_flight_transmit_2
        MOVS     R4,#+1
        B.N      ??mbedtls_ssl_flight_transmit_3
??mbedtls_ssl_flight_transmit_2:
        MOVS     R4,#+0
// 2969 
// 2970         uint8_t const force_flush = ssl->disable_datagram_packing == 1 ?
// 2971             SSL_FORCE_FLUSH : SSL_DONT_FORCE_FLUSH;
??mbedtls_ssl_flight_transmit_3:
        LDRB     R0,[R6, #+172]
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_flight_transmit_4
        MOV      R9,#+1
        B.N      ??mbedtls_ssl_flight_transmit_5
??mbedtls_ssl_flight_transmit_4:
        MOV      R9,#+0
// 2972 
// 2973         /* Swap epochs before sending Finished: we can't do it after
// 2974          * sending ChangeCipherSpec, in case write returns WANT_READ.
// 2975          * Must be done before copying, may change out_msg pointer */
// 2976         if( is_finished && ssl->handshake->cur_msg_p == ( cur->p + 12 ) )
??mbedtls_ssl_flight_transmit_5:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_flight_transmit_6
        LDR      R0,[R6, #+60]
        LDR      R0,[R0, #+500]
        LDR      R1,[R8, #+0]
        ADDS     R1,R1,#+12
        CMP      R0,R1
        BNE.N    ??mbedtls_ssl_flight_transmit_6
// 2977         {
// 2978             MBEDTLS_SSL_DEBUG_MSG( 2, ( "swap epochs to send finished message" ) );
        LDR.W    R0,??DataTable26_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+2978
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 2979             ssl_swap_epochs( ssl );
        MOV      R0,R6
          CFI FunCall ssl_swap_epochs
        BL       ssl_swap_epochs
// 2980         }
// 2981 
// 2982         ret = ssl_get_remaining_payload_in_datagram( ssl );
??mbedtls_ssl_flight_transmit_6:
        MOV      R0,R6
          CFI FunCall ssl_get_remaining_payload_in_datagram
        BL       ssl_get_remaining_payload_in_datagram
// 2983         if( ret < 0 )
        CMP      R0,#+0
        BMI.W    ??mbedtls_ssl_flight_transmit_7
// 2984             return( ret );
// 2985         max_frag_len = (size_t) ret;
// 2986 
// 2987         /* CCS is copied as is, while HS messages may need fragmentation */
// 2988         if( cur->type == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )
        LDRB     R1,[R8, #+8]
        CMP      R1,#+20
        BNE.N    ??mbedtls_ssl_flight_transmit_8
// 2989         {
// 2990             if( max_frag_len == 0 )
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_flight_transmit_9
// 2991             {
// 2992                 if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
        MOV      R0,R6
          CFI FunCall mbedtls_ssl_flush_output
        BL       mbedtls_ssl_flush_output
        CMP      R0,#+0
        BNE.W    ??mbedtls_ssl_flight_transmit_7
        B.N      ??mbedtls_ssl_flight_transmit_0
// 2993                     return( ret );
// 2994 
// 2995                 continue;
// 2996             }
// 2997 
// 2998             memcpy( ssl->out_msg, cur->p, cur->len );
??mbedtls_ssl_flight_transmit_9:
        LDR      R2,[R8, #+4]
        LDR      R1,[R8, #+0]
        LDR      R0,[R6, #+196]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 2999             ssl->out_msglen  = cur->len;
        LDR      R0,[R8, #+4]
        STR      R0,[R6, #+204]
// 3000             ssl->out_msgtype = cur->type;
        LDRB     R0,[R8, #+8]
        STR      R0,[R6, #+200]
// 3001 
// 3002             /* Update position inside current message */
// 3003             ssl->handshake->cur_msg_p += cur->len;
        LDR      R0,[R6, #+60]
        LDR      R0,[R0, #+500]
        LDR      R1,[R8, #+4]
        ADD      R0,R0,R1
        LDR      R1,[R6, #+60]
        STR      R0,[R1, #+500]
        B.N      ??mbedtls_ssl_flight_transmit_10
// 3004         }
// 3005         else
// 3006         {
// 3007             const unsigned char * const p = ssl->handshake->cur_msg_p;
??mbedtls_ssl_flight_transmit_8:
        LDR      R1,[R6, #+60]
        LDR      R10,[R1, #+500]
// 3008             const size_t hs_len = cur->len - 12;
        LDR      R1,[R8, #+4]
        SUBS     R1,R1,#+12
// 3009             const size_t frag_off = p - ( cur->p + 12 );
        LDR      R2,[R8, #+0]
        ADD      R5,R2,#+12
        SUB      R5,R10,R5
// 3010             const size_t rem_len = hs_len - frag_off;
        SUBS     R2,R1,R5
// 3011             size_t cur_hs_frag_len, max_hs_frag_len;
// 3012 
// 3013             if( ( max_frag_len < 12 ) || ( max_frag_len == 12 && hs_len != 0 ) )
        CMP      R0,#+12
        BCC.N    ??mbedtls_ssl_flight_transmit_11
        BNE.N    ??mbedtls_ssl_flight_transmit_12
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_flight_transmit_12
// 3014             {
// 3015                 if( is_finished )
??mbedtls_ssl_flight_transmit_11:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_flight_transmit_13
// 3016                     ssl_swap_epochs( ssl );
        MOV      R0,R6
          CFI FunCall ssl_swap_epochs
        BL       ssl_swap_epochs
// 3017 
// 3018                 if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
??mbedtls_ssl_flight_transmit_13:
        MOV      R0,R6
          CFI FunCall mbedtls_ssl_flush_output
        BL       mbedtls_ssl_flush_output
        CMP      R0,#+0
        BNE.W    ??mbedtls_ssl_flight_transmit_7
        B.N      ??mbedtls_ssl_flight_transmit_0
// 3019                     return( ret );
// 3020 
// 3021                 continue;
// 3022             }
// 3023             max_hs_frag_len = max_frag_len - 12;
??mbedtls_ssl_flight_transmit_12:
        SUBS     R0,R0,#+12
// 3024 
// 3025             cur_hs_frag_len = rem_len > max_hs_frag_len ?
// 3026                 max_hs_frag_len : rem_len;
        MOV      R4,R0
        CMP      R0,R2
        BLS.N    ??mbedtls_ssl_flight_transmit_14
        MOV      R4,R2
// 3027 
// 3028             if( frag_off == 0 && cur_hs_frag_len != hs_len )
??mbedtls_ssl_flight_transmit_14:
        CMP      R5,#+0
        BNE.N    ??mbedtls_ssl_flight_transmit_15
        CMP      R4,R1
        BEQ.N    ??mbedtls_ssl_flight_transmit_15
// 3029             {
// 3030                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "fragmenting handshake message (%u > %u)",
// 3031                                             (unsigned) cur_hs_frag_len,
// 3032                                             (unsigned) max_hs_frag_len ) );
        STR      R0,[SP, #+8]
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable26_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+3032
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3033             }
// 3034 
// 3035             /* Messages are stored with handshake headers as if not fragmented,
// 3036              * copy beginning of headers then fill fragmentation fields.
// 3037              * Handshake headers: type(1) len(3) seq(2) f_off(3) f_len(3) */
// 3038             memcpy( ssl->out_msg, cur->p, 6 );
??mbedtls_ssl_flight_transmit_15:
        MOVS     R2,#+6
        LDR      R1,[R8, #+0]
        LDR      R0,[R6, #+196]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 3039 
// 3040             ssl->out_msg[6] = ( ( frag_off >> 16 ) & 0xff );
        MOV      R0,R5
        LSRS     R0,R0,#+16
        LDR      R1,[R6, #+196]
        STRB     R0,[R1, #+6]
// 3041             ssl->out_msg[7] = ( ( frag_off >>  8 ) & 0xff );
        MOV      R0,R5
        LSRS     R0,R0,#+8
        LDR      R1,[R6, #+196]
        STRB     R0,[R1, #+7]
// 3042             ssl->out_msg[8] = ( ( frag_off       ) & 0xff );
        LDR      R0,[R6, #+196]
        STRB     R5,[R0, #+8]
// 3043 
// 3044             ssl->out_msg[ 9] = ( ( cur_hs_frag_len >> 16 ) & 0xff );
        MOV      R0,R4
        LSRS     R0,R0,#+16
        LDR      R1,[R6, #+196]
        STRB     R0,[R1, #+9]
// 3045             ssl->out_msg[10] = ( ( cur_hs_frag_len >>  8 ) & 0xff );
        MOV      R0,R4
        LSRS     R0,R0,#+8
        LDR      R1,[R6, #+196]
        STRB     R0,[R1, #+10]
// 3046             ssl->out_msg[11] = ( ( cur_hs_frag_len       ) & 0xff );
        LDR      R0,[R6, #+196]
        STRB     R4,[R0, #+11]
// 3047 
// 3048             MBEDTLS_SSL_DEBUG_BUF( 3, "handshake header", ssl->out_msg, 12 );
        MOVS     R0,#+12
        STR      R0,[SP, #+8]
        LDR      R0,[R6, #+196]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable26_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+3048
        MOV      R2,R7
        MOVS     R1,#+3
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 3049 
// 3050             /* Copy the handshake message content and set records fields */
// 3051             memcpy( ssl->out_msg + 12, p, cur_hs_frag_len );
        MOV      R2,R4
        MOV      R1,R10
        LDR      R0,[R6, #+196]
        ADDS     R0,R0,#+12
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 3052             ssl->out_msglen = cur_hs_frag_len + 12;
        ADD      R0,R4,#+12
        STR      R0,[R6, #+204]
// 3053             ssl->out_msgtype = cur->type;
        LDRB     R0,[R8, #+8]
        STR      R0,[R6, #+200]
// 3054 
// 3055             /* Update position inside current message */
// 3056             ssl->handshake->cur_msg_p += cur_hs_frag_len;
        LDR      R0,[R6, #+60]
        LDR      R0,[R0, #+500]
        ADD      R0,R0,R4
        LDR      R1,[R6, #+60]
        STR      R0,[R1, #+500]
// 3057         }
// 3058 
// 3059         /* If done with the current message move to the next one if any */
// 3060         if( ssl->handshake->cur_msg_p >= cur->p + cur->len )
??mbedtls_ssl_flight_transmit_10:
        LDR      R0,[R6, #+60]
        LDR      R0,[R0, #+500]
        LDR      R1,[R8, #+0]
        LDR      R2,[R8, #+4]
        ADD      R1,R1,R2
        CMP      R0,R1
        BCC.N    ??mbedtls_ssl_flight_transmit_16
// 3061         {
// 3062             if( cur->next != NULL )
        LDR      R0,[R8, #+12]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_flight_transmit_17
// 3063             {
// 3064                 ssl->handshake->cur_msg = cur->next;
        LDR      R1,[R6, #+60]
        STR      R0,[R1, #+496]
// 3065                 ssl->handshake->cur_msg_p = cur->next->p + 12;
        LDR      R0,[R8, #+12]
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+12
        LDR      R1,[R6, #+60]
        STR      R0,[R1, #+500]
        B.N      ??mbedtls_ssl_flight_transmit_16
// 3066             }
// 3067             else
// 3068             {
// 3069                 ssl->handshake->cur_msg = NULL;
??mbedtls_ssl_flight_transmit_17:
        MOVS     R0,#+0
        LDR      R1,[R6, #+60]
        STR      R0,[R1, #+496]
// 3070                 ssl->handshake->cur_msg_p = NULL;
        LDR      R1,[R6, #+60]
        STR      R0,[R1, #+500]
// 3071             }
// 3072         }
// 3073 
// 3074         /* Actually send the message out */
// 3075         if( ( ret = mbedtls_ssl_write_record( ssl, force_flush ) ) != 0 )
??mbedtls_ssl_flight_transmit_16:
        MOV      R1,R9
        MOV      R0,R6
          CFI FunCall mbedtls_ssl_write_record
        BL       mbedtls_ssl_write_record
        MOVS     R4,R0
        BEQ.W    ??mbedtls_ssl_flight_transmit_0
        MOV      R0,R6
// 3076         {
// 3077             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
        STR      R4,[SP, #+4]
        LDR.W    R1,??DataTable27
        STR      R1,[SP, #+0]
        MOVW     R3,#+3077
        MOV      R2,R7
        MOVS     R1,#+1
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 3078             return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_flight_transmit_7
// 3079         }
// 3080     }
// 3081 
// 3082     if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
// 3083         return( ret );
// 3084 
// 3085     /* Update state and set timer */
// 3086     if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
??mbedtls_ssl_flight_transmit_18:
        LDR      R0,[R6, #+4]
        CMP      R0,#+16
        BNE.N    ??mbedtls_ssl_flight_transmit_19
// 3087         ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
        MOVS     R0,#+3
        LDR      R1,[R6, #+60]
        STRB     R0,[R1, #+488]
        B.N      ??mbedtls_ssl_flight_transmit_20
// 3088     else
// 3089     {
// 3090         ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;
??mbedtls_ssl_flight_transmit_19:
        MOVS     R0,#+2
        LDR      R1,[R6, #+60]
        STRB     R0,[R1, #+488]
// 3091         ssl_set_timer( ssl, ssl->handshake->retransmit_timeout );
        LDR      R0,[R6, #+60]
        LDR      R1,[R0, #+484]
        MOV      R0,R6
          CFI FunCall ssl_set_timer
        BL       ssl_set_timer
// 3092     }
// 3093 
// 3094     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= mbedtls_ssl_flight_transmit" ) );
??mbedtls_ssl_flight_transmit_20:
        LDR.W    R0,??DataTable28
        STR      R0,[SP, #+0]
        MOVW     R3,#+3094
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3095 
// 3096     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_flight_transmit_7:
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
          CFI CFA R13+48
??mbedtls_ssl_flight_transmit_1:
        MOV      R0,R6
          CFI FunCall mbedtls_ssl_flush_output
        BL       mbedtls_ssl_flush_output
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_flight_transmit_18
        B.N      ??mbedtls_ssl_flight_transmit_7
// 3097 }
          CFI EndBlock cfiBlock37

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22:
        DATA32
        DC32     ?_59

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22_1:
        DATA32
        DC32     0xffff8e00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22_2:
        DATA32
        DC32     ?_60

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22_3:
        DATA32
        DC32     ?_62

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22_4:
        DATA32
        DC32     ?_61

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22_5:
        DATA32
        DC32     ?_63

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22_6:
        DATA32
        DC32     ?_64
// 3098 
// 3099 /*
// 3100  * To be called when the last message of an incoming flight is received.
// 3101  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function mbedtls_ssl_recv_flight_completed
        THUMB
// 3102 void mbedtls_ssl_recv_flight_completed( mbedtls_ssl_context *ssl )
// 3103 {
mbedtls_ssl_recv_flight_completed:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 3104     /* We won't need to resend that one any more */
// 3105     ssl_flight_free( ssl->handshake->flight );
        LDR      R0,[R4, #+60]
        LDR      R0,[R0, #+492]
          CFI FunCall ssl_flight_free
        BL       ssl_flight_free
// 3106     ssl->handshake->flight = NULL;
        MOVS     R0,#+0
        LDR      R1,[R4, #+60]
        STR      R0,[R1, #+492]
// 3107     ssl->handshake->cur_msg = NULL;
        LDR      R1,[R4, #+60]
        STR      R0,[R1, #+496]
// 3108 
// 3109     /* The next incoming flight will start with this msg_seq */
// 3110     ssl->handshake->in_flight_start_seq = ssl->handshake->in_msg_seq;
        LDR      R0,[R4, #+60]
        LDR      R0,[R0, #+472]
        LDR      R1,[R4, #+60]
        STR      R0,[R1, #+504]
// 3111 
// 3112     /* We don't want to remember CCS's across flight boundaries. */
// 3113     ssl->handshake->buffering.seen_ccs = 0;
        MOVS     R0,#+0
        LDR      R1,[R4, #+60]
        STRB     R0,[R1, #+524]
// 3114 
// 3115     /* Clear future message buffering structure. */
// 3116     ssl_buffering_free( ssl );
        MOV      R0,R4
          CFI FunCall ssl_buffering_free
        BL       ssl_buffering_free
// 3117 
// 3118     /* Cancel timer */
// 3119     ssl_set_timer( ssl, 0 );
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall ssl_set_timer
        BL       ssl_set_timer
// 3120 
// 3121     if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
// 3122         ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )
        LDR      R0,[R4, #+120]
        CMP      R0,#+22
        BNE.N    ??mbedtls_ssl_recv_flight_completed_0
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+20
        BNE.N    ??mbedtls_ssl_recv_flight_completed_0
// 3123     {
// 3124         ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
        MOVS     R0,#+3
        LDR      R1,[R4, #+60]
        STRB     R0,[R1, #+488]
        POP      {R4,PC}
// 3125     }
// 3126     else
// 3127         ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_PREPARING;
??mbedtls_ssl_recv_flight_completed_0:
        MOVS     R0,#+0
        LDR      R1,[R4, #+60]
        STRB     R0,[R1, #+488]
// 3128 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock38
// 3129 
// 3130 /*
// 3131  * To be called when the last message of an outgoing flight is send.
// 3132  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function mbedtls_ssl_send_flight_completed
        THUMB
// 3133 void mbedtls_ssl_send_flight_completed( mbedtls_ssl_context *ssl )
// 3134 {
mbedtls_ssl_send_flight_completed:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 3135     ssl_reset_retransmit_timeout( ssl );
          CFI FunCall ssl_reset_retransmit_timeout
        BL       ssl_reset_retransmit_timeout
// 3136     ssl_set_timer( ssl, ssl->handshake->retransmit_timeout );
        LDR      R0,[R4, #+60]
        LDR      R1,[R0, #+484]
        MOV      R0,R4
          CFI FunCall ssl_set_timer
        BL       ssl_set_timer
// 3137 
// 3138     if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
// 3139         ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )
        LDR      R0,[R4, #+120]
        CMP      R0,#+22
        BNE.N    ??mbedtls_ssl_send_flight_completed_0
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+20
        BNE.N    ??mbedtls_ssl_send_flight_completed_0
// 3140     {
// 3141         ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
        MOVS     R0,#+3
        LDR      R1,[R4, #+60]
        STRB     R0,[R1, #+488]
        POP      {R4,PC}
// 3142     }
// 3143     else
// 3144         ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;
??mbedtls_ssl_send_flight_completed_0:
        MOVS     R0,#+2
        LDR      R1,[R4, #+60]
        STRB     R0,[R1, #+488]
// 3145 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock39
// 3146 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 3147 
// 3148 /*
// 3149  * Handshake layer functions
// 3150  */
// 3151 
// 3152 /*
// 3153  * Write (DTLS: or queue) current handshake (including CCS) message.
// 3154  *
// 3155  *  - fill in handshake headers
// 3156  *  - update handshake checksum
// 3157  *  - DTLS: save message for resending
// 3158  *  - then pass to the record layer
// 3159  *
// 3160  * DTLS: except for HelloRequest, messages are only queued, and will only be
// 3161  * actually sent when calling flight_transmit() or resend().
// 3162  *
// 3163  * Inputs:
// 3164  *  - ssl->out_msglen: 4 + actual handshake message len
// 3165  *      (4 is the size of handshake headers for TLS)
// 3166  *  - ssl->out_msg[0]: the handshake type (ClientHello, ServerHello, etc)
// 3167  *  - ssl->out_msg + 4: the handshake message body
// 3168  *
// 3169  * Outputs, ie state before passing to flight_append() or write_record():
// 3170  *   - ssl->out_msglen: the length of the record contents
// 3171  *      (including handshake headers but excluding record headers)
// 3172  *   - ssl->out_msg: the record contents (handshake headers + content)
// 3173  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function mbedtls_ssl_write_handshake_msg
        THUMB
// 3174 int mbedtls_ssl_write_handshake_msg( mbedtls_ssl_context *ssl )
// 3175 {
mbedtls_ssl_write_handshake_msg:
        PUSH     {R1-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+32
        MOV      R5,R0
// 3176     int ret;
// 3177     const size_t hs_len = ssl->out_msglen - 4;
        LDR      R7,[R5, #+204]
        SUBS     R7,R7,#+4
// 3178     const unsigned char hs_type = ssl->out_msg[0];
        LDR      R0,[R5, #+196]
        LDRB     R4,[R0, #+0]
// 3179 
// 3180     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write handshake message" ) );
        LDR.W    R6,??DataTable25_8
        LDR.W    R0,??DataTable28_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+3180
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3181 
// 3182     /*
// 3183      * Sanity checks
// 3184      */
// 3185     if( ssl->out_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE          &&
// 3186         ssl->out_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )
        LDR      R0,[R5, #+200]
        CMP      R0,#+22
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_0
        CMP      R0,#+20
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_0
// 3187     {
// 3188         /* In SSLv3, the client might send a NoCertificate alert. */
// 3189 #if defined(MBEDTLS_SSL_PROTO_SSL3) && defined(MBEDTLS_SSL_CLI_C)
// 3190         if( ! ( ssl->minor_ver      == MBEDTLS_SSL_MINOR_VERSION_0 &&
// 3191                 ssl->out_msgtype    == MBEDTLS_SSL_MSG_ALERT       &&
// 3192                 ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT ) )
// 3193 #endif /* MBEDTLS_SSL_PROTO_SSL3 && MBEDTLS_SSL_SRV_C */
// 3194         {
// 3195             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable28_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+3195
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3196             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable25_13  ;; 0xffff9400
        POP      {R1-R7,PC}
// 3197         }
// 3198     }
// 3199 
// 3200     if( ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
// 3201         hs_type != MBEDTLS_SSL_HS_HELLO_REQUEST &&
// 3202         ssl->handshake == NULL )
??mbedtls_ssl_write_handshake_msg_0:
        CMP      R0,#+22
        BNE.N    ??mbedtls_ssl_write_handshake_msg_1
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_1
        LDR      R0,[R5, #+60]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_write_handshake_msg_1
// 3203     {
// 3204         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable28_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+3204
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3205         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable25_13  ;; 0xffff9400
        POP      {R1-R7,PC}
// 3206     }
// 3207 
// 3208 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 3209     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 3210         ssl->handshake != NULL &&
// 3211         ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )
??mbedtls_ssl_write_handshake_msg_1:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_2
        LDR      R0,[R5, #+60]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_2
        LDRB     R0,[R0, #+488]
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_write_handshake_msg_2
// 3212     {
// 3213         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable28_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+3213
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3214         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable25_13  ;; 0xffff9400
        POP      {R1-R7,PC}
// 3215     }
// 3216 #endif
// 3217 
// 3218     /* Double-check that we did not exceed the bounds
// 3219      * of the outgoing record buffer.
// 3220      * This should never fail as the various message
// 3221      * writing functions must obey the bounds of the
// 3222      * outgoing record buffer, but better be safe.
// 3223      *
// 3224      * Note: We deliberately do not check for the MTU or MFL here.
// 3225      */
// 3226     if( ssl->out_msglen > MBEDTLS_SSL_OUT_CONTENT_LEN )
??mbedtls_ssl_write_handshake_msg_2:
        LDR      R0,[R5, #+204]
        MOVW     R1,#+10241
        CMP      R0,R1
        BCC.N    ??mbedtls_ssl_write_handshake_msg_3
// 3227     {
// 3228         MBEDTLS_SSL_DEBUG_MSG( 1, ( "Record too large: "
// 3229                                     "size %u, maximum %u",
// 3230                                     (unsigned) ssl->out_msglen,
// 3231                                     (unsigned) MBEDTLS_SSL_OUT_CONTENT_LEN ) );
        MOV      R0,#+10240
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+204]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable28_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+3231
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3232         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable25_13  ;; 0xffff9400
        POP      {R1-R7,PC}
// 3233     }
// 3234 
// 3235     /*
// 3236      * Fill handshake headers
// 3237      */
// 3238     if( ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
??mbedtls_ssl_write_handshake_msg_3:
        LDR      R0,[R5, #+200]
        CMP      R0,#+22
        BNE.N    ??mbedtls_ssl_write_handshake_msg_4
// 3239     {
// 3240         ssl->out_msg[1] = (unsigned char)( hs_len >> 16 );
        MOV      R0,R7
        LSRS     R0,R0,#+16
        LDR      R1,[R5, #+196]
        STRB     R0,[R1, #+1]
// 3241         ssl->out_msg[2] = (unsigned char)( hs_len >>  8 );
        MOV      R0,R7
        LSRS     R0,R0,#+8
        LDR      R1,[R5, #+196]
        STRB     R0,[R1, #+2]
// 3242         ssl->out_msg[3] = (unsigned char)( hs_len       );
        LDR      R0,[R5, #+196]
        STRB     R7,[R0, #+3]
// 3243 
// 3244         /*
// 3245          * DTLS has additional fields in the Handshake layer,
// 3246          * between the length field and the actual payload:
// 3247          *      uint16 message_seq;
// 3248          *      uint24 fragment_offset;
// 3249          *      uint24 fragment_length;
// 3250          */
// 3251 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 3252         if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_5
// 3253         {
// 3254             /* Make room for the additional DTLS fields */
// 3255             if( MBEDTLS_SSL_OUT_CONTENT_LEN - ssl->out_msglen < 8 )
        LDR      R0,[R5, #+204]
        RSB      R0,R0,#+10240
        CMP      R0,#+8
        BCS.N    ??mbedtls_ssl_write_handshake_msg_6
// 3256             {
// 3257                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "DTLS handshake message too large: "
// 3258                               "size %u, maximum %u",
// 3259                                (unsigned) ( hs_len ),
// 3260                                (unsigned) ( MBEDTLS_SSL_OUT_CONTENT_LEN - 12 ) ) );
        MOVW     R0,#+10228
        STR      R0,[SP, #+8]
        STR      R7,[SP, #+4]
        LDR.W    R0,??DataTable28_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+3260
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3261                 return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.N    R0,??DataTable23_2  ;; 0xffff8f00
        POP      {R1-R7,PC}
// 3262             }
// 3263 
// 3264             memmove( ssl->out_msg + 12, ssl->out_msg + 4, hs_len );
??mbedtls_ssl_write_handshake_msg_6:
        MOV      R2,R7
        LDR      R0,[R5, #+196]
        ADDS     R1,R0,#+4
        ADDS     R0,R0,#+12
          CFI FunCall __aeabi_memmove
        BL       __aeabi_memmove
// 3265             ssl->out_msglen += 8;
        LDR      R0,[R5, #+204]
        ADDS     R0,R0,#+8
        STR      R0,[R5, #+204]
// 3266 
// 3267             /* Write message_seq and update it, except for HelloRequest */
// 3268             if( hs_type != MBEDTLS_SSL_HS_HELLO_REQUEST )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_7
// 3269             {
// 3270                 ssl->out_msg[4] = ( ssl->handshake->out_msg_seq >> 8 ) & 0xFF;
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+468]
        LSRS     R0,R0,#+8
        LDR      R1,[R5, #+196]
        STRB     R0,[R1, #+4]
// 3271                 ssl->out_msg[5] = ( ssl->handshake->out_msg_seq      ) & 0xFF;
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+468]
        LDR      R1,[R5, #+196]
        STRB     R0,[R1, #+5]
// 3272                 ++( ssl->handshake->out_msg_seq );
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+468]
        ADDS     R0,R0,#+1
        LDR      R1,[R5, #+60]
        STR      R0,[R1, #+468]
        B.N      ??mbedtls_ssl_write_handshake_msg_8
// 3273             }
// 3274             else
// 3275             {
// 3276                 ssl->out_msg[4] = 0;
??mbedtls_ssl_write_handshake_msg_7:
        MOVS     R0,#+0
        LDR      R1,[R5, #+196]
        STRB     R0,[R1, #+4]
// 3277                 ssl->out_msg[5] = 0;
        LDR      R1,[R5, #+196]
        STRB     R0,[R1, #+5]
// 3278             }
// 3279 
// 3280             /* Handshake hashes are computed without fragmentation,
// 3281              * so set frag_offset = 0 and frag_len = hs_len for now */
// 3282             memset( ssl->out_msg + 6, 0x00, 3 );
??mbedtls_ssl_write_handshake_msg_8:
        MOVS     R2,#+0
        MOVS     R1,#+3
        LDR      R0,[R5, #+196]
        ADDS     R0,R0,#+6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 3283             memcpy( ssl->out_msg + 9, ssl->out_msg + 1, 3 );
        MOVS     R2,#+3
        LDR      R0,[R5, #+196]
        ADDS     R1,R0,#+1
        ADDS     R0,R0,#+9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 3284         }
// 3285 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 3286 
// 3287         /* Update running hashes of handshake messages seen */
// 3288         if( hs_type != MBEDTLS_SSL_HS_HELLO_REQUEST )
??mbedtls_ssl_write_handshake_msg_5:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_4
// 3289             ssl->handshake->update_checksum( ssl, ssl->out_msg, ssl->out_msglen );
        LDR      R2,[R5, #+204]
        LDR      R1,[R5, #+196]
        MOV      R0,R5
        LDR      R3,[R5, #+60]
        LDR      R3,[R3, #+1096]
          CFI FunCall
        BLX      R3
// 3290     }
// 3291 
// 3292     /* Either send now, or just save to be sent (and resent) later */
// 3293 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 3294     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 3295         ( ssl->out_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||
// 3296           hs_type != MBEDTLS_SSL_HS_HELLO_REQUEST ) )
??mbedtls_ssl_write_handshake_msg_4:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_9
        LDR      R0,[R5, #+200]
        CMP      R0,#+22
        BNE.N    ??mbedtls_ssl_write_handshake_msg_10
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_9
// 3297     {
// 3298         if( ( ret = ssl_flight_append( ssl ) ) != 0 )
??mbedtls_ssl_write_handshake_msg_10:
        MOV      R0,R5
          CFI FunCall ssl_flight_append
        BL       ssl_flight_append
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_11
// 3299         {
// 3300             MBEDTLS_SSL_DEBUG_RET( 1, "ssl_flight_append", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable28_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+3300
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 3301             return( ret );
        MOV      R0,R4
        POP      {R1-R7,PC}
// 3302         }
// 3303     }
// 3304     else
// 3305 #endif
// 3306     {
// 3307         if( ( ret = mbedtls_ssl_write_record( ssl, SSL_FORCE_FLUSH ) ) != 0 )
??mbedtls_ssl_write_handshake_msg_9:
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_write_record
        BL       mbedtls_ssl_write_record
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_write_handshake_msg_11
// 3308         {
// 3309             MBEDTLS_SSL_DEBUG_RET( 1, "ssl_write_record", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable28_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+3309
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 3310             return( ret );
        MOV      R0,R4
        POP      {R1-R7,PC}
// 3311         }
// 3312     }
// 3313 
// 3314     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write handshake message" ) );
??mbedtls_ssl_write_handshake_msg_11:
        LDR.W    R0,??DataTable30
        STR      R0,[SP, #+0]
        MOVW     R3,#+3314
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3315 
// 3316     return( 0 );
        MOVS     R0,#+0
        POP      {R1-R7,PC}       ;; return
// 3317 }
          CFI EndBlock cfiBlock40

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23:
        DATA32
        DC32     0xffff9480

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_1:
        DATA32
        DC32     ?_65

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_2:
        DATA32
        DC32     0xffff8f00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_3:
        DATA32
        DC32     ?_66

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_4:
        DATA32
        DC32     ?_67

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_5:
        DATA32
        DC32     ?_68

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_6:
        DATA32
        DC32     ?_69

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_7:
        DATA32
        DC32     ?_70

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_8:
        DATA32
        DC32     ?_71

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_9:
        DATA32
        DC32     0xffff9800

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_10:
        DATA32
        DC32     ?_72

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_11:
        DATA32
        DC32     ?_73

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_12:
        DATA32
        DC32     ?_74

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_13:
        DATA32
        DC32     ?_75

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_14:
        DATA32
        DC32     ?_76

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_15:
        DATA32
        DC32     0xffff9700
// 3318 
// 3319 /*
// 3320  * Record layer functions
// 3321  */
// 3322 
// 3323 /*
// 3324  * Write current record.
// 3325  *
// 3326  * Uses:
// 3327  *  - ssl->out_msgtype: type of the message (AppData, Handshake, Alert, CCS)
// 3328  *  - ssl->out_msglen: length of the record content (excl headers)
// 3329  *  - ssl->out_msg: record content
// 3330  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function mbedtls_ssl_write_record
        THUMB
// 3331 int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl, uint8_t force_flush )
// 3332 {
mbedtls_ssl_write_record:
        PUSH     {R3-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+28
        SUB      SP,SP,#+20
          CFI CFA R13+48
        MOV      R7,R0
// 3333     int ret, done = 0;
// 3334     size_t len = ssl->out_msglen;
        LDR      R4,[R7, #+204]
// 3335     uint8_t flush = force_flush;
        MOV      R5,R1
// 3336 
// 3337     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write record" ) );
        LDR.N    R6,??DataTable25_8
        LDR.W    R0,??DataTable29
        STR      R0,[SP, #+0]
        MOVW     R3,#+3337
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3338 
// 3339 #if defined(MBEDTLS_ZLIB_SUPPORT)
// 3340     if( ssl->transform_out != NULL &&
// 3341         ssl->session_out->compression == MBEDTLS_SSL_COMPRESS_DEFLATE )
// 3342     {
// 3343         if( ( ret = ssl_compress_buf( ssl ) ) != 0 )
// 3344         {
// 3345             MBEDTLS_SSL_DEBUG_RET( 1, "ssl_compress_buf", ret );
// 3346             return( ret );
// 3347         }
// 3348 
// 3349         len = ssl->out_msglen;
// 3350     }
// 3351 #endif /*MBEDTLS_ZLIB_SUPPORT */
// 3352 
// 3353 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
// 3354     if( mbedtls_ssl_hw_record_write != NULL )
// 3355     {
// 3356         MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_write()" ) );
// 3357 
// 3358         ret = mbedtls_ssl_hw_record_write( ssl );
// 3359         if( ret != 0 && ret != MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH )
// 3360         {
// 3361             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_write", ret );
// 3362             return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
// 3363         }
// 3364 
// 3365         if( ret == 0 )
// 3366             done = 1;
// 3367     }
// 3368 #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
// 3369     if( !done )
// 3370     {
// 3371         unsigned i;
// 3372         size_t protected_record_size;
// 3373 
// 3374         ssl->out_hdr[0] = (unsigned char) ssl->out_msgtype;
        LDR      R0,[R7, #+200]
        LDR      R1,[R7, #+184]
        STRB     R0,[R1, #+0]
// 3375         mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
// 3376                            ssl->conf->transport, ssl->out_hdr + 1 );
        LDR      R0,[R7, #+184]
        ADDS     R3,R0,#+1
        LDR      R0,[R7, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R2,R0,#+1,#+1
        LDR      R1,[R7, #+20]
        LDR      R0,[R7, #+16]
          CFI FunCall mbedtls_ssl_write_version
        BL       mbedtls_ssl_write_version
// 3377 
// 3378         memcpy( ssl->out_ctr, ssl->cur_out_ctr, 8 );
        MOVS     R2,#+8
        ADD      R1,R7,#+212
        LDR      R0,[R7, #+180]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 3379         ssl->out_len[0] = (unsigned char)( len >> 8 );
        MOV      R0,R4
        LSRS     R0,R0,#+8
        LDR      R1,[R7, #+188]
        STRB     R0,[R1, #+0]
// 3380         ssl->out_len[1] = (unsigned char)( len      );
        LDR      R0,[R7, #+188]
        STRB     R4,[R0, #+1]
// 3381 
// 3382         if( ssl->transform_out != NULL )
        LDR      R0,[R7, #+68]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_record_0
// 3383         {
// 3384             if( ( ret = ssl_encrypt_buf( ssl ) ) != 0 )
        MOV      R0,R7
          CFI FunCall ssl_encrypt_buf
        BL       ssl_encrypt_buf
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_write_record_1
// 3385             {
// 3386                 MBEDTLS_SSL_DEBUG_RET( 1, "ssl_encrypt_buf", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable29_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+3386
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 3387                 return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_write_record_2
// 3388             }
// 3389 
// 3390             len = ssl->out_msglen;
??mbedtls_ssl_write_record_1:
        LDR      R4,[R7, #+204]
// 3391             ssl->out_len[0] = (unsigned char)( len >> 8 );
        MOV      R0,R4
        LSRS     R0,R0,#+8
        LDR      R1,[R7, #+188]
        STRB     R0,[R1, #+0]
// 3392             ssl->out_len[1] = (unsigned char)( len      );
        LDR      R0,[R7, #+188]
        STRB     R4,[R0, #+1]
// 3393         }
// 3394 
// 3395         protected_record_size = len + mbedtls_ssl_hdr_len( ssl );
??mbedtls_ssl_write_record_0:
        MOV      R0,R7
          CFI FunCall mbedtls_ssl_hdr_len
        BL       mbedtls_ssl_hdr_len
        MOV      R8,R0
        ADD      R8,R8,R4
// 3396 
// 3397 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 3398         /* In case of DTLS, double-check that we don't exceed
// 3399          * the remaining space in the datagram. */
// 3400         if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R7, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_record_3
// 3401         {
// 3402             ret = ssl_get_remaining_space_in_datagram( ssl );
        MOV      R0,R7
          CFI FunCall ssl_get_remaining_space_in_datagram
        BL       ssl_get_remaining_space_in_datagram
// 3403             if( ret < 0 )
        CMP      R0,#+0
        BMI.W    ??mbedtls_ssl_write_record_2
// 3404                 return( ret );
// 3405 
// 3406             if( protected_record_size > (size_t) ret )
        CMP      R0,R8
        BCS.N    ??mbedtls_ssl_write_record_3
// 3407             {
// 3408                 /* Should never happen */
// 3409                 return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.N    R0,??DataTable25_13  ;; 0xffff9400
        B.N      ??mbedtls_ssl_write_record_2
// 3410             }
// 3411         }
// 3412 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 3413 
// 3414         MBEDTLS_SSL_DEBUG_MSG( 3, ( "output record: msgtype = %d, "
// 3415                                     "version = [%d:%d], msglen = %d",
// 3416                                     ssl->out_hdr[0], ssl->out_hdr[1],
// 3417                                     ssl->out_hdr[2], len ) );
??mbedtls_ssl_write_record_3:
        STR      R4,[SP, #+16]
        LDR      R0,[R7, #+184]
        LDRB     R0,[R0, #+2]
        STR      R0,[SP, #+12]
        LDR      R0,[R7, #+184]
        LDRB     R0,[R0, #+1]
        STR      R0,[SP, #+8]
        LDR      R0,[R7, #+184]
        LDRB     R0,[R0, #+0]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable30_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+3417
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3418 
// 3419         MBEDTLS_SSL_DEBUG_BUF( 4, "output record sent to network",
// 3420                                ssl->out_hdr, protected_record_size );
        STR      R8,[SP, #+8]
        LDR      R0,[R7, #+184]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable30_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+3420
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 3421 
// 3422         ssl->out_left += protected_record_size;
        LDR      R0,[R7, #+208]
        ADD      R0,R8,R0
        STR      R0,[R7, #+208]
// 3423         ssl->out_hdr  += protected_record_size;
        LDR      R0,[R7, #+184]
        ADD      R0,R0,R8
        STR      R0,[R7, #+184]
// 3424         ssl_update_out_pointers( ssl, ssl->transform_out );
        LDR      R1,[R7, #+68]
        MOV      R0,R7
          CFI FunCall ssl_update_out_pointers
        BL       ssl_update_out_pointers
// 3425 
// 3426         for( i = 8; i > ssl_ep_len( ssl ); i-- )
        MOVS     R4,#+8
??mbedtls_ssl_write_record_4:
        MOV      R0,R7
          CFI FunCall ssl_ep_len
        BL       ssl_ep_len
        CMP      R0,R4
        BCS.N    ??mbedtls_ssl_write_record_5
// 3427             if( ++ssl->cur_out_ctr[i - 1] != 0 )
        ADDS     R0,R7,R4
        LDRB     R0,[R0, #+211]
        ADDS     R0,R0,#+1
        ADDS     R1,R7,R4
        STRB     R0,[R1, #+211]
        ADDS     R0,R7,R4
        LDRB     R0,[R0, #+211]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_write_record_5
        SUBS     R4,R4,#+1
        B.N      ??mbedtls_ssl_write_record_4
// 3428                 break;
// 3429 
// 3430         /* The loop goes to its end iff the counter is wrapping */
// 3431         if( i == ssl_ep_len( ssl ) )
// 3432         {
// 3433             MBEDTLS_SSL_DEBUG_MSG( 1, ( "outgoing message counter would wrap" ) );
// 3434             return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
// 3435         }
// 3436     }
// 3437 
// 3438 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 3439     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 3440         flush == SSL_DONT_FORCE_FLUSH )
??mbedtls_ssl_write_record_6:
        LDR      R0,[R7, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_record_7
        MOVS     R0,R5
        BNE.N    ??mbedtls_ssl_write_record_7
// 3441     {
// 3442         size_t remaining;
// 3443         ret = ssl_get_remaining_payload_in_datagram( ssl );
        MOV      R0,R7
          CFI FunCall ssl_get_remaining_payload_in_datagram
        BL       ssl_get_remaining_payload_in_datagram
        MOVS     R4,R0
// 3444         if( ret < 0 )
        BPL.N    ??mbedtls_ssl_write_record_8
// 3445         {
// 3446             MBEDTLS_SSL_DEBUG_RET( 1, "ssl_get_remaining_payload_in_datagram",
// 3447                                    ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable30_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+3447
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 3448             return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_write_record_2
// 3449         }
// 3450 
// 3451         remaining = (size_t) ret;
// 3452         if( remaining == 0 )
??mbedtls_ssl_write_record_8:
        BNE.N    ??mbedtls_ssl_write_record_9
// 3453         {
// 3454             flush = SSL_FORCE_FLUSH;
        MOVS     R5,#+1
        B.N      ??mbedtls_ssl_write_record_7
// 3455         }
// 3456         else
// 3457         {
// 3458             MBEDTLS_SSL_DEBUG_MSG( 2, ( "Still %u bytes available in current datagram", (unsigned) remaining ) );
??mbedtls_ssl_write_record_9:
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable30_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+3458
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3459         }
// 3460     }
// 3461 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 3462 
// 3463     if( ( flush == SSL_FORCE_FLUSH ) &&
// 3464         ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
??mbedtls_ssl_write_record_7:
        CMP      R5,#+1
        BNE.N    ??mbedtls_ssl_write_record_10
        MOV      R0,R7
          CFI FunCall mbedtls_ssl_flush_output
        BL       mbedtls_ssl_flush_output
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_write_record_10
// 3465     {
// 3466         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_flush_output", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable30_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+3466
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 3467         return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_write_record_2
// 3468     }
// 3469 
// 3470     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write record" ) );
??mbedtls_ssl_write_record_10:
        LDR.W    R0,??DataTable30_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+3470
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3471 
// 3472     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_write_record_2:
        ADD      SP,SP,#+24
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI CFA R13+48
??mbedtls_ssl_write_record_5:
        MOV      R0,R7
          CFI FunCall ssl_ep_len
        BL       ssl_ep_len
        CMP      R4,R0
        BNE.N    ??mbedtls_ssl_write_record_6
        LDR.W    R0,??DataTable31
        STR      R0,[SP, #+0]
        MOVW     R3,#+3433
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable31_1  ;; 0xffff9480
        B.N      ??mbedtls_ssl_write_record_2
// 3473 }
          CFI EndBlock cfiBlock41

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24:
        DATA32
        DC32     ?_77
// 3474 
// 3475 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 3476 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function ssl_hs_is_proper_fragment
        THUMB
// 3477 static int ssl_hs_is_proper_fragment( mbedtls_ssl_context *ssl )
// 3478 {
ssl_hs_is_proper_fragment:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 3479     if( ssl->in_msglen < ssl->in_hslen ||
// 3480         memcmp( ssl->in_msg + 6, "\0\0\0",        3 ) != 0 ||
// 3481         memcmp( ssl->in_msg + 9, ssl->in_msg + 1, 3 ) != 0 )
        LDR      R0,[R4, #+124]
        LDR      R1,[R4, #+160]
        CMP      R0,R1
        BCC.N    ??ssl_hs_is_proper_fragment_0
        MOVS     R2,#+3
        ADR.N    R1,??DataTable25_7  ;; 0x00, 0x00, 0x00, 0x00
        LDR      R0,[R4, #+112]
        ADDS     R0,R0,#+6
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BNE.N    ??ssl_hs_is_proper_fragment_0
        MOVS     R2,#+3
        LDR      R0,[R4, #+112]
        ADDS     R1,R0,#+1
        ADDS     R0,R0,#+9
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ.N    ??ssl_hs_is_proper_fragment_1
// 3482     {
// 3483         return( 1 );
??ssl_hs_is_proper_fragment_0:
        MOVS     R0,#+1
        POP      {R4,PC}
// 3484     }
// 3485     return( 0 );
??ssl_hs_is_proper_fragment_1:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
// 3486 }
          CFI EndBlock cfiBlock42

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25:
        DATA32
        DC32     0xffff8d80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_1:
        DATA32
        DC32     ?_78

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_2:
        DATA32
        DC32     ?_79

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_3:
        DATA32
        DC32     ?_80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_4:
        DATA32
        DC32     ?_81

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_5:
        DATA32
        DC32     ?_82

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_6:
        DATA32
        DC32     ?_83

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_7:
        DATA8
        DC8      0x00, 0x00, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_8:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_9:
        DATA32
        DC32     ?_84

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_10:
        DATA32
        DC32     ?_85

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_11:
        DATA32
        DC32     ?_86

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_12:
        DATA32
        DC32     0xffff8100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_13:
        DATA32
        DC32     0xffff9400
// 3487 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function ssl_get_hs_frag_len
          CFI NoCalls
        THUMB
// 3488 static uint32_t ssl_get_hs_frag_len( mbedtls_ssl_context const *ssl )
// 3489 {
ssl_get_hs_frag_len:
        MOV      R1,R0
// 3490     return( ( ssl->in_msg[9] << 16  ) |
// 3491             ( ssl->in_msg[10] << 8  ) |
// 3492               ssl->in_msg[11] );
        LDR      R0,[R1, #+112]
        LDRB     R2,[R0, #+9]
        LDRB     R0,[R0, #+10]
        LSLS     R0,R0,#+8
        ORR      R0,R0,R2, LSL #+16
        LDR      R1,[R1, #+112]
        LDRB     R1,[R1, #+11]
        ORRS     R0,R1,R0
        BX       LR               ;; return
// 3493 }
          CFI EndBlock cfiBlock43
// 3494 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function ssl_get_hs_frag_off
          CFI NoCalls
        THUMB
// 3495 static uint32_t ssl_get_hs_frag_off( mbedtls_ssl_context const *ssl )
// 3496 {
ssl_get_hs_frag_off:
        MOV      R1,R0
// 3497     return( ( ssl->in_msg[6] << 16 ) |
// 3498             ( ssl->in_msg[7] << 8  ) |
// 3499               ssl->in_msg[8] );
        LDR      R0,[R1, #+112]
        LDRB     R2,[R0, #+6]
        LDRB     R0,[R0, #+7]
        LSLS     R0,R0,#+8
        ORR      R0,R0,R2, LSL #+16
        LDR      R1,[R1, #+112]
        LDRB     R1,[R1, #+8]
        ORRS     R0,R1,R0
        BX       LR               ;; return
// 3500 }
          CFI EndBlock cfiBlock44
// 3501 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function ssl_check_hs_header
        THUMB
// 3502 static int ssl_check_hs_header( mbedtls_ssl_context const *ssl )
// 3503 {
ssl_check_hs_header:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 3504     uint32_t msg_len, frag_off, frag_len;
// 3505 
// 3506     msg_len  = ssl_get_hs_total_len( ssl );
          CFI FunCall ssl_get_hs_total_len
        BL       ssl_get_hs_total_len
        MOV      R5,R0
// 3507     frag_off = ssl_get_hs_frag_off( ssl );
        MOV      R0,R4
          CFI FunCall ssl_get_hs_frag_off
        BL       ssl_get_hs_frag_off
        MOV      R6,R0
// 3508     frag_len = ssl_get_hs_frag_len( ssl );
        MOV      R0,R4
          CFI FunCall ssl_get_hs_frag_len
        BL       ssl_get_hs_frag_len
// 3509 
// 3510     if( frag_off > msg_len )
        CMP      R5,R6
        BCS.N    ??ssl_check_hs_header_0
// 3511         return( -1 );
        MOV      R0,#-1
        POP      {R4-R6,PC}
// 3512 
// 3513     if( frag_len > msg_len - frag_off )
??ssl_check_hs_header_0:
        SUBS     R5,R5,R6
        CMP      R5,R0
        BCS.N    ??ssl_check_hs_header_1
// 3514         return( -1 );
        MOV      R0,#-1
        POP      {R4-R6,PC}
// 3515 
// 3516     if( frag_len + 12 > ssl->in_msglen )
??ssl_check_hs_header_1:
        LDR      R1,[R4, #+124]
        ADDS     R0,R0,#+12
        CMP      R1,R0
        BCS.N    ??ssl_check_hs_header_2
// 3517         return( -1 );
        MOV      R0,#-1
        POP      {R4-R6,PC}
// 3518 
// 3519     return( 0 );
??ssl_check_hs_header_2:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
// 3520 }
          CFI EndBlock cfiBlock45
// 3521 
// 3522 /*
// 3523  * Mark bits in bitmask (used for DTLS HS reassembly)
// 3524  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function ssl_bitmask_set
        THUMB
// 3525 static void ssl_bitmask_set( unsigned char *mask, size_t offset, size_t len )
// 3526 {
ssl_bitmask_set:
        PUSH     {R4-R7}
          CFI R7 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R3,R0
        MOV      R4,R1
        MOV      R1,R2
// 3527     unsigned int start_bits, end_bits;
// 3528 
// 3529     start_bits = 8 - ( offset % 8 );
        AND      R0,R4,#0x7
        RSB      R0,R0,#+8
// 3530     if( start_bits != 8 )
        CMP      R0,#+8
        BEQ.N    ??ssl_bitmask_set_0
// 3531     {
// 3532         size_t first_byte_idx = offset / 8;
        MOV      R2,R4
        LSRS     R2,R2,#+3
// 3533 
// 3534         /* Special case */
// 3535         if( len <= start_bits )
        CMP      R0,R1
        BCS.N    ??ssl_bitmask_set_1
// 3536         {
// 3537             for( ; len != 0; len-- )
// 3538                 mask[first_byte_idx] |= 1 << ( start_bits - len );
// 3539 
// 3540             /* Avoid potential issues with offset or len becoming invalid */
// 3541             return;
// 3542         }
// 3543 
// 3544         offset += start_bits; /* Now offset % 8 == 0 */
        ADDS     R4,R0,R4
// 3545         len -= start_bits;
        SUBS     R1,R1,R0
        CMP      R0,#+0
        B.N      ??ssl_bitmask_set_2
??ssl_bitmask_set_3:
        LDRB     R4,[R3, R2]
        MOVS     R5,#+1
        SUBS     R6,R0,R1
        LSLS     R5,R5,R6
        ORRS     R4,R5,R4
        STRB     R4,[R3, R2]
        SUBS     R1,R1,#+1
??ssl_bitmask_set_1:
        CMP      R1,#+0
        BNE.N    ??ssl_bitmask_set_3
        B.N      ??ssl_bitmask_set_4
// 3546 
// 3547         for( ; start_bits != 0; start_bits-- )
// 3548             mask[first_byte_idx] |= 1 << ( start_bits - 1 );
??ssl_bitmask_set_5:
        LDRB     R5,[R3, R2]
        MOVS     R6,#+1
        MOV      R7,R0
        SUBS     R7,R7,#+1
        LSLS     R6,R6,R7
        ORRS     R5,R6,R5
        STRB     R5,[R3, R2]
        SUBS     R0,R0,#+1
??ssl_bitmask_set_2:
        BNE.N    ??ssl_bitmask_set_5
// 3549     }
// 3550 
// 3551     end_bits = len % 8;
??ssl_bitmask_set_0:
        ANDS     R0,R1,#0x7
// 3552     if( end_bits != 0 )
        BEQ.N    ??ssl_bitmask_set_6
// 3553     {
// 3554         size_t last_byte_idx = ( offset + len ) / 8;
        ADDS     R2,R1,R4
        LSRS     R2,R2,#+3
// 3555 
// 3556         len -= end_bits; /* Now len % 8 == 0 */
        SUBS     R1,R1,R0
        CMP      R0,#+0
        B.N      ??ssl_bitmask_set_7
// 3557 
// 3558         for( ; end_bits != 0; end_bits-- )
// 3559             mask[last_byte_idx] |= 1 << ( 8 - end_bits );
??ssl_bitmask_set_8:
        LDRB     R5,[R3, R2]
        MOVS     R6,#+1
        RSB      R7,R0,#+8
        LSLS     R6,R6,R7
        ORRS     R5,R6,R5
        STRB     R5,[R3, R2]
        SUBS     R0,R0,#+1
??ssl_bitmask_set_7:
        BNE.N    ??ssl_bitmask_set_8
// 3560     }
// 3561 
// 3562     memset( mask + offset / 8, 0xFF, len / 8 );
??ssl_bitmask_set_6:
        MOVS     R2,#+255
        LSRS     R1,R1,#+3
        ADDS     R0,R3,R4, LSR #+3
        POP      {R4-R7}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_memset
        B.W      __aeabi_memset
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R7 Frame(CFA, -4)
          CFI CFA R13+16
??ssl_bitmask_set_4:
        POP      {R4-R7}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
// 3563 }
          CFI EndBlock cfiBlock46
// 3564 
// 3565 /*
// 3566  * Check that bitmask is full
// 3567  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function ssl_bitmask_check
          CFI NoCalls
        THUMB
// 3568 static int ssl_bitmask_check( unsigned char *mask, size_t len )
// 3569 {
ssl_bitmask_check:
        PUSH     {R4,R5}
          CFI R5 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 3570     size_t i;
// 3571 
// 3572     for( i = 0; i < len / 8; i++ )
        MOVS     R2,#+0
        B.N      ??ssl_bitmask_check_0
// 3573         if( mask[i] != 0xFF )
??ssl_bitmask_check_1:
        LDRB     R3,[R0, R2]
        CMP      R3,#+255
        BNE.N    ??ssl_bitmask_check_2
        ADDS     R2,R2,#+1
??ssl_bitmask_check_0:
        CMP      R2,R1, LSR #+3
        BCC.N    ??ssl_bitmask_check_1
// 3574             return( -1 );
// 3575 
// 3576     for( i = 0; i < len % 8; i++ )
        MOVS     R2,#+0
??ssl_bitmask_check_3:
        AND      R3,R1,#0x7
        CMP      R2,R3
        BCS.N    ??ssl_bitmask_check_4
// 3577         if( ( mask[len / 8] & ( 1 << ( 7 - i ) ) ) == 0 )
        MOV      R3,R1
        LSRS     R3,R3,#+3
        LDRB     R3,[R0, R3]
        MOVS     R4,#+1
        RSB      R5,R2,#+7
        LSLS     R4,R4,R5
        TST      R3,R4
        BEQ.N    ??ssl_bitmask_check_2
        ADDS     R2,R2,#+1
        B.N      ??ssl_bitmask_check_3
// 3578             return( -1 );
??ssl_bitmask_check_2:
        MOV      R0,#-1
        B.N      ??ssl_bitmask_check_5
// 3579 
// 3580     return( 0 );
??ssl_bitmask_check_4:
        MOVS     R0,#+0
??ssl_bitmask_check_5:
        POP      {R4,R5}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
// 3581 }
          CFI EndBlock cfiBlock47
// 3582 
// 3583 /* msg_len does not include the handshake header */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function ssl_get_reassembly_buffer_size
          CFI NoCalls
        THUMB
// 3584 static size_t ssl_get_reassembly_buffer_size( size_t msg_len,
// 3585                                               unsigned add_bitmap )
// 3586 {
ssl_get_reassembly_buffer_size:
        MOV      R2,R0
// 3587     size_t alloc_len;
// 3588 
// 3589     alloc_len  = 12;                                 /* Handshake header */
// 3590     alloc_len += msg_len;                            /* Content buffer   */
        ADD      R0,R2,#+12
// 3591 
// 3592     if( add_bitmap )
        CMP      R1,#+0
        BEQ.N    ??ssl_get_reassembly_buffer_size_0
// 3593         alloc_len += msg_len / 8 + ( msg_len % 8 != 0 ); /* Bitmap       */
        AND      R1,R2,#0x7
        SUBS     R1,R1,#+1
        SBCS     R1,R1,R1
        MVNS     R1,R1
        LSRS     R2,R2,#+3
        ADDS     R1,R2,R1, LSR #+31
        ADDS     R0,R1,R0
// 3594 
// 3595     return( alloc_len );
??ssl_get_reassembly_buffer_size_0:
        BX       LR               ;; return
// 3596 }
          CFI EndBlock cfiBlock48
// 3597 
// 3598 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 3599 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function ssl_get_hs_total_len
          CFI NoCalls
        THUMB
// 3600 static uint32_t ssl_get_hs_total_len( mbedtls_ssl_context const *ssl )
// 3601 {
ssl_get_hs_total_len:
        MOV      R1,R0
// 3602     return( ( ssl->in_msg[1] << 16 ) |
// 3603             ( ssl->in_msg[2] << 8  ) |
// 3604               ssl->in_msg[3] );
        LDR      R0,[R1, #+112]
        LDRB     R2,[R0, #+1]
        LDRB     R0,[R0, #+2]
        LSLS     R0,R0,#+8
        ORR      R0,R0,R2, LSL #+16
        LDR      R1,[R1, #+112]
        LDRB     R1,[R1, #+3]
        ORRS     R0,R1,R0
        BX       LR               ;; return
// 3605 }
          CFI EndBlock cfiBlock49
// 3606 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function mbedtls_ssl_prepare_handshake_record
        THUMB
// 3607 int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
// 3608 {
mbedtls_ssl_prepare_handshake_record:
        PUSH     {R0-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+32
        MOV      R5,R0
// 3609     if( ssl->in_msglen < mbedtls_ssl_hs_hdr_len( ssl ) )
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        LDR      R1,[R5, #+124]
        CMP      R1,R0
        BCS.N    ??mbedtls_ssl_prepare_handshake_record_0
// 3610     {
// 3611         MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake message too short: %d",
// 3612                             ssl->in_msglen ) );
        MOV      R0,R1
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable32
        STR      R0,[SP, #+0]
        MOVW     R3,#+3612
        LDR.W    R2,??DataTable32_1
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3613         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??mbedtls_ssl_prepare_handshake_record_1
// 3614     }
// 3615 
// 3616     ssl->in_hslen = mbedtls_ssl_hs_hdr_len( ssl ) + ssl_get_hs_total_len( ssl );
??mbedtls_ssl_prepare_handshake_record_0:
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        MOV      R4,R0
        MOV      R0,R5
          CFI FunCall ssl_get_hs_total_len
        BL       ssl_get_hs_total_len
        ADDS     R4,R0,R4
        STR      R4,[R5, #+160]
// 3617 
// 3618     MBEDTLS_SSL_DEBUG_MSG( 3, ( "handshake message: msglen ="
// 3619                         " %d, type = %d, hslen = %d",
// 3620                         ssl->in_msglen, ssl->in_msg[0], ssl->in_hslen ) );
        LDR.W    R6,??DataTable32_1
        MOV      R0,R4
        STR      R0,[SP, #+12]
        LDR      R0,[R5, #+112]
        LDRB     R0,[R0, #+0]
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+124]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable32_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+3620
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3621 
// 3622 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 3623     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.W    ??mbedtls_ssl_prepare_handshake_record_2
// 3624     {
// 3625         int ret;
// 3626         unsigned int recv_msg_seq = ( ssl->in_msg[4] << 8 ) | ssl->in_msg[5];
        LDR      R0,[R5, #+112]
        LDRB     R0,[R0, #+4]
        LDR      R1,[R5, #+112]
        LDRB     R4,[R1, #+5]
        ORR      R4,R4,R0, LSL #+8
// 3627 
// 3628         if( ssl_check_hs_header( ssl ) != 0 )
        MOV      R0,R5
          CFI FunCall ssl_check_hs_header
        BL       ssl_check_hs_header
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_prepare_handshake_record_3
// 3629         {
// 3630             MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid handshake header" ) );
        LDR.W    R0,??DataTable32_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+3630
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3631             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??mbedtls_ssl_prepare_handshake_record_1
// 3632         }
// 3633 
// 3634         if( ssl->handshake != NULL &&
// 3635             ( ( ssl->state   != MBEDTLS_SSL_HANDSHAKE_OVER &&
// 3636                 recv_msg_seq != ssl->handshake->in_msg_seq ) ||
// 3637               ( ssl->state  == MBEDTLS_SSL_HANDSHAKE_OVER &&
// 3638                 ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_HELLO ) ) )
??mbedtls_ssl_prepare_handshake_record_3:
        LDR      R0,[R5, #+60]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_prepare_handshake_record_4
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BEQ.N    ??mbedtls_ssl_prepare_handshake_record_5
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+472]
        CMP      R4,R0
        BNE.N    ??mbedtls_ssl_prepare_handshake_record_6
??mbedtls_ssl_prepare_handshake_record_5:
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BNE.N    ??mbedtls_ssl_prepare_handshake_record_4
        LDR      R0,[R5, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??mbedtls_ssl_prepare_handshake_record_4
// 3639         {
// 3640             if( recv_msg_seq > ssl->handshake->in_msg_seq )
??mbedtls_ssl_prepare_handshake_record_6:
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+472]
        CMP      R0,R4
        LDR      R0,[R5, #+60]
        BCS.N    ??mbedtls_ssl_prepare_handshake_record_7
// 3641             {
// 3642                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "received future handshake message of sequence number %u (next %u)",
// 3643                                             recv_msg_seq,
// 3644                                             ssl->handshake->in_msg_seq ) );
        LDR      R0,[R0, #+472]
        STR      R0,[SP, #+8]
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable33
        STR      R0,[SP, #+0]
        MOVW     R3,#+3644
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3645                 return( MBEDTLS_ERR_SSL_EARLY_MESSAGE );
        LDR.W    R0,??DataTable33_1  ;; 0xffff9b80
        B.N      ??mbedtls_ssl_prepare_handshake_record_1
// 3646             }
// 3647 
// 3648             /* Retransmit only on last message from previous flight, to avoid
// 3649              * too many retransmissions.
// 3650              * Besides, No sane server ever retransmits HelloVerifyRequest */
// 3651             if( recv_msg_seq == ssl->handshake->in_flight_start_seq - 1 &&
// 3652                 ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST )
??mbedtls_ssl_prepare_handshake_record_7:
        LDR      R0,[R0, #+504]
        SUBS     R0,R0,#+1
        CMP      R4,R0
        BNE.N    ??mbedtls_ssl_prepare_handshake_record_8
        LDR      R0,[R5, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+3
        BEQ.N    ??mbedtls_ssl_prepare_handshake_record_8
// 3653             {
// 3654                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "received message from last flight, "
// 3655                                     "message_seq = %d, start_of_flight = %d",
// 3656                                     recv_msg_seq,
// 3657                                     ssl->handshake->in_flight_start_seq ) );
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+504]
        STR      R0,[SP, #+8]
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable33_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+3657
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3658 
// 3659                 if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_resend
        BL       mbedtls_ssl_resend
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_prepare_handshake_record_9
// 3660                 {
// 3661                     MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_resend", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable33_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+3661
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 3662                     return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_prepare_handshake_record_1
// 3663                 }
// 3664             }
// 3665             else
// 3666             {
// 3667                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "dropping out-of-sequence message: "
// 3668                                     "message_seq = %d, expected = %d",
// 3669                                     recv_msg_seq,
// 3670                                     ssl->handshake->in_msg_seq ) );
??mbedtls_ssl_prepare_handshake_record_8:
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+472]
        STR      R0,[SP, #+8]
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable33_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+3670
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3671             }
// 3672 
// 3673             return( MBEDTLS_ERR_SSL_CONTINUE_PROCESSING );
??mbedtls_ssl_prepare_handshake_record_9:
        LDR.W    R0,??DataTable33_5  ;; 0xffff9a80
        B.N      ??mbedtls_ssl_prepare_handshake_record_1
// 3674         }
// 3675         /* Wait until message completion to increment in_msg_seq */
// 3676 
// 3677         /* Message reassembly is handled alongside buffering of future
// 3678          * messages; the commonality is that both handshake fragments and
// 3679          * future messages cannot be forwarded immediately to the
// 3680          * handshake logic layer. */
// 3681         if( ssl_hs_is_proper_fragment( ssl ) == 1 )
??mbedtls_ssl_prepare_handshake_record_4:
        MOV      R0,R5
          CFI FunCall ssl_hs_is_proper_fragment
        BL       ssl_hs_is_proper_fragment
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_prepare_handshake_record_10
// 3682         {
// 3683             MBEDTLS_SSL_DEBUG_MSG( 2, ( "found fragmented DTLS handshake message" ) );
        LDR.W    R0,??DataTable33_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+3683
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3684             return( MBEDTLS_ERR_SSL_EARLY_MESSAGE );
        LDR.W    R0,??DataTable33_1  ;; 0xffff9b80
        B.N      ??mbedtls_ssl_prepare_handshake_record_1
// 3685         }
// 3686     }
// 3687     else
// 3688 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 3689     /* With TLS we don't handle fragmentation (for now) */
// 3690     if( ssl->in_msglen < ssl->in_hslen )
??mbedtls_ssl_prepare_handshake_record_2:
        LDR      R0,[R5, #+124]
        LDR      R1,[R5, #+160]
        CMP      R0,R1
        BCS.N    ??mbedtls_ssl_prepare_handshake_record_10
// 3691     {
// 3692         MBEDTLS_SSL_DEBUG_MSG( 1, ( "TLS handshake fragmentation not supported" ) );
        LDR.W    R0,??DataTable33_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+3692
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 3693         return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
        LDR.W    R0,??DataTable33_8  ;; 0xffff8f80
        B.N      ??mbedtls_ssl_prepare_handshake_record_1
// 3694     }
// 3695 
// 3696     return( 0 );
??mbedtls_ssl_prepare_handshake_record_10:
        MOVS     R0,#+0
??mbedtls_ssl_prepare_handshake_record_1:
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
// 3697 }
          CFI EndBlock cfiBlock50

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26:
        DATA32
        DC32     ?_87

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_1:
        DATA32
        DC32     ?_88

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_2:
        DATA32
        DC32     ?_89

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_3:
        DATA32
        DC32     ?_90

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_4:
        DATA32
        DC32     ?_91

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_5:
        DATA32
        DC32     ?_92

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_6:
        DATA32
        DC32     ?_93

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_7:
        DATA32
        DC32     ?_94

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_8:
        DATA32
        DC32     ?_95

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_9:
        DATA32
        DC32     ?_96
// 3698 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function mbedtls_ssl_update_handshake_status
        THUMB
// 3699 void mbedtls_ssl_update_handshake_status( mbedtls_ssl_context *ssl )
// 3700 {
mbedtls_ssl_update_handshake_status:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R5,R0
// 3701     mbedtls_ssl_handshake_params * const hs = ssl->handshake;
        LDR      R4,[R5, #+60]
// 3702 
// 3703     if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER && hs != NULL )
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BEQ.N    ??mbedtls_ssl_update_handshake_status_0
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_update_handshake_status_0
// 3704     {
// 3705         ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );
        LDR      R2,[R5, #+160]
        LDR      R1,[R5, #+112]
        MOV      R0,R5
        MOV      R3,R4
        LDR      R3,[R3, #+1096]
          CFI FunCall
        BLX      R3
// 3706     }
// 3707 
// 3708     /* Handshake message is complete, increment counter */
// 3709 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 3710     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 3711         ssl->handshake != NULL )
??mbedtls_ssl_update_handshake_status_0:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_update_handshake_status_1
        LDR      R0,[R5, #+60]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_update_handshake_status_1
// 3712     {
// 3713         unsigned offset;
// 3714         mbedtls_ssl_hs_buffer *hs_buf;
// 3715 
// 3716         /* Increment handshake sequence number */
// 3717         hs->in_msg_seq++;
        LDR      R0,[R4, #+472]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+472]
// 3718 
// 3719         /*
// 3720          * Clear up handshake buffering and reassembly structure.
// 3721          */
// 3722 
// 3723         /* Free first entry */
// 3724         ssl_buffering_free_slot( ssl, 0 );
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall ssl_buffering_free_slot
        BL       ssl_buffering_free_slot
// 3725 
// 3726         /* Shift all other entries */
// 3727         for( offset = 0, hs_buf = &hs->buffering.hs[0];
        MOVS     R1,#+0
        ADD      R0,R4,#+528
        B.N      ??mbedtls_ssl_update_handshake_status_2
// 3728              offset + 1 < MBEDTLS_SSL_MAX_BUFFERED_HS;
// 3729              offset++, hs_buf++ )
// 3730         {
// 3731             *hs_buf = *(hs_buf + 1);
??mbedtls_ssl_update_handshake_status_3:
        ADD      R2,R0,#+12
        LDM      R2,{R3-R5}
        STM      R0,{R3-R5}
// 3732         }
        ADDS     R1,R1,#+1
        ADDS     R0,R0,#+12
??mbedtls_ssl_update_handshake_status_2:
        ADDS     R2,R1,#+1
        CMP      R2,#+4
        BCC.N    ??mbedtls_ssl_update_handshake_status_3
// 3733 
// 3734         /* Create a fresh last entry */
// 3735         memset( hs_buf, 0, sizeof( mbedtls_ssl_hs_buffer ) );
        MOVS     R2,#+0
        MOVS     R1,#+12
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_memset4
        B.W      __aeabi_memset4
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 3736     }
// 3737 #endif
// 3738 }
??mbedtls_ssl_update_handshake_status_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock51
// 3739 
// 3740 /*
// 3741  * DTLS anti-replay: RFC 6347 4.1.2.6
// 3742  *
// 3743  * in_window is a field of bits numbered from 0 (lsb) to 63 (msb).
// 3744  * Bit n is set iff record number in_window_top - n has been seen.
// 3745  *
// 3746  * Usually, in_window_top is the last record number seen and the lsb of
// 3747  * in_window is set. The only exception is the initial state (record number 0
// 3748  * not seen yet).
// 3749  */
// 3750 #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function ssl_dtls_replay_reset
          CFI NoCalls
        THUMB
// 3751 static void ssl_dtls_replay_reset( mbedtls_ssl_context *ssl )
// 3752 {
// 3753     ssl->in_window_top = 0;
ssl_dtls_replay_reset:
        MOVS     R2,#+0
        MOV      R3,R2
        STRD     R2,R3,[R0, #+144]
// 3754     ssl->in_window = 0;
        STRD     R2,R3,[R0, #+152]
// 3755 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock52
// 3756 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function ssl_load_six_bytes
          CFI NoCalls
        THUMB
// 3757 static inline uint64_t ssl_load_six_bytes( unsigned char *buf )
// 3758 {
ssl_load_six_bytes:
        PUSH     {R4,R5}
          CFI R5 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 3759     return( ( (uint64_t) buf[0] << 40 ) |
// 3760             ( (uint64_t) buf[1] << 32 ) |
// 3761             ( (uint64_t) buf[2] << 24 ) |
// 3762             ( (uint64_t) buf[3] << 16 ) |
// 3763             ( (uint64_t) buf[4] <<  8 ) |
// 3764             ( (uint64_t) buf[5]       ) );
        LDRB     R4,[R0, #+0]
        LSLS     R5,R4,#+8
        MOVS     R4,#+0
        LDRB     R2,[R0, #+1]
        MOV      R3,R2
        ORRS     R5,R5,R3
        LDRB     R2,[R0, #+2]
        MOV      R3,R4
        ORRS     R4,R4,R2, LSL #+24
        LDRB     R2,[R0, #+3]
        ORRS     R4,R4,R2, LSL #+16
        LDRB     R2,[R0, #+4]
        ORRS     R2,R4,R2, LSL #+8
        ORRS     R3,R5,R3
        LDRB     R0,[R0, #+5]
        MOVS     R1,#+0
        ORRS     R0,R2,R0
        ORRS     R1,R3,R1
        POP      {R4,R5}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
// 3765 }
          CFI EndBlock cfiBlock53
// 3766 
// 3767 /*
// 3768  * Return 0 if sequence number is acceptable, -1 otherwise
// 3769  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function mbedtls_ssl_dtls_replay_check
        THUMB
// 3770 int mbedtls_ssl_dtls_replay_check( mbedtls_ssl_context *ssl )
// 3771 {
mbedtls_ssl_dtls_replay_check:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 3772     uint64_t rec_seqnum = ssl_load_six_bytes( ssl->in_ctr + 2 );
        LDR      R0,[R4, #+96]
        ADDS     R0,R0,#+2
          CFI FunCall ssl_load_six_bytes
        BL       ssl_load_six_bytes
// 3773     uint64_t bit;
// 3774 
// 3775     if( ssl->conf->anti_replay == MBEDTLS_SSL_ANTI_REPLAY_DISABLED )
        LDR      R2,[R4, #+0]
        LDR      R2,[R2, #+204]
        UBFX     R2,R2,#+11,#+1
        CMP      R2,#+0
        BNE.N    ??mbedtls_ssl_dtls_replay_check_0
// 3776         return( 0 );
        MOVS     R0,#+0
        POP      {R4,PC}
// 3777 
// 3778     if( rec_seqnum > ssl->in_window_top )
??mbedtls_ssl_dtls_replay_check_0:
        LDRD     R2,R3,[R4, #+144]
        CMP      R3,R1
        BHI.N    ??mbedtls_ssl_dtls_replay_check_1
        BCC.N    ??mbedtls_ssl_dtls_replay_check_2
        CMP      R2,R0
        BCS.N    ??mbedtls_ssl_dtls_replay_check_1
// 3779         return( 0 );
??mbedtls_ssl_dtls_replay_check_2:
        MOVS     R0,#+0
        POP      {R4,PC}
// 3780 
// 3781     bit = ssl->in_window_top - rec_seqnum;
??mbedtls_ssl_dtls_replay_check_1:
        SUBS     R2,R2,R0
        SBCS     R3,R3,R1
// 3782 
// 3783     if( bit >= 64 )
        CMP      R3,#+0
        BCC.N    ??mbedtls_ssl_dtls_replay_check_3
        BHI.N    ??mbedtls_ssl_dtls_replay_check_4
        CMP      R2,#+64
        BCC.N    ??mbedtls_ssl_dtls_replay_check_3
// 3784         return( -1 );
??mbedtls_ssl_dtls_replay_check_4:
        MOV      R0,#-1
        POP      {R4,PC}
// 3785 
// 3786     if( ( ssl->in_window & ( (uint64_t) 1 << bit ) ) != 0 )
??mbedtls_ssl_dtls_replay_check_3:
        LDRD     R0,R1,[R4, #+152]
          CFI FunCall __aeabi_llsr
        BL       __aeabi_llsr
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_dtls_replay_check_5
// 3787         return( -1 );
        MOV      R0,#-1
        POP      {R4,PC}
// 3788 
// 3789     return( 0 );
??mbedtls_ssl_dtls_replay_check_5:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
// 3790 }
          CFI EndBlock cfiBlock54
// 3791 
// 3792 /*
// 3793  * Update replay window on new validated record
// 3794  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function mbedtls_ssl_dtls_replay_update
        THUMB
// 3795 void mbedtls_ssl_dtls_replay_update( mbedtls_ssl_context *ssl )
// 3796 {
mbedtls_ssl_dtls_replay_update:
        PUSH     {R4,R6,R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 3797     uint64_t rec_seqnum = ssl_load_six_bytes( ssl->in_ctr + 2 );
        LDR      R0,[R4, #+96]
        ADDS     R0,R0,#+2
          CFI FunCall ssl_load_six_bytes
        BL       ssl_load_six_bytes
        MOV      R6,R0
        MOV      R7,R1
// 3798 
// 3799     if( ssl->conf->anti_replay == MBEDTLS_SSL_ANTI_REPLAY_DISABLED )
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+11,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_dtls_replay_update_0
// 3800         return;
// 3801 
// 3802     if( rec_seqnum > ssl->in_window_top )
        LDRD     R0,R1,[R4, #+144]
        CMP      R1,R7
        BHI.N    ??mbedtls_ssl_dtls_replay_update_1
        BCC.N    ??mbedtls_ssl_dtls_replay_update_2
        CMP      R0,R6
        BCS.N    ??mbedtls_ssl_dtls_replay_update_1
// 3803     {
// 3804         /* Update window_top and the contents of the window */
// 3805         uint64_t shift = rec_seqnum - ssl->in_window_top;
??mbedtls_ssl_dtls_replay_update_2:
        SUBS     R2,R6,R0
        SBC      R3,R7,R1
// 3806 
// 3807         if( shift >= 64 )
        CMP      R3,#+0
        BCC.N    ??mbedtls_ssl_dtls_replay_update_3
        BHI.N    ??mbedtls_ssl_dtls_replay_update_4
        CMP      R2,#+64
        BCC.N    ??mbedtls_ssl_dtls_replay_update_3
// 3808             ssl->in_window = 1;
??mbedtls_ssl_dtls_replay_update_4:
        MOVS     R0,#+1
        MOVS     R1,#+0
        STRD     R0,R1,[R4, #+152]
        B.N      ??mbedtls_ssl_dtls_replay_update_5
// 3809         else
// 3810         {
// 3811             ssl->in_window <<= shift;
??mbedtls_ssl_dtls_replay_update_3:
        LDRD     R0,R1,[R4, #+152]
          CFI FunCall __aeabi_llsl
        BL       __aeabi_llsl
        STRD     R0,R1,[R4, #+152]
// 3812             ssl->in_window |= 1;
        ORR      R0,R0,#0x1
        STRD     R0,R1,[R4, #+152]
// 3813         }
// 3814 
// 3815         ssl->in_window_top = rec_seqnum;
??mbedtls_ssl_dtls_replay_update_5:
        STRD     R6,R7,[R4, #+144]
        POP      {R4,R6,R7,PC}
// 3816     }
// 3817     else
// 3818     {
// 3819         /* Mark that number as seen in the current window */
// 3820         uint64_t bit = ssl->in_window_top - rec_seqnum;
??mbedtls_ssl_dtls_replay_update_1:
        SUBS     R2,R0,R6
        SBC      R3,R1,R7
// 3821 
// 3822         if( bit < 64 ) /* Always true, but be extra sure */
        CMP      R3,#+0
        BHI.N    ??mbedtls_ssl_dtls_replay_update_0
        BCC.N    ??mbedtls_ssl_dtls_replay_update_6
        CMP      R2,#+64
        BCS.N    ??mbedtls_ssl_dtls_replay_update_0
// 3823             ssl->in_window |= (uint64_t) 1 << bit;
??mbedtls_ssl_dtls_replay_update_6:
        LDRD     R6,R7,[R4, #+152]
        MOVS     R0,#+1
        MOVS     R1,#+0
          CFI FunCall __aeabi_llsl
        BL       __aeabi_llsl
        ORRS     R0,R6,R0
        ORRS     R1,R7,R1
        STRD     R0,R1,[R4, #+152]
// 3824     }
// 3825 }
??mbedtls_ssl_dtls_replay_update_0:
        POP      {R4,R6,R7,PC}    ;; return
          CFI EndBlock cfiBlock55
// 3826 #endif /* MBEDTLS_SSL_DTLS_ANTI_REPLAY */
// 3827 
// 3828 #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && defined(MBEDTLS_SSL_SRV_C)
// 3829 /* Forward declaration */
// 3830 static int ssl_session_reset_int( mbedtls_ssl_context *ssl, int partial );
// 3831 
// 3832 /*
// 3833  * Without any SSL context, check if a datagram looks like a ClientHello with
// 3834  * a valid cookie, and if it doesn't, generate a HelloVerifyRequest message.
// 3835  * Both input and output include full DTLS headers.
// 3836  *
// 3837  * - if cookie is valid, return 0
// 3838  * - if ClientHello looks superficially valid but cookie is not,
// 3839  *   fill obuf and set olen, then
// 3840  *   return MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED
// 3841  * - otherwise return a specific error code
// 3842  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function ssl_check_dtls_clihlo_cookie
        THUMB
// 3843 static int ssl_check_dtls_clihlo_cookie(
// 3844                            mbedtls_ssl_cookie_write_t *f_cookie_write,
// 3845                            mbedtls_ssl_cookie_check_t *f_cookie_check,
// 3846                            void *p_cookie,
// 3847                            const unsigned char *cli_id, size_t cli_id_len,
// 3848                            const unsigned char *in, size_t in_len,
// 3849                            unsigned char *obuf, size_t buf_len, size_t *olen )
// 3850 {
ssl_check_dtls_clihlo_cookie:
        PUSH     {R2-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+40
        MOV      R5,R0
        MOV      R4,R1
// 3851     size_t sid_len, cookie_len;
// 3852     unsigned char *p;
// 3853 
// 3854     if( f_cookie_write == NULL || f_cookie_check == NULL )
        MOVS     R0,R5
        BEQ.N    ??ssl_check_dtls_clihlo_cookie_0
        MOVS     R0,R4
        BNE.N    ??ssl_check_dtls_clihlo_cookie_1
// 3855         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??ssl_check_dtls_clihlo_cookie_0:
        LDR.W    R0,??DataTable33_9  ;; 0xffff8f00
        B.N      ??ssl_check_dtls_clihlo_cookie_2
??ssl_check_dtls_clihlo_cookie_1:
        LDR      R1,[SP, #+48]
// 3856 
// 3857     /*
// 3858      * Structure of ClientHello with record and handshake headers,
// 3859      * and expected values. We don't need to check a lot, more checks will be
// 3860      * done when actually parsing the ClientHello - skipping those checks
// 3861      * avoids code duplication and does not make cookie forging any easier.
// 3862      *
// 3863      *  0-0  ContentType type;                  copied, must be handshake
// 3864      *  1-2  ProtocolVersion version;           copied
// 3865      *  3-4  uint16 epoch;                      copied, must be 0
// 3866      *  5-10 uint48 sequence_number;            copied
// 3867      * 11-12 uint16 length;                     (ignored)
// 3868      *
// 3869      * 13-13 HandshakeType msg_type;            (ignored)
// 3870      * 14-16 uint24 length;                     (ignored)
// 3871      * 17-18 uint16 message_seq;                copied
// 3872      * 19-21 uint24 fragment_offset;            copied, must be 0
// 3873      * 22-24 uint24 fragment_length;            (ignored)
// 3874      *
// 3875      * 25-26 ProtocolVersion client_version;    (ignored)
// 3876      * 27-58 Random random;                     (ignored)
// 3877      * 59-xx SessionID session_id;              1 byte len + sid_len content
// 3878      * 60+   opaque cookie<0..2^8-1>;           1 byte len + content
// 3879      *       ...
// 3880      *
// 3881      * Minimum length is 61 bytes.
// 3882      */
// 3883     if( in_len < 61 ||
// 3884         in[0] != MBEDTLS_SSL_MSG_HANDSHAKE ||
// 3885         in[3] != 0 || in[4] != 0 ||
// 3886         in[19] != 0 || in[20] != 0 || in[21] != 0 )
        CMP      R1,#+61
        BCC.N    ??ssl_check_dtls_clihlo_cookie_3
        LDR      R6,[SP, #+44]
        LDRB     R0,[R6, #+0]
        CMP      R0,#+22
        BNE.N    ??ssl_check_dtls_clihlo_cookie_3
        LDRB     R0,[R6, #+3]
        CMP      R0,#+0
        BNE.N    ??ssl_check_dtls_clihlo_cookie_3
        LDRB     R0,[R6, #+4]
        CMP      R0,#+0
        BNE.N    ??ssl_check_dtls_clihlo_cookie_3
        LDRB     R0,[R6, #+19]
        CMP      R0,#+0
        BNE.N    ??ssl_check_dtls_clihlo_cookie_3
        LDRB     R0,[R6, #+20]
        CMP      R0,#+0
        BNE.N    ??ssl_check_dtls_clihlo_cookie_3
        LDRB     R0,[R6, #+21]
        CMP      R0,#+0
        BNE.N    ??ssl_check_dtls_clihlo_cookie_3
// 3887     {
// 3888         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
// 3889     }
// 3890 
// 3891     sid_len = in[59];
        LDRB     R12,[R6, #+59]
// 3892     if( sid_len > in_len - 61 )
        SUB      R0,R1,#+61
        CMP      R0,R12
        BCC.N    ??ssl_check_dtls_clihlo_cookie_3
// 3893         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
// 3894 
// 3895     cookie_len = in[60 + sid_len];
        ADD      R0,R6,R12
        LDRB     R0,[R0, #+60]
// 3896     if( cookie_len > in_len - 60 )
        SUBS     R1,R1,#+60
        CMP      R1,R0
        BCS.N    ??ssl_check_dtls_clihlo_cookie_4
// 3897         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
??ssl_check_dtls_clihlo_cookie_3:
        LDR.W    R0,??DataTable34  ;; 0xffff8700
        B.N      ??ssl_check_dtls_clihlo_cookie_2
??ssl_check_dtls_clihlo_cookie_4:
        LDR      R8,[SP, #+40]
        MOV      R7,R3
        MOV      R9,R2
// 3898 
// 3899     if( f_cookie_check( p_cookie, in + sid_len + 61, cookie_len,
// 3900                         cli_id, cli_id_len ) == 0 )
        STR      R8,[SP, #+0]
        MOV      R2,R0
        ADD      R0,R6,R12
        ADD      R1,R0,#+61
        MOV      R0,R9
          CFI FunCall
        BLX      R4
        CMP      R0,#+0
        BNE.N    ??ssl_check_dtls_clihlo_cookie_5
// 3901     {
// 3902         /* Valid cookie */
// 3903         return( 0 );
        MOVS     R0,#+0
        B.N      ??ssl_check_dtls_clihlo_cookie_2
// 3904     }
??ssl_check_dtls_clihlo_cookie_5:
        LDR      R10,[SP, #+56]
// 3905 
// 3906     /*
// 3907      * If we get here, we've got an invalid cookie, let's prepare HVR.
// 3908      *
// 3909      *  0-0  ContentType type;                  copied
// 3910      *  1-2  ProtocolVersion version;           copied
// 3911      *  3-4  uint16 epoch;                      copied
// 3912      *  5-10 uint48 sequence_number;            copied
// 3913      * 11-12 uint16 length;                     olen - 13
// 3914      *
// 3915      * 13-13 HandshakeType msg_type;            hello_verify_request
// 3916      * 14-16 uint24 length;                     olen - 25
// 3917      * 17-18 uint16 message_seq;                copied
// 3918      * 19-21 uint24 fragment_offset;            copied
// 3919      * 22-24 uint24 fragment_length;            olen - 25
// 3920      *
// 3921      * 25-26 ProtocolVersion server_version;    0xfe 0xff
// 3922      * 27-27 opaque cookie<0..2^8-1>;           cookie_len = olen - 27, cookie
// 3923      *
// 3924      * Minimum length is 28.
// 3925      */
// 3926     if( buf_len < 28 )
        CMP      R10,#+28
        BCS.N    ??ssl_check_dtls_clihlo_cookie_6
// 3927         return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
        LDR.W    R0,??DataTable35  ;; 0xffff9600
        B.N      ??ssl_check_dtls_clihlo_cookie_2
??ssl_check_dtls_clihlo_cookie_6:
        LDR      R4,[SP, #+52]
// 3928 
// 3929     /* Copy most fields and adapt others */
// 3930     memcpy( obuf, in, 25 );
        MOVS     R2,#+25
        MOV      R1,R6
        MOV      R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 3931     obuf[13] = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
        MOVS     R0,#+3
        STRB     R0,[R4, #+13]
// 3932     obuf[25] = 0xfe;
        MOVS     R0,#+254
        STRB     R0,[R4, #+25]
// 3933     obuf[26] = 0xff;
        MOVS     R0,#+255
        STRB     R0,[R4, #+26]
// 3934 
// 3935     /* Generate and write actual cookie */
// 3936     p = obuf + 28;
        ADD      R0,R4,#+28
        STR      R0,[SP, #+4]
// 3937     if( f_cookie_write( p_cookie,
// 3938                         &p, obuf + buf_len, cli_id, cli_id_len ) != 0 )
        STR      R8,[SP, #+0]
        MOV      R3,R7
        ADD      R2,R4,R10
        ADD      R1,SP,#+4
        MOV      R0,R9
          CFI FunCall
        BLX      R5
        CMP      R0,#+0
        BEQ.N    ??ssl_check_dtls_clihlo_cookie_7
// 3939     {
// 3940         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable35_1  ;; 0xffff9400
        B.N      ??ssl_check_dtls_clihlo_cookie_2
// 3941     }
??ssl_check_dtls_clihlo_cookie_7:
        LDR      R0,[SP, #+60]
// 3942 
// 3943     *olen = p - obuf;
        LDR      R1,[SP, #+4]
        SUBS     R1,R1,R4
        STR      R1,[R0, #+0]
// 3944 
// 3945     /* Go back and fill length fields */
// 3946     obuf[27] = (unsigned char)( *olen - 28 );
        SUBS     R1,R1,#+28
        STRB     R1,[R4, #+27]
// 3947 
// 3948     obuf[14] = obuf[22] = (unsigned char)( ( *olen - 25 ) >> 16 );
        LDR      R1,[R0, #+0]
        SUBS     R1,R1,#+25
        LSRS     R1,R1,#+16
        STRB     R1,[R4, #+22]
        LDRB     R1,[R4, #+22]
        STRB     R1,[R4, #+14]
// 3949     obuf[15] = obuf[23] = (unsigned char)( ( *olen - 25 ) >>  8 );
        LDR      R1,[R0, #+0]
        SUBS     R1,R1,#+25
        LSRS     R1,R1,#+8
        STRB     R1,[R4, #+23]
        LDRB     R1,[R4, #+23]
        STRB     R1,[R4, #+15]
// 3950     obuf[16] = obuf[24] = (unsigned char)( ( *olen - 25 )       );
        LDR      R1,[R0, #+0]
        SUBS     R1,R1,#+25
        STRB     R1,[R4, #+24]
        LDRB     R1,[R4, #+24]
        STRB     R1,[R4, #+16]
// 3951 
// 3952     obuf[11] = (unsigned char)( ( *olen - 13 ) >>  8 );
        LDR      R1,[R0, #+0]
        SUBS     R1,R1,#+13
        LSRS     R1,R1,#+8
        STRB     R1,[R4, #+11]
// 3953     obuf[12] = (unsigned char)( ( *olen - 13 )       );
        LDR      R0,[R0, #+0]
        SUBS     R0,R0,#+13
        STRB     R0,[R4, #+12]
// 3954 
// 3955     return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );
        LDR.W    R0,??DataTable35_2  ;; 0xffff9580
??ssl_check_dtls_clihlo_cookie_2:
        POP      {R1,R2,R4-R10,PC}  ;; return
// 3956 }
          CFI EndBlock cfiBlock56

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27:
        DATA32
        DC32     ?_97
// 3957 
// 3958 /*
// 3959  * Handle possible client reconnect with the same UDP quadruplet
// 3960  * (RFC 6347 Section 4.2.8).
// 3961  *
// 3962  * Called by ssl_parse_record_header() in case we receive an epoch 0 record
// 3963  * that looks like a ClientHello.
// 3964  *
// 3965  * - if the input looks like a ClientHello without cookies,
// 3966  *   send back HelloVerifyRequest, then
// 3967  *   return MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED
// 3968  * - if the input looks like a ClientHello with a valid cookie,
// 3969  *   reset the session of the current context, and
// 3970  *   return MBEDTLS_ERR_SSL_CLIENT_RECONNECT
// 3971  * - if anything goes wrong, return a specific error code
// 3972  *
// 3973  * mbedtls_ssl_read_record() will ignore the record if anything else than
// 3974  * MBEDTLS_ERR_SSL_CLIENT_RECONNECT or 0 is returned, although this function
// 3975  * cannot not return 0.
// 3976  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function ssl_handle_possible_reconnect
        THUMB
// 3977 static int ssl_handle_possible_reconnect( mbedtls_ssl_context *ssl )
// 3978 {
ssl_handle_possible_reconnect:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+28
          CFI CFA R13+48
        MOV      R5,R0
// 3979     int ret;
// 3980     size_t len;
// 3981 
// 3982     ret = ssl_check_dtls_clihlo_cookie(
// 3983             ssl->conf->f_cookie_write,
// 3984             ssl->conf->f_cookie_check,
// 3985             ssl->conf->p_cookie,
// 3986             ssl->cli_id, ssl->cli_id_len,
// 3987             ssl->in_buf, ssl->in_left,
// 3988             ssl->out_buf, MBEDTLS_SSL_OUT_CONTENT_LEN, &len );
        ADD      R0,SP,#+24
        STR      R0,[SP, #+20]
        MOV      R0,#+10240
        STR      R0,[SP, #+16]
        LDR      R0,[R5, #+176]
        STR      R0,[SP, #+12]
        LDR      R0,[R5, #+128]
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+92]
        STR      R0,[SP, #+4]
        LDR      R0,[R5, #+240]
        STR      R0,[SP, #+0]
        LDR      R3,[R5, #+236]
        LDR      R0,[R5, #+0]
        LDR      R2,[R0, #+76]
        LDR      R1,[R0, #+72]
        LDR      R0,[R0, #+68]
          CFI FunCall ssl_check_dtls_clihlo_cookie
        BL       ssl_check_dtls_clihlo_cookie
        MOV      R4,R0
// 3989 
// 3990     MBEDTLS_SSL_DEBUG_RET( 2, "ssl_check_dtls_clihlo_cookie", ret );
        LDR.W    R6,??DataTable32_1
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable35_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+3990
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 3991 
// 3992     if( ret == MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED )
        LDR.W    R7,??DataTable35_2  ;; 0xffff9580
        CMP      R4,R7
        BNE.N    ??ssl_handle_possible_reconnect_0
// 3993     {
// 3994         /* Don't check write errors as we can't do anything here.
// 3995          * If the error is permanent we'll catch it later,
// 3996          * if it's not, then hopefully it'll work next time. */
// 3997         (void) ssl->f_send( ssl->p_bio, ssl->out_buf, len );
        LDR      R2,[SP, #+24]
        LDR      R1,[R5, #+176]
        LDR      R0,[R5, #+40]
        LDR      R3,[R5, #+28]
          CFI FunCall
        BLX      R3
// 3998 
// 3999         return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );
        MOV      R0,R7
        B.N      ??ssl_handle_possible_reconnect_1
// 4000     }
// 4001 
// 4002     if( ret == 0 )
??ssl_handle_possible_reconnect_0:
        CMP      R4,#+0
        BNE.N    ??ssl_handle_possible_reconnect_2
// 4003     {
// 4004         /* Got a valid cookie, partially reset context */
// 4005         if( ( ret = ssl_session_reset_int( ssl, 1 ) ) != 0 )
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall ssl_session_reset_int
        BL       ssl_session_reset_int
        MOVS     R4,R0
        BEQ.N    ??ssl_handle_possible_reconnect_3
// 4006         {
// 4007             MBEDTLS_SSL_DEBUG_RET( 1, "reset", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable35_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+4007
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 4008             return( ret );
        MOV      R0,R4
        B.N      ??ssl_handle_possible_reconnect_1
// 4009         }
// 4010 
// 4011         return( MBEDTLS_ERR_SSL_CLIENT_RECONNECT );
??ssl_handle_possible_reconnect_3:
        LDR.W    R0,??DataTable36  ;; 0xffff9880
        B.N      ??ssl_handle_possible_reconnect_1
// 4012     }
// 4013 
// 4014     return( ret );
??ssl_handle_possible_reconnect_2:
        MOV      R0,R4
??ssl_handle_possible_reconnect_1:
        ADD      SP,SP,#+28
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
// 4015 }
          CFI EndBlock cfiBlock57

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28:
        DATA32
        DC32     ?_98

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28_1:
        DATA32
        DC32     ?_99

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28_2:
        DATA32
        DC32     ?_7

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28_3:
        DATA32
        DC32     ?_100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28_4:
        DATA32
        DC32     ?_101

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28_5:
        DATA32
        DC32     ?_102

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28_6:
        DATA32
        DC32     ?_103
// 4016 #endif /* MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE && MBEDTLS_SSL_SRV_C */
// 4017 
// 4018 /*
// 4019  * ContentType type;
// 4020  * ProtocolVersion version;
// 4021  * uint16 epoch;            // DTLS only
// 4022  * uint48 sequence_number;  // DTLS only
// 4023  * uint16 length;
// 4024  *
// 4025  * Return 0 if header looks sane (and, for DTLS, the record is expected)
// 4026  * MBEDTLS_ERR_SSL_INVALID_RECORD if the header looks bad,
// 4027  * MBEDTLS_ERR_SSL_UNEXPECTED_RECORD (DTLS only) if sane but unexpected.
// 4028  *
// 4029  * With DTLS, mbedtls_ssl_read_record() will:
// 4030  * 1. proceed with the record if this function returns 0
// 4031  * 2. drop only the current record if this function returns UNEXPECTED_RECORD
// 4032  * 3. return CLIENT_RECONNECT if this function return that value
// 4033  * 4. drop the whole datagram if this function returns anything else.
// 4034  * Point 2 is needed when the peer is resending, and we have already received
// 4035  * the first record from a datagram but are still waiting for the others.
// 4036  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function ssl_parse_record_header
        THUMB
// 4037 static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
// 4038 {
ssl_parse_record_header:
        PUSH     {R3-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+20
        SUB      SP,SP,#+28
          CFI CFA R13+48
        MOV      R5,R0
// 4039     int major_ver, minor_ver;
// 4040 
// 4041     MBEDTLS_SSL_DEBUG_BUF( 4, "input record header", ssl->in_hdr, mbedtls_ssl_hdr_len( ssl ) );
          CFI FunCall mbedtls_ssl_hdr_len
        BL       mbedtls_ssl_hdr_len
        LDR.W    R6,??DataTable32_1
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+100]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable35_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+4041
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 4042 
// 4043     ssl->in_msgtype =  ssl->in_hdr[0];
        LDR      R0,[R5, #+100]
        LDRB     R0,[R0, #+0]
        STR      R0,[R5, #+120]
// 4044     ssl->in_msglen = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
        LDR      R0,[R5, #+104]
        LDRB     R0,[R0, #+0]
        LDR      R1,[R5, #+104]
        LDRB     R1,[R1, #+1]
        ORR      R1,R1,R0, LSL #+8
        STR      R1,[R5, #+124]
// 4045     mbedtls_ssl_read_version( &major_ver, &minor_ver, ssl->conf->transport, ssl->in_hdr + 1 );
        LDR      R0,[R5, #+100]
        ADDS     R3,R0,#+1
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R2,R0,#+1,#+1
        ADD      R1,SP,#+20
        ADD      R0,SP,#+24
          CFI FunCall mbedtls_ssl_read_version
        BL       mbedtls_ssl_read_version
// 4046 
// 4047     MBEDTLS_SSL_DEBUG_MSG( 3, ( "input record: msgtype = %d, "
// 4048                         "version = [%d:%d], msglen = %d",
// 4049                         ssl->in_msgtype,
// 4050                         major_ver, minor_ver, ssl->in_msglen ) );
        LDR      R0,[R5, #+124]
        STR      R0,[SP, #+16]
        LDR      R0,[SP, #+20]
        STR      R0,[SP, #+12]
        LDR      R0,[SP, #+24]
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+120]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable36_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+4050
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4051 
// 4052     /* Check record type */
// 4053     if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE &&
// 4054         ssl->in_msgtype != MBEDTLS_SSL_MSG_ALERT &&
// 4055         ssl->in_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
// 4056         ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
        LDR      R0,[R5, #+120]
        CMP      R0,#+22
        BEQ.N    ??ssl_parse_record_header_0
        CMP      R0,#+21
        BEQ.N    ??ssl_parse_record_header_0
        CMP      R0,#+20
        BEQ.N    ??ssl_parse_record_header_0
        CMP      R0,#+23
        BEQ.N    ??ssl_parse_record_header_0
// 4057     {
// 4058         MBEDTLS_SSL_DEBUG_MSG( 1, ( "unknown record type" ) );
        LDR.W    R0,??DataTable36_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+4058
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4059 
// 4060 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 4061         /* Silently ignore invalid DTLS records as recommended by RFC 6347
// 4062          * Section 4.1.2.7 */
// 4063         if( ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BNE.N    ??ssl_parse_record_header_1
// 4064 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 4065             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 4066                                     MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
        MOVS     R2,#+10
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 4067 
// 4068         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
??ssl_parse_record_header_1:
        LDR.W    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??ssl_parse_record_header_2
// 4069     }
// 4070 
// 4071     /* Check version */
// 4072     if( major_ver != ssl->major_ver )
??ssl_parse_record_header_0:
        LDR      R0,[SP, #+24]
        LDR      R1,[R5, #+16]
        CMP      R0,R1
        BEQ.N    ??ssl_parse_record_header_3
// 4073     {
// 4074         MBEDTLS_SSL_DEBUG_MSG( 1, ( "major version mismatch" ) );
        LDR.W    R0,??DataTable36_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+4074
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4075         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??ssl_parse_record_header_2
// 4076     }
// 4077 
// 4078     if( minor_ver > ssl->conf->max_minor_ver )
??ssl_parse_record_header_3:
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+201]
        LDR      R1,[SP, #+20]
        CMP      R0,R1
        BGE.N    ??ssl_parse_record_header_4
// 4079     {
// 4080         MBEDTLS_SSL_DEBUG_MSG( 1, ( "minor version mismatch" ) );
        LDR.W    R0,??DataTable36_4
        STR      R0,[SP, #+0]
        MOV      R3,#+4080
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4081         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??ssl_parse_record_header_2
// 4082     }
// 4083 
// 4084     /* Check length against the size of our buffer */
// 4085     if( ssl->in_msglen > MBEDTLS_SSL_IN_BUFFER_LEN
// 4086                          - (size_t)( ssl->in_msg - ssl->in_buf ) )
??ssl_parse_record_header_4:
        MOVW     R1,#+10573
        LDR      R0,[R5, #+112]
        SUBS     R1,R1,R0
        LDR      R0,[R5, #+92]
        ADDS     R1,R0,R1
        LDR      R0,[R5, #+124]
        CMP      R1,R0
        BCS.N    ??ssl_parse_record_header_5
// 4087     {
// 4088         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
        LDR.W    R0,??DataTable37_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+4088
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4089         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??ssl_parse_record_header_2
// 4090     }
// 4091 
// 4092     /*
// 4093      * DTLS-related tests.
// 4094      * Check epoch before checking length constraint because
// 4095      * the latter varies with the epoch. E.g., if a ChangeCipherSpec
// 4096      * message gets duplicated before the corresponding Finished message,
// 4097      * the second ChangeCipherSpec should be discarded because it belongs
// 4098      * to an old epoch, but not because its length is shorter than
// 4099      * the minimum record length for packets using the new record transform.
// 4100      * Note that these two kinds of failures are handled differently,
// 4101      * as an unexpected record is silently skipped but an invalid
// 4102      * record leads to the entire datagram being dropped.
// 4103      */
// 4104 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 4105     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
??ssl_parse_record_header_5:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_parse_record_header_6
// 4106     {
// 4107         unsigned int rec_epoch = ( ssl->in_ctr[0] << 8 ) | ssl->in_ctr[1];
        LDR      R0,[R5, #+96]
        LDRB     R0,[R0, #+0]
        LDR      R1,[R5, #+96]
        LDRB     R4,[R1, #+1]
        ORR      R4,R4,R0, LSL #+8
// 4108 
// 4109         /* Check epoch (and sequence number) with DTLS */
// 4110         if( rec_epoch != ssl->in_epoch )
        LDRH     R0,[R5, #+132]
        CMP      R4,R0
        BEQ.N    ??ssl_parse_record_header_7
// 4111         {
// 4112             MBEDTLS_SSL_DEBUG_MSG( 1, ( "record from another epoch: "
// 4113                                         "expected %d, received %d",
// 4114                                         ssl->in_epoch, rec_epoch ) );
        STR      R4,[SP, #+8]
        LDRH     R0,[R5, #+132]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable37_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+4114
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4115 
// 4116 #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && defined(MBEDTLS_SSL_SRV_C)
// 4117             /*
// 4118              * Check for an epoch 0 ClientHello. We can't use in_msg here to
// 4119              * access the first byte of record content (handshake type), as we
// 4120              * have an active transform (possibly iv_len != 0), so use the
// 4121              * fact that the record header len is 13 instead.
// 4122              */
// 4123             if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
// 4124                 ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER &&
// 4125                 rec_epoch == 0 &&
// 4126                 ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
// 4127                 ssl->in_left > 13 &&
// 4128                 ssl->in_buf[13] == MBEDTLS_SSL_HS_CLIENT_HELLO )
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??ssl_parse_record_header_8
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BNE.N    ??ssl_parse_record_header_8
        CMP      R4,#+0
        BNE.N    ??ssl_parse_record_header_8
        LDR      R0,[R5, #+120]
        CMP      R0,#+22
        BNE.N    ??ssl_parse_record_header_8
        LDR      R0,[R5, #+128]
        CMP      R0,#+14
        BCC.N    ??ssl_parse_record_header_8
        LDR      R0,[R5, #+92]
        LDRB     R0,[R0, #+13]
        CMP      R0,#+1
        BNE.N    ??ssl_parse_record_header_8
// 4129             {
// 4130                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "possible client reconnect "
// 4131                                             "from the same port" ) );
        LDR.W    R0,??DataTable37_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+4131
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4132                 return( ssl_handle_possible_reconnect( ssl ) );
        MOV      R0,R5
          CFI FunCall ssl_handle_possible_reconnect
        BL       ssl_handle_possible_reconnect
        B.N      ??ssl_parse_record_header_2
// 4133             }
// 4134             else
// 4135 #endif /* MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE && MBEDTLS_SSL_SRV_C */
// 4136             {
// 4137                 /* Consider buffering the record. */
// 4138                 if( rec_epoch == (unsigned int) ssl->in_epoch + 1 )
??ssl_parse_record_header_8:
        LDRH     R0,[R5, #+132]
        ADDS     R0,R0,#+1
        CMP      R4,R0
        BNE.N    ??ssl_parse_record_header_9
// 4139                 {
// 4140                     MBEDTLS_SSL_DEBUG_MSG( 2, ( "Consider record for buffering" ) );
        LDR.W    R0,??DataTable37_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+4140
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4141                     return( MBEDTLS_ERR_SSL_EARLY_MESSAGE );
        LDR.W    R0,??DataTable33_1  ;; 0xffff9b80
        B.N      ??ssl_parse_record_header_2
// 4142                 }
// 4143 
// 4144                 return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );
??ssl_parse_record_header_9:
        LDR.W    R0,??DataTable37_5  ;; 0xffff9900
        B.N      ??ssl_parse_record_header_2
// 4145             }
// 4146         }
// 4147 
// 4148 #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
// 4149         /* Replay detection only works for the current epoch */
// 4150         if( rec_epoch == ssl->in_epoch &&
// 4151             mbedtls_ssl_dtls_replay_check( ssl ) != 0 )
??ssl_parse_record_header_7:
        BNE.N    ??ssl_parse_record_header_10
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_dtls_replay_check
        BL       mbedtls_ssl_dtls_replay_check
        CMP      R0,#+0
        BEQ.N    ??ssl_parse_record_header_10
// 4152         {
// 4153             MBEDTLS_SSL_DEBUG_MSG( 1, ( "replayed record" ) );
        LDR.W    R0,??DataTable37_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+4153
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4154             return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );
        LDR.W    R0,??DataTable37_5  ;; 0xffff9900
        B.N      ??ssl_parse_record_header_2
// 4155         }
// 4156 #endif
// 4157 
// 4158         /* Drop unexpected ApplicationData records,
// 4159          * except at the beginning of renegotiations */
// 4160         if( ssl->in_msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA &&
// 4161             ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER
// 4162 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 4163             && ! ( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
// 4164                    ssl->state == MBEDTLS_SSL_SERVER_HELLO )
// 4165 #endif
// 4166             )
??ssl_parse_record_header_10:
        LDR      R0,[R5, #+120]
        CMP      R0,#+23
        BNE.N    ??ssl_parse_record_header_6
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BEQ.N    ??ssl_parse_record_header_6
        LDR      R0,[R5, #+8]
        CMP      R0,#+1
        BNE.N    ??ssl_parse_record_header_11
        LDR      R0,[R5, #+4]
        CMP      R0,#+2
        BEQ.N    ??ssl_parse_record_header_6
// 4167         {
// 4168             MBEDTLS_SSL_DEBUG_MSG( 1, ( "dropping unexpected ApplicationData" ) );
??ssl_parse_record_header_11:
        LDR.W    R0,??DataTable37_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+4168
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4169             return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );
        LDR.W    R0,??DataTable37_5  ;; 0xffff9900
        B.N      ??ssl_parse_record_header_2
// 4170         }
// 4171     }
// 4172 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 4173 
// 4174 
// 4175     /* Check length against bounds of the current transform and version */
// 4176     if( ssl->transform_in == NULL )
??ssl_parse_record_header_6:
        LDR      R0,[R5, #+64]
        CMP      R0,#+0
        LDR      R0,[R5, #+124]
        BNE.N    ??ssl_parse_record_header_12
// 4177     {
// 4178         if( ssl->in_msglen < 1 ||
// 4179             ssl->in_msglen > MBEDTLS_SSL_IN_CONTENT_LEN )
        CMP      R0,#+0
        BEQ.N    ??ssl_parse_record_header_13
        MOVW     R1,#+10241
        CMP      R0,R1
        BCC.N    ??ssl_parse_record_header_14
// 4180         {
// 4181             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
??ssl_parse_record_header_13:
        LDR.W    R0,??DataTable37_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+4181
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4182             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??ssl_parse_record_header_2
// 4183         }
// 4184     }
// 4185     else
// 4186     {
// 4187         if( ssl->in_msglen < ssl->transform_in->minlen )
??ssl_parse_record_header_12:
        LDR      R1,[R5, #+64]
        LDR      R1,[R1, #+8]
        CMP      R0,R1
        BCS.N    ??ssl_parse_record_header_15
// 4188         {
// 4189             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
        LDR.W    R0,??DataTable37_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+4189
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4190             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??ssl_parse_record_header_2
// 4191         }
// 4192 
// 4193 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 4194         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 &&
// 4195             ssl->in_msglen > ssl->transform_in->minlen + MBEDTLS_SSL_IN_CONTENT_LEN )
// 4196         {
// 4197             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
// 4198             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
// 4199         }
// 4200 #endif
// 4201 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ 
// 4202     defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 4203         /*
// 4204          * TLS encrypted messages can have up to 256 bytes of padding
// 4205          */
// 4206         if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 &&
// 4207             ssl->in_msglen > ssl->transform_in->minlen +
// 4208                              MBEDTLS_SSL_IN_CONTENT_LEN + 256 )
??ssl_parse_record_header_15:
        LDR      R0,[R5, #+20]
        CMP      R0,#+1
        BLT.N    ??ssl_parse_record_header_14
        MOV      R0,R1
        ADD      R0,R0,#+10496
        LDR      R1,[R5, #+124]
        CMP      R0,R1
        BCS.N    ??ssl_parse_record_header_14
// 4209         {
// 4210             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
        LDR.W    R0,??DataTable37_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+4210
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4211             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??ssl_parse_record_header_2
// 4212         }
// 4213 #endif
// 4214     }
// 4215 
// 4216     return( 0 );
??ssl_parse_record_header_14:
        MOVS     R0,#+0
??ssl_parse_record_header_2:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
// 4217 }
          CFI EndBlock cfiBlock58

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29:
        DATA32
        DC32     ?_105

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_1:
        DATA32
        DC32     ?_106
// 4218 
// 4219 /*
// 4220  * If applicable, decrypt (and decompress) record content
// 4221  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock59 Using cfiCommon0
          CFI Function ssl_prepare_record_content
        THUMB
// 4222 static int ssl_prepare_record_content( mbedtls_ssl_context *ssl )
// 4223 {
ssl_prepare_record_content:
        PUSH     {R0-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+32
        MOV      R5,R0
// 4224     int ret, done = 0;
// 4225 
// 4226     MBEDTLS_SSL_DEBUG_BUF( 4, "input record from network",
// 4227                    ssl->in_hdr, mbedtls_ssl_hdr_len( ssl ) + ssl->in_msglen );
          CFI FunCall mbedtls_ssl_hdr_len
        BL       mbedtls_ssl_hdr_len
        LDR.W    R6,??DataTable32_1
        LDR      R1,[R5, #+124]
        ADDS     R0,R1,R0
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+100]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable37_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+4227
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 4228 
// 4229 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
// 4230     if( mbedtls_ssl_hw_record_read != NULL )
// 4231     {
// 4232         MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_read()" ) );
// 4233 
// 4234         ret = mbedtls_ssl_hw_record_read( ssl );
// 4235         if( ret != 0 && ret != MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH )
// 4236         {
// 4237             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_read", ret );
// 4238             return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
// 4239         }
// 4240 
// 4241         if( ret == 0 )
// 4242             done = 1;
// 4243     }
// 4244 #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
// 4245     if( !done && ssl->transform_in != NULL )
        LDR      R0,[R5, #+64]
        CMP      R0,#+0
        BEQ.N    ??ssl_prepare_record_content_0
// 4246     {
// 4247         if( ( ret = ssl_decrypt_buf( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall ssl_decrypt_buf
        BL       ssl_decrypt_buf
        MOVS     R4,R0
        BEQ.N    ??ssl_prepare_record_content_1
// 4248         {
// 4249             MBEDTLS_SSL_DEBUG_RET( 1, "ssl_decrypt_buf", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable37_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+4249
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 4250             return( ret );
        MOV      R0,R4
        B.N      ??ssl_prepare_record_content_2
// 4251         }
// 4252 
// 4253         MBEDTLS_SSL_DEBUG_BUF( 4, "input payload after decrypt",
// 4254                        ssl->in_msg, ssl->in_msglen );
??ssl_prepare_record_content_1:
        LDR      R0,[R5, #+124]
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+112]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable38
        STR      R0,[SP, #+0]
        MOVW     R3,#+4254
        MOV      R2,R6
        MOVS     R1,#+4
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 4255 
// 4256         if( ssl->in_msglen > MBEDTLS_SSL_IN_CONTENT_LEN )
        LDR      R0,[R5, #+124]
        MOVW     R1,#+10241
        CMP      R0,R1
        BCC.N    ??ssl_prepare_record_content_0
// 4257         {
// 4258             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
        LDR.W    R0,??DataTable37_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+4258
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4259             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.N    R0,??DataTable32_2  ;; 0xffff8e00
        B.N      ??ssl_prepare_record_content_2
// 4260         }
// 4261     }
// 4262 
// 4263 #if defined(MBEDTLS_ZLIB_SUPPORT)
// 4264     if( ssl->transform_in != NULL &&
// 4265         ssl->session_in->compression == MBEDTLS_SSL_COMPRESS_DEFLATE )
// 4266     {
// 4267         if( ( ret = ssl_decompress_buf( ssl ) ) != 0 )
// 4268         {
// 4269             MBEDTLS_SSL_DEBUG_RET( 1, "ssl_decompress_buf", ret );
// 4270             return( ret );
// 4271         }
// 4272     }
// 4273 #endif /* MBEDTLS_ZLIB_SUPPORT */
// 4274 
// 4275 #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
// 4276     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
??ssl_prepare_record_content_0:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_prepare_record_content_3
// 4277     {
// 4278         mbedtls_ssl_dtls_replay_update( ssl );
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_dtls_replay_update
        BL       mbedtls_ssl_dtls_replay_update
// 4279     }
// 4280 #endif
// 4281 
// 4282     return( 0 );
??ssl_prepare_record_content_3:
        MOVS     R0,#+0
??ssl_prepare_record_content_2:
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
// 4283 }
          CFI EndBlock cfiBlock59

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30:
        DATA32
        DC32     ?_104

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30_1:
        DATA32
        DC32     ?_107

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30_2:
        DATA32
        DC32     ?_108

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30_3:
        DATA32
        DC32     ?_110

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30_4:
        DATA32
        DC32     ?_111

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30_5:
        DATA32
        DC32     ?_112

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30_6:
        DATA32
        DC32     ?_113
// 4284 
// 4285 static void ssl_handshake_wrapup_free_hs_transform( mbedtls_ssl_context *ssl );
// 4286 
// 4287 /*
// 4288  * Read a record.
// 4289  *
// 4290  * Silently ignore non-fatal alert (and for DTLS, invalid records as well,
// 4291  * RFC 6347 4.1.2.7) and continue reading until a valid record is found.
// 4292  *
// 4293  */
// 4294 
// 4295 /* Helper functions for mbedtls_ssl_read_record(). */
// 4296 static int ssl_consume_current_message( mbedtls_ssl_context *ssl );
// 4297 static int ssl_get_next_record( mbedtls_ssl_context *ssl );
// 4298 static int ssl_record_is_in_progress( mbedtls_ssl_context *ssl );
// 4299 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock60 Using cfiCommon0
          CFI Function mbedtls_ssl_read_record
        THUMB
// 4300 int mbedtls_ssl_read_record( mbedtls_ssl_context *ssl,
// 4301                              unsigned update_hs_digest )
// 4302 {
mbedtls_ssl_read_record:
        PUSH     {R1-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+32
        MOV      R5,R0
        MOV      R6,R1
// 4303     int ret;
// 4304 
// 4305     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> read record" ) );
        LDR.N    R7,??DataTable32_1
        LDR.W    R0,??DataTable38_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+4305
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4306 
// 4307     if( ssl->keep_current_message == 0 )
        LDR      R0,[R5, #+168]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_record_0
// 4308     {
// 4309         do {
// 4310 
// 4311             ret = ssl_consume_current_message( ssl );
??mbedtls_ssl_read_record_1:
        MOV      R0,R5
          CFI FunCall ssl_consume_current_message
        BL       ssl_consume_current_message
// 4312             if( ret != 0 )
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_record_2
// 4313                 return( ret );
// 4314 
// 4315             if( ssl_record_is_in_progress( ssl ) == 0 )
        MOV      R0,R5
          CFI FunCall ssl_record_is_in_progress
        BL       ssl_record_is_in_progress
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_record_3
// 4316             {
// 4317 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 4318                 int have_buffered = 0;
        MOVS     R4,#+0
// 4319 
// 4320                 /* We only check for buffered messages if the
// 4321                  * current datagram is fully consumed. */
// 4322                 if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 4323                     ssl_next_record_is_in_datagram( ssl ) == 0 )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_read_record_4
        MOV      R0,R5
          CFI FunCall ssl_next_record_is_in_datagram
        BL       ssl_next_record_is_in_datagram
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_record_4
// 4324                 {
// 4325                     if( ssl_load_buffered_message( ssl ) == 0 )
        MOV      R0,R5
          CFI FunCall ssl_load_buffered_message
        BL       ssl_load_buffered_message
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_record_4
// 4326                         have_buffered = 1;
        MOVS     R4,#+1
// 4327                 }
// 4328 
// 4329                 if( have_buffered == 0 )
??mbedtls_ssl_read_record_4:
        CMP      R4,#+0
        BNE.N    ??mbedtls_ssl_read_record_3
// 4330 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 4331                 {
// 4332                     ret = ssl_get_next_record( ssl );
        MOV      R0,R5
          CFI FunCall ssl_get_next_record
        BL       ssl_get_next_record
        MOV      R4,R0
// 4333                     if( ret == MBEDTLS_ERR_SSL_CONTINUE_PROCESSING )
        CMN      R4,#+25984
        BEQ.N    ??mbedtls_ssl_read_record_5
// 4334                         continue;
// 4335 
// 4336                     if( ret != 0 )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_read_record_3
// 4337                     {
// 4338                         MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_get_next_record" ), ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable38_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+4338
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 4339                         return( ret );
        MOV      R0,R4
        POP      {R1-R7,PC}
// 4340                     }
// 4341                 }
// 4342             }
// 4343 
// 4344             ret = mbedtls_ssl_handle_message_type( ssl );
??mbedtls_ssl_read_record_3:
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_handle_message_type
        BL       mbedtls_ssl_handle_message_type
        MOV      R4,R0
// 4345 
// 4346 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 4347             if( ret == MBEDTLS_ERR_SSL_EARLY_MESSAGE )
        CMN      R4,#+25728
        BNE.N    ??mbedtls_ssl_read_record_5
// 4348             {
// 4349                 /* Buffer future message */
// 4350                 ret = ssl_buffer_message( ssl );
        MOV      R0,R5
          CFI FunCall ssl_buffer_message
        BL       ssl_buffer_message
// 4351                 if( ret != 0 )
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_record_2
// 4352                     return( ret );
// 4353 
// 4354                 ret = MBEDTLS_ERR_SSL_CONTINUE_PROCESSING;
        LDR.N    R4,??DataTable33_5  ;; 0xffff9a80
// 4355             }
// 4356 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 4357 
// 4358         } while( MBEDTLS_ERR_SSL_NON_FATAL           == ret  ||
// 4359                  MBEDTLS_ERR_SSL_CONTINUE_PROCESSING == ret );
??mbedtls_ssl_read_record_5:
        CMN      R4,#+26240
        BEQ.N    ??mbedtls_ssl_read_record_1
        CMN      R4,#+25984
        BEQ.N    ??mbedtls_ssl_read_record_1
// 4360 
// 4361         if( 0 != ret )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_read_record_6
// 4362         {
// 4363             MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_handle_message_type" ), ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable38_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+4363
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 4364             return( ret );
        MOV      R0,R4
        POP      {R1-R7,PC}
// 4365         }
// 4366 
// 4367         if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
// 4368             update_hs_digest == 1 )
??mbedtls_ssl_read_record_6:
        LDR      R0,[R5, #+120]
        CMP      R0,#+22
        BNE.N    ??mbedtls_ssl_read_record_7
        CMP      R6,#+1
        BNE.N    ??mbedtls_ssl_read_record_7
// 4369         {
// 4370             mbedtls_ssl_update_handshake_status( ssl );
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_update_handshake_status
        BL       mbedtls_ssl_update_handshake_status
        B.N      ??mbedtls_ssl_read_record_7
// 4371         }
// 4372     }
// 4373     else
// 4374     {
// 4375         MBEDTLS_SSL_DEBUG_MSG( 2, ( "reuse previously read message" ) );
??mbedtls_ssl_read_record_0:
        LDR.W    R0,??DataTable38_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+4375
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4376         ssl->keep_current_message = 0;
        MOVS     R0,#+0
        STR      R0,[R5, #+168]
// 4377     }
// 4378 
// 4379     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= read record" ) );
??mbedtls_ssl_read_record_7:
        LDR.W    R0,??DataTable39
        STR      R0,[SP, #+0]
        MOVW     R3,#+4379
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4380 
// 4381     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_read_record_2:
        POP      {R1-R7,PC}       ;; return
// 4382 }
          CFI EndBlock cfiBlock60

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31:
        DATA32
        DC32     ?_109

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_1:
        DATA32
        DC32     0xffff9480
// 4383 
// 4384 #if defined(MBEDTLS_SSL_PROTO_DTLS)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock61 Using cfiCommon0
          CFI Function ssl_next_record_is_in_datagram
          CFI NoCalls
        THUMB
// 4385 static int ssl_next_record_is_in_datagram( mbedtls_ssl_context *ssl )
// 4386 {
// 4387     if( ssl->in_left > ssl->next_record_offset )
ssl_next_record_is_in_datagram:
        LDR      R1,[R0, #+136]
        LDR      R0,[R0, #+128]
        CMP      R1,R0
        SBCS     R0,R0,R0
        LSRS     R0,R0,#+31
// 4388         return( 1 );
        BX       LR               ;; return
// 4389 
// 4390     return( 0 );
// 4391 }
          CFI EndBlock cfiBlock61
// 4392 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock62 Using cfiCommon0
          CFI Function ssl_load_buffered_message
        THUMB
// 4393 static int ssl_load_buffered_message( mbedtls_ssl_context *ssl )
// 4394 {
ssl_load_buffered_message:
        PUSH     {R0-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+40
        MOV      R7,R0
// 4395     mbedtls_ssl_handshake_params * const hs = ssl->handshake;
        LDR      R4,[R7, #+60]
// 4396     mbedtls_ssl_hs_buffer * hs_buf;
// 4397     int ret = 0;
        MOVS     R6,#+0
// 4398 
// 4399     if( hs == NULL )
        CMP      R4,#+0
        BNE.N    ??ssl_load_buffered_message_0
// 4400         return( -1 );
        MOV      R0,#-1
        B.N      ??ssl_load_buffered_message_1
// 4401 
// 4402     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> ssl_load_buffered_messsage" ) );
??ssl_load_buffered_message_0:
        LDR.N    R5,??DataTable32_1
        LDR.W    R0,??DataTable38_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+4402
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4403 
// 4404     if( ssl->state == MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC ||
// 4405         ssl->state == MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC )
        LDR      R0,[R7, #+4]
        CMP      R0,#+10
        BEQ.N    ??ssl_load_buffered_message_2
        CMP      R0,#+12
        BNE.N    ??ssl_load_buffered_message_3
// 4406     {
// 4407         /* Check if we have seen a ChangeCipherSpec before.
// 4408          * If yes, synthesize a CCS record. */
// 4409         if( !hs->buffering.seen_ccs )
??ssl_load_buffered_message_2:
        LDRB     R0,[R4, #+524]
        CMP      R0,#+0
        BNE.N    ??ssl_load_buffered_message_4
// 4410         {
// 4411             MBEDTLS_SSL_DEBUG_MSG( 2, ( "CCS not seen in the current flight" ) );
        LDR.W    R0,??DataTable38_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+4411
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4412             ret = -1;
        MOV      R6,#-1
// 4413             goto exit;
        B.N      ??ssl_load_buffered_message_5
// 4414         }
// 4415 
// 4416         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Injecting buffered CCS message" ) );
??ssl_load_buffered_message_4:
        LDR.W    R0,??DataTable39_1
        STR      R0,[SP, #+0]
        MOV      R3,#+4416
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4417         ssl->in_msgtype = MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC;
        MOVS     R0,#+20
        STR      R0,[R7, #+120]
// 4418         ssl->in_msglen = 1;
        MOVS     R0,#+1
        STR      R0,[R7, #+124]
// 4419         ssl->in_msg[0] = 1;
        LDR      R1,[R7, #+112]
        STRB     R0,[R1, #+0]
// 4420 
// 4421         /* As long as they are equal, the exact value doesn't matter. */
// 4422         ssl->in_left            = 0;
        MOV      R0,R6
        STR      R0,[R7, #+128]
// 4423         ssl->next_record_offset = 0;
        STR      R0,[R7, #+136]
// 4424 
// 4425         hs->buffering.seen_ccs = 0;
        STRB     R0,[R4, #+524]
// 4426         goto exit;
        B.N      ??ssl_load_buffered_message_5
// 4427     }
// 4428 
// 4429 #if defined(MBEDTLS_DEBUG_C)
// 4430     /* Debug only */
// 4431     {
// 4432         unsigned offset;
// 4433         for( offset = 1; offset < MBEDTLS_SSL_MAX_BUFFERED_HS; offset++ )
??ssl_load_buffered_message_3:
        MOV      R8,#+1
??ssl_load_buffered_message_6:
        CMP      R8,#+4
        BCS.N    ??ssl_load_buffered_message_7
// 4434         {
// 4435             hs_buf = &hs->buffering.hs[offset];
        ADD      R0,R8,R8, LSL #+1
        ADD      R0,R4,R0, LSL #+2
        ADD      R0,R0,#+528
// 4436             if( hs_buf->is_valid == 1 )
        LDRB     R1,[R0, #+0]
        LSLS     R1,R1,#+31
        BPL.N    ??ssl_load_buffered_message_8
// 4437             {
// 4438                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "Future message with sequence number %u %s buffered.",
// 4439                             hs->in_msg_seq + offset,
// 4440                             hs_buf->is_complete ? "fully" : "partially" ) );
        LDR      R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+1
        CMP      R0,#+0
        BNE.N    ??ssl_load_buffered_message_9
        LDR.W    R0,??DataTable39_2
        B.N      ??ssl_load_buffered_message_10
??ssl_load_buffered_message_9:
        LDR.W    R0,??DataTable39_3
??ssl_load_buffered_message_10:
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+472]
        ADD      R0,R8,R0
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable39_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+4440
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4441             }
// 4442         }
??ssl_load_buffered_message_8:
        ADD      R8,R8,#+1
        B.N      ??ssl_load_buffered_message_6
// 4443     }
// 4444 #endif /* MBEDTLS_DEBUG_C */
// 4445 
// 4446     /* Check if we have buffered and/or fully reassembled the
// 4447      * next handshake message. */
// 4448     hs_buf = &hs->buffering.hs[0];
// 4449     if( ( hs_buf->is_valid == 1 ) && ( hs_buf->is_complete == 1 ) )
// 4450     {
// 4451         /* Synthesize a record containing the buffered HS message. */
// 4452         size_t msg_len = ( hs_buf->data[1] << 16 ) |
// 4453                          ( hs_buf->data[2] << 8  ) |
// 4454                            hs_buf->data[3];
// 4455 
// 4456         /* Double-check that we haven't accidentally buffered
// 4457          * a message that doesn't fit into the input buffer. */
// 4458         if( msg_len + 12 > MBEDTLS_SSL_IN_CONTENT_LEN )
// 4459         {
// 4460             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 4461             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 4462         }
// 4463 
// 4464         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Next handshake message has been buffered - load" ) );
??ssl_load_buffered_message_11:
        LDR.W    R0,??DataTable39_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+4464
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4465         MBEDTLS_SSL_DEBUG_BUF( 3, "Buffered handshake message (incl. header)",
// 4466                                hs_buf->data, msg_len + 12 );
        ADD      R0,R4,#+12
        STR      R0,[SP, #+8]
        LDR      R0,[R8, #+4]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable39_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+4466
        MOV      R2,R5
        MOVS     R1,#+3
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 4467 
// 4468         ssl->in_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
        MOVS     R0,#+22
        STR      R0,[R7, #+120]
// 4469         ssl->in_hslen   = msg_len + 12;
        ADD      R0,R4,#+12
        STR      R0,[R7, #+160]
// 4470         ssl->in_msglen  = msg_len + 12;
        ADDS     R4,R4,#+12
        STR      R4,[R7, #+124]
// 4471         memcpy( ssl->in_msg, hs_buf->data, ssl->in_hslen );
        LDR      R2,[R7, #+160]
        LDR      R1,[R8, #+4]
        LDR      R0,[R7, #+112]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 4472 
// 4473         ret = 0;
// 4474         goto exit;
        B.N      ??ssl_load_buffered_message_5
// 4475     }
// 4476     else
// 4477     {
// 4478         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Next handshake message %u not or only partially bufffered",
// 4479                                     hs->in_msg_seq ) );
??ssl_load_buffered_message_12:
        LDR      R0,[R4, #+472]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable40
        STR      R0,[SP, #+0]
        MOVW     R3,#+4479
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4480     }
// 4481 
// 4482     ret = -1;
        MOV      R6,#-1
// 4483 
// 4484 exit:
// 4485 
// 4486     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= ssl_load_buffered_message" ) );
??ssl_load_buffered_message_5:
        LDR.W    R0,??DataTable40_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+4486
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4487     return( ret );
        MOV      R0,R6
??ssl_load_buffered_message_1:
        ADD      SP,SP,#+16
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI CFA R13+40
??ssl_load_buffered_message_7:
        ADD      R8,R4,#+528
        LDRB     R0,[R8, #+0]
        AND      R0,R0,#0x5
        CMP      R0,#+5
        BNE.N    ??ssl_load_buffered_message_12
        LDR      R0,[R8, #+4]
        LDRB     R0,[R0, #+1]
        LDR      R1,[R8, #+4]
        LDRB     R4,[R1, #+2]
        LSLS     R4,R4,#+8
        ORR      R4,R4,R0, LSL #+16
        MOV      R0,R1
        LDRB     R0,[R0, #+3]
        ORRS     R4,R0,R4
        ADD      R0,R4,#+12
        MOVW     R1,#+10241
        CMP      R0,R1
        BCC.N    ??ssl_load_buffered_message_11
        LDR.W    R0,??DataTable40_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+4460
        MOV      R2,R5
        MOVS     R1,#+1
        MOV      R0,R7
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable35_1  ;; 0xffff9400
        B.N      ??ssl_load_buffered_message_1
// 4488 }
          CFI EndBlock cfiBlock62

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32:
        DATA32
        DC32     ?_115

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_1:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_2:
        DATA32
        DC32     0xffff8e00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_3:
        DATA32
        DC32     ?_116

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_4:
        DATA32
        DC32     ?_117
// 4489 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock63 Using cfiCommon0
          CFI Function ssl_buffer_make_space
        THUMB
// 4490 static int ssl_buffer_make_space( mbedtls_ssl_context *ssl,
// 4491                                   size_t desired )
// 4492 {
ssl_buffer_make_space:
        PUSH     {R2-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+32
        MOV      R5,R0
        MOV      R6,R1
// 4493     int offset;
// 4494     mbedtls_ssl_handshake_params * const hs = ssl->handshake;
        LDR      R7,[R5, #+60]
// 4495     MBEDTLS_SSL_DEBUG_MSG( 2, ( "Attempt to free buffered messages to have %u bytes available",
// 4496                                 (unsigned) desired ) );
        LDR.W    R4,??DataTable41
        STR      R6,[SP, #+4]
        LDR.W    R0,??DataTable40_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+4496
        MOV      R2,R4
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4497 
// 4498     /* Get rid of future records epoch first, if such exist. */
// 4499     ssl_free_buffered_record( ssl );
        MOV      R0,R5
          CFI FunCall ssl_free_buffered_record
        BL       ssl_free_buffered_record
// 4500 
// 4501     /* Check if we have enough space available now. */
// 4502     if( desired <= ( MBEDTLS_SSL_DTLS_MAX_BUFFERING -
// 4503                      hs->buffering.total_bytes_buffered ) )
        LDR      R0,[R7, #+520]
        RSB      R0,R0,#+32768
        CMP      R0,R6
        BCC.N    ??ssl_buffer_make_space_0
// 4504     {
// 4505         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Enough space available after freeing future epoch record" ) );
        LDR.W    R0,??DataTable40_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+4505
        MOV      R2,R4
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4506         return( 0 );
        MOVS     R0,#+0
        B.N      ??ssl_buffer_make_space_1
// 4507     }
// 4508 
// 4509     /* We don't have enough space to buffer the next expected handshake
// 4510      * message. Remove buffers used for future messages to gain space,
// 4511      * starting with the most distant one. */
// 4512     for( offset = MBEDTLS_SSL_MAX_BUFFERED_HS - 1;
??ssl_buffer_make_space_0:
        MOV      R8,#+3
        B.N      ??ssl_buffer_make_space_2
// 4513          offset >= 0; offset-- )
??ssl_buffer_make_space_3:
        SUB      R8,R8,#+1
??ssl_buffer_make_space_2:
        CMP      R8,#+0
        BMI.N    ??ssl_buffer_make_space_4
// 4514     {
// 4515         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Free buffering slot %d to make space for reassembly of next handshake message",
// 4516                                     offset ) );
        STR      R8,[SP, #+4]
        LDR.W    R0,??DataTable40_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+4516
        MOV      R2,R4
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4517 
// 4518         ssl_buffering_free_slot( ssl, (uint8_t) offset );
        MOV      R0,R8
        MOV      R1,R0
        UXTB     R1,R1
        MOV      R0,R5
          CFI FunCall ssl_buffering_free_slot
        BL       ssl_buffering_free_slot
// 4519 
// 4520         /* Check if we have enough space available now. */
// 4521         if( desired <= ( MBEDTLS_SSL_DTLS_MAX_BUFFERING -
// 4522                          hs->buffering.total_bytes_buffered ) )
        LDR      R0,[R7, #+520]
        RSB      R0,R0,#+32768
        CMP      R0,R6
        BCC.N    ??ssl_buffer_make_space_3
// 4523         {
// 4524             MBEDTLS_SSL_DEBUG_MSG( 2, ( "Enough space available after freeing buffered HS messages" ) );
        LDR.W    R0,??DataTable41_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+4524
        MOV      R2,R4
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4525             return( 0 );
        MOVS     R0,#+0
        B.N      ??ssl_buffer_make_space_1
// 4526         }
// 4527     }
// 4528 
// 4529     return( -1 );
??ssl_buffer_make_space_4:
        MOV      R0,#-1
??ssl_buffer_make_space_1:
        POP      {R1,R2,R4-R8,PC}  ;; return
// 4530 }
          CFI EndBlock cfiBlock63

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33:
        DATA32
        DC32     ?_118

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_1:
        DATA32
        DC32     0xffff9b80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_2:
        DATA32
        DC32     ?_119

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_3:
        DATA32
        DC32     ?_76

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_4:
        DATA32
        DC32     ?_120

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_5:
        DATA32
        DC32     0xffff9a80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_6:
        DATA32
        DC32     ?_121

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_7:
        DATA32
        DC32     ?_122

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_8:
        DATA32
        DC32     0xffff8f80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_9:
        DATA32
        DC32     0xffff8f00
// 4531 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock64 Using cfiCommon0
          CFI Function ssl_buffer_message
        THUMB
// 4532 static int ssl_buffer_message( mbedtls_ssl_context *ssl )
// 4533 {
ssl_buffer_message:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+20
          CFI CFA R13+56
        MOV      R6,R0
// 4534     int ret = 0;
        MOV      R8,#+0
// 4535     mbedtls_ssl_handshake_params * const hs = ssl->handshake;
        LDR      R4,[R6, #+60]
// 4536 
// 4537     if( hs == NULL )
        CMP      R4,#+0
        BNE.N    ??ssl_buffer_message_0
// 4538         return( 0 );
        MOV      R0,R8
        B.N      ??ssl_buffer_message_1
// 4539 
// 4540     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> ssl_buffer_message" ) );
??ssl_buffer_message_0:
        LDR.W    R7,??DataTable41
        LDR.W    R0,??DataTable40_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+4540
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4541 
// 4542     switch( ssl->in_msgtype )
        LDR      R0,[R6, #+120]
        CMP      R0,#+20
        BEQ.N    ??ssl_buffer_message_2
        CMP      R0,#+22
        BEQ.N    ??ssl_buffer_message_3
        B.N      ??ssl_buffer_message_4
// 4543     {
// 4544         case MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC:
// 4545             MBEDTLS_SSL_DEBUG_MSG( 2, ( "Remember CCS message" ) );
??ssl_buffer_message_2:
        LDR.W    R0,??DataTable40_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+4545
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4546 
// 4547             hs->buffering.seen_ccs = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+524]
// 4548             break;
        B.N      ??ssl_buffer_message_4
// 4549 
// 4550         case MBEDTLS_SSL_MSG_HANDSHAKE:
// 4551         {
// 4552             unsigned recv_msg_seq_offset;
// 4553             unsigned recv_msg_seq = ( ssl->in_msg[4] << 8 ) | ssl->in_msg[5];
??ssl_buffer_message_3:
        LDR      R0,[R6, #+112]
        LDRB     R1,[R0, #+4]
        LDRB     R0,[R0, #+5]
        ORR      R0,R0,R1, LSL #+8
// 4554             mbedtls_ssl_hs_buffer *hs_buf;
// 4555             size_t msg_len = ssl->in_hslen - 12;
        LDR      R9,[R6, #+160]
        SUB      R9,R9,#+12
// 4556 
// 4557             /* We should never receive an old handshake
// 4558              * message - double-check nonetheless. */
// 4559             if( recv_msg_seq < ssl->handshake->in_msg_seq )
        LDR      R1,[R6, #+60]
        LDR      R1,[R1, #+472]
        CMP      R0,R1
        BCS.N    ??ssl_buffer_message_5
// 4560             {
// 4561                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable40_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+4561
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4562                 return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.N    R0,??DataTable35_1  ;; 0xffff9400
        B.N      ??ssl_buffer_message_1
// 4563             }
// 4564 
// 4565             recv_msg_seq_offset = recv_msg_seq - ssl->handshake->in_msg_seq;
??ssl_buffer_message_5:
        LDR      R1,[R6, #+60]
        LDR      R5,[R1, #+472]
        SUBS     R5,R0,R5
// 4566             if( recv_msg_seq_offset >= MBEDTLS_SSL_MAX_BUFFERED_HS )
        CMP      R5,#+4
        BCC.N    ??ssl_buffer_message_6
// 4567             {
// 4568                 /* Silently ignore -- message too far in the future */
// 4569                 MBEDTLS_SSL_DEBUG_MSG( 2,
// 4570                  ( "Ignore future HS message with sequence number %u, "
// 4571                    "buffering window %u - %u",
// 4572                    recv_msg_seq, ssl->handshake->in_msg_seq,
// 4573                    ssl->handshake->in_msg_seq + MBEDTLS_SSL_MAX_BUFFERED_HS - 1 ) );
        LDR      R1,[R1, #+472]
        ADDS     R1,R1,#+3
        STR      R1,[SP, #+12]
        LDR      R1,[R6, #+60]
        LDR      R1,[R1, #+472]
        STR      R1,[SP, #+8]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable41_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+4573
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4574 
// 4575                 goto exit;
        B.N      ??ssl_buffer_message_4
// 4576             }
// 4577 
// 4578             MBEDTLS_SSL_DEBUG_MSG( 2, ( "Buffering HS message with sequence number %u, offset %u ",
// 4579                                         recv_msg_seq, recv_msg_seq_offset ) );
??ssl_buffer_message_6:
        STR      R5,[SP, #+8]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable41_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+4579
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4580 
// 4581             hs_buf = &hs->buffering.hs[ recv_msg_seq_offset ];
        ADD      R0,R5,R5, LSL #+1
        ADD      R0,R4,R0, LSL #+2
        ADD      R10,R0,#+528
// 4582 
// 4583             /* Check if the buffering for this seq nr has already commenced. */
// 4584             if( !hs_buf->is_valid )
        LDRB     R0,[R10, #+0]
        LSLS     R0,R0,#+31
        BMI.W    ??ssl_buffer_message_7
// 4585             {
// 4586                 size_t reassembly_buf_sz;
// 4587 
// 4588                 hs_buf->is_fragmented =
// 4589                     ( ssl_hs_is_proper_fragment( ssl ) == 1 );
        MOV      R0,R6
          CFI FunCall ssl_hs_is_proper_fragment
        BL       ssl_hs_is_proper_fragment
        CMP      R0,#+1
        BNE.N    ??ssl_buffer_message_8
        MOVS     R0,#+1
        B.N      ??ssl_buffer_message_9
??ssl_buffer_message_8:
        MOV      R0,R8
??ssl_buffer_message_9:
        LDR      R1,[R10, #+0]
        BFI      R1,R0,#+1,#+1
        STR      R1,[R10, #+0]
// 4590 
// 4591                 /* We copy the message back into the input buffer
// 4592                  * after reassembly, so check that it's not too large.
// 4593                  * This is an implementation-specific limitation
// 4594                  * and not one from the standard, hence it is not
// 4595                  * checked in ssl_check_hs_header(). */
// 4596                 if( msg_len + 12 > MBEDTLS_SSL_IN_CONTENT_LEN )
        ADD      R0,R9,#+12
        MOVW     R1,#+10241
        CMP      R0,R1
        BCS.W    ??ssl_buffer_message_4
// 4597                 {
// 4598                     /* Ignore message */
// 4599                     goto exit;
// 4600                 }
// 4601 
// 4602                 /* Check if we have enough space to buffer the message. */
// 4603                 if( hs->buffering.total_bytes_buffered >
// 4604                     MBEDTLS_SSL_DTLS_MAX_BUFFERING )
        LDR      R0,[R4, #+520]
        MOVW     R1,#+32769
        CMP      R0,R1
        BCC.N    ??ssl_buffer_message_10
// 4605                 {
// 4606                     MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable40_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+4606
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4607                     return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.N    R0,??DataTable35_1  ;; 0xffff9400
        B.N      ??ssl_buffer_message_1
// 4608                 }
// 4609 
// 4610                 reassembly_buf_sz = ssl_get_reassembly_buffer_size( msg_len,
// 4611                                                        hs_buf->is_fragmented );
??ssl_buffer_message_10:
        LDR      R0,[R10, #+0]
        UBFX     R1,R0,#+1,#+1
        MOV      R0,R9
          CFI FunCall ssl_get_reassembly_buffer_size
        BL       ssl_get_reassembly_buffer_size
        MOV      R11,R0
// 4612 
// 4613                 if( reassembly_buf_sz > ( MBEDTLS_SSL_DTLS_MAX_BUFFERING -
// 4614                                           hs->buffering.total_bytes_buffered ) )
        LDR      R0,[R4, #+520]
        RSB      R0,R0,#+32768
        CMP      R0,R11
        BCS.N    ??ssl_buffer_message_11
// 4615                 {
// 4616                     if( recv_msg_seq_offset > 0 )
        CMP      R5,#+0
        LDR      R0,[R4, #+520]
        STR      R0,[SP, #+12]
        MOV      R0,#+32768
        STR      R0,[SP, #+8]
        STR      R9,[SP, #+4]
        BEQ.N    ??ssl_buffer_message_12
// 4617                     {
// 4618                         /* If we can't buffer a future message because
// 4619                          * of space limitations -- ignore. */
// 4620                         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Buffering of future message of size %u would exceed the compile-time limit %u (already %u bytes buffered) -- ignore\n",
// 4621                              (unsigned) msg_len, MBEDTLS_SSL_DTLS_MAX_BUFFERING,
// 4622                              (unsigned) hs->buffering.total_bytes_buffered ) );
        LDR.W    R0,??DataTable41_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+4622
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4623                         goto exit;
        B.N      ??ssl_buffer_message_4
// 4624                     }
// 4625                     else
// 4626                     {
// 4627                         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Buffering of future message of size %u would exceed the compile-time limit %u (already %u bytes buffered) -- attempt to make space by freeing buffered future messages\n",
// 4628                              (unsigned) msg_len, MBEDTLS_SSL_DTLS_MAX_BUFFERING,
// 4629                              (unsigned) hs->buffering.total_bytes_buffered ) );
??ssl_buffer_message_12:
        LDR.W    R0,??DataTable41_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+4629
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4630                     }
// 4631 
// 4632                     if( ssl_buffer_make_space( ssl, reassembly_buf_sz ) != 0 )
        MOV      R1,R11
        MOV      R0,R6
          CFI FunCall ssl_buffer_make_space
        BL       ssl_buffer_make_space
        CMP      R0,#+0
        BEQ.N    ??ssl_buffer_message_11
// 4633                     {
// 4634                         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Reassembly of next message of size %u (%u with bitmap) would exceed the compile-time limit %u (already %u bytes buffered) -- fail\n",
// 4635                              (unsigned) msg_len,
// 4636                              (unsigned) reassembly_buf_sz,
// 4637                              MBEDTLS_SSL_DTLS_MAX_BUFFERING,
// 4638                              (unsigned) hs->buffering.total_bytes_buffered ) );
        LDR      R0,[R4, #+520]
        STR      R0,[SP, #+16]
        MOV      R0,#+32768
        STR      R0,[SP, #+12]
        STR      R11,[SP, #+8]
        STR      R9,[SP, #+4]
        LDR.W    R0,??DataTable41_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+4638
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4639                         ret = MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
        LDR.W    R8,??DataTable35  ;; 0xffff9600
// 4640                         goto exit;
        B.N      ??ssl_buffer_message_4
// 4641                     }
// 4642                 }
// 4643 
// 4644                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "initialize reassembly, total length = %d",
// 4645                                             msg_len ) );
??ssl_buffer_message_11:
        STR      R9,[SP, #+4]
        LDR.W    R0,??DataTable41_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+4645
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4646 
// 4647                 hs_buf->data = mbedtls_calloc( 1, reassembly_buf_sz );
        MOV      R1,R11
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R10, #+4]
// 4648                 if( hs_buf->data == NULL )
        CMP      R0,#+0
        BNE.N    ??ssl_buffer_message_13
// 4649                 {
// 4650                     ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
        LDR.W    R8,??DataTable41_8  ;; 0xffff8100
// 4651                     goto exit;
        B.N      ??ssl_buffer_message_4
// 4652                 }
// 4653                 hs_buf->data_len = reassembly_buf_sz;
??ssl_buffer_message_13:
        STR      R11,[R10, #+8]
// 4654 
// 4655                 /* Prepare final header: copy msg_type, length and message_seq,
// 4656                  * then add standardised fragment_offset and fragment_length */
// 4657                 memcpy( hs_buf->data, ssl->in_msg, 6 );
        MOVS     R2,#+6
        LDR      R1,[R6, #+112]
        LDR      R0,[R10, #+4]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 4658                 memset( hs_buf->data + 6, 0, 3 );
        MOV      R2,R8
        MOVS     R1,#+3
        LDR      R0,[R10, #+4]
        ADDS     R0,R0,#+6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 4659                 memcpy( hs_buf->data + 9, hs_buf->data + 1, 3 );
        MOVS     R2,#+3
        LDR      R0,[R10, #+4]
        ADDS     R1,R0,#+1
        ADDS     R0,R0,#+9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 4660 
// 4661                 hs_buf->is_valid = 1;
        LDR      R0,[R10, #+0]
        ORR      R0,R0,#0x1
        STR      R0,[R10, #+0]
// 4662 
// 4663                 hs->buffering.total_bytes_buffered += reassembly_buf_sz;
        LDR      R0,[R4, #+520]
        ADD      R11,R11,R0
        STR      R11,[R4, #+520]
// 4664             }
// 4665             else
// 4666             {
// 4667                 /* Make sure msg_type and length are consistent */
// 4668                 if( memcmp( hs_buf->data, ssl->in_msg, 4 ) != 0 )
// 4669                 {
// 4670                     MBEDTLS_SSL_DEBUG_MSG( 1, ( "Fragment header mismatch - ignore" ) );
// 4671                     /* Ignore */
// 4672                     goto exit;
// 4673                 }
// 4674             }
// 4675 
// 4676             if( !hs_buf->is_complete )
??ssl_buffer_message_14:
        LDR      R0,[R10, #+0]
        UBFX     R0,R0,#+2,#+1
        CMP      R0,#+0
        BNE.N    ??ssl_buffer_message_4
// 4677             {
// 4678                 size_t frag_len, frag_off;
// 4679                 unsigned char * const msg = hs_buf->data + 12;
        LDR      R0,[R10, #+4]
        ADD      R4,R0,#+12
// 4680 
// 4681                 /*
// 4682                  * Check and copy current fragment
// 4683                  */
// 4684 
// 4685                 /* Validation of header fields already done in
// 4686                  * mbedtls_ssl_prepare_handshake_record(). */
// 4687                 frag_off = ssl_get_hs_frag_off( ssl );
        MOV      R0,R6
          CFI FunCall ssl_get_hs_frag_off
        BL       ssl_get_hs_frag_off
        MOV      R5,R0
// 4688                 frag_len = ssl_get_hs_frag_len( ssl );
        MOV      R0,R6
          CFI FunCall ssl_get_hs_frag_len
        BL       ssl_get_hs_frag_len
        MOV      R11,R0
// 4689 
// 4690                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "adding fragment, offset = %d, length = %d",
// 4691                                             frag_off, frag_len ) );
        STR      R11,[SP, #+8]
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable41_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+4691
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4692                 memcpy( msg + frag_off, ssl->in_msg + 12, frag_len );
        MOV      R2,R11
        LDR      R0,[R6, #+112]
        ADD      R1,R0,#+12
        ADDS     R0,R4,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 4693 
// 4694                 if( hs_buf->is_fragmented )
        LDR      R0,[R10, #+0]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_buffer_message_15
// 4695                 {
// 4696                     unsigned char * const bitmask = msg + msg_len;
        ADD      R4,R4,R9
// 4697                     ssl_bitmask_set( bitmask, frag_off, frag_len );
        MOV      R2,R11
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall ssl_bitmask_set
        BL       ssl_bitmask_set
// 4698                     hs_buf->is_complete = ( ssl_bitmask_check( bitmask,
// 4699                                                                msg_len ) == 0 );
        MOV      R1,R9
        MOV      R0,R4
          CFI FunCall ssl_bitmask_check
        BL       ssl_bitmask_check
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        LSRS     R0,R0,#+31
        LDR      R1,[R10, #+0]
        BFI      R1,R0,#+2,#+1
        STR      R1,[R10, #+0]
        B.N      ??ssl_buffer_message_16
// 4700                 }
??ssl_buffer_message_7:
        MOVS     R2,#+4
        LDR      R1,[R6, #+112]
        LDR      R0,[R10, #+4]
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ.N    ??ssl_buffer_message_14
        LDR.W    R0,??DataTable41_10
        STR      R0,[SP, #+0]
        MOVW     R3,#+4670
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        B.N      ??ssl_buffer_message_4
// 4701                 else
// 4702                 {
// 4703                     hs_buf->is_complete = 1;
??ssl_buffer_message_15:
        LDR      R0,[R10, #+0]
        ORR      R0,R0,#0x4
        STR      R0,[R10, #+0]
// 4704                 }
// 4705 
// 4706                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "message %scomplete",
// 4707                                    hs_buf->is_complete ? "" : "not yet " ) );
??ssl_buffer_message_16:
        LDR      R0,[R10, #+0]
        UBFX     R0,R0,#+2,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_buffer_message_17
        ADR.N    R0,??DataTable37  ;; ""
        B.N      ??ssl_buffer_message_18
??ssl_buffer_message_17:
        LDR.W    R0,??DataTable41_11
??ssl_buffer_message_18:
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable41_12
        STR      R0,[SP, #+0]
        MOVW     R3,#+4707
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4708             }
// 4709 
// 4710             break;
// 4711         }
// 4712 
// 4713         default:
// 4714             /* We don't buffer other types of messages. */
// 4715             break;
// 4716     }
// 4717 
// 4718 exit:
// 4719 
// 4720     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= ssl_buffer_message" ) );
??ssl_buffer_message_4:
        LDR.W    R0,??DataTable41_13
        STR      R0,[SP, #+0]
        MOVW     R3,#+4720
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4721     return( ret );
        MOV      R0,R8
??ssl_buffer_message_1:
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
// 4722 }
          CFI EndBlock cfiBlock64

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable34:
        DATA32
        DC32     0xffff8700
// 4723 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 4724 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock65 Using cfiCommon0
          CFI Function ssl_consume_current_message
        THUMB
// 4725 static int ssl_consume_current_message( mbedtls_ssl_context *ssl )
// 4726 {
ssl_consume_current_message:
        PUSH     {R0-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+24
        MOV      R4,R0
// 4727     /*
// 4728      * Consume last content-layer message and potentially
// 4729      * update in_msglen which keeps track of the contents'
// 4730      * consumption state.
// 4731      *
// 4732      * (1) Handshake messages:
// 4733      *     Remove last handshake message, move content
// 4734      *     and adapt in_msglen.
// 4735      *
// 4736      * (2) Alert messages:
// 4737      *     Consume whole record content, in_msglen = 0.
// 4738      *
// 4739      * (3) Change cipher spec:
// 4740      *     Consume whole record content, in_msglen = 0.
// 4741      *
// 4742      * (4) Application data:
// 4743      *     Don't do anything - the record layer provides
// 4744      *     the application data as a stream transport
// 4745      *     and consumes through mbedtls_ssl_read only.
// 4746      *
// 4747      */
// 4748 
// 4749     /* Case (1): Handshake messages */
// 4750     if( ssl->in_hslen != 0 )
        LDR      R0,[R4, #+160]
        CMP      R0,#+0
        LDR      R0,[R4, #+116]
        BEQ.N    ??ssl_consume_current_message_0
// 4751     {
// 4752         /* Hard assertion to be sure that no application data
// 4753          * is in flight, as corrupting ssl->in_msglen during
// 4754          * ssl->in_offt != NULL is fatal. */
// 4755         if( ssl->in_offt != NULL )
        CMP      R0,#+0
        BEQ.N    ??ssl_consume_current_message_1
// 4756         {
// 4757             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable40_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+4757
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4758             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.N    R0,??DataTable35_1  ;; 0xffff9400
        B.N      ??ssl_consume_current_message_2
// 4759         }
// 4760 
// 4761         /*
// 4762          * Get next Handshake message in the current record
// 4763          */
// 4764 
// 4765         /* Notes:
// 4766          * (1) in_hslen is not necessarily the size of the
// 4767          *     current handshake content: If DTLS handshake
// 4768          *     fragmentation is used, that's the fragment
// 4769          *     size instead. Using the total handshake message
// 4770          *     size here is faulty and should be changed at
// 4771          *     some point.
// 4772          * (2) While it doesn't seem to cause problems, one
// 4773          *     has to be very careful not to assume that in_hslen
// 4774          *     is always <= in_msglen in a sensible communication.
// 4775          *     Again, it's wrong for DTLS handshake fragmentation.
// 4776          *     The following check is therefore mandatory, and
// 4777          *     should not be treated as a silently corrected assertion.
// 4778          *     Additionally, ssl->in_hslen might be arbitrarily out of
// 4779          *     bounds after handling a DTLS message with an unexpected
// 4780          *     sequence number, see mbedtls_ssl_prepare_handshake_record.
// 4781          */
// 4782         if( ssl->in_hslen < ssl->in_msglen )
??ssl_consume_current_message_1:
        LDR      R0,[R4, #+160]
        LDR      R1,[R4, #+124]
        CMP      R0,R1
        BCS.N    ??ssl_consume_current_message_3
// 4783         {
// 4784             ssl->in_msglen -= ssl->in_hslen;
        SUBS     R1,R1,R0
        STR      R1,[R4, #+124]
// 4785             memmove( ssl->in_msg, ssl->in_msg + ssl->in_hslen,
// 4786                      ssl->in_msglen );
        MOV      R2,R1
        LDR      R0,[R4, #+112]
        LDR      R1,[R4, #+160]
        ADD      R1,R0,R1
          CFI FunCall __aeabi_memmove
        BL       __aeabi_memmove
// 4787 
// 4788             MBEDTLS_SSL_DEBUG_BUF( 4, "remaining content in record",
// 4789                                    ssl->in_msg, ssl->in_msglen );
        LDR      R0,[R4, #+124]
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+112]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable41_14
        STR      R0,[SP, #+0]
        MOVW     R3,#+4789
        LDR.W    R2,??DataTable41
        MOVS     R1,#+4
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
        B.N      ??ssl_consume_current_message_4
// 4790         }
// 4791         else
// 4792         {
// 4793             ssl->in_msglen = 0;
??ssl_consume_current_message_3:
        MOVS     R0,#+0
        STR      R0,[R4, #+124]
// 4794         }
// 4795 
// 4796         ssl->in_hslen   = 0;
??ssl_consume_current_message_4:
        MOVS     R0,#+0
        STR      R0,[R4, #+160]
        B.N      ??ssl_consume_current_message_5
// 4797     }
// 4798     /* Case (4): Application data */
// 4799     else if( ssl->in_offt != NULL )
??ssl_consume_current_message_0:
        CMP      R0,#+0
        BNE.N    ??ssl_consume_current_message_5
// 4800     {
// 4801         return( 0 );
// 4802     }
// 4803     /* Everything else (CCS & Alerts) */
// 4804     else
// 4805     {
// 4806         ssl->in_msglen = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+124]
// 4807     }
// 4808 
// 4809     return( 0 );
??ssl_consume_current_message_5:
        MOVS     R0,#+0
??ssl_consume_current_message_2:
        ADD      SP,SP,#+16
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
// 4810 }
          CFI EndBlock cfiBlock65

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable35:
        DATA32
        DC32     0xffff9600

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable35_1:
        DATA32
        DC32     0xffff9400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable35_2:
        DATA32
        DC32     0xffff9580

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable35_3:
        DATA32
        DC32     ?_123

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable35_4:
        DATA32
        DC32     ?_124

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable35_5:
        DATA32
        DC32     ?_125
// 4811 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock66 Using cfiCommon0
          CFI Function ssl_record_is_in_progress
          CFI NoCalls
        THUMB
// 4812 static int ssl_record_is_in_progress( mbedtls_ssl_context *ssl )
// 4813 {
// 4814     if( ssl->in_msglen > 0 )
ssl_record_is_in_progress:
        LDR      R0,[R0, #+124]
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
// 4815         return( 1 );
// 4816 
// 4817     return( 0 );
        BX       LR               ;; return
// 4818 }
          CFI EndBlock cfiBlock66
// 4819 
// 4820 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 4821 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock67 Using cfiCommon0
          CFI Function ssl_free_buffered_record
        THUMB
// 4822 static void ssl_free_buffered_record( mbedtls_ssl_context *ssl )
// 4823 {
ssl_free_buffered_record:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 4824     mbedtls_ssl_handshake_params * const hs = ssl->handshake;
        LDR      R4,[R0, #+60]
// 4825     if( hs == NULL )
        CMP      R4,#+0
        BEQ.N    ??ssl_free_buffered_record_0
// 4826         return;
// 4827 
// 4828     if( hs->buffering.future_record.data != NULL )
        LDR      R0,[R4, #+576]
        CMP      R0,#+0
        BEQ.N    ??ssl_free_buffered_record_0
// 4829     {
// 4830         hs->buffering.total_bytes_buffered -=
// 4831             hs->buffering.future_record.len;
        LDR      R1,[R4, #+520]
        LDR      R0,[R4, #+580]
        SUBS     R1,R1,R0
        STR      R1,[R4, #+520]
// 4832 
// 4833         mbedtls_free( hs->buffering.future_record.data );
        LDR      R0,[R4, #+576]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 4834         hs->buffering.future_record.data = NULL;
        MOVS     R0,#+0
        STR      R0,[R4, #+576]
// 4835     }
// 4836 }
??ssl_free_buffered_record_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock67
// 4837 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function ssl_load_buffered_record
        THUMB
// 4838 static int ssl_load_buffered_record( mbedtls_ssl_context *ssl )
// 4839 {
ssl_load_buffered_record:
        PUSH     {R2-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+32
        MOV      R5,R0
// 4840     mbedtls_ssl_handshake_params * const hs = ssl->handshake;
        LDR      R0,[R5, #+60]
// 4841     unsigned char * rec;
// 4842     size_t rec_len;
// 4843     unsigned rec_epoch;
// 4844 
// 4845     if( ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R1,[R5, #+0]
        LDR      R1,[R1, #+204]
        UBFX     R1,R1,#+1,#+1
        CMP      R1,#+0
        BEQ.N    ??ssl_load_buffered_record_0
// 4846         return( 0 );
// 4847 
// 4848     if( hs == NULL )
        CMP      R0,#+0
        BEQ.N    ??ssl_load_buffered_record_0
// 4849         return( 0 );
// 4850 
// 4851     rec       = hs->buffering.future_record.data;
        LDR      R4,[R0, #+576]
// 4852     rec_len   = hs->buffering.future_record.len;
        LDR      R6,[R0, #+580]
// 4853     rec_epoch = hs->buffering.future_record.epoch;
        LDR      R8,[R0, #+584]
// 4854 
// 4855     if( rec == NULL )
        CMP      R4,#+0
        BEQ.N    ??ssl_load_buffered_record_0
// 4856         return( 0 );
// 4857 
// 4858     /* Only consider loading future records if the
// 4859      * input buffer is empty. */
// 4860     if( ssl_next_record_is_in_datagram( ssl ) == 1 )
        MOV      R0,R5
          CFI FunCall ssl_next_record_is_in_datagram
        BL       ssl_next_record_is_in_datagram
        CMP      R0,#+1
        BNE.N    ??ssl_load_buffered_record_1
// 4861         return( 0 );
??ssl_load_buffered_record_0:
        MOVS     R0,#+0
        B.N      ??ssl_load_buffered_record_2
// 4862 
// 4863     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> ssl_load_buffered_record" ) );
??ssl_load_buffered_record_1:
        LDR.W    R7,??DataTable41
        LDR.W    R0,??DataTable41_15
        STR      R0,[SP, #+0]
        MOVW     R3,#+4863
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4864 
// 4865     if( rec_epoch != ssl->in_epoch )
        LDRH     R0,[R5, #+132]
        CMP      R8,R0
        BEQ.N    ??ssl_load_buffered_record_3
// 4866     {
// 4867         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Buffered record not from current epoch." ) );
        LDR.W    R0,??DataTable41_16
        STR      R0,[SP, #+0]
        MOVW     R3,#+4867
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4868         goto exit;
        B.N      ??ssl_load_buffered_record_4
// 4869     }
// 4870 
// 4871     MBEDTLS_SSL_DEBUG_MSG( 2, ( "Found buffered record from current epoch - load" ) );
??ssl_load_buffered_record_3:
        LDR.W    R0,??DataTable41_17
        STR      R0,[SP, #+0]
        MOVW     R3,#+4871
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4872 
// 4873     /* Double-check that the record is not too large */
// 4874     if( rec_len > MBEDTLS_SSL_IN_BUFFER_LEN -
// 4875         (size_t)( ssl->in_hdr - ssl->in_buf ) )
        MOVW     R1,#+10573
        LDR      R0,[R5, #+100]
        SUBS     R1,R1,R0
        LDR      R0,[R5, #+92]
        ADDS     R1,R0,R1
        CMP      R1,R6
        BCS.N    ??ssl_load_buffered_record_5
// 4876     {
// 4877         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        LDR.W    R0,??DataTable40_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+4877
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4878         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        LDR.W    R0,??DataTable41_18  ;; 0xffff9400
        B.N      ??ssl_load_buffered_record_2
// 4879     }
// 4880 
// 4881     memcpy( ssl->in_hdr, rec, rec_len );
??ssl_load_buffered_record_5:
        MOV      R2,R6
        MOV      R1,R4
        LDR      R0,[R5, #+100]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 4882     ssl->in_left = rec_len;
        STR      R6,[R5, #+128]
// 4883     ssl->next_record_offset = 0;
        MOVS     R0,#+0
        STR      R0,[R5, #+136]
// 4884 
// 4885     ssl_free_buffered_record( ssl );
        MOV      R0,R5
          CFI FunCall ssl_free_buffered_record
        BL       ssl_free_buffered_record
// 4886 
// 4887 exit:
// 4888     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= ssl_load_buffered_record" ) );
??ssl_load_buffered_record_4:
        LDR.W    R0,??DataTable41_19
        STR      R0,[SP, #+0]
        MOVW     R3,#+4888
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4889     return( 0 );
        MOVS     R0,#+0
??ssl_load_buffered_record_2:
        POP      {R1,R2,R4-R8,PC}  ;; return
// 4890 }
          CFI EndBlock cfiBlock68

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable36:
        DATA32
        DC32     0xffff9880

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable36_1:
        DATA32
        DC32     ?_126

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable36_2:
        DATA32
        DC32     ?_127

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable36_3:
        DATA32
        DC32     ?_128

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable36_4:
        DATA32
        DC32     ?_129
// 4891 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock69 Using cfiCommon0
          CFI Function ssl_buffer_future_record
        THUMB
// 4892 static int ssl_buffer_future_record( mbedtls_ssl_context *ssl )
// 4893 {
ssl_buffer_future_record:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        SUB      SP,SP,#+16
          CFI CFA R13+40
        MOV      R5,R0
// 4894     mbedtls_ssl_handshake_params * const hs = ssl->handshake;
        LDR      R4,[R5, #+60]
// 4895     size_t const rec_hdr_len = 13;
// 4896     size_t const total_buf_sz = rec_hdr_len + ssl->in_msglen;
        LDR      R6,[R5, #+124]
        ADDS     R6,R6,#+13
// 4897 
// 4898     /* Don't buffer future records outside handshakes. */
// 4899     if( hs == NULL )
        CMP      R4,#+0
        BNE.N    ??ssl_buffer_future_record_0
// 4900         return( 0 );
        MOVS     R0,#+0
        B.N      ??ssl_buffer_future_record_1
// 4901 
// 4902     /* Only buffer handshake records (we are only interested
// 4903      * in Finished messages). */
// 4904     if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
??ssl_buffer_future_record_0:
        LDR      R0,[R5, #+120]
        CMP      R0,#+22
        BEQ.N    ??ssl_buffer_future_record_2
// 4905         return( 0 );
        MOVS     R0,#+0
        B.N      ??ssl_buffer_future_record_1
// 4906 
// 4907     /* Don't buffer more than one future epoch record. */
// 4908     if( hs->buffering.future_record.data != NULL )
??ssl_buffer_future_record_2:
        LDR      R0,[R4, #+576]
        CMP      R0,#+0
        BEQ.N    ??ssl_buffer_future_record_3
// 4909         return( 0 );
        MOVS     R0,#+0
        B.N      ??ssl_buffer_future_record_1
// 4910 
// 4911     /* Don't buffer record if there's not enough buffering space remaining. */
// 4912     if( total_buf_sz > ( MBEDTLS_SSL_DTLS_MAX_BUFFERING -
// 4913                          hs->buffering.total_bytes_buffered ) )
??ssl_buffer_future_record_3:
        LDR      R0,[R4, #+520]
        RSB      R0,R0,#+32768
        CMP      R0,R6
        BCS.N    ??ssl_buffer_future_record_4
// 4914     {
// 4915         MBEDTLS_SSL_DEBUG_MSG( 2, ( "Buffering of future epoch record of size %u would exceed the compile-time limit %u (already %u bytes buffered) -- ignore\n",
// 4916                         (unsigned) total_buf_sz, MBEDTLS_SSL_DTLS_MAX_BUFFERING,
// 4917                         (unsigned) hs->buffering.total_bytes_buffered ) );
        LDR      R0,[R4, #+520]
        STR      R0,[SP, #+12]
        MOV      R0,#+32768
        STR      R0,[SP, #+8]
        STR      R6,[SP, #+4]
        LDR.W    R0,??DataTable41_20
        STR      R0,[SP, #+0]
        MOVW     R3,#+4917
        LDR.W    R2,??DataTable41
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4918         return( 0 );
        MOVS     R0,#+0
        B.N      ??ssl_buffer_future_record_1
// 4919     }
// 4920 
// 4921     /* Buffer record */
// 4922     MBEDTLS_SSL_DEBUG_MSG( 2, ( "Buffer record from epoch %u",
// 4923                                 ssl->in_epoch + 1 ) );
??ssl_buffer_future_record_4:
        LDR.W    R7,??DataTable41
        LDRH     R0,[R5, #+132]
        ADDS     R0,R0,#+1
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable41_21
        STR      R0,[SP, #+0]
        MOVW     R3,#+4923
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 4924     MBEDTLS_SSL_DEBUG_BUF( 3, "Buffered record", ssl->in_hdr,
// 4925                            rec_hdr_len + ssl->in_msglen );
        LDR      R0,[R5, #+124]
        ADDS     R0,R0,#+13
        STR      R0,[SP, #+8]
        LDR      R0,[R5, #+100]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable41_22
        STR      R0,[SP, #+0]
        MOVW     R3,#+4925
        MOV      R2,R7
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 4926 
// 4927     /* ssl_parse_record_header() only considers records
// 4928      * of the next epoch as candidates for buffering. */
// 4929     hs->buffering.future_record.epoch = ssl->in_epoch + 1;
        LDRH     R0,[R5, #+132]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+584]
// 4930     hs->buffering.future_record.len   = total_buf_sz;
        STR      R6,[R4, #+580]
// 4931 
// 4932     hs->buffering.future_record.data =
// 4933         mbedtls_calloc( 1, hs->buffering.future_record.len );
        MOV      R1,R6
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R4, #+576]
// 4934     if( hs->buffering.future_record.data == NULL )
        CMP      R0,#+0
        BNE.N    ??ssl_buffer_future_record_5
// 4935     {
// 4936         /* If we run out of RAM trying to buffer a
// 4937          * record from the next epoch, just ignore. */
// 4938         return( 0 );
        MOVS     R0,#+0
        B.N      ??ssl_buffer_future_record_1
// 4939     }
// 4940 
// 4941     memcpy( hs->buffering.future_record.data, ssl->in_hdr, total_buf_sz );
??ssl_buffer_future_record_5:
        MOV      R2,R6
        LDR      R1,[R5, #+100]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 4942 
// 4943     hs->buffering.total_bytes_buffered += total_buf_sz;
        LDR      R0,[R4, #+520]
        ADDS     R6,R6,R0
        STR      R6,[R4, #+520]
// 4944     return( 0 );
        MOVS     R0,#+0
??ssl_buffer_future_record_1:
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
// 4945 }
          CFI EndBlock cfiBlock69

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37:
        DATA8
        DC8      "",0x0,0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_1:
        DATA32
        DC32     ?_130

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_2:
        DATA32
        DC32     ?_131

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_3:
        DATA32
        DC32     ?_132

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_4:
        DATA32
        DC32     ?_133

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_5:
        DATA32
        DC32     0xffff9900

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_6:
        DATA32
        DC32     ?_134

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_7:
        DATA32
        DC32     ?_135

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_8:
        DATA32
        DC32     ?_136

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_9:
        DATA32
        DC32     ?_137
// 4946 
// 4947 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 4948 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock70 Using cfiCommon0
          CFI Function ssl_get_next_record
        THUMB
// 4949 static int ssl_get_next_record( mbedtls_ssl_context *ssl )
// 4950 {
ssl_get_next_record:
        PUSH     {R1-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        MOV      R5,R0
// 4951     int ret;
// 4952 
// 4953 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 4954     /* We might have buffered a future record; if so,
// 4955      * and if the epoch matches now, load it.
// 4956      * On success, this call will set ssl->in_left to
// 4957      * the length of the buffered record, so that
// 4958      * the calls to ssl_fetch_input() below will
// 4959      * essentially be no-ops. */
// 4960     ret = ssl_load_buffered_record( ssl );
          CFI FunCall ssl_load_buffered_record
        BL       ssl_load_buffered_record
        MOVS     R4,R0
// 4961     if( ret != 0 )
        BNE.W    ??ssl_get_next_record_0
// 4962         return( ret );
// 4963 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 4964 
// 4965     if( ( ret = mbedtls_ssl_fetch_input( ssl, mbedtls_ssl_hdr_len( ssl ) ) ) != 0 )
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_hdr_len
        BL       mbedtls_ssl_hdr_len
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_fetch_input
        BL       mbedtls_ssl_fetch_input
        MOVS     R4,R0
        BEQ.N    ??ssl_get_next_record_1
// 4966     {
// 4967         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable41_23
        STR      R0,[SP, #+0]
        MOVW     R3,#+4967
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 4968         return( ret );
        MOV      R0,R4
        POP      {R1-R5,PC}
// 4969     }
// 4970 
// 4971     if( ( ret = ssl_parse_record_header( ssl ) ) != 0 )
??ssl_get_next_record_1:
        MOV      R0,R5
          CFI FunCall ssl_parse_record_header
        BL       ssl_parse_record_header
        MOVS     R4,R0
        BEQ.N    ??ssl_get_next_record_2
// 4972     {
// 4973 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 4974         if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 4975             ret != MBEDTLS_ERR_SSL_CLIENT_RECONNECT )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.W    ??ssl_get_next_record_0
        CMN      R4,#+26496
        BEQ.W    ??ssl_get_next_record_0
// 4976         {
// 4977             if( ret == MBEDTLS_ERR_SSL_EARLY_MESSAGE )
        CMN      R4,#+25728
        BNE.N    ??ssl_get_next_record_3
// 4978             {
// 4979                 ret = ssl_buffer_future_record( ssl );
        MOV      R0,R5
          CFI FunCall ssl_buffer_future_record
        BL       ssl_buffer_future_record
        MOVS     R4,R0
// 4980                 if( ret != 0 )
        BNE.W    ??ssl_get_next_record_0
// 4981                     return( ret );
// 4982 
// 4983                 /* Fall through to handling of unexpected records */
// 4984                 ret = MBEDTLS_ERR_SSL_UNEXPECTED_RECORD;
        LDR.W    R4,??DataTable41_24  ;; 0xffff9900
// 4985             }
// 4986 
// 4987             if( ret == MBEDTLS_ERR_SSL_UNEXPECTED_RECORD )
??ssl_get_next_record_3:
        CMN      R4,#+26368
        BNE.N    ??ssl_get_next_record_4
// 4988             {
// 4989                 /* Skip unexpected record (but not whole datagram) */
// 4990                 ssl->next_record_offset = ssl->in_msglen
// 4991                                         + mbedtls_ssl_hdr_len( ssl );
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_hdr_len
        BL       mbedtls_ssl_hdr_len
        LDR      R1,[R5, #+124]
        ADDS     R0,R0,R1
        STR      R0,[R5, #+136]
// 4992 
// 4993                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "discarding unexpected record "
// 4994                                             "(header)" ) );
        LDR.W    R0,??DataTable41_25
        STR      R0,[SP, #+0]
        MOVW     R3,#+4994
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        B.N      ??ssl_get_next_record_5
// 4995             }
// 4996             else
// 4997             {
// 4998                 /* Skip invalid record and the rest of the datagram */
// 4999                 ssl->next_record_offset = 0;
??ssl_get_next_record_4:
        MOVS     R0,#+0
        STR      R0,[R5, #+136]
// 5000                 ssl->in_left = 0;
        STR      R0,[R5, #+128]
// 5001 
// 5002                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "discarding invalid record "
// 5003                                             "(header)" ) );
        LDR.W    R0,??DataTable41_26
        STR      R0,[SP, #+0]
        MOVW     R3,#+5003
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5004             }
// 5005 
// 5006             /* Get next record */
// 5007             return( MBEDTLS_ERR_SSL_CONTINUE_PROCESSING );
??ssl_get_next_record_5:
        LDR.W    R0,??DataTable42  ;; 0xffff9a80
        POP      {R1-R5,PC}
// 5008         }
// 5009 #endif
// 5010         return( ret );
// 5011     }
// 5012 
// 5013     /*
// 5014      * Read and optionally decrypt the message contents
// 5015      */
// 5016     if( ( ret = mbedtls_ssl_fetch_input( ssl,
// 5017                                  mbedtls_ssl_hdr_len( ssl ) + ssl->in_msglen ) ) != 0 )
??ssl_get_next_record_2:
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_hdr_len
        BL       mbedtls_ssl_hdr_len
        LDR      R1,[R5, #+124]
        ADDS     R0,R1,R0
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_fetch_input
        BL       mbedtls_ssl_fetch_input
        MOVS     R4,R0
        BEQ.N    ??ssl_get_next_record_6
// 5018     {
// 5019         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable41_23
        STR      R0,[SP, #+0]
        MOVW     R3,#+5019
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 5020         return( ret );
        MOV      R0,R4
        POP      {R1-R5,PC}
// 5021     }
// 5022 
// 5023     /* Done reading this record, get ready for the next one */
// 5024 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 5025     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
??ssl_get_next_record_6:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_get_next_record_7
// 5026     {
// 5027         ssl->next_record_offset = ssl->in_msglen + mbedtls_ssl_hdr_len( ssl );
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_hdr_len
        BL       mbedtls_ssl_hdr_len
        LDR      R1,[R5, #+124]
        ADDS     R0,R0,R1
        STR      R0,[R5, #+136]
// 5028         if( ssl->next_record_offset < ssl->in_left )
        LDR      R1,[R5, #+128]
        CMP      R0,R1
        BCS.N    ??ssl_get_next_record_8
// 5029         {
// 5030             MBEDTLS_SSL_DEBUG_MSG( 3, ( "more than one record within datagram" ) );
        LDR.W    R0,??DataTable41_27
        STR      R0,[SP, #+0]
        MOVW     R3,#+5030
        LDR.W    R2,??DataTable41
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        B.N      ??ssl_get_next_record_8
// 5031         }
// 5032     }
// 5033     else
// 5034 #endif
// 5035         ssl->in_left = 0;
??ssl_get_next_record_7:
        MOVS     R0,#+0
        STR      R0,[R5, #+128]
// 5036 
// 5037     if( ( ret = ssl_prepare_record_content( ssl ) ) != 0 )
??ssl_get_next_record_8:
        MOV      R0,R5
          CFI FunCall ssl_prepare_record_content
        BL       ssl_prepare_record_content
        MOVS     R4,R0
        BEQ.N    ??ssl_get_next_record_9
// 5038     {
// 5039 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 5040         if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_get_next_record_10
// 5041         {
// 5042             /* Silently discard invalid records */
// 5043             if( ret == MBEDTLS_ERR_SSL_INVALID_RECORD ||
// 5044                 ret == MBEDTLS_ERR_SSL_INVALID_MAC )
        CMN      R4,#+29184
        BEQ.N    ??ssl_get_next_record_11
        CMN      R4,#+29056
        BNE.N    ??ssl_get_next_record_0
// 5045             {
// 5046                 /* Except when waiting for Finished as a bad mac here
// 5047                  * probably means something went wrong in the handshake
// 5048                  * (eg wrong psk used, mitm downgrade attempt, etc.) */
// 5049                 if( ssl->state == MBEDTLS_SSL_CLIENT_FINISHED ||
// 5050                     ssl->state == MBEDTLS_SSL_SERVER_FINISHED )
??ssl_get_next_record_11:
        LDR      R0,[R5, #+4]
        CMP      R0,#+11
        BEQ.N    ??ssl_get_next_record_12
        CMP      R0,#+13
        BNE.N    ??ssl_get_next_record_13
// 5051                 {
// 5052 #if defined(MBEDTLS_SSL_ALL_ALERT_MESSAGES)
// 5053                     if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )
??ssl_get_next_record_12:
        CMN      R4,#+29056
        BNE.N    ??ssl_get_next_record_0
// 5054                     {
// 5055                         mbedtls_ssl_send_alert_message( ssl,
// 5056                                 MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5057                                 MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC );
        MOVS     R2,#+20
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
        B.N      ??ssl_get_next_record_0
// 5058                     }
// 5059 #endif
// 5060                     return( ret );
// 5061                 }
// 5062 
// 5063 #if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)
// 5064                 if( ssl->conf->badmac_limit != 0 &&
// 5065                     ++ssl->badmac_seen >= ssl->conf->badmac_limit )
??ssl_get_next_record_13:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+192]
        CMP      R0,#+0
        BEQ.N    ??ssl_get_next_record_14
        LDR      R0,[R5, #+24]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+24]
        LDR      R1,[R5, #+0]
        LDR      R1,[R1, #+192]
        CMP      R0,R1
        BCC.N    ??ssl_get_next_record_14
// 5066                 {
// 5067                     MBEDTLS_SSL_DEBUG_MSG( 1, ( "too many records with bad MAC" ) );
        LDR.W    R0,??DataTable42_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5067
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5068                     return( MBEDTLS_ERR_SSL_INVALID_MAC );
        LDR.W    R0,??DataTable42_2  ;; 0xffff8e80
        POP      {R1-R5,PC}
// 5069                 }
// 5070 #endif
// 5071 
// 5072                 /* As above, invalid records cause
// 5073                  * dismissal of the whole datagram. */
// 5074 
// 5075                 ssl->next_record_offset = 0;
??ssl_get_next_record_14:
        MOVS     R0,#+0
        STR      R0,[R5, #+136]
// 5076                 ssl->in_left = 0;
        STR      R0,[R5, #+128]
// 5077 
// 5078                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "discarding invalid record (mac)" ) );
        LDR.W    R0,??DataTable42_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5078
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5079                 return( MBEDTLS_ERR_SSL_CONTINUE_PROCESSING );
        LDR.W    R0,??DataTable42  ;; 0xffff9a80
        POP      {R1-R5,PC}
// 5080             }
// 5081 
// 5082             return( ret );
// 5083         }
// 5084         else
// 5085 #endif
// 5086         {
// 5087             /* Error out (and send alert) on invalid records */
// 5088 #if defined(MBEDTLS_SSL_ALL_ALERT_MESSAGES)
// 5089             if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )
??ssl_get_next_record_10:
        CMN      R4,#+29056
        BNE.N    ??ssl_get_next_record_0
// 5090             {
// 5091                 mbedtls_ssl_send_alert_message( ssl,
// 5092                         MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5093                         MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC );
        MOVS     R2,#+20
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 5094             }
// 5095 #endif
// 5096             return( ret );
??ssl_get_next_record_0:
        MOV      R0,R4
        POP      {R1-R5,PC}
// 5097         }
// 5098     }
// 5099 
// 5100     return( 0 );
??ssl_get_next_record_9:
        MOVS     R0,#+0
        POP      {R1-R5,PC}       ;; return
// 5101 }
          CFI EndBlock cfiBlock70

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38:
        DATA32
        DC32     ?_138

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_1:
        DATA32
        DC32     ?_139

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_2:
        DATA32
        DC32     ?_140

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_3:
        DATA32
        DC32     ?_141

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_4:
        DATA32
        DC32     ?_142

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_5:
        DATA32
        DC32     ?_144

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_6:
        DATA32
        DC32     ?_145
// 5102 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock71 Using cfiCommon0
          CFI Function mbedtls_ssl_handle_message_type
        THUMB
// 5103 int mbedtls_ssl_handle_message_type( mbedtls_ssl_context *ssl )
// 5104 {
mbedtls_ssl_handle_message_type:
        PUSH     {R1-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        MOV      R4,R0
// 5105     int ret;
// 5106 
// 5107     /*
// 5108      * Handle particular types of records
// 5109      */
// 5110     if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
        LDR      R0,[R4, #+120]
        CMP      R0,#+22
        BNE.N    ??mbedtls_ssl_handle_message_type_0
// 5111     {
// 5112         if( ( ret = mbedtls_ssl_prepare_handshake_record( ssl ) ) != 0 )
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_prepare_handshake_record
        BL       mbedtls_ssl_prepare_handshake_record
        CMP      R0,#+0
        BNE.W    ??mbedtls_ssl_handle_message_type_1
// 5113         {
// 5114             return( ret );
// 5115         }
// 5116     }
// 5117 
// 5118     if( ssl->in_msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )
??mbedtls_ssl_handle_message_type_0:
        LDR      R0,[R4, #+120]
        CMP      R0,#+20
        BNE.N    ??mbedtls_ssl_handle_message_type_2
// 5119     {
// 5120         if( ssl->in_msglen != 1 )
        LDR      R0,[R4, #+124]
        CMP      R0,#+1
        BEQ.N    ??mbedtls_ssl_handle_message_type_3
// 5121         {
// 5122             MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid CCS message, len: %d",
// 5123                            ssl->in_msglen ) );
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable43
        STR      R0,[SP, #+0]
        MOVW     R3,#+5123
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5124             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable43_1  ;; 0xffff8e00
        POP      {R1-R5,PC}
// 5125         }
// 5126 
// 5127         if( ssl->in_msg[0] != 1 )
??mbedtls_ssl_handle_message_type_3:
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??mbedtls_ssl_handle_message_type_4
// 5128         {
// 5129             MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid CCS message, content: %02x",
// 5130                                         ssl->in_msg[0] ) );
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+0]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable43_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+5130
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5131             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable43_1  ;; 0xffff8e00
        POP      {R1-R5,PC}
// 5132         }
// 5133 
// 5134 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 5135         if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 5136             ssl->state != MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC    &&
// 5137             ssl->state != MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC )
??mbedtls_ssl_handle_message_type_4:
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handle_message_type_2
        LDR      R0,[R4, #+4]
        CMP      R0,#+10
        BEQ.N    ??mbedtls_ssl_handle_message_type_2
        CMP      R0,#+12
        BEQ.N    ??mbedtls_ssl_handle_message_type_2
// 5138         {
// 5139             if( ssl->handshake == NULL )
        LDR      R0,[R4, #+60]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_handle_message_type_5
// 5140             {
// 5141                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "dropping ChangeCipherSpec outside handshake" ) );
        LDR.W    R0,??DataTable43_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5141
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5142                 return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );
        LDR.W    R0,??DataTable41_24  ;; 0xffff9900
        POP      {R1-R5,PC}
// 5143             }
// 5144 
// 5145             MBEDTLS_SSL_DEBUG_MSG( 1, ( "received out-of-order ChangeCipherSpec - remember" ) );
??mbedtls_ssl_handle_message_type_5:
        LDR.W    R0,??DataTable43_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+5145
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5146             return( MBEDTLS_ERR_SSL_EARLY_MESSAGE );
        LDR.W    R0,??DataTable43_5  ;; 0xffff9b80
        POP      {R1-R5,PC}
// 5147         }
// 5148 #endif
// 5149     }
// 5150 
// 5151     if( ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT )
??mbedtls_ssl_handle_message_type_2:
        LDR      R0,[R4, #+120]
        CMP      R0,#+21
        BNE.N    ??mbedtls_ssl_handle_message_type_6
// 5152     {
// 5153         if( ssl->in_msglen != 2 )
        LDR      R0,[R4, #+124]
        CMP      R0,#+2
        BEQ.N    ??mbedtls_ssl_handle_message_type_7
// 5154         {
// 5155             /* Note: Standard allows for more than one 2 byte alert
// 5156                to be packed in a single message, but Mbed TLS doesn't
// 5157                currently support this. */
// 5158             MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid alert message, len: %d",
// 5159                            ssl->in_msglen ) );
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable43_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+5159
        LDR.W    R2,??DataTable41
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5160             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
        LDR.W    R0,??DataTable43_1  ;; 0xffff8e00
        POP      {R1-R5,PC}
// 5161         }
// 5162 
// 5163         MBEDTLS_SSL_DEBUG_MSG( 2, ( "got an alert message, type: [%d:%d]",
// 5164                        ssl->in_msg[0], ssl->in_msg[1] ) );
??mbedtls_ssl_handle_message_type_7:
        LDR.N    R5,??DataTable41
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+1]
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+0]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable44
        STR      R0,[SP, #+0]
        MOVW     R3,#+5164
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5165 
// 5166         /*
// 5167          * Ignore non-fatal alerts, except close_notify and no_renegotiation
// 5168          */
// 5169         if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_FATAL )
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        LDR      R0,[R4, #+112]
        BNE.N    ??mbedtls_ssl_handle_message_type_8
// 5170         {
// 5171             MBEDTLS_SSL_DEBUG_MSG( 1, ( "is a fatal alert message (msg %d)",
// 5172                            ssl->in_msg[1] ) );
        LDRB     R0,[R0, #+1]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable44_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5172
        MOV      R2,R5
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5173             return( MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE );
        LDR.W    R0,??DataTable44_2  ;; 0xffff8880
        POP      {R1-R5,PC}
// 5174         }
// 5175 
// 5176         if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
// 5177             ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY )
??mbedtls_ssl_handle_message_type_8:
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_handle_message_type_9
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_handle_message_type_9
// 5178         {
// 5179             MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a close notify message" ) );
        LDR.W    R0,??DataTable44_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5179
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5180             return( MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY );
        LDR.W    R0,??DataTable44_4  ;; 0xffff8780
        POP      {R1-R5,PC}
// 5181         }
// 5182 
// 5183 #if defined(MBEDTLS_SSL_RENEGOTIATION_ENABLED)
// 5184         if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
// 5185             ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION )
??mbedtls_ssl_handle_message_type_9:
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_handle_message_type_10
        LDR      R0,[R4, #+112]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+100
        BNE.N    ??mbedtls_ssl_handle_message_type_10
// 5186         {
// 5187             MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a SSLv3 no renegotiation alert" ) );
        LDR.W    R0,??DataTable44_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+5187
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5188             /* Will be handled when trying to parse ServerHello */
// 5189             return( 0 );
        MOVS     R0,#+0
        POP      {R1-R5,PC}
// 5190         }
// 5191 #endif
// 5192 
// 5193 #if defined(MBEDTLS_SSL_PROTO_SSL3) && defined(MBEDTLS_SSL_SRV_C)
// 5194         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 &&
// 5195             ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
// 5196             ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
// 5197             ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_CERT )
// 5198         {
// 5199             MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a SSLv3 no_cert" ) );
// 5200             /* Will be handled in mbedtls_ssl_parse_certificate() */
// 5201             return( 0 );
// 5202         }
// 5203 #endif /* MBEDTLS_SSL_PROTO_SSL3 && MBEDTLS_SSL_SRV_C */
// 5204 
// 5205         /* Silently ignore: fetch new message */
// 5206         return MBEDTLS_ERR_SSL_NON_FATAL;
??mbedtls_ssl_handle_message_type_10:
        LDR.W    R0,??DataTable44_6  ;; 0xffff9980
        POP      {R1-R5,PC}
// 5207     }
// 5208 
// 5209 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 5210     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 5211         ssl->handshake != NULL &&
// 5212         ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER  )
??mbedtls_ssl_handle_message_type_6:
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handle_message_type_11
        LDR      R0,[R4, #+60]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handle_message_type_11
        LDR      R0,[R4, #+4]
        CMP      R0,#+16
        BNE.N    ??mbedtls_ssl_handle_message_type_11
// 5213     {
// 5214         ssl_handshake_wrapup_free_hs_transform( ssl );
        MOV      R0,R4
          CFI FunCall ssl_handshake_wrapup_free_hs_transform
        BL       ssl_handshake_wrapup_free_hs_transform
// 5215     }
// 5216 #endif
// 5217 
// 5218     return( 0 );
??mbedtls_ssl_handle_message_type_11:
        MOVS     R0,#+0
??mbedtls_ssl_handle_message_type_1:
        POP      {R1-R5,PC}       ;; return
// 5219 }
          CFI EndBlock cfiBlock71

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable39:
        DATA32
        DC32     ?_143

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable39_1:
        DATA32
        DC32     ?_146

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable39_2:
        DATA32
        DC32     ?_149

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable39_3:
        DATA32
        DC32     ?_148

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable39_4:
        DATA32
        DC32     ?_147

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable39_5:
        DATA32
        DC32     ?_150

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable39_6:
        DATA32
        DC32     ?_151
// 5220 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock72 Using cfiCommon0
          CFI Function mbedtls_ssl_send_fatal_handshake_failure
        THUMB
// 5221 int mbedtls_ssl_send_fatal_handshake_failure( mbedtls_ssl_context *ssl )
// 5222 {
mbedtls_ssl_send_fatal_handshake_failure:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 5223     int ret;
// 5224 
// 5225     if( ( ret = mbedtls_ssl_send_alert_message( ssl,
// 5226                     MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5227                     MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE ) ) != 0 )
        MOVS     R2,#+40
        MOVS     R1,#+2
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_send_fatal_handshake_failure_0
// 5228     {
// 5229         return( ret );
// 5230     }
// 5231 
// 5232     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_send_fatal_handshake_failure_0:
        POP      {R1,PC}          ;; return
// 5233 }
          CFI EndBlock cfiBlock72
// 5234 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock73 Using cfiCommon0
          CFI Function mbedtls_ssl_send_alert_message
        THUMB
// 5235 int mbedtls_ssl_send_alert_message( mbedtls_ssl_context *ssl,
// 5236                             unsigned char level,
// 5237                             unsigned char message )
// 5238 {
mbedtls_ssl_send_alert_message:
        PUSH     {R1-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R5,R1
        MOV      R7,R2
// 5239     int ret;
// 5240 
// 5241     if( ssl == NULL || ssl->conf == NULL )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_send_alert_message_0
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_send_alert_message_1
// 5242         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_send_alert_message_0:
        LDR.W    R0,??DataTable44_7  ;; 0xffff8f00
        POP      {R1-R7,PC}
// 5243 
// 5244     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> send alert message" ) );
??mbedtls_ssl_send_alert_message_1:
        LDR.N    R6,??DataTable41
        LDR.W    R0,??DataTable44_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+5244
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5245     MBEDTLS_SSL_DEBUG_MSG( 3, ( "send alert level=%u message=%u", level, message ));
        MOV      R0,R7
        STR      R0,[SP, #+8]
        MOV      R0,R5
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable44_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+5245
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5246 
// 5247     ssl->out_msgtype = MBEDTLS_SSL_MSG_ALERT;
        MOVS     R0,#+21
        STR      R0,[R4, #+200]
// 5248     ssl->out_msglen = 2;
        MOVS     R0,#+2
        STR      R0,[R4, #+204]
// 5249     ssl->out_msg[0] = level;
        LDR      R0,[R4, #+196]
        STRB     R5,[R0, #+0]
// 5250     ssl->out_msg[1] = message;
        LDR      R0,[R4, #+196]
        STRB     R7,[R0, #+1]
// 5251 
// 5252     if( ( ret = mbedtls_ssl_write_record( ssl, SSL_FORCE_FLUSH ) ) != 0 )
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_write_record
        BL       mbedtls_ssl_write_record
        MOVS     R5,R0
        BEQ.N    ??mbedtls_ssl_send_alert_message_2
// 5253     {
// 5254         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable44_10
        STR      R0,[SP, #+0]
        MOVW     R3,#+5254
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 5255         return( ret );
        MOV      R0,R5
        POP      {R1-R7,PC}
// 5256     }
// 5257     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= send alert message" ) );
??mbedtls_ssl_send_alert_message_2:
        LDR.W    R0,??DataTable46
        STR      R0,[SP, #+0]
        MOVW     R3,#+5257
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5258 
// 5259     return( 0 );
        MOVS     R0,#+0
        POP      {R1-R7,PC}       ;; return
// 5260 }
          CFI EndBlock cfiBlock73

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40:
        DATA32
        DC32     ?_152

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_1:
        DATA32
        DC32     ?_153

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_2:
        DATA32
        DC32     ?_7

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_3:
        DATA32
        DC32     ?_154

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_4:
        DATA32
        DC32     ?_155

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_5:
        DATA32
        DC32     ?_156

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_6:
        DATA32
        DC32     ?_158

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_7:
        DATA32
        DC32     ?_159
// 5261 
// 5262 /*
// 5263  * Handshake functions
// 5264  */
// 5265 #if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)         && \ 
// 5266     !defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)     && \ 
// 5267     !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)     && \ 
// 5268     !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)   && \ 
// 5269     !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) && \ 
// 5270     !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)    && \ 
// 5271     !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
// 5272 /* No certificate support -> dummy functions */
// 5273 int mbedtls_ssl_write_certificate( mbedtls_ssl_context *ssl )
// 5274 {
// 5275     const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
// 5276 
// 5277     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate" ) );
// 5278 
// 5279     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
// 5280         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
// 5281         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
// 5282         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
// 5283     {
// 5284         MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate" ) );
// 5285         ssl->state++;
// 5286         return( 0 );
// 5287     }
// 5288 
// 5289     MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 5290     return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 5291 }
// 5292 
// 5293 int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
// 5294 {
// 5295     const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
// 5296 
// 5297     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate" ) );
// 5298 
// 5299     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
// 5300         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
// 5301         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
// 5302         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
// 5303     {
// 5304         MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate" ) );
// 5305         ssl->state++;
// 5306         return( 0 );
// 5307     }
// 5308 
// 5309     MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 5310     return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 5311 }
// 5312 
// 5313 #else
// 5314 /* Some certificate support -> implement write and parse */
// 5315 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock74 Using cfiCommon0
          CFI Function mbedtls_ssl_write_certificate
        THUMB
// 5316 int mbedtls_ssl_write_certificate( mbedtls_ssl_context *ssl )
// 5317 {
mbedtls_ssl_write_certificate:
        PUSH     {R0-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+40
        MOV      R6,R0
// 5318     int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
// 5319     size_t i, n;
// 5320     const mbedtls_x509_crt *crt;
// 5321     const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
        LDR      R0,[R6, #+76]
        LDR      R4,[R0, #+0]
// 5322 
// 5323     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate" ) );
        LDR.N    R7,??DataTable41
        LDR.W    R0,??DataTable45
        STR      R0,[SP, #+0]
        MOVW     R3,#+5323
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5324 
// 5325     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
// 5326         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
// 5327         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
// 5328         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
        LDRB     R0,[R4, #+10]
        CMP      R0,#+5
        BEQ.N    ??mbedtls_ssl_write_certificate_0
        CMP      R0,#+6
        BEQ.N    ??mbedtls_ssl_write_certificate_0
        CMP      R0,#+8
        BEQ.N    ??mbedtls_ssl_write_certificate_0
        CMP      R0,#+11
        BNE.N    ??mbedtls_ssl_write_certificate_1
// 5329     {
// 5330         MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate" ) );
??mbedtls_ssl_write_certificate_0:
        LDR.W    R0,??DataTable45_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5330
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5331         ssl->state++;
        LDR      R0,[R6, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R6, #+4]
// 5332         return( 0 );
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_write_certificate_2
// 5333     }
// 5334 
// 5335 #if defined(MBEDTLS_SSL_CLI_C)
// 5336     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
??mbedtls_ssl_write_certificate_1:
        LDR      R0,[R6, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BMI.N    ??mbedtls_ssl_write_certificate_3
// 5337     {
// 5338         if( ssl->client_auth == 0 )
        LDR      R0,[R6, #+224]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_write_certificate_3
// 5339         {
// 5340             MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate" ) );
        LDR.W    R0,??DataTable45_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5340
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5341             ssl->state++;
        LDR      R0,[R6, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R6, #+4]
// 5342             return( 0 );
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_write_certificate_2
// 5343         }
// 5344 
// 5345 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 5346         /*
// 5347          * If using SSLv3 and got no cert, send an Alert message
// 5348          * (otherwise an empty Certificate message will be sent).
// 5349          */
// 5350         if( mbedtls_ssl_own_cert( ssl )  == NULL &&
// 5351             ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
// 5352         {
// 5353             ssl->out_msglen  = 2;
// 5354             ssl->out_msgtype = MBEDTLS_SSL_MSG_ALERT;
// 5355             ssl->out_msg[0]  = MBEDTLS_SSL_ALERT_LEVEL_WARNING;
// 5356             ssl->out_msg[1]  = MBEDTLS_SSL_ALERT_MSG_NO_CERT;
// 5357 
// 5358             MBEDTLS_SSL_DEBUG_MSG( 2, ( "got no certificate to send" ) );
// 5359             goto write_msg;
// 5360         }
// 5361 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
// 5362     }
// 5363 #endif /* MBEDTLS_SSL_CLI_C */
// 5364 #if defined(MBEDTLS_SSL_SRV_C)
// 5365     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
??mbedtls_ssl_write_certificate_3:
        LDR      R0,[R6, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_write_certificate_4
// 5366     {
// 5367         if( mbedtls_ssl_own_cert( ssl ) == NULL )
        MOV      R0,R6
          CFI FunCall mbedtls_ssl_own_cert
        BL       mbedtls_ssl_own_cert
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_write_certificate_4
// 5368         {
// 5369             MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no certificate to send" ) );
        LDR.W    R0,??DataTable45_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+5369
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5370             return( MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED );
        LDR.W    R0,??DataTable45_3  ;; 0xffff8a80
        B.N      ??mbedtls_ssl_write_certificate_2
// 5371         }
// 5372     }
// 5373 #endif
// 5374 
// 5375     MBEDTLS_SSL_DEBUG_CRT( 3, "own certificate", mbedtls_ssl_own_cert( ssl ) );
??mbedtls_ssl_write_certificate_4:
        MOV      R0,R6
          CFI FunCall mbedtls_ssl_own_cert
        BL       mbedtls_ssl_own_cert
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable45_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+5375
        MOV      R2,R7
        MOVS     R1,#+3
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_crt
        BL       mbedtls_debug_print_crt
// 5376 
// 5377     /*
// 5378      *     0  .  0    handshake type
// 5379      *     1  .  3    handshake length
// 5380      *     4  .  6    length of all certs
// 5381      *     7  .  9    length of cert. 1
// 5382      *    10  . n-1   peer certificate
// 5383      *     n  . n+2   length of cert. 2
// 5384      *    n+3 . ...   upper level cert, etc.
// 5385      */
// 5386     i = 7;
        MOV      R8,#+7
// 5387     crt = mbedtls_ssl_own_cert( ssl );
        MOV      R0,R6
          CFI FunCall mbedtls_ssl_own_cert
        BL       mbedtls_ssl_own_cert
        MOV      R5,R0
        B.N      ??mbedtls_ssl_write_certificate_5
// 5388 
// 5389     while( crt != NULL )
// 5390     {
// 5391         n = crt->raw.len;
// 5392         if( n > MBEDTLS_SSL_OUT_CONTENT_LEN - 3 - i )
// 5393         {
// 5394             MBEDTLS_SSL_DEBUG_MSG( 1, ( "certificate too large, %d > %d",
// 5395                            i + 3 + n, MBEDTLS_SSL_OUT_CONTENT_LEN ) );
// 5396             return( MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE );
// 5397         }
// 5398 
// 5399         ssl->out_msg[i    ] = (unsigned char)( n >> 16 );
??mbedtls_ssl_write_certificate_6:
        MOV      R0,R4
        LSRS     R0,R0,#+16
        LDR      R1,[R6, #+196]
        STRB     R0,[R1, R8]
// 5400         ssl->out_msg[i + 1] = (unsigned char)( n >>  8 );
        MOV      R0,R4
        LSRS     R0,R0,#+8
        LDR      R1,[R6, #+196]
        ADD      R1,R1,R8
        STRB     R0,[R1, #+1]
// 5401         ssl->out_msg[i + 2] = (unsigned char)( n       );
        LDR      R0,[R6, #+196]
        ADD      R0,R0,R8
        STRB     R4,[R0, #+2]
// 5402 
// 5403         i += 3; memcpy( ssl->out_msg + i, crt->raw.p, n );
        ADD      R8,R8,#+3
        MOV      R2,R4
        LDR      R1,[R5, #+8]
        LDR      R0,[R6, #+196]
        ADD      R0,R0,R8
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 5404         i += n; crt = crt->next;
        ADD      R8,R4,R8
        LDR      R5,[R5, #+304]
??mbedtls_ssl_write_certificate_5:
        CMP      R5,#+0
        BEQ.N    ??mbedtls_ssl_write_certificate_7
        LDR      R4,[R5, #+4]
        MOVW     R0,#+10237
        SUB      R0,R0,R8
        CMP      R0,R4
        BCS.N    ??mbedtls_ssl_write_certificate_6
        MOV      R0,#+10240
        STR      R0,[SP, #+8]
        ADD      R8,R4,R8
        ADD      R8,R8,#+3
        STR      R8,[SP, #+4]
        LDR.W    R0,??DataTable46_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5395
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable46_2  ;; 0xffff8b00
        B.N      ??mbedtls_ssl_write_certificate_2
// 5405     }
// 5406 
// 5407     ssl->out_msg[4]  = (unsigned char)( ( i - 7 ) >> 16 );
// 5408     ssl->out_msg[5]  = (unsigned char)( ( i - 7 ) >>  8 );
// 5409     ssl->out_msg[6]  = (unsigned char)( ( i - 7 )       );
// 5410 
// 5411     ssl->out_msglen  = i;
// 5412     ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
// 5413     ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE;
// 5414 
// 5415 #if defined(MBEDTLS_SSL_PROTO_SSL3) && defined(MBEDTLS_SSL_CLI_C)
// 5416 write_msg:
// 5417 #endif
// 5418 
// 5419     ssl->state++;
// 5420 
// 5421     if( ( ret = mbedtls_ssl_write_handshake_msg( ssl ) ) != 0 )
// 5422     {
// 5423         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_handshake_msg", ret );
// 5424         return( ret );
// 5425     }
// 5426 
// 5427     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write certificate" ) );
??mbedtls_ssl_write_certificate_8:
        LDR.W    R0,??DataTable46_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5427
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5428 
// 5429     return( ret );
        MOV      R0,R4
??mbedtls_ssl_write_certificate_2:
        ADD      SP,SP,#+16
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI CFA R13+40
??mbedtls_ssl_write_certificate_7:
        SUB      R0,R8,#+7
        LSRS     R0,R0,#+16
        LDR      R1,[R6, #+196]
        STRB     R0,[R1, #+4]
        SUB      R0,R8,#+7
        LSRS     R0,R0,#+8
        LDR      R1,[R6, #+196]
        STRB     R0,[R1, #+5]
        MOV      R0,R8
        SUBS     R0,R0,#+7
        LDR      R1,[R6, #+196]
        STRB     R0,[R1, #+6]
        STR      R8,[R6, #+204]
        MOVS     R0,#+22
        STR      R0,[R6, #+200]
        MOVS     R0,#+11
        LDR      R1,[R6, #+196]
        STRB     R0,[R1, #+0]
        LDR      R0,[R6, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R6, #+4]
        MOV      R0,R6
          CFI FunCall mbedtls_ssl_write_handshake_msg
        BL       mbedtls_ssl_write_handshake_msg
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_write_certificate_8
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable48
        STR      R0,[SP, #+0]
        MOVW     R3,#+5423
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
        MOV      R0,R4
        B.N      ??mbedtls_ssl_write_certificate_2
// 5430 }
          CFI EndBlock cfiBlock74

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_1:
        DATA32
        DC32     ?_157

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_2:
        DATA32
        DC32     ?_160

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_3:
        DATA32
        DC32     ?_161

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_4:
        DATA32
        DC32     ?_162

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_5:
        DATA32
        DC32     ?_163

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_6:
        DATA32
        DC32     ?_164

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_7:
        DATA32
        DC32     ?_165

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_8:
        DATA32
        DC32     0xffff8100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_9:
        DATA32
        DC32     ?_167

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_10:
        DATA32
        DC32     ?_166

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_11:
        DATA32
        DC32     ?_170

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_12:
        DATA32
        DC32     ?_168

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_13:
        DATA32
        DC32     ?_171

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_14:
        DATA32
        DC32     ?_172

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_15:
        DATA32
        DC32     ?_173

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_16:
        DATA32
        DC32     ?_174

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_17:
        DATA32
        DC32     ?_175

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_18:
        DATA32
        DC32     0xffff9400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_19:
        DATA32
        DC32     ?_176

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_20:
        DATA32
        DC32     ?_177

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_21:
        DATA32
        DC32     ?_178

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_22:
        DATA32
        DC32     ?_179

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_23:
        DATA32
        DC32     ?_180

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_24:
        DATA32
        DC32     0xffff9900

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_25:
        DATA32
        DC32     ?_181

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_26:
        DATA32
        DC32     ?_182

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_27:
        DATA32
        DC32     ?_183
// 5431 

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock75 Using cfiCommon0
          CFI Function mbedtls_ssl_parse_certificate
        THUMB
// 5432 int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
// 5433 {
mbedtls_ssl_parse_certificate:
        PUSH     {R0-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+48
        MOV      R9,R0
// 5434     int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
// 5435     size_t i, n;
// 5436     const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
        LDR      R0,[R9, #+76]
        LDR      R6,[R0, #+0]
// 5437     int authmode = ssl->conf->authmode;
        LDR      R0,[R9, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R5,R0,#+2,#+2
// 5438     uint8_t alert;
// 5439 
// 5440     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate" ) );
        LDR.W    R7,??DataTable49
        LDR.W    R0,??DataTable48_1
        STR      R0,[SP, #+0]
        MOV      R3,#+5440
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5441 
// 5442     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
// 5443         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
// 5444         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
// 5445         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
        LDRB     R0,[R6, #+10]
        CMP      R0,#+5
        BEQ.N    ??mbedtls_ssl_parse_certificate_1
        CMP      R0,#+6
        BEQ.N    ??mbedtls_ssl_parse_certificate_1
        CMP      R0,#+8
        BEQ.N    ??mbedtls_ssl_parse_certificate_1
        CMP      R0,#+11
        BNE.N    ??mbedtls_ssl_parse_certificate_2
// 5446     {
// 5447         MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate" ) );
??mbedtls_ssl_parse_certificate_1:
        LDR.W    R0,??DataTable48_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+5447
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5448         ssl->state++;
        LDR      R0,[R9, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R9, #+4]
// 5449         return( 0 );
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5450     }
// 5451 
// 5452 #if defined(MBEDTLS_SSL_SRV_C)
// 5453     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
// 5454         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
??mbedtls_ssl_parse_certificate_2:
        LDR      R0,[R9, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_parse_certificate_4
        LDRB     R0,[R6, #+10]
        CMP      R0,#+7
        BNE.N    ??mbedtls_ssl_parse_certificate_4
// 5455     {
// 5456         MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate" ) );
        LDR.W    R0,??DataTable48_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+5456
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5457         ssl->state++;
        LDR      R0,[R9, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R9, #+4]
// 5458         return( 0 );
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5459     }
// 5460 
// 5461 #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
// 5462     if( ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET )
??mbedtls_ssl_parse_certificate_4:
        LDR      R0,[R9, #+60]
        LDR      R0,[R0, #+452]
        CMP      R0,#+3
        BEQ.N    ??mbedtls_ssl_parse_certificate_5
// 5463         authmode = ssl->handshake->sni_authmode;
        LDR      R0,[R9, #+60]
        LDR      R5,[R0, #+452]
// 5464 #endif
// 5465 
// 5466     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
// 5467         authmode == MBEDTLS_SSL_VERIFY_NONE )
??mbedtls_ssl_parse_certificate_5:
        LDR      R0,[R9, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_parse_certificate_6
        CMP      R5,#+0
        BNE.N    ??mbedtls_ssl_parse_certificate_6
// 5468     {
// 5469         ssl->session_negotiate->verify_result = MBEDTLS_X509_BADCERT_SKIP_VERIFY;
        MOVS     R0,#+128
        LDR      R1,[R9, #+56]
        STR      R0,[R1, #+96]
// 5470         MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate" ) );
        LDR.W    R0,??DataTable48_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+5470
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5471         ssl->state++;
        LDR      R0,[R9, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R9, #+4]
// 5472         return( 0 );
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5473     }
// 5474 #endif
// 5475 
// 5476     if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )
??mbedtls_ssl_parse_certificate_6:
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_read_record
        BL       mbedtls_ssl_read_record
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_parse_certificate_7
// 5477     {
// 5478         /* mbedtls_ssl_read_record may have sent an alert already. We
// 5479            let it decide whether to alert. */
// 5480         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable48_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5480
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 5481         return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5482     }
// 5483 
// 5484     ssl->state++;
??mbedtls_ssl_parse_certificate_7:
        LDR      R0,[R9, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R9, #+4]
// 5485 
// 5486 #if defined(MBEDTLS_SSL_SRV_C)
// 5487 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 5488     /*
// 5489      * Check if the client sent an empty certificate
// 5490      */
// 5491     if( ssl->conf->endpoint  == MBEDTLS_SSL_IS_SERVER &&
// 5492         ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
// 5493     {
// 5494         if( ssl->in_msglen  == 2                        &&
// 5495             ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT            &&
// 5496             ssl->in_msg[0]  == MBEDTLS_SSL_ALERT_LEVEL_WARNING  &&
// 5497             ssl->in_msg[1]  == MBEDTLS_SSL_ALERT_MSG_NO_CERT )
// 5498         {
// 5499             MBEDTLS_SSL_DEBUG_MSG( 1, ( "SSLv3 client has no certificate" ) );
// 5500 
// 5501             /* The client was asked for a certificate but didn't send
// 5502                one. The client should know what's going on, so we
// 5503                don't send an alert. */
// 5504             ssl->session_negotiate->verify_result = MBEDTLS_X509_BADCERT_MISSING;
// 5505             if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL )
// 5506                 return( 0 );
// 5507             else
// 5508                 return( MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE );
// 5509         }
// 5510     }
// 5511 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
// 5512 
// 5513 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ 
// 5514     defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 5515     if( ssl->conf->endpoint  == MBEDTLS_SSL_IS_SERVER &&
// 5516         ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
        LDR      R0,[R9, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_parse_certificate_8
        LDR      R0,[R9, #+20]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_certificate_8
// 5517     {
// 5518         if( ssl->in_hslen   == 3 + mbedtls_ssl_hs_hdr_len( ssl ) &&
// 5519             ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE    &&
// 5520             ssl->in_msg[0]  == MBEDTLS_SSL_HS_CERTIFICATE   &&
// 5521             memcmp( ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl ), "\0\0\0", 3 ) == 0 )
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        LDR      R1,[R9, #+160]
        ADDS     R0,R0,#+3
        CMP      R1,R0
        BNE.N    ??mbedtls_ssl_parse_certificate_8
        LDR      R0,[R9, #+120]
        CMP      R0,#+22
        BNE.N    ??mbedtls_ssl_parse_certificate_8
        LDR      R0,[R9, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+11
        BNE.N    ??mbedtls_ssl_parse_certificate_8
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        MOVS     R2,#+3
        ADR.N    R1,??mbedtls_ssl_parse_certificate_0  ;; 0x00, 0x00, 0x00, 0x00
        LDR      R3,[R9, #+112]
        ADD      R0,R3,R0
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_parse_certificate_8
// 5522         {
// 5523             MBEDTLS_SSL_DEBUG_MSG( 1, ( "TLSv1 client has no certificate" ) );
        LDR.W    R0,??DataTable49_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5523
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5524 
// 5525             /* The client was asked for a certificate but didn't send
// 5526                one. The client should know what's going on, so we
// 5527                don't send an alert. */
// 5528             ssl->session_negotiate->verify_result = MBEDTLS_X509_BADCERT_MISSING;
        MOVS     R0,#+64
        LDR      R1,[R9, #+56]
        STR      R0,[R1, #+96]
// 5529             if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL )
        CMP      R5,#+1
        BNE.N    ??mbedtls_ssl_parse_certificate_9
// 5530                 return( 0 );
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5531             else
// 5532                 return( MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE );
??mbedtls_ssl_parse_certificate_9:
        LDR.W    R0,??DataTable49_2  ;; 0xffff8b80
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5533         }
// 5534     }
// 5535 #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \ 
// 5536           MBEDTLS_SSL_PROTO_TLS1_2 */
// 5537 #endif /* MBEDTLS_SSL_SRV_C */
// 5538 
// 5539     if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
??mbedtls_ssl_parse_certificate_8:
        LDR      R0,[R9, #+120]
        CMP      R0,#+22
        BEQ.N    ??mbedtls_ssl_parse_certificate_10
// 5540     {
// 5541         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
        LDR.W    R0,??DataTable49_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5541
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5542         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5543                                         MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
        MOVS     R2,#+10
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 5544         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
        LDR.W    R0,??DataTable49_4  ;; 0xffff8900
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5545     }
// 5546 
// 5547     if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE ||
// 5548         ssl->in_hslen < mbedtls_ssl_hs_hdr_len( ssl ) + 3 + 3 )
??mbedtls_ssl_parse_certificate_10:
        LDR      R0,[R9, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+11
        BNE.N    ??mbedtls_ssl_parse_certificate_11
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        LDR      R1,[R9, #+160]
        ADDS     R0,R0,#+6
        CMP      R1,R0
        BCS.N    ??mbedtls_ssl_parse_certificate_12
// 5549     {
// 5550         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
??mbedtls_ssl_parse_certificate_11:
        LDR.W    R0,??DataTable49_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5550
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5551         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5552                                         MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        MOVS     R2,#+50
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 5553         return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
        LDR.W    R0,??DataTable49_5  ;; 0xffff8600
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5554     }
// 5555 
// 5556     i = mbedtls_ssl_hs_hdr_len( ssl );
??mbedtls_ssl_parse_certificate_12:
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        MOV      R10,R0
// 5557 
// 5558     /*
// 5559      * Same message structure as in mbedtls_ssl_write_certificate()
// 5560      */
// 5561     n = ( ssl->in_msg[i+1] << 8 ) | ssl->in_msg[i+2];
        LDR      R0,[R9, #+112]
        ADD      R0,R0,R10
        LDRB     R0,[R0, #+1]
        LDR      R1,[R9, #+112]
        ADD      R1,R1,R10
        LDRB     R8,[R1, #+2]
        ORR      R8,R8,R0, LSL #+8
// 5562 
// 5563     if( ssl->in_msg[i] != 0 ||
// 5564         ssl->in_hslen != n + 3 + mbedtls_ssl_hs_hdr_len( ssl ) )
        LDR      R0,[R9, #+112]
        LDRB     R0,[R0, R10]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_parse_certificate_13
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        LDR      R1,[R9, #+160]
        ADD      R8,R0,R8
        ADD      R8,R8,#+3
        CMP      R1,R8
        BEQ.N    ??mbedtls_ssl_parse_certificate_14
// 5565     {
// 5566         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
??mbedtls_ssl_parse_certificate_13:
        LDR.W    R0,??DataTable49_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5566
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5567         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5568                                         MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        MOVS     R2,#+50
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 5569         return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
        LDR.W    R0,??DataTable49_5  ;; 0xffff8600
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5570     }
// 5571 
// 5572     /* In case we tried to reuse a session but it failed */
// 5573     if( ssl->session_negotiate->peer_cert != NULL )
??mbedtls_ssl_parse_certificate_14:
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_certificate_15
// 5574     {
// 5575         mbedtls_x509_crt_free( ssl->session_negotiate->peer_cert );
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
          CFI FunCall mbedtls_x509_crt_free
        BL       mbedtls_x509_crt_free
// 5576         mbedtls_free( ssl->session_negotiate->peer_cert );
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 5577     }
// 5578 
// 5579     if( ( ssl->session_negotiate->peer_cert = mbedtls_calloc( 1,
// 5580                     sizeof( mbedtls_x509_crt ) ) ) == NULL )
??mbedtls_ssl_parse_certificate_15:
        MOV      R1,#+308
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        LDR      R1,[R9, #+56]
        STR      R0,[R1, #+92]
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_parse_certificate_16
// 5581     {
// 5582         MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed",
// 5583                        sizeof( mbedtls_x509_crt ) ) );
        MOV      R0,#+308
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable49_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+5583
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5584         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5585                                         MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
        MOVS     R2,#+80
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 5586         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        LDR.W    R0,??DataTable49_7  ;; 0xffff8100
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5587     }
// 5588 
// 5589     mbedtls_x509_crt_init( ssl->session_negotiate->peer_cert );
??mbedtls_ssl_parse_certificate_16:
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
          CFI FunCall mbedtls_x509_crt_init
        BL       mbedtls_x509_crt_init
// 5590 
// 5591     i += 3;
        ADD      R10,R10,#+3
        B.N      ??mbedtls_ssl_parse_certificate_17
// 5592 
// 5593     while( i < ssl->in_hslen )
// 5594     {
// 5595         if ( i + 3 > ssl->in_hslen ) {
// 5596             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
// 5597             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5598                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
// 5599             return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
// 5600         }
// 5601         if( ssl->in_msg[i] != 0 )
??mbedtls_ssl_parse_certificate_18:
        LDR      R0,[R9, #+112]
        LDRB     R0,[R0, R10]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_parse_certificate_19
// 5602         {
// 5603             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
// 5604             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5605                                             MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
// 5606             return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
// 5607         }
// 5608 
// 5609         n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )
// 5610             | (unsigned int) ssl->in_msg[i + 2];
        LDR      R0,[R9, #+112]
        ADD      R0,R0,R10
        LDRB     R0,[R0, #+1]
        LDR      R1,[R9, #+112]
        ADD      R1,R1,R10
        LDRB     R8,[R1, #+2]
        ORR      R8,R8,R0, LSL #+8
// 5611         i += 3;
        ADD      R10,R10,#+3
// 5612 
// 5613         if( n < 128 || i + n > ssl->in_hslen )
        CMP      R8,#+128
        BCC.W    ??mbedtls_ssl_parse_certificate_20
        LDR      R0,[R9, #+160]
        ADD      R1,R8,R10
        CMP      R0,R1
        BCC.W    ??mbedtls_ssl_parse_certificate_20
// 5614         {
// 5615             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
// 5616             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5617                                             MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
// 5618             return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
// 5619         }
// 5620 
// 5621         ret = mbedtls_x509_crt_parse_der( ssl->session_negotiate->peer_cert,
// 5622                                   ssl->in_msg + i, n );
        MOV      R2,R8
        LDR      R0,[R9, #+112]
        ADD      R1,R0,R10
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
          CFI FunCall mbedtls_x509_crt_parse_der
        BL       mbedtls_x509_crt_parse_der
        MOVS     R4,R0
// 5623         switch( ret )
        BEQ.N    ??mbedtls_ssl_parse_certificate_21
        LDR.W    R1,??DataTable50  ;; 0xffffd780
        SUBS     R0,R0,R1
        BEQ.N    ??mbedtls_ssl_parse_certificate_22
        MOVW     R1,#+594
        SUBS     R0,R0,R1
        BEQ.N    ??mbedtls_ssl_parse_certificate_21
        SUBS     R0,R0,#+174
        BEQ.W    ??mbedtls_ssl_parse_certificate_23
        B.N      ??mbedtls_ssl_parse_certificate_24
        DATA
??mbedtls_ssl_parse_certificate_0:
        DATA8
        DC8      0x00, 0x00, 0x00, 0x00
        THUMB
// 5624         {
// 5625         case 0: /*ok*/
// 5626         case MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + MBEDTLS_ERR_OID_NOT_FOUND:
// 5627             /* Ignore certificate with an unknown algorithm: maybe a
// 5628                prior certificate was already trusted. */
// 5629             break;
// 5630 
// 5631         case MBEDTLS_ERR_X509_ALLOC_FAILED:
// 5632             alert = MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR;
// 5633             goto crt_parse_der_failed;
// 5634 
// 5635         case MBEDTLS_ERR_X509_UNKNOWN_VERSION:
// 5636             alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
// 5637             goto crt_parse_der_failed;
// 5638 
// 5639         default:
// 5640             alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;
// 5641         crt_parse_der_failed:
// 5642             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, alert );
// 5643             MBEDTLS_SSL_DEBUG_RET( 1, " mbedtls_x509_crt_parse_der", ret );
// 5644             return( ret );
// 5645         }
// 5646 
// 5647         i += n;
??mbedtls_ssl_parse_certificate_21:
        ADD      R10,R8,R10
??mbedtls_ssl_parse_certificate_17:
        LDR      R0,[R9, #+160]
        CMP      R10,R0
        BCS.W    ??mbedtls_ssl_parse_certificate_25
        ADD      R1,R10,#+3
        CMP      R0,R1
        BCS.N    ??mbedtls_ssl_parse_certificate_18
        LDR.W    R0,??DataTable49_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5596
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        MOVS     R2,#+50
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
        LDR.W    R0,??DataTable49_5  ;; 0xffff8600
        B.N      ??mbedtls_ssl_parse_certificate_3
??mbedtls_ssl_parse_certificate_19:
        LDR.W    R0,??DataTable49_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5603
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        MOVS     R2,#+50
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
        LDR.W    R0,??DataTable49_5  ;; 0xffff8600
        B.N      ??mbedtls_ssl_parse_certificate_3
??mbedtls_ssl_parse_certificate_22:
        MOVS     R2,#+80
        B.N      ??mbedtls_ssl_parse_certificate_26
// 5648     }
// 5649 
// 5650     MBEDTLS_SSL_DEBUG_CRT( 3, "peer certificate", ssl->session_negotiate->peer_cert );
// 5651 
// 5652     /*
// 5653      * On client, make sure the server cert doesn't change during renego to
// 5654      * avoid "triple handshake" attack: https://secure-resumption.com/
// 5655      */
// 5656 #if defined(MBEDTLS_SSL_RENEGOTIATION) && defined(MBEDTLS_SSL_CLI_C)
// 5657     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
// 5658         ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
// 5659     {
// 5660         if( ssl->session->peer_cert == NULL )
// 5661         {
// 5662             MBEDTLS_SSL_DEBUG_MSG( 1, ( "new server cert during renegotiation" ) );
// 5663             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5664                                             MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED );
// 5665             return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
// 5666         }
// 5667 
// 5668         if( ssl->session->peer_cert->raw.len !=
// 5669             ssl->session_negotiate->peer_cert->raw.len ||
// 5670             memcmp( ssl->session->peer_cert->raw.p,
// 5671                     ssl->session_negotiate->peer_cert->raw.p,
// 5672                     ssl->session->peer_cert->raw.len ) != 0 )
??mbedtls_ssl_parse_certificate_27:
        LDR      R0,[R9, #+52]
        LDR      R0,[R0, #+92]
        LDR      R0,[R0, #+4]
        LDR      R1,[R9, #+56]
        LDR      R1,[R1, #+92]
        LDR      R1,[R1, #+4]
        CMP      R0,R1
        BNE.N    ??mbedtls_ssl_parse_certificate_28
        LDR      R0,[R9, #+52]
        LDR      R0,[R0, #+92]
        LDR      R2,[R0, #+4]
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
        LDR      R1,[R0, #+8]
        LDR      R0,[R9, #+52]
        LDR      R0,[R0, #+92]
        LDR      R0,[R0, #+8]
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_certificate_29
// 5673         {
// 5674             MBEDTLS_SSL_DEBUG_MSG( 1, ( "server cert changed during renegotiation" ) );
??mbedtls_ssl_parse_certificate_28:
        LDR.W    R0,??DataTable50_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5674
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5675             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5676                                             MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED );
        MOVS     R2,#+49
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 5677             return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
        LDR.W    R0,??DataTable49_5  ;; 0xffff8600
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5678         }
// 5679     }
// 5680 #endif /* MBEDTLS_SSL_RENEGOTIATION && MBEDTLS_SSL_CLI_C */
// 5681 
// 5682     if( authmode != MBEDTLS_SSL_VERIFY_NONE )
??mbedtls_ssl_parse_certificate_29:
        CMP      R5,#+0
        BEQ.W    ??mbedtls_ssl_parse_certificate_30
// 5683     {
// 5684         mbedtls_x509_crt *ca_chain;
// 5685         mbedtls_x509_crl *ca_crl;
// 5686 
// 5687 #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
// 5688         if( ssl->handshake->sni_ca_chain != NULL )
        LDR      R0,[R9, #+60]
        LDR      R0,[R0, #+460]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_certificate_31
// 5689         {
// 5690             ca_chain = ssl->handshake->sni_ca_chain;
        LDR      R0,[R9, #+60]
        LDR      R8,[R0, #+460]
// 5691             ca_crl   = ssl->handshake->sni_ca_crl;
        LDR      R2,[R0, #+464]
        B.N      ??mbedtls_ssl_parse_certificate_32
// 5692         }
// 5693         else
// 5694 #endif
// 5695         {
// 5696             ca_chain = ssl->conf->ca_chain;
??mbedtls_ssl_parse_certificate_31:
        LDR      R0,[R9, #+0]
        LDR      R8,[R0, #+108]
// 5697             ca_crl   = ssl->conf->ca_crl;
        LDR      R2,[R0, #+112]
// 5698         }
// 5699 
// 5700         /*
// 5701          * Main check: verify certificate
// 5702          */
// 5703         ret = mbedtls_x509_crt_verify_with_profile(
// 5704                                 ssl->session_negotiate->peer_cert,
// 5705                                 ca_chain, ca_crl,
// 5706                                 ssl->conf->cert_profile,
// 5707                                 ssl->hostname,
// 5708                                &ssl->session_negotiate->verify_result,
// 5709                                 ssl->conf->f_vrfy, ssl->conf->p_vrfy );
??mbedtls_ssl_parse_certificate_32:
        LDR      R0,[R9, #+0]
        LDR      R0,[R0, #+56]
        STR      R0,[SP, #+12]
        LDR      R0,[R9, #+0]
        LDR      R0,[R0, #+52]
        STR      R0,[SP, #+8]
        LDR      R0,[R9, #+56]
        ADDS     R0,R0,#+96
        STR      R0,[SP, #+4]
        LDR      R0,[R9, #+228]
        STR      R0,[SP, #+0]
        LDR      R0,[R9, #+0]
        LDR      R3,[R0, #+100]
        MOV      R1,R8
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
          CFI FunCall mbedtls_x509_crt_verify_with_profile
        BL       mbedtls_x509_crt_verify_with_profile
        MOVS     R4,R0
// 5710 
// 5711         if( ret != 0 )
        BEQ.N    ??mbedtls_ssl_parse_certificate_33
// 5712         {
// 5713             MBEDTLS_SSL_DEBUG_RET( 1, "x509_verify_cert", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable50_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+5713
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 5714         }
// 5715 
// 5716         /*
// 5717          * Secondary checks: always done, but change 'ret' only if it was 0
// 5718          */
// 5719 
// 5720 #if defined(MBEDTLS_ECP_C)
// 5721         {
// 5722             const mbedtls_pk_context *pk = &ssl->session_negotiate->peer_cert->pk;
??mbedtls_ssl_parse_certificate_33:
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
        ADD      R10,R0,#+188
// 5723 
// 5724             /* If certificate uses an EC key, make sure the curve is OK */
// 5725             if( mbedtls_pk_can_do( pk, MBEDTLS_PK_ECKEY ) &&
// 5726                 mbedtls_ssl_check_curve( ssl, mbedtls_pk_ec( *pk )->grp.id ) != 0 )
        MOVS     R1,#+2
        MOV      R0,R10
          CFI FunCall mbedtls_pk_can_do
        BL       mbedtls_pk_can_do
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_certificate_34
        LDRD     R0,R1,[R10, #+0]
          CFI FunCall mbedtls_pk_ec
        BL       mbedtls_pk_ec
        LDRB     R1,[R0, #+0]
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_check_curve
        BL       mbedtls_ssl_check_curve
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_certificate_34
// 5727             {
// 5728                 ssl->session_negotiate->verify_result |= MBEDTLS_X509_BADCERT_BAD_KEY;
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+96]
        ORR      R0,R0,#0x10000
        LDR      R1,[R9, #+56]
        STR      R0,[R1, #+96]
// 5729 
// 5730                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate (EC key curve)" ) );
        LDR.W    R0,??DataTable51
        STR      R0,[SP, #+0]
        MOVW     R3,#+5730
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5731                 if( ret == 0 )
        CMP      R4,#+0
        BNE.N    ??mbedtls_ssl_parse_certificate_34
// 5732                     ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;
        LDR.W    R4,??DataTable49_5  ;; 0xffff8600
// 5733             }
// 5734         }
// 5735 #endif /* MBEDTLS_ECP_C */
// 5736 
// 5737         if( mbedtls_ssl_check_cert_usage( ssl->session_negotiate->peer_cert,
// 5738                                  ciphersuite_info,
// 5739                                  ! ssl->conf->endpoint,
// 5740                                  &ssl->session_negotiate->verify_result ) != 0 )
??mbedtls_ssl_parse_certificate_34:
        LDR      R0,[R9, #+56]
        ADD      R3,R0,#+96
        LDR      R0,[R9, #+0]
        LDR      R2,[R0, #+204]
        EOR      R2,R2,#0x1
        AND      R2,R2,#0x1
        MOV      R1,R6
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
          CFI FunCall mbedtls_ssl_check_cert_usage
        BL       mbedtls_ssl_check_cert_usage
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_certificate_35
// 5741         {
// 5742             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate (usage extensions)" ) );
        LDR.W    R0,??DataTable52
        STR      R0,[SP, #+0]
        MOVW     R3,#+5742
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5743             if( ret == 0 )
        CMP      R4,#+0
        BNE.N    ??mbedtls_ssl_parse_certificate_35
// 5744                 ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;
        LDR.W    R4,??DataTable49_5  ;; 0xffff8600
// 5745         }
// 5746 
// 5747         /* mbedtls_x509_crt_verify_with_profile is supposed to report a
// 5748          * verification failure through MBEDTLS_ERR_X509_CERT_VERIFY_FAILED,
// 5749          * with details encoded in the verification flags. All other kinds
// 5750          * of error codes, including those from the user provided f_vrfy
// 5751          * functions, are treated as fatal and lead to a failure of
// 5752          * ssl_parse_certificate even if verification was optional. */
// 5753         if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL &&
// 5754             ( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED ||
// 5755               ret == MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE ) )
??mbedtls_ssl_parse_certificate_35:
        CMP      R5,#+1
        BNE.N    ??mbedtls_ssl_parse_certificate_36
        CMN      R4,#+9984
        BEQ.N    ??mbedtls_ssl_parse_certificate_37
        CMN      R4,#+31232
        BNE.N    ??mbedtls_ssl_parse_certificate_36
// 5756         {
// 5757             ret = 0;
??mbedtls_ssl_parse_certificate_37:
        MOVS     R4,#+0
// 5758         }
// 5759 
// 5760         if( ca_chain == NULL && authmode == MBEDTLS_SSL_VERIFY_REQUIRED )
??mbedtls_ssl_parse_certificate_36:
        CMP      R8,#+0
        BNE.N    ??mbedtls_ssl_parse_certificate_38
        CMP      R5,#+2
        BNE.N    ??mbedtls_ssl_parse_certificate_38
// 5761         {
// 5762             MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no CA chain" ) );
        LDR.W    R0,??DataTable52_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5762
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5763             ret = MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED;
        LDR.W    R4,??DataTable52_2  ;; 0xffff8980
// 5764         }
// 5765 
// 5766         if( ret != 0 )
??mbedtls_ssl_parse_certificate_38:
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_parse_certificate_39
// 5767         {
// 5768             /* The certificate may have been rejected for several reasons.
// 5769                Pick one and send the corresponding alert. Which alert to send
// 5770                may be a subject of debate in some cases. */
// 5771             if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_OTHER )
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+96]
        LSLS     R0,R0,#+23
        BPL.N    ??mbedtls_ssl_parse_certificate_40
// 5772                 alert = MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED;
        MOVS     R2,#+49
        B.N      ??mbedtls_ssl_parse_certificate_41
// 5773             else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_CN_MISMATCH )
??mbedtls_ssl_parse_certificate_40:
        LDR      R0,[R9, #+56]
        LDRB     R0,[R0, #+96]
        LSLS     R0,R0,#+29
        BPL.N    ??mbedtls_ssl_parse_certificate_42
// 5774                 alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;
        MOVS     R2,#+42
        B.N      ??mbedtls_ssl_parse_certificate_41
// 5775             else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_KEY_USAGE )
??mbedtls_ssl_parse_certificate_42:
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+96]
        TST      R0,#0x1B800
        BEQ.N    ??mbedtls_ssl_parse_certificate_43
// 5776                 alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
// 5777             else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_EXT_KEY_USAGE )
// 5778                 alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
// 5779             else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_NS_CERT_TYPE )
// 5780                 alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
// 5781             else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_BAD_PK )
// 5782                 alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
// 5783             else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_BAD_KEY )
// 5784                 alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
        MOVS     R2,#+43
        B.N      ??mbedtls_ssl_parse_certificate_41
// 5785             else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_EXPIRED )
??mbedtls_ssl_parse_certificate_43:
        LDR      R0,[R9, #+56]
        LDRB     R0,[R0, #+96]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_parse_certificate_44
// 5786                 alert = MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED;
        MOVS     R2,#+45
        B.N      ??mbedtls_ssl_parse_certificate_41
// 5787             else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_REVOKED )
??mbedtls_ssl_parse_certificate_44:
        LDR      R0,[R9, #+56]
        LDRB     R0,[R0, #+96]
        LSLS     R0,R0,#+30
        BPL.N    ??mbedtls_ssl_parse_certificate_45
// 5788                 alert = MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED;
        MOVS     R2,#+44
        B.N      ??mbedtls_ssl_parse_certificate_41
// 5789             else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_NOT_TRUSTED )
??mbedtls_ssl_parse_certificate_45:
        LDR      R0,[R9, #+56]
        LDRB     R0,[R0, #+96]
        LSLS     R0,R0,#+28
        BPL.N    ??mbedtls_ssl_parse_certificate_46
// 5790                 alert = MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA;
        MOVS     R2,#+48
        B.N      ??mbedtls_ssl_parse_certificate_41
// 5791             else
// 5792                 alert = MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN;
??mbedtls_ssl_parse_certificate_46:
        MOVS     R2,#+46
// 5793             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5794                                             alert );
??mbedtls_ssl_parse_certificate_41:
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 5795         }
// 5796 
// 5797 #if defined(MBEDTLS_DEBUG_C)
// 5798         if( ssl->session_negotiate->verify_result != 0 )
??mbedtls_ssl_parse_certificate_39:
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+96]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_certificate_47
// 5799         {
// 5800             MBEDTLS_SSL_DEBUG_MSG( 3, ( "! Certificate verification flags %x",
// 5801                                         ssl->session_negotiate->verify_result ) );
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+96]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable52_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5801
        MOV      R2,R7
        MOVS     R1,#+3
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        B.N      ??mbedtls_ssl_parse_certificate_30
// 5802         }
// 5803         else
// 5804         {
// 5805             MBEDTLS_SSL_DEBUG_MSG( 3, ( "Certificate verification flags clear" ) );
??mbedtls_ssl_parse_certificate_47:
        LDR.W    R0,??DataTable52_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+5805
        MOV      R2,R7
        MOVS     R1,#+3
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5806         }
// 5807 #endif /* MBEDTLS_DEBUG_C */
// 5808     }
// 5809 
// 5810     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse certificate" ) );
??mbedtls_ssl_parse_certificate_30:
        LDR.W    R0,??DataTable53
        STR      R0,[SP, #+0]
        MOVW     R3,#+5810
        MOV      R2,R7
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5811 
// 5812     return( ret );
        MOV      R0,R4
??mbedtls_ssl_parse_certificate_3:
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
          CFI CFA R13+48
??mbedtls_ssl_parse_certificate_25:
        LDR      R0,[R9, #+56]
        LDR      R0,[R0, #+92]
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable55
        STR      R0,[SP, #+0]
        MOVW     R3,#+5650
        MOV      R2,R7
        MOVS     R1,#+3
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_crt
        BL       mbedtls_debug_print_crt
        LDR      R0,[R9, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BMI.W    ??mbedtls_ssl_parse_certificate_29
        LDR      R0,[R9, #+8]
        CMP      R0,#+1
        BNE.W    ??mbedtls_ssl_parse_certificate_29
        LDR      R0,[R9, #+52]
        LDR      R0,[R0, #+92]
        CMP      R0,#+0
        BNE.W    ??mbedtls_ssl_parse_certificate_27
        LDR.W    R0,??DataTable55_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5662
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        MOVS     R2,#+49
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
        LDR.W    R0,??DataTable49_5  ;; 0xffff8600
        B.N      ??mbedtls_ssl_parse_certificate_3
??mbedtls_ssl_parse_certificate_20:
        LDR.W    R0,??DataTable49_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5615
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        MOVS     R2,#+50
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
        LDR.W    R0,??DataTable49_5  ;; 0xffff8600
        B.N      ??mbedtls_ssl_parse_certificate_3
??mbedtls_ssl_parse_certificate_23:
        MOVS     R2,#+43
        B.N      ??mbedtls_ssl_parse_certificate_26
??mbedtls_ssl_parse_certificate_24:
        MOVS     R2,#+42
??mbedtls_ssl_parse_certificate_26:
        MOVS     R1,#+2
        MOV      R0,R9
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable56
        STR      R0,[SP, #+0]
        MOVW     R3,#+5643
        MOV      R2,R7
        MOVS     R1,#+1
        MOV      R0,R9
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
        MOV      R0,R4
        B.N      ??mbedtls_ssl_parse_certificate_3
// 5813 }
          CFI EndBlock cfiBlock75

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42:
        DATA32
        DC32     0xffff9a80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42_1:
        DATA32
        DC32     ?_184

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42_2:
        DATA32
        DC32     0xffff8e80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42_3:
        DATA32
        DC32     ?_185
// 5814 #endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
// 5815           !MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
// 5816           !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
// 5817           !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
// 5818           !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
// 5819           !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
// 5820           !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
// 5821 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock76 Using cfiCommon0
          CFI Function mbedtls_ssl_write_change_cipher_spec
        THUMB
// 5822 int mbedtls_ssl_write_change_cipher_spec( mbedtls_ssl_context *ssl )
// 5823 {
mbedtls_ssl_write_change_cipher_spec:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R5,R0
// 5824     int ret;
// 5825 
// 5826     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write change cipher spec" ) );
        LDR.W    R6,??DataTable49
        LDR.W    R0,??DataTable55_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+5826
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5827 
// 5828     ssl->out_msgtype = MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC;
        MOVS     R0,#+20
        STR      R0,[R5, #+200]
// 5829     ssl->out_msglen  = 1;
        MOVS     R0,#+1
        STR      R0,[R5, #+204]
// 5830     ssl->out_msg[0]  = 1;
        LDR      R1,[R5, #+196]
        STRB     R0,[R1, #+0]
// 5831 
// 5832     ssl->state++;
        LDR      R0,[R5, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+4]
// 5833 
// 5834     if( ( ret = mbedtls_ssl_write_handshake_msg( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_write_handshake_msg
        BL       mbedtls_ssl_write_handshake_msg
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_write_change_cipher_spec_0
// 5835     {
// 5836         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_handshake_msg", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable48
        STR      R0,[SP, #+0]
        MOVW     R3,#+5836
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 5837         return( ret );
        MOV      R0,R4
        POP      {R1,R2,R4-R6,PC}
// 5838     }
// 5839 
// 5840     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write change cipher spec" ) );
??mbedtls_ssl_write_change_cipher_spec_0:
        LDR.W    R0,??DataTable56_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+5840
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5841 
// 5842     return( 0 );
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
// 5843 }
          CFI EndBlock cfiBlock76

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43:
        DATA32
        DC32     ?_186

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_1:
        DATA32
        DC32     0xffff8e00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_2:
        DATA32
        DC32     ?_187

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_3:
        DATA32
        DC32     ?_188

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_4:
        DATA32
        DC32     ?_189

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_5:
        DATA32
        DC32     0xffff9b80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_6:
        DATA32
        DC32     ?_190
// 5844 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock77 Using cfiCommon0
          CFI Function mbedtls_ssl_parse_change_cipher_spec
        THUMB
// 5845 int mbedtls_ssl_parse_change_cipher_spec( mbedtls_ssl_context *ssl )
// 5846 {
mbedtls_ssl_parse_change_cipher_spec:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R5,R0
// 5847     int ret;
// 5848 
// 5849     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse change cipher spec" ) );
        LDR.W    R6,??DataTable49
        LDR.W    R0,??DataTable55_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5849
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5850 
// 5851     if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_read_record
        BL       mbedtls_ssl_read_record
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_parse_change_cipher_spec_0
// 5852     {
// 5853         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable48_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5853
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 5854         return( ret );
        MOV      R0,R4
        POP      {R1,R2,R4-R6,PC}
// 5855     }
// 5856 
// 5857     if( ssl->in_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )
??mbedtls_ssl_parse_change_cipher_spec_0:
        LDR      R0,[R5, #+120]
        CMP      R0,#+20
        BEQ.N    ??mbedtls_ssl_parse_change_cipher_spec_1
// 5858     {
// 5859         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad change cipher spec message" ) );
        LDR.W    R0,??DataTable55_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+5859
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5860         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5861                                         MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
        MOVS     R2,#+10
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 5862         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
        LDR.W    R0,??DataTable49_4  ;; 0xffff8900
        POP      {R1,R2,R4-R6,PC}
// 5863     }
// 5864 
// 5865     /* CCS records are only accepted if they have length 1 and content '1',
// 5866      * so we don't need to check this here. */
// 5867 
// 5868     /*
// 5869      * Switch to our negotiated transform and session parameters for inbound
// 5870      * data.
// 5871      */
// 5872     MBEDTLS_SSL_DEBUG_MSG( 3, ( "switching to new transform spec for inbound data" ) );
??mbedtls_ssl_parse_change_cipher_spec_1:
        LDR.W    R0,??DataTable56_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+5872
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5873     ssl->transform_in = ssl->transform_negotiate;
        LDR      R0,[R5, #+76]
        STR      R0,[R5, #+64]
// 5874     ssl->session_in = ssl->session_negotiate;
        LDR      R0,[R5, #+56]
        STR      R0,[R5, #+44]
// 5875 
// 5876 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 5877     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_change_cipher_spec_2
// 5878     {
// 5879 #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
// 5880         ssl_dtls_replay_reset( ssl );
        MOV      R0,R5
          CFI FunCall ssl_dtls_replay_reset
        BL       ssl_dtls_replay_reset
// 5881 #endif
// 5882 
// 5883         /* Increment epoch */
// 5884         if( ++ssl->in_epoch == 0 )
        LDRH     R0,[R5, #+132]
        ADDS     R0,R0,#+1
        STRH     R0,[R5, #+132]
        LDRH     R0,[R5, #+132]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_parse_change_cipher_spec_3
// 5885         {
// 5886             MBEDTLS_SSL_DEBUG_MSG( 1, ( "DTLS epoch would wrap" ) );
        LDR.W    R0,??DataTable56_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+5886
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5887             /* This is highly unlikely to happen for legitimate reasons, so
// 5888                treat it as an attack and don't send an alert. */
// 5889             return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
        LDR.W    R0,??DataTable56_4  ;; 0xffff9480
        POP      {R1,R2,R4-R6,PC}
// 5890         }
// 5891     }
// 5892     else
// 5893 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 5894     memset( ssl->in_ctr, 0, 8 );
??mbedtls_ssl_parse_change_cipher_spec_2:
        MOVS     R2,#+0
        MOVS     R1,#+8
        LDR      R0,[R5, #+96]
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 5895 
// 5896     ssl_update_in_pointers( ssl, ssl->transform_negotiate );
??mbedtls_ssl_parse_change_cipher_spec_3:
        LDR      R1,[R5, #+76]
        MOV      R0,R5
          CFI FunCall ssl_update_in_pointers
        BL       ssl_update_in_pointers
// 5897 
// 5898 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
// 5899     if( mbedtls_ssl_hw_record_activate != NULL )
// 5900     {
// 5901         if( ( ret = mbedtls_ssl_hw_record_activate( ssl, MBEDTLS_SSL_CHANNEL_INBOUND ) ) != 0 )
// 5902         {
// 5903             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_activate", ret );
// 5904             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 5905                                             MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
// 5906             return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
// 5907         }
// 5908     }
// 5909 #endif
// 5910 
// 5911     ssl->state++;
        LDR      R0,[R5, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+4]
// 5912 
// 5913     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse change cipher spec" ) );
        LDR.W    R0,??DataTable56_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+5913
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 5914 
// 5915     return( 0 );
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
// 5916 }
          CFI EndBlock cfiBlock77

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44:
        DATA32
        DC32     ?_191

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_1:
        DATA32
        DC32     ?_192

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_2:
        DATA32
        DC32     0xffff8880

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_3:
        DATA32
        DC32     ?_193

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_4:
        DATA32
        DC32     0xffff8780

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_5:
        DATA32
        DC32     ?_194

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_6:
        DATA32
        DC32     0xffff9980

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_7:
        DATA32
        DC32     0xffff8f00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_8:
        DATA32
        DC32     ?_195

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_9:
        DATA32
        DC32     ?_196

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_10:
        DATA32
        DC32     ?_97
// 5917 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock78 Using cfiCommon0
          CFI Function mbedtls_ssl_optimize_checksum
          CFI NoCalls
        THUMB
// 5918 void mbedtls_ssl_optimize_checksum( mbedtls_ssl_context *ssl,
// 5919                             const mbedtls_ssl_ciphersuite_t *ciphersuite_info )
// 5920 {
// 5921     ((void) ciphersuite_info);
// 5922 
// 5923 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ 
// 5924     defined(MBEDTLS_SSL_PROTO_TLS1_1)
// 5925     if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )
mbedtls_ssl_optimize_checksum:
        LDR      R2,[R0, #+20]
        CMP      R2,#+3
        BGE.N    ??mbedtls_ssl_optimize_checksum_0
// 5926         ssl->handshake->update_checksum = ssl_update_checksum_md5sha1;
        ADR.W    R1,ssl_update_checksum_md5sha1
        LDR      R0,[R0, #+60]
        STR      R1,[R0, #+1096]
        BX       LR
// 5927     else
// 5928 #endif
// 5929 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 5930 #if defined(MBEDTLS_SHA512_C)
// 5931     if( ciphersuite_info->mac == MBEDTLS_MD_SHA384 )
??mbedtls_ssl_optimize_checksum_0:
        LDRB     R1,[R1, #+9]
        CMP      R1,#+7
        BNE.N    ??mbedtls_ssl_optimize_checksum_1
// 5932         ssl->handshake->update_checksum = ssl_update_checksum_sha384;
        ADR.W    R1,ssl_update_checksum_sha384
        LDR      R0,[R0, #+60]
        STR      R1,[R0, #+1096]
        BX       LR
// 5933     else
// 5934 #endif
// 5935 #if defined(MBEDTLS_SHA256_C)
// 5936     if( ciphersuite_info->mac != MBEDTLS_MD_SHA384 )
// 5937         ssl->handshake->update_checksum = ssl_update_checksum_sha256;
??mbedtls_ssl_optimize_checksum_1:
        ADR.W    R1,ssl_update_checksum_sha256
        LDR      R0,[R0, #+60]
        STR      R1,[R0, #+1096]
// 5938     else
// 5939 #endif
// 5940 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 5941     {
// 5942         MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 5943         return;
// 5944     }
// 5945 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock78
// 5946 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock79 Using cfiCommon0
          CFI Function mbedtls_ssl_reset_checksum
        THUMB
// 5947 void mbedtls_ssl_reset_checksum( mbedtls_ssl_context *ssl )
// 5948 {
mbedtls_ssl_reset_checksum:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 5949 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ 
// 5950     defined(MBEDTLS_SSL_PROTO_TLS1_1)
// 5951      mbedtls_md5_starts_ret( &ssl->handshake->fin_md5  );
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+592
          CFI FunCall mbedtls_md5_starts_ret
        BL       mbedtls_md5_starts_ret
// 5952     mbedtls_sha1_starts_ret( &ssl->handshake->fin_sha1 );
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+680
          CFI FunCall mbedtls_sha1_starts_ret
        BL       mbedtls_sha1_starts_ret
// 5953 #endif
// 5954 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 5955 #if defined(MBEDTLS_SHA256_C)
// 5956     mbedtls_sha256_starts_ret( &ssl->handshake->fin_sha256, 0 );
        MOVS     R1,#+0
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+772
          CFI FunCall mbedtls_sha256_starts_ret
        BL       mbedtls_sha256_starts_ret
// 5957 #endif
// 5958 #if defined(MBEDTLS_SHA512_C)
// 5959     mbedtls_sha512_starts_ret( &ssl->handshake->fin_sha512, 1 );
        MOVS     R1,#+1
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+880
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_sha512_starts_ret
        B.W      mbedtls_sha512_starts_ret
// 5960 #endif
// 5961 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 5962 }
          CFI EndBlock cfiBlock79
// 5963 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock80 Using cfiCommon0
          CFI Function ssl_update_checksum_start
        THUMB
// 5964 static void ssl_update_checksum_start( mbedtls_ssl_context *ssl,
// 5965                                        const unsigned char *buf, size_t len )
// 5966 {
ssl_update_checksum_start:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
// 5967 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ 
// 5968     defined(MBEDTLS_SSL_PROTO_TLS1_1)
// 5969      mbedtls_md5_update_ret( &ssl->handshake->fin_md5 , buf, len );
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+592
          CFI FunCall mbedtls_md5_update_ret
        BL       mbedtls_md5_update_ret
// 5970     mbedtls_sha1_update_ret( &ssl->handshake->fin_sha1, buf, len );
        MOV      R2,R6
        MOV      R1,R5
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+680
          CFI FunCall mbedtls_sha1_update_ret
        BL       mbedtls_sha1_update_ret
// 5971 #endif
// 5972 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 5973 #if defined(MBEDTLS_SHA256_C)
// 5974     mbedtls_sha256_update_ret( &ssl->handshake->fin_sha256, buf, len );
        MOV      R2,R6
        MOV      R1,R5
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+772
          CFI FunCall mbedtls_sha256_update_ret
        BL       mbedtls_sha256_update_ret
// 5975 #endif
// 5976 #if defined(MBEDTLS_SHA512_C)
// 5977     mbedtls_sha512_update_ret( &ssl->handshake->fin_sha512, buf, len );
        MOV      R2,R6
        MOV      R1,R5
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+880
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_sha512_update_ret
        B.W      mbedtls_sha512_update_ret
// 5978 #endif
// 5979 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 5980 }
          CFI EndBlock cfiBlock80
// 5981 
// 5982 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ 
// 5983     defined(MBEDTLS_SSL_PROTO_TLS1_1)

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock81 Using cfiCommon0
          CFI Function ssl_update_checksum_md5sha1
        THUMB
// 5984 static void ssl_update_checksum_md5sha1( mbedtls_ssl_context *ssl,
// 5985                                          const unsigned char *buf, size_t len )
// 5986 {
ssl_update_checksum_md5sha1:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
// 5987      mbedtls_md5_update_ret( &ssl->handshake->fin_md5 , buf, len );
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+592
          CFI FunCall mbedtls_md5_update_ret
        BL       mbedtls_md5_update_ret
// 5988     mbedtls_sha1_update_ret( &ssl->handshake->fin_sha1, buf, len );
        MOV      R2,R6
        MOV      R1,R5
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+680
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_sha1_update_ret
        B.W      mbedtls_sha1_update_ret
// 5989 }
          CFI EndBlock cfiBlock81
// 5990 #endif
// 5991 
// 5992 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 5993 #if defined(MBEDTLS_SHA256_C)

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock82 Using cfiCommon0
          CFI Function ssl_update_checksum_sha256
        THUMB
// 5994 static void ssl_update_checksum_sha256( mbedtls_ssl_context *ssl,
// 5995                                         const unsigned char *buf, size_t len )
// 5996 {
// 5997     mbedtls_sha256_update_ret( &ssl->handshake->fin_sha256, buf, len );
ssl_update_checksum_sha256:
        LDR      R0,[R0, #+60]
        ADD      R0,R0,#+772
          CFI FunCall mbedtls_sha256_update_ret
        B.W      mbedtls_sha256_update_ret
// 5998 }
          CFI EndBlock cfiBlock82
// 5999 #endif
// 6000 
// 6001 #if defined(MBEDTLS_SHA512_C)

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function ssl_update_checksum_sha384
        THUMB
// 6002 static void ssl_update_checksum_sha384( mbedtls_ssl_context *ssl,
// 6003                                         const unsigned char *buf, size_t len )
// 6004 {
// 6005     mbedtls_sha512_update_ret( &ssl->handshake->fin_sha512, buf, len );
ssl_update_checksum_sha384:
        LDR      R0,[R0, #+60]
        ADD      R0,R0,#+880
          CFI FunCall mbedtls_sha512_update_ret
        B.W      mbedtls_sha512_update_ret
// 6006 }
          CFI EndBlock cfiBlock83
// 6007 #endif
// 6008 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 6009 
// 6010 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 6011 static void ssl_calc_finished_ssl(
// 6012                 mbedtls_ssl_context *ssl, unsigned char *buf, int from )
// 6013 {
// 6014     const char *sender;
// 6015     mbedtls_md5_context  md5;
// 6016     mbedtls_sha1_context sha1;
// 6017 
// 6018     unsigned char padbuf[48];
// 6019     unsigned char md5sum[16];
// 6020     unsigned char sha1sum[20];
// 6021 
// 6022     mbedtls_ssl_session *session = ssl->session_negotiate;
// 6023     if( !session )
// 6024         session = ssl->session;
// 6025 
// 6026     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished ssl" ) );
// 6027 
// 6028     mbedtls_md5_init( &md5 );
// 6029     mbedtls_sha1_init( &sha1 );
// 6030 
// 6031     mbedtls_md5_clone( &md5, &ssl->handshake->fin_md5 );
// 6032     mbedtls_sha1_clone( &sha1, &ssl->handshake->fin_sha1 );
// 6033 
// 6034     /*
// 6035      * SSLv3:
// 6036      *   hash =
// 6037      *      MD5( master + pad2 +
// 6038      *          MD5( handshake + sender + master + pad1 ) )
// 6039      *   + SHA1( master + pad2 +
// 6040      *         SHA1( handshake + sender + master + pad1 ) )
// 6041      */
// 6042 
// 6043 #if !defined(MBEDTLS_MD5_ALT)
// 6044     MBEDTLS_SSL_DEBUG_BUF( 4, "finished  md5 state", (unsigned char *)
// 6045                     md5.state, sizeof(  md5.state ) );
// 6046 #endif
// 6047 
// 6048 #if !defined(MBEDTLS_SHA1_ALT)
// 6049     MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha1 state", (unsigned char *)
// 6050                    sha1.state, sizeof( sha1.state ) );
// 6051 #endif
// 6052 
// 6053     sender = ( from == MBEDTLS_SSL_IS_CLIENT ) ? "CLNT"
// 6054                                        : "SRVR";
// 6055 
// 6056     memset( padbuf, 0x36, 48 );
// 6057 
// 6058     mbedtls_md5_update_ret( &md5, (const unsigned char *) sender, 4 );
// 6059     mbedtls_md5_update_ret( &md5, session->master, 48 );
// 6060     mbedtls_md5_update_ret( &md5, padbuf, 48 );
// 6061     mbedtls_md5_finish_ret( &md5, md5sum );
// 6062 
// 6063     mbedtls_sha1_update_ret( &sha1, (const unsigned char *) sender, 4 );
// 6064     mbedtls_sha1_update_ret( &sha1, session->master, 48 );
// 6065     mbedtls_sha1_update_ret( &sha1, padbuf, 40 );
// 6066     mbedtls_sha1_finish_ret( &sha1, sha1sum );
// 6067 
// 6068     memset( padbuf, 0x5C, 48 );
// 6069 
// 6070     mbedtls_md5_starts_ret( &md5 );
// 6071     mbedtls_md5_update_ret( &md5, session->master, 48 );
// 6072     mbedtls_md5_update_ret( &md5, padbuf, 48 );
// 6073     mbedtls_md5_update_ret( &md5, md5sum, 16 );
// 6074     mbedtls_md5_finish_ret( &md5, buf );
// 6075 
// 6076     mbedtls_sha1_starts_ret( &sha1 );
// 6077     mbedtls_sha1_update_ret( &sha1, session->master, 48 );
// 6078     mbedtls_sha1_update_ret( &sha1, padbuf , 40 );
// 6079     mbedtls_sha1_update_ret( &sha1, sha1sum, 20 );
// 6080     mbedtls_sha1_finish_ret( &sha1, buf + 16 );
// 6081 
// 6082     MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, 36 );
// 6083 
// 6084     mbedtls_md5_free(  &md5  );
// 6085     mbedtls_sha1_free( &sha1 );
// 6086 
// 6087     mbedtls_platform_zeroize(  padbuf, sizeof(  padbuf ) );
// 6088     mbedtls_platform_zeroize(  md5sum, sizeof(  md5sum ) );
// 6089     mbedtls_platform_zeroize( sha1sum, sizeof( sha1sum ) );
// 6090 
// 6091     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
// 6092 }
// 6093 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
// 6094 
// 6095 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock84 Using cfiCommon0
          CFI Function ssl_calc_finished_tls
        THUMB
// 6096 static void ssl_calc_finished_tls(
// 6097                 mbedtls_ssl_context *ssl, unsigned char *buf, int from )
// 6098 {
ssl_calc_finished_tls:
        PUSH     {R3-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+28
        SUB      SP,SP,#+228
          CFI CFA R13+256
        MOV      R6,R0
        MOV      R7,R1
        MOV      R5,R2
// 6099     int len = 12;
// 6100     const char *sender;
// 6101     mbedtls_md5_context  md5;
// 6102     mbedtls_sha1_context sha1;
// 6103     unsigned char padbuf[36];
// 6104 
// 6105     mbedtls_ssl_session *session = ssl->session_negotiate;
        LDR      R4,[R6, #+56]
// 6106     if( !session )
        CMP      R4,#+0
        BNE.N    ??ssl_calc_finished_tls_0
// 6107         session = ssl->session;
        LDR      R4,[R6, #+52]
// 6108 
// 6109     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished tls" ) );
??ssl_calc_finished_tls_0:
        LDR.W    R8,??DataTable49
        LDR.W    R0,??DataTable56_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+6109
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6110 
// 6111     mbedtls_md5_init( &md5 );
        ADD      R0,SP,#+140
          CFI FunCall mbedtls_md5_init
        BL       mbedtls_md5_init
// 6112     mbedtls_sha1_init( &sha1 );
        ADD      R0,SP,#+48
          CFI FunCall mbedtls_sha1_init
        BL       mbedtls_sha1_init
// 6113 
// 6114     mbedtls_md5_clone( &md5, &ssl->handshake->fin_md5 );
        LDR      R0,[R6, #+60]
        ADD      R1,R0,#+592
        ADD      R0,SP,#+140
          CFI FunCall mbedtls_md5_clone
        BL       mbedtls_md5_clone
// 6115     mbedtls_sha1_clone( &sha1, &ssl->handshake->fin_sha1 );
        LDR      R0,[R6, #+60]
        ADD      R1,R0,#+680
        ADD      R0,SP,#+48
          CFI FunCall mbedtls_sha1_clone
        BL       mbedtls_sha1_clone
// 6116 
// 6117     /*
// 6118      * TLSv1:
// 6119      *   hash = PRF( master, finished_label,
// 6120      *               MD5( handshake ) + SHA1( handshake ) )[0..11]
// 6121      */
// 6122 
// 6123 #if !defined(MBEDTLS_MD5_ALT)
// 6124     MBEDTLS_SSL_DEBUG_BUF( 4, "finished  md5 state", (unsigned char *)
// 6125                     md5.state, sizeof(  md5.state ) );
        MOVS     R0,#+16
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+148
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable57
        STR      R0,[SP, #+0]
        MOVW     R3,#+6125
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 6126 #endif
// 6127 
// 6128 #if !defined(MBEDTLS_SHA1_ALT)
// 6129     MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha1 state", (unsigned char *)
// 6130                    sha1.state, sizeof( sha1.state ) );
        MOVS     R0,#+20
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+56
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable57_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6130
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 6131 #endif
// 6132 
// 6133     sender = ( from == MBEDTLS_SSL_IS_CLIENT )
// 6134              ? "client finished"
// 6135              : "server finished";
        CMP      R5,#+0
        BNE.N    ??ssl_calc_finished_tls_1
        LDR.W    R5,??DataTable57_2
        B.N      ??ssl_calc_finished_tls_2
??ssl_calc_finished_tls_1:
        LDR.W    R5,??DataTable57_3
// 6136 
// 6137     mbedtls_md5_finish_ret(  &md5, padbuf );
??ssl_calc_finished_tls_2:
        ADD      R1,SP,#+12
        ADD      R0,SP,#+140
          CFI FunCall mbedtls_md5_finish_ret
        BL       mbedtls_md5_finish_ret
// 6138     mbedtls_sha1_finish_ret( &sha1, padbuf + 16 );
        ADD      R1,SP,#+28
        ADD      R0,SP,#+48
          CFI FunCall mbedtls_sha1_finish_ret
        BL       mbedtls_sha1_finish_ret
// 6139 
// 6140     ssl->handshake->tls_prf( session->master, 48, sender,
// 6141                              padbuf, 36, buf, len );
        MOVS     R0,#+12
        STR      R0,[SP, #+8]
        STR      R7,[SP, #+4]
        MOVS     R0,#+36
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+12
        MOV      R2,R5
        MOVS     R1,#+48
        ADD      R0,R4,#+44
        LDR      R4,[R6, #+60]
        LDR      R4,[R4, #+1108]
          CFI FunCall
        BLX      R4
// 6142 
// 6143     MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, len );
        MOVS     R0,#+12
        STR      R0,[SP, #+8]
        STR      R7,[SP, #+4]
        LDR.W    R0,??DataTable58
        STR      R0,[SP, #+0]
        MOVW     R3,#+6143
        MOV      R2,R8
        MOVS     R1,#+3
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 6144 
// 6145     mbedtls_md5_free(  &md5  );
        ADD      R0,SP,#+140
          CFI FunCall mbedtls_md5_free
        BL       mbedtls_md5_free
// 6146     mbedtls_sha1_free( &sha1 );
        ADD      R0,SP,#+48
          CFI FunCall mbedtls_sha1_free
        BL       mbedtls_sha1_free
// 6147 
// 6148     mbedtls_platform_zeroize(  padbuf, sizeof(  padbuf ) );
        MOVS     R1,#+36
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 6149 
// 6150     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
        LDR.W    R0,??DataTable59
        STR      R0,[SP, #+0]
        MOVW     R3,#+6150
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6151 }
        ADD      SP,SP,#+232
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock84

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45:
        DATA32
        DC32     ?_198

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45_1:
        DATA32
        DC32     ?_199

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45_2:
        DATA32
        DC32     ?_200

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45_3:
        DATA32
        DC32     0xffff8a80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45_4:
        DATA32
        DC32     ?_201
// 6152 #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 */
// 6153 
// 6154 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 6155 #if defined(MBEDTLS_SHA256_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock85 Using cfiCommon0
          CFI Function ssl_calc_finished_tls_sha256
        THUMB
// 6156 static void ssl_calc_finished_tls_sha256(
// 6157                 mbedtls_ssl_context *ssl, unsigned char *buf, int from )
// 6158 {
ssl_calc_finished_tls_sha256:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+152
          CFI CFA R13+176
        MOV      R6,R0
        MOV      R7,R1
        MOV      R5,R2
// 6159     int len = 12;
// 6160     const char *sender;
// 6161     mbedtls_sha256_context sha256;
// 6162     unsigned char padbuf[32];
// 6163 
// 6164     mbedtls_ssl_session *session = ssl->session_negotiate;
        LDR      R4,[R6, #+56]
// 6165     if( !session )
        CMP      R4,#+0
        BNE.N    ??ssl_calc_finished_tls_sha256_0
// 6166         session = ssl->session;
        LDR      R4,[R6, #+52]
// 6167 
// 6168     mbedtls_sha256_init( &sha256 );
??ssl_calc_finished_tls_sha256_0:
        ADD      R0,SP,#+44
          CFI FunCall mbedtls_sha256_init
        BL       mbedtls_sha256_init
// 6169 
// 6170     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished tls sha256" ) );
        LDR.W    R8,??DataTable49
        LDR.W    R0,??DataTable58_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6170
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6171 
// 6172     mbedtls_sha256_clone( &sha256, &ssl->handshake->fin_sha256 );
        LDR      R0,[R6, #+60]
        ADD      R1,R0,#+772
        ADD      R0,SP,#+44
          CFI FunCall mbedtls_sha256_clone
        BL       mbedtls_sha256_clone
// 6173 
// 6174     /*
// 6175      * TLSv1.2:
// 6176      *   hash = PRF( master, finished_label,
// 6177      *               Hash( handshake ) )[0.11]
// 6178      */
// 6179 
// 6180 #if !defined(MBEDTLS_SHA256_ALT)
// 6181     MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha2 state", (unsigned char *)
// 6182                    sha256.state, sizeof( sha256.state ) );
        MOVS     R0,#+32
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+52
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable58_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+6182
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 6183 #endif
// 6184 
// 6185     sender = ( from == MBEDTLS_SSL_IS_CLIENT )
// 6186              ? "client finished"
// 6187              : "server finished";
        CMP      R5,#+0
        BNE.N    ??ssl_calc_finished_tls_sha256_1
        LDR.W    R5,??DataTable57_2
        B.N      ??ssl_calc_finished_tls_sha256_2
??ssl_calc_finished_tls_sha256_1:
        LDR.W    R5,??DataTable57_3
// 6188 
// 6189     mbedtls_sha256_finish_ret( &sha256, padbuf );
??ssl_calc_finished_tls_sha256_2:
        ADD      R1,SP,#+12
        ADD      R0,SP,#+44
          CFI FunCall mbedtls_sha256_finish_ret
        BL       mbedtls_sha256_finish_ret
// 6190 
// 6191     ssl->handshake->tls_prf( session->master, 48, sender,
// 6192                              padbuf, 32, buf, len );
        MOVS     R0,#+12
        STR      R0,[SP, #+8]
        STR      R7,[SP, #+4]
        MOVS     R0,#+32
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+12
        MOV      R2,R5
        MOVS     R1,#+48
        ADD      R0,R4,#+44
        LDR      R4,[R6, #+60]
        LDR      R4,[R4, #+1108]
          CFI FunCall
        BLX      R4
// 6193 
// 6194     MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, len );
        MOVS     R0,#+12
        STR      R0,[SP, #+8]
        STR      R7,[SP, #+4]
        LDR.W    R0,??DataTable58
        STR      R0,[SP, #+0]
        MOVW     R3,#+6194
        MOV      R2,R8
        MOVS     R1,#+3
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 6195 
// 6196     mbedtls_sha256_free( &sha256 );
        ADD      R0,SP,#+44
          CFI FunCall mbedtls_sha256_free
        BL       mbedtls_sha256_free
// 6197 
// 6198     mbedtls_platform_zeroize(  padbuf, sizeof(  padbuf ) );
        MOVS     R1,#+32
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 6199 
// 6200     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
        LDR.W    R0,??DataTable59
        STR      R0,[SP, #+0]
        MOVW     R3,#+6200
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6201 }
        ADD      SP,SP,#+152
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock85

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable46:
        DATA32
        DC32     ?_197

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable46_1:
        DATA32
        DC32     ?_202

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable46_2:
        DATA32
        DC32     0xffff8b00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable46_3:
        DATA32
        DC32     ?_204
// 6202 #endif /* MBEDTLS_SHA256_C */
// 6203 
// 6204 #if defined(MBEDTLS_SHA512_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock86 Using cfiCommon0
          CFI Function ssl_calc_finished_tls_sha384
        THUMB
// 6205 static void ssl_calc_finished_tls_sha384(
// 6206                 mbedtls_ssl_context *ssl, unsigned char *buf, int from )
// 6207 {
ssl_calc_finished_tls_sha384:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+280
          CFI CFA R13+304
        MOV      R6,R0
        MOV      R7,R1
        MOV      R5,R2
// 6208     int len = 12;
// 6209     const char *sender;
// 6210     mbedtls_sha512_context sha512;
// 6211     unsigned char padbuf[48];
// 6212 
// 6213     mbedtls_ssl_session *session = ssl->session_negotiate;
        LDR      R4,[R6, #+56]
// 6214     if( !session )
        CMP      R4,#+0
        BNE.N    ??ssl_calc_finished_tls_sha384_0
// 6215         session = ssl->session;
        LDR      R4,[R6, #+52]
// 6216 
// 6217     mbedtls_sha512_init( &sha512 );
??ssl_calc_finished_tls_sha384_0:
        ADD      R0,SP,#+64
          CFI FunCall mbedtls_sha512_init
        BL       mbedtls_sha512_init
// 6218 
// 6219     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished tls sha384" ) );
        LDR.W    R8,??DataTable49
        LDR.W    R0,??DataTable59_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6219
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6220 
// 6221     mbedtls_sha512_clone( &sha512, &ssl->handshake->fin_sha512 );
        LDR      R0,[R6, #+60]
        ADD      R1,R0,#+880
        ADD      R0,SP,#+64
          CFI FunCall mbedtls_sha512_clone
        BL       mbedtls_sha512_clone
// 6222 
// 6223     /*
// 6224      * TLSv1.2:
// 6225      *   hash = PRF( master, finished_label,
// 6226      *               Hash( handshake ) )[0.11]
// 6227      */
// 6228 
// 6229 #if !defined(MBEDTLS_SHA512_ALT)
// 6230     MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha512 state", (unsigned char *)
// 6231                    sha512.state, sizeof( sha512.state ) );
        MOVS     R0,#+64
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+80
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable60
        STR      R0,[SP, #+0]
        MOVW     R3,#+6231
        MOV      R2,R8
        MOVS     R1,#+4
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 6232 #endif
// 6233 
// 6234     sender = ( from == MBEDTLS_SSL_IS_CLIENT )
// 6235              ? "client finished"
// 6236              : "server finished";
        CMP      R5,#+0
        BNE.N    ??ssl_calc_finished_tls_sha384_1
        LDR.W    R5,??DataTable57_2
        B.N      ??ssl_calc_finished_tls_sha384_2
??ssl_calc_finished_tls_sha384_1:
        LDR.W    R5,??DataTable57_3
// 6237 
// 6238     mbedtls_sha512_finish_ret( &sha512, padbuf );
??ssl_calc_finished_tls_sha384_2:
        ADD      R1,SP,#+12
        ADD      R0,SP,#+64
          CFI FunCall mbedtls_sha512_finish_ret
        BL       mbedtls_sha512_finish_ret
// 6239 
// 6240     ssl->handshake->tls_prf( session->master, 48, sender,
// 6241                              padbuf, 48, buf, len );
        MOVS     R0,#+12
        STR      R0,[SP, #+8]
        STR      R7,[SP, #+4]
        MOVS     R0,#+48
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+12
        MOV      R2,R5
        MOV      R1,R0
        ADD      R0,R4,#+44
        LDR      R4,[R6, #+60]
        LDR      R4,[R4, #+1108]
          CFI FunCall
        BLX      R4
// 6242 
// 6243     MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, len );
        MOVS     R0,#+12
        STR      R0,[SP, #+8]
        STR      R7,[SP, #+4]
        LDR.W    R0,??DataTable58
        STR      R0,[SP, #+0]
        MOVW     R3,#+6243
        MOV      R2,R8
        MOVS     R1,#+3
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_buf
        BL       mbedtls_debug_print_buf
// 6244 
// 6245     mbedtls_sha512_free( &sha512 );
        ADD      R0,SP,#+64
          CFI FunCall mbedtls_sha512_free
        BL       mbedtls_sha512_free
// 6246 
// 6247     mbedtls_platform_zeroize(  padbuf, sizeof( padbuf ) );
        MOVS     R1,#+48
        ADD      R0,SP,#+12
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 6248 
// 6249     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
        LDR.W    R0,??DataTable59
        STR      R0,[SP, #+0]
        MOVW     R3,#+6249
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R6
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6250 }
        ADD      SP,SP,#+280
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock86
// 6251 #endif /* MBEDTLS_SHA512_C */
// 6252 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 6253 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock87 Using cfiCommon0
          CFI Function ssl_handshake_wrapup_free_hs_transform
        THUMB
// 6254 static void ssl_handshake_wrapup_free_hs_transform( mbedtls_ssl_context *ssl )
// 6255 {
ssl_handshake_wrapup_free_hs_transform:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 6256     MBEDTLS_SSL_DEBUG_MSG( 3, ( "=> handshake wrapup: final free" ) );
        LDR.N    R5,??DataTable49
        LDR.W    R0,??DataTable60_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6256
        MOV      R2,R5
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6257 
// 6258     /*
// 6259      * Free our handshake params
// 6260      */
// 6261     mbedtls_ssl_handshake_free( ssl );
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_handshake_free
        BL       mbedtls_ssl_handshake_free
// 6262     mbedtls_free( ssl->handshake );
        LDR      R0,[R4, #+60]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6263     ssl->handshake = NULL;
        MOVS     R0,#+0
        STR      R0,[R4, #+60]
// 6264 
// 6265     /*
// 6266      * Free the previous transform and swith in the current one
// 6267      */
// 6268     if( ssl->transform )
        LDR      R0,[R4, #+72]
        CMP      R0,#+0
        BEQ.N    ??ssl_handshake_wrapup_free_hs_transform_0
// 6269     {
// 6270         mbedtls_ssl_transform_free( ssl->transform );
          CFI FunCall mbedtls_ssl_transform_free
        BL       mbedtls_ssl_transform_free
// 6271         mbedtls_free( ssl->transform );
        LDR      R0,[R4, #+72]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6272     }
// 6273     ssl->transform = ssl->transform_negotiate;
??ssl_handshake_wrapup_free_hs_transform_0:
        LDR      R0,[R4, #+76]
        STR      R0,[R4, #+72]
// 6274     ssl->transform_negotiate = NULL;
        MOVS     R0,#+0
        STR      R0,[R4, #+76]
// 6275 
// 6276     MBEDTLS_SSL_DEBUG_MSG( 3, ( "<= handshake wrapup: final free" ) );
        LDR.W    R0,??DataTable61
        STR      R0,[SP, #+0]
        MOVW     R3,#+6276
        MOV      R2,R5
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6277 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock87

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48:
        DATA32
        DC32     ?_203

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_1:
        DATA32
        DC32     ?_205

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_2:
        DATA32
        DC32     ?_206

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_3:
        DATA32
        DC32     ?_207
// 6278 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock88 Using cfiCommon0
          CFI Function mbedtls_ssl_handshake_wrapup
        THUMB
// 6279 void mbedtls_ssl_handshake_wrapup( mbedtls_ssl_context *ssl )
// 6280 {
mbedtls_ssl_handshake_wrapup:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R5,R0
// 6281     int resume = ssl->handshake->resume;
        LDR      R0,[R5, #+60]
        LDR      R4,[R0, #+1728]
// 6282 
// 6283     MBEDTLS_SSL_DEBUG_MSG( 3, ( "=> handshake wrapup" ) );
        LDR.W    R6,??DataTable55_5
        LDR.W    R0,??DataTable60_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+6283
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6284 
// 6285 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 6286     if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
        LDR      R0,[R5, #+8]
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_handshake_wrapup_0
// 6287     {
// 6288         ssl->renego_status =  MBEDTLS_SSL_RENEGOTIATION_DONE;
        MOVS     R0,#+2
        STR      R0,[R5, #+8]
// 6289         ssl->renego_records_seen = 0;
        MOVS     R0,#+0
        STR      R0,[R5, #+12]
// 6290     }
// 6291 #endif
// 6292 
// 6293     /*
// 6294      * Free the previous session and switch in the current one
// 6295      */
// 6296     if( ssl->session )
??mbedtls_ssl_handshake_wrapup_0:
        LDR      R0,[R5, #+52]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handshake_wrapup_1
// 6297     {
// 6298 #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
// 6299         /* RFC 7366 3.1: keep the EtM state */
// 6300         ssl->session_negotiate->encrypt_then_mac =
// 6301                   ssl->session->encrypt_then_mac;
        LDR      R0,[R0, #+120]
        LDR      R1,[R5, #+56]
        STR      R0,[R1, #+120]
// 6302 #endif
// 6303 
// 6304         mbedtls_ssl_session_free( ssl->session );
        LDR      R0,[R5, #+52]
          CFI FunCall mbedtls_ssl_session_free
        BL       mbedtls_ssl_session_free
// 6305         mbedtls_free( ssl->session );
        LDR      R0,[R5, #+52]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6306     }
// 6307     ssl->session = ssl->session_negotiate;
??mbedtls_ssl_handshake_wrapup_1:
        LDR      R0,[R5, #+56]
        STR      R0,[R5, #+52]
// 6308     ssl->session_negotiate = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+56]
// 6309 
// 6310     /*
// 6311      * Add cache entry
// 6312      */
// 6313     if( ssl->conf->f_set_cache != NULL &&
// 6314         ssl->session->id_len != 0 &&
// 6315         resume == 0 )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+36]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handshake_wrapup_2
        LDR      R0,[R5, #+52]
        LDR      R0,[R0, #+8]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handshake_wrapup_2
        CMP      R4,#+0
        BNE.N    ??mbedtls_ssl_handshake_wrapup_2
// 6316     {
// 6317         if( ssl->conf->f_set_cache( ssl->conf->p_cache, ssl->session ) != 0 )
        LDR      R1,[R5, #+52]
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+40]
        LDR      R2,[R5, #+0]
        LDR      R2,[R2, #+36]
          CFI FunCall
        BLX      R2
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handshake_wrapup_2
// 6318             MBEDTLS_SSL_DEBUG_MSG( 1, ( "cache did not store session" ) );
        LDR.W    R0,??DataTable62
        STR      R0,[SP, #+0]
        MOVW     R3,#+6318
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6319     }
// 6320 
// 6321 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6322     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 6323         ssl->handshake->flight != NULL )
??mbedtls_ssl_handshake_wrapup_2:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handshake_wrapup_3
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+492]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handshake_wrapup_3
// 6324     {
// 6325         /* Cancel handshake timer */
// 6326         ssl_set_timer( ssl, 0 );
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall ssl_set_timer
        BL       ssl_set_timer
// 6327 
// 6328         /* Keep last flight around in case we need to resend it:
// 6329          * we need the handshake and transform structures for that */
// 6330         MBEDTLS_SSL_DEBUG_MSG( 3, ( "skip freeing handshake and transform" ) );
        LDR.W    R0,??DataTable62_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6330
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        B.N      ??mbedtls_ssl_handshake_wrapup_4
// 6331     }
// 6332     else
// 6333 #endif
// 6334         ssl_handshake_wrapup_free_hs_transform( ssl );
??mbedtls_ssl_handshake_wrapup_3:
        MOV      R0,R5
          CFI FunCall ssl_handshake_wrapup_free_hs_transform
        BL       ssl_handshake_wrapup_free_hs_transform
// 6335 
// 6336     ssl->state++;
??mbedtls_ssl_handshake_wrapup_4:
        LDR      R0,[R5, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+4]
// 6337 
// 6338     MBEDTLS_SSL_DEBUG_MSG( 3, ( "<= handshake wrapup" ) );
        LDR.W    R0,??DataTable63
        STR      R0,[SP, #+0]
        MOVW     R3,#+6338
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6339 }
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock88

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49_1:
        DATA32
        DC32     ?_208

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49_2:
        DATA32
        DC32     0xffff8b80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49_3:
        DATA32
        DC32     ?_209

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49_4:
        DATA32
        DC32     0xffff8900

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49_5:
        DATA32
        DC32     0xffff8600

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49_6:
        DATA32
        DC32     ?_210

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49_7:
        DATA32
        DC32     0xffff8100
// 6340 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock89 Using cfiCommon0
          CFI Function mbedtls_ssl_write_finished
        THUMB
// 6341 int mbedtls_ssl_write_finished( mbedtls_ssl_context *ssl )
// 6342 {
mbedtls_ssl_write_finished:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
// 6343     int ret, hash_len;
// 6344 
// 6345     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write finished" ) );
        LDR.W    R6,??DataTable55_5
        LDR.W    R0,??DataTable63_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6345
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6346 
// 6347     ssl_update_out_pointers( ssl, ssl->transform_negotiate );
        LDR      R1,[R4, #+76]
        MOV      R0,R4
          CFI FunCall ssl_update_out_pointers
        BL       ssl_update_out_pointers
// 6348 
// 6349     ssl->handshake->calc_finished( ssl, ssl->out_msg + 4, ssl->conf->endpoint );
        LDR      R0,[R4, #+0]
        LDRB     R2,[R0, #+204]
        AND      R2,R2,#0x1
        LDR      R0,[R4, #+196]
        ADDS     R1,R0,#+4
        MOV      R0,R4
        LDR      R3,[R4, #+60]
        LDR      R3,[R3, #+1104]
          CFI FunCall
        BLX      R3
// 6350 
// 6351     /*
// 6352      * RFC 5246 7.4.9 (Page 63) says 12 is the default length and ciphersuites
// 6353      * may define some other value. Currently (early 2016), no defined
// 6354      * ciphersuite does this (and this is unlikely to change as activity has
// 6355      * moved to TLS 1.3 now) so we can keep the hardcoded 12 here.
// 6356      */
// 6357     hash_len = ( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ) ? 36 : 12;
        LDR      R0,[R4, #+20]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_write_finished_0
        MOVS     R5,#+36
        B.N      ??mbedtls_ssl_write_finished_1
??mbedtls_ssl_write_finished_0:
        MOVS     R5,#+12
// 6358 
// 6359 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 6360     ssl->verify_data_len = hash_len;
??mbedtls_ssl_write_finished_1:
        STR      R5,[R4, #+248]
// 6361     memcpy( ssl->own_verify_data, ssl->out_msg + 4, hash_len );
        MOV      R2,R5
        LDR      R0,[R4, #+196]
        ADDS     R1,R0,#+4
        ADD      R0,R4,#+252
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 6362 #endif
// 6363 
// 6364     ssl->out_msglen  = 4 + hash_len;
        ADDS     R5,R5,#+4
        STR      R5,[R4, #+204]
// 6365     ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
        MOVS     R0,#+22
        STR      R0,[R4, #+200]
// 6366     ssl->out_msg[0]  = MBEDTLS_SSL_HS_FINISHED;
        MOVS     R0,#+20
        LDR      R1,[R4, #+196]
        STRB     R0,[R1, #+0]
// 6367 
// 6368     /*
// 6369      * In case of session resuming, invert the client and server
// 6370      * ChangeCipherSpec messages order.
// 6371      */
// 6372     if( ssl->handshake->resume != 0 )
        LDR      R0,[R4, #+60]
        LDR      R0,[R0, #+1728]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_finished_2
// 6373     {
// 6374 #if defined(MBEDTLS_SSL_CLI_C)
// 6375         if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BMI.N    ??mbedtls_ssl_write_finished_3
// 6376             ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
        MOVS     R0,#+15
        STR      R0,[R4, #+4]
// 6377 #endif
// 6378 #if defined(MBEDTLS_SSL_SRV_C)
// 6379         if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
??mbedtls_ssl_write_finished_3:
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_write_finished_4
// 6380             ssl->state = MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC;
        MOVS     R0,#+10
        STR      R0,[R4, #+4]
        B.N      ??mbedtls_ssl_write_finished_4
// 6381 #endif
// 6382     }
// 6383     else
// 6384         ssl->state++;
??mbedtls_ssl_write_finished_2:
        LDR      R0,[R4, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+4]
// 6385 
// 6386     /*
// 6387      * Switch to our negotiated transform and session parameters for outbound
// 6388      * data.
// 6389      */
// 6390     MBEDTLS_SSL_DEBUG_MSG( 3, ( "switching to new transform spec for outbound data" ) );
??mbedtls_ssl_write_finished_4:
        LDR.W    R0,??DataTable63_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+6390
        MOV      R2,R6
        MOVS     R1,#+3
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6391 
// 6392 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6393     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_finished_5
// 6394     {
// 6395         unsigned char i;
// 6396 
// 6397         /* Remember current epoch settings for resending */
// 6398         ssl->handshake->alt_transform_out = ssl->transform_out;
        LDR      R0,[R4, #+68]
        LDR      R1,[R4, #+60]
        STR      R0,[R1, #+508]
// 6399         memcpy( ssl->handshake->alt_out_ctr, ssl->cur_out_ctr, 8 );
        MOVS     R2,#+8
        ADD      R1,R4,#+212
        LDR      R0,[R4, #+60]
        ADD      R0,R0,#+512
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 6400 
// 6401         /* Set sequence_number to zero */
// 6402         memset( ssl->cur_out_ctr + 2, 0, 6 );
        MOVS     R2,#+0
        MOVS     R1,#+6
        ADD      R0,R4,#+214
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 6403 
// 6404         /* Increment epoch */
// 6405         for( i = 2; i > 0; i-- )
        MOVS     R1,#+2
??mbedtls_ssl_write_finished_6:
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_write_finished_7
// 6406             if( ++ssl->cur_out_ctr[i - 1] != 0 )
        ADDS     R0,R4,R1
        LDRB     R0,[R0, #+211]
        ADDS     R0,R0,#+1
        ADDS     R2,R4,R1
        STRB     R0,[R2, #+211]
        ADDS     R0,R4,R1
        LDRB     R0,[R0, #+211]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_write_finished_7
        SUBS     R1,R1,#+1
        UXTB     R1,R1
        B.N      ??mbedtls_ssl_write_finished_6
// 6407                 break;
// 6408 
// 6409         /* The loop goes to its end iff the counter is wrapping */
// 6410         if( i == 0 )
// 6411         {
// 6412             MBEDTLS_SSL_DEBUG_MSG( 1, ( "DTLS epoch would wrap" ) );
// 6413             return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
// 6414         }
// 6415     }
// 6416     else
// 6417 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 6418     memset( ssl->cur_out_ctr, 0, 8 );
??mbedtls_ssl_write_finished_5:
        MOVS     R2,#+0
        MOVS     R1,#+8
        ADD      R0,R4,#+212
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 6419 
// 6420     ssl->transform_out = ssl->transform_negotiate;
??mbedtls_ssl_write_finished_8:
        LDR      R0,[R4, #+76]
        STR      R0,[R4, #+68]
// 6421     ssl->session_out = ssl->session_negotiate;
        LDR      R0,[R4, #+56]
        STR      R0,[R4, #+48]
// 6422 
// 6423 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
// 6424     if( mbedtls_ssl_hw_record_activate != NULL )
// 6425     {
// 6426         if( ( ret = mbedtls_ssl_hw_record_activate( ssl, MBEDTLS_SSL_CHANNEL_OUTBOUND ) ) != 0 )
// 6427         {
// 6428             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_activate", ret );
// 6429             return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
// 6430         }
// 6431     }
// 6432 #endif
// 6433 
// 6434 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6435     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_finished_9
// 6436         mbedtls_ssl_send_flight_completed( ssl );
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_send_flight_completed
        BL       mbedtls_ssl_send_flight_completed
// 6437 #endif
// 6438 
// 6439     if( ( ret = mbedtls_ssl_write_handshake_msg( ssl ) ) != 0 )
??mbedtls_ssl_write_finished_9:
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_write_handshake_msg
        BL       mbedtls_ssl_write_handshake_msg
        MOVS     R5,R0
        BEQ.N    ??mbedtls_ssl_write_finished_10
// 6440     {
// 6441         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_handshake_msg", ret );
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable55_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+6441
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 6442         return( ret );
        MOV      R0,R5
        POP      {R1,R2,R4-R6,PC}
// 6443     }
// 6444 
// 6445 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6446     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 6447         ( ret = mbedtls_ssl_flight_transmit( ssl ) ) != 0 )
??mbedtls_ssl_write_finished_10:
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_write_finished_11
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_flight_transmit
        BL       mbedtls_ssl_flight_transmit
        MOVS     R5,R0
        BEQ.N    ??mbedtls_ssl_write_finished_11
// 6448     {
// 6449         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_flight_transmit", ret );
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable64
        STR      R0,[SP, #+0]
        MOVW     R3,#+6449
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 6450         return( ret );
        MOV      R0,R5
        POP      {R1,R2,R4-R6,PC}
// 6451     }
// 6452 #endif
// 6453 
// 6454     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write finished" ) );
??mbedtls_ssl_write_finished_11:
        LDR.W    R0,??DataTable64_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6454
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6455 
// 6456     return( 0 );
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
??mbedtls_ssl_write_finished_7:
        CMP      R1,#+0
        BNE.N    ??mbedtls_ssl_write_finished_8
        LDR.W    R0,??DataTable56_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+6412
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable56_4  ;; 0xffff9480
        POP      {R1,R2,R4-R6,PC}
// 6457 }
          CFI EndBlock cfiBlock89

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable50:
        DATA32
        DC32     0xffffd780

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable50_1:
        DATA32
        DC32     ?_214

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable50_2:
        DATA32
        DC32     ?_215
// 6458 
// 6459 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 6460 #define SSL_MAX_HASH_LEN 36
// 6461 #else
// 6462 #define SSL_MAX_HASH_LEN 12
// 6463 #endif
// 6464 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock90 Using cfiCommon0
          CFI Function mbedtls_ssl_parse_finished
        THUMB
// 6465 int mbedtls_ssl_parse_finished( mbedtls_ssl_context *ssl )
// 6466 {
mbedtls_ssl_parse_finished:
        PUSH     {R3-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+20
        SUB      SP,SP,#+20
          CFI CFA R13+40
        MOV      R5,R0
// 6467     int ret;
// 6468     unsigned int hash_len;
// 6469     unsigned char buf[SSL_MAX_HASH_LEN];
// 6470 
// 6471     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse finished" ) );
        LDR.N    R6,??DataTable55_5
        LDR.W    R0,??DataTable64_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+6471
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6472 
// 6473     ssl->handshake->calc_finished( ssl, buf, ssl->conf->endpoint ^ 1 );
        LDR      R0,[R5, #+0]
        LDRB     R2,[R0, #+204]
        AND      R2,R2,#0x1
        EOR      R2,R2,#0x1
        ADD      R1,SP,#+8
        MOV      R0,R5
        LDR      R3,[R5, #+60]
        LDR      R3,[R3, #+1104]
          CFI FunCall
        BLX      R3
// 6474 
// 6475     if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_read_record
        BL       mbedtls_ssl_read_record
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_parse_finished_0
// 6476     {
// 6477         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable65
        STR      R0,[SP, #+0]
        MOVW     R3,#+6477
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 6478         return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_parse_finished_1
// 6479     }
// 6480 
// 6481     if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
??mbedtls_ssl_parse_finished_0:
        LDR      R0,[R5, #+120]
        CMP      R0,#+22
        BEQ.N    ??mbedtls_ssl_parse_finished_2
// 6482     {
// 6483         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
        LDR.W    R0,??DataTable65_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6483
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6484         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 6485                                         MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
        MOVS     R2,#+10
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 6486         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
        LDR.W    R0,??DataTable65_2  ;; 0xffff8900
        B.N      ??mbedtls_ssl_parse_finished_1
// 6487     }
// 6488 
// 6489     /* There is currently no ciphersuite using another length with TLS 1.2 */
// 6490 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 6491     if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
// 6492         hash_len = 36;
// 6493     else
// 6494 #endif
// 6495         hash_len = 12;
// 6496 
// 6497     if( ssl->in_msg[0] != MBEDTLS_SSL_HS_FINISHED ||
// 6498         ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) + hash_len )
??mbedtls_ssl_parse_finished_2:
        LDR      R0,[R5, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+20
        BNE.N    ??mbedtls_ssl_parse_finished_3
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        LDR      R1,[R5, #+160]
        ADDS     R0,R0,#+12
        CMP      R1,R0
        BEQ.N    ??mbedtls_ssl_parse_finished_4
// 6499     {
// 6500         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
??mbedtls_ssl_parse_finished_3:
        LDR.W    R0,??DataTable65_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6500
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6501         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 6502                                         MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        MOVS     R2,#+50
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 6503         return( MBEDTLS_ERR_SSL_BAD_HS_FINISHED );
        LDR.W    R0,??DataTable66  ;; 0xffff8180
        B.N      ??mbedtls_ssl_parse_finished_1
// 6504     }
// 6505 
// 6506     if( mbedtls_ssl_safer_memcmp( ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl ),
// 6507                       buf, hash_len ) != 0 )
??mbedtls_ssl_parse_finished_4:
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        MOVS     R2,#+12
        ADD      R1,SP,#+8
        LDR      R3,[R5, #+112]
        ADD      R0,R3,R0
          CFI FunCall mbedtls_ssl_safer_memcmp
        BL       mbedtls_ssl_safer_memcmp
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_finished_5
// 6508     {
// 6509         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
        LDR.W    R0,??DataTable65_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+6509
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6510         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 6511                                         MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        MOVS     R2,#+50
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 6512         return( MBEDTLS_ERR_SSL_BAD_HS_FINISHED );
        LDR.W    R0,??DataTable66  ;; 0xffff8180
        B.N      ??mbedtls_ssl_parse_finished_1
// 6513     }
// 6514 
// 6515 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 6516     ssl->verify_data_len = hash_len;
??mbedtls_ssl_parse_finished_5:
        MOVS     R0,#+12
        STR      R0,[R5, #+248]
// 6517     memcpy( ssl->peer_verify_data, buf, hash_len );
        MOV      R2,R0
        ADD      R1,SP,#+8
        ADD      R0,R5,#+264
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 6518 #endif
// 6519 
// 6520     if( ssl->handshake->resume != 0 )
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+1728]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_finished_6
// 6521     {
// 6522 #if defined(MBEDTLS_SSL_CLI_C)
// 6523         if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BMI.N    ??mbedtls_ssl_parse_finished_7
// 6524             ssl->state = MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC;
        MOVS     R0,#+10
        STR      R0,[R5, #+4]
// 6525 #endif
// 6526 #if defined(MBEDTLS_SSL_SRV_C)
// 6527         if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
??mbedtls_ssl_parse_finished_7:
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_parse_finished_8
// 6528             ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
        MOVS     R0,#+15
        STR      R0,[R5, #+4]
        B.N      ??mbedtls_ssl_parse_finished_8
// 6529 #endif
// 6530     }
// 6531     else
// 6532         ssl->state++;
??mbedtls_ssl_parse_finished_6:
        LDR      R0,[R5, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+4]
// 6533 
// 6534 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6535     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
??mbedtls_ssl_parse_finished_8:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_parse_finished_9
// 6536         mbedtls_ssl_recv_flight_completed( ssl );
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_recv_flight_completed
        BL       mbedtls_ssl_recv_flight_completed
// 6537 #endif
// 6538 
// 6539     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse finished" ) );
??mbedtls_ssl_parse_finished_9:
        LDR.W    R0,??DataTable67
        STR      R0,[SP, #+0]
        MOVW     R3,#+6539
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6540 
// 6541     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_parse_finished_1:
        ADD      SP,SP,#+24
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
// 6542 }
          CFI EndBlock cfiBlock90

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable51:
        DATA32
        DC32     ?_216
// 6543 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock91 Using cfiCommon0
          CFI Function ssl_handshake_params_init
        THUMB
// 6544 static void ssl_handshake_params_init( mbedtls_ssl_handshake_params *handshake )
// 6545 {
ssl_handshake_params_init:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 6546     memset( handshake, 0, sizeof( mbedtls_ssl_handshake_params ) );
        MOVS     R2,#+0
        MOV      R1,#+1752
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 6547 
// 6548 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ 
// 6549     defined(MBEDTLS_SSL_PROTO_TLS1_1)
// 6550      mbedtls_md5_init(   &handshake->fin_md5  );
        ADD      R0,R4,#+592
          CFI FunCall mbedtls_md5_init
        BL       mbedtls_md5_init
// 6551     mbedtls_sha1_init(   &handshake->fin_sha1 );
        ADD      R0,R4,#+680
          CFI FunCall mbedtls_sha1_init
        BL       mbedtls_sha1_init
// 6552      mbedtls_md5_starts_ret( &handshake->fin_md5  );
        ADD      R0,R4,#+592
          CFI FunCall mbedtls_md5_starts_ret
        BL       mbedtls_md5_starts_ret
// 6553     mbedtls_sha1_starts_ret( &handshake->fin_sha1 );
        ADD      R0,R4,#+680
          CFI FunCall mbedtls_sha1_starts_ret
        BL       mbedtls_sha1_starts_ret
// 6554 #endif
// 6555 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 6556 #if defined(MBEDTLS_SHA256_C)
// 6557     mbedtls_sha256_init(   &handshake->fin_sha256    );
        ADD      R0,R4,#+772
          CFI FunCall mbedtls_sha256_init
        BL       mbedtls_sha256_init
// 6558     mbedtls_sha256_starts_ret( &handshake->fin_sha256, 0 );
        MOVS     R1,#+0
        ADD      R0,R4,#+772
          CFI FunCall mbedtls_sha256_starts_ret
        BL       mbedtls_sha256_starts_ret
// 6559 #endif
// 6560 #if defined(MBEDTLS_SHA512_C)
// 6561     mbedtls_sha512_init(   &handshake->fin_sha512    );
        ADD      R0,R4,#+880
          CFI FunCall mbedtls_sha512_init
        BL       mbedtls_sha512_init
// 6562     mbedtls_sha512_starts_ret( &handshake->fin_sha512, 1 );
        MOVS     R1,#+1
        ADD      R0,R4,#+880
          CFI FunCall mbedtls_sha512_starts_ret
        BL       mbedtls_sha512_starts_ret
// 6563 #endif
// 6564 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 6565 
// 6566     handshake->update_checksum = ssl_update_checksum_start;
        LDR.W    R0,??DataTable68
        STR      R0,[R4, #+1096]
// 6567 
// 6568 #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \ 
// 6569     defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
// 6570     mbedtls_ssl_sig_hash_set_init( &handshake->hash_algs );
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_sig_hash_set_init
        BL       mbedtls_ssl_sig_hash_set_init
// 6571 #endif
// 6572 
// 6573 #if defined(MBEDTLS_DHM_C)
// 6574     mbedtls_dhm_init( &handshake->dhm_ctx );
        ADDS     R0,R4,#+4
          CFI FunCall mbedtls_dhm_init
        BL       mbedtls_dhm_init
// 6575 #endif
// 6576 #if defined(MBEDTLS_ECDH_C)
// 6577     mbedtls_ecdh_init( &handshake->ecdh_ctx );
        ADD      R0,R4,#+128
          CFI FunCall mbedtls_ecdh_init
        BL       mbedtls_ecdh_init
// 6578 #endif
// 6579 #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
// 6580     mbedtls_ecjpake_init( &handshake->ecjpake_ctx );
// 6581 #if defined(MBEDTLS_SSL_CLI_C)
// 6582     handshake->ecjpake_cache = NULL;
// 6583     handshake->ecjpake_cache_len = 0;
// 6584 #endif
// 6585 #endif
// 6586 
// 6587 #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
// 6588     handshake->sni_authmode = MBEDTLS_SSL_VERIFY_UNSET;
        MOVS     R0,#+3
        STR      R0,[R4, #+452]
// 6589 #endif
// 6590 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock91

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable52:
        DATA32
        DC32     ?_217

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable52_1:
        DATA32
        DC32     ?_218

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable52_2:
        DATA32
        DC32     0xffff8980

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable52_3:
        DATA32
        DC32     ?_219

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable52_4:
        DATA32
        DC32     ?_220
// 6591 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock92 Using cfiCommon0
          CFI Function ssl_transform_init
        THUMB
// 6592 static void ssl_transform_init( mbedtls_ssl_transform *transform )
// 6593 {
ssl_transform_init:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 6594     memset( transform, 0, sizeof(mbedtls_ssl_transform) );
        MOVS     R2,#+0
        MOVS     R1,#+208
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 6595 
// 6596     mbedtls_cipher_init( &transform->cipher_ctx_enc );
        ADD      R0,R4,#+80
          CFI FunCall mbedtls_cipher_init
        BL       mbedtls_cipher_init
// 6597     mbedtls_cipher_init( &transform->cipher_ctx_dec );
        ADD      R0,R4,#+144
          CFI FunCall mbedtls_cipher_init
        BL       mbedtls_cipher_init
// 6598 
// 6599     mbedtls_md_init( &transform->md_ctx_enc );
        ADD      R0,R4,#+56
          CFI FunCall mbedtls_md_init
        BL       mbedtls_md_init
// 6600     mbedtls_md_init( &transform->md_ctx_dec );
        ADD      R0,R4,#+68
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_md_init
        B.W      mbedtls_md_init
// 6601 }
          CFI EndBlock cfiBlock92
// 6602 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock93 Using cfiCommon0
          CFI Function mbedtls_ssl_session_init
        THUMB
// 6603 void mbedtls_ssl_session_init( mbedtls_ssl_session *session )
// 6604 {
// 6605     memset( session, 0, sizeof(mbedtls_ssl_session) );
mbedtls_ssl_session_init:
        MOVS     R2,#+0
        MOVS     R1,#+124
          CFI FunCall __aeabi_memset4
        B.W      __aeabi_memset4
// 6606 }
          CFI EndBlock cfiBlock93
// 6607 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock94 Using cfiCommon0
          CFI Function ssl_handshake_init
        THUMB
// 6608 static int ssl_handshake_init( mbedtls_ssl_context *ssl )
// 6609 {
ssl_handshake_init:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        MOV      R4,R0
// 6610     /* Clear old handshake information if present */
// 6611     if( ssl->transform_negotiate )
        LDR      R0,[R4, #+76]
        CMP      R0,#+0
        BEQ.N    ??ssl_handshake_init_0
// 6612         mbedtls_ssl_transform_free( ssl->transform_negotiate );
          CFI FunCall mbedtls_ssl_transform_free
        BL       mbedtls_ssl_transform_free
// 6613     if( ssl->session_negotiate )
??ssl_handshake_init_0:
        LDR      R0,[R4, #+56]
        CMP      R0,#+0
        BEQ.N    ??ssl_handshake_init_1
// 6614         mbedtls_ssl_session_free( ssl->session_negotiate );
          CFI FunCall mbedtls_ssl_session_free
        BL       mbedtls_ssl_session_free
// 6615     if( ssl->handshake )
??ssl_handshake_init_1:
        LDR      R0,[R4, #+60]
        CMP      R0,#+0
        BEQ.N    ??ssl_handshake_init_2
// 6616         mbedtls_ssl_handshake_free( ssl );
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_handshake_free
        BL       mbedtls_ssl_handshake_free
// 6617 
// 6618     /*
// 6619      * Either the pointers are now NULL or cleared properly and can be freed.
// 6620      * Now allocate missing structures.
// 6621      */
// 6622     if( ssl->transform_negotiate == NULL )
??ssl_handshake_init_2:
        LDR      R0,[R4, #+76]
        CMP      R0,#+0
        BNE.N    ??ssl_handshake_init_3
// 6623     {
// 6624         ssl->transform_negotiate = mbedtls_calloc( 1, sizeof(mbedtls_ssl_transform) );
        MOVS     R1,#+208
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R4, #+76]
// 6625     }
// 6626 
// 6627     if( ssl->session_negotiate == NULL )
??ssl_handshake_init_3:
        LDR      R0,[R4, #+56]
        CMP      R0,#+0
        BNE.N    ??ssl_handshake_init_4
// 6628     {
// 6629         ssl->session_negotiate = mbedtls_calloc( 1, sizeof(mbedtls_ssl_session) );
        MOVS     R1,#+124
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R4, #+56]
// 6630     }
// 6631 
// 6632     if( ssl->handshake == NULL )
??ssl_handshake_init_4:
        LDR      R0,[R4, #+60]
        CMP      R0,#+0
        BNE.N    ??ssl_handshake_init_5
// 6633     {
// 6634         ssl->handshake = mbedtls_calloc( 1, sizeof(mbedtls_ssl_handshake_params) );
        MOV      R1,#+1752
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R4, #+60]
// 6635     }
// 6636 
// 6637     /* All pointers should exist and can be directly freed without issue */
// 6638     if( ssl->handshake == NULL ||
// 6639         ssl->transform_negotiate == NULL ||
// 6640         ssl->session_negotiate == NULL )
??ssl_handshake_init_5:
        LDR      R0,[R4, #+60]
        CMP      R0,#+0
        BEQ.N    ??ssl_handshake_init_6
        LDR      R0,[R4, #+76]
        CMP      R0,#+0
        BEQ.N    ??ssl_handshake_init_6
        LDR      R0,[R4, #+56]
        CMP      R0,#+0
        BNE.N    ??ssl_handshake_init_7
// 6641     {
// 6642         MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc() of ssl sub-contexts failed" ) );
??ssl_handshake_init_6:
        LDR.W    R0,??DataTable69
        STR      R0,[SP, #+0]
        MOVW     R3,#+6642
        LDR.N    R2,??DataTable55_5
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6643 
// 6644         mbedtls_free( ssl->handshake );
        LDR      R0,[R4, #+60]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6645         mbedtls_free( ssl->transform_negotiate );
        LDR      R0,[R4, #+76]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6646         mbedtls_free( ssl->session_negotiate );
        LDR      R0,[R4, #+56]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6647 
// 6648         ssl->handshake = NULL;
        MOVS     R0,#+0
        STR      R0,[R4, #+60]
// 6649         ssl->transform_negotiate = NULL;
        STR      R0,[R4, #+76]
// 6650         ssl->session_negotiate = NULL;
        STR      R0,[R4, #+56]
// 6651 
// 6652         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        LDR.W    R0,??DataTable71  ;; 0xffff8100
        POP      {R1,R2,R4,PC}
// 6653     }
// 6654 
// 6655     /* Initialize structures */
// 6656     mbedtls_ssl_session_init( ssl->session_negotiate );
??ssl_handshake_init_7:
          CFI FunCall mbedtls_ssl_session_init
        BL       mbedtls_ssl_session_init
// 6657     ssl_transform_init( ssl->transform_negotiate );
        LDR      R0,[R4, #+76]
          CFI FunCall ssl_transform_init
        BL       ssl_transform_init
// 6658     ssl_handshake_params_init( ssl->handshake );
        LDR      R0,[R4, #+60]
          CFI FunCall ssl_handshake_params_init
        BL       ssl_handshake_params_init
// 6659 
// 6660 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6661     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_handshake_init_8
// 6662     {
// 6663         ssl->handshake->alt_transform_out = ssl->transform_out;
        LDR      R0,[R4, #+68]
        LDR      R1,[R4, #+60]
        STR      R0,[R1, #+508]
// 6664 
// 6665         if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BMI.N    ??ssl_handshake_init_9
// 6666             ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_PREPARING;
        MOVS     R0,#+0
        LDR      R1,[R4, #+60]
        STRB     R0,[R1, #+488]
        B.N      ??ssl_handshake_init_10
// 6667         else
// 6668             ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;
??ssl_handshake_init_9:
        MOVS     R0,#+2
        LDR      R1,[R4, #+60]
        STRB     R0,[R1, #+488]
// 6669 
// 6670         ssl_set_timer( ssl, 0 );
??ssl_handshake_init_10:
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall ssl_set_timer
        BL       ssl_set_timer
// 6671     }
// 6672 #endif
// 6673 
// 6674     return( 0 );
??ssl_handshake_init_8:
        MOVS     R0,#+0
        POP      {R1,R2,R4,PC}    ;; return
// 6675 }
          CFI EndBlock cfiBlock94

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53:
        DATA32
        DC32     ?_221
// 6676 
// 6677 #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
// 6678 /* Dummy cookie callbacks for defaults */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock95 Using cfiCommon0
          CFI Function ssl_cookie_write_dummy
          CFI NoCalls
        THUMB
// 6679 static int ssl_cookie_write_dummy( void *ctx,
// 6680                       unsigned char **p, unsigned char *end,
// 6681                       const unsigned char *cli_id, size_t cli_id_len )
// 6682 {
// 6683     ((void) ctx);
// 6684     ((void) p);
// 6685     ((void) end);
// 6686     ((void) cli_id);
// 6687     ((void) cli_id_len);
// 6688 
// 6689     return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
ssl_cookie_write_dummy:
        LDR.W    R0,??DataTable71_1  ;; 0xffff8f80
        BX       LR               ;; return
// 6690 }
          CFI EndBlock cfiBlock95
// 6691 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock96 Using cfiCommon0
          CFI Function ssl_cookie_check_dummy
          CFI NoCalls
        THUMB
// 6692 static int ssl_cookie_check_dummy( void *ctx,
// 6693                       const unsigned char *cookie, size_t cookie_len,
// 6694                       const unsigned char *cli_id, size_t cli_id_len )
// 6695 {
// 6696     ((void) ctx);
// 6697     ((void) cookie);
// 6698     ((void) cookie_len);
// 6699     ((void) cli_id);
// 6700     ((void) cli_id_len);
// 6701 
// 6702     return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
ssl_cookie_check_dummy:
        LDR.W    R0,??DataTable71_1  ;; 0xffff8f80
        BX       LR               ;; return
// 6703 }
          CFI EndBlock cfiBlock96

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55:
        DATA32
        DC32     ?_212

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_1:
        DATA32
        DC32     ?_213

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_2:
        DATA32
        DC32     ?_222

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_3:
        DATA32
        DC32     ?_224

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_4:
        DATA32
        DC32     ?_225

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_5:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_6:
        DATA32
        DC32     ?_203
// 6704 #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY && MBEDTLS_SSL_SRV_C */
// 6705 
// 6706 /* Once ssl->out_hdr as the address of the beginning of the
// 6707  * next outgoing record is set, deduce the other pointers.
// 6708  *
// 6709  * Note: For TLS, we save the implicit record sequence number
// 6710  *       (entering MAC computation) in the 8 bytes before ssl->out_hdr,
// 6711  *       and the caller has to make sure there's space for this.
// 6712  */
// 6713 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock97 Using cfiCommon0
          CFI Function ssl_update_out_pointers
          CFI NoCalls
        THUMB
// 6714 static void ssl_update_out_pointers( mbedtls_ssl_context *ssl,
// 6715                                      mbedtls_ssl_transform *transform )
// 6716 {
// 6717 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6718     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
ssl_update_out_pointers:
        LDR      R2,[R0, #+0]
        LDR      R2,[R2, #+204]
        UBFX     R2,R2,#+1,#+1
        CMP      R2,#+0
        LDR      R2,[R0, #+184]
        BEQ.N    ??ssl_update_out_pointers_0
// 6719     {
// 6720         ssl->out_ctr = ssl->out_hdr +  3;
        ADDS     R2,R2,#+3
        STR      R2,[R0, #+180]
// 6721         ssl->out_len = ssl->out_hdr + 11;
        LDR      R2,[R0, #+184]
        ADDS     R2,R2,#+11
        STR      R2,[R0, #+188]
// 6722         ssl->out_iv  = ssl->out_hdr + 13;
        LDR      R2,[R0, #+184]
        ADDS     R2,R2,#+13
        STR      R2,[R0, #+192]
        B.N      ??ssl_update_out_pointers_1
// 6723     }
// 6724     else
// 6725 #endif
// 6726     {
// 6727         ssl->out_ctr = ssl->out_hdr - 8;
??ssl_update_out_pointers_0:
        SUBS     R2,R2,#+8
        STR      R2,[R0, #+180]
// 6728         ssl->out_len = ssl->out_hdr + 3;
        LDR      R2,[R0, #+184]
        ADDS     R2,R2,#+3
        STR      R2,[R0, #+188]
// 6729         ssl->out_iv  = ssl->out_hdr + 5;
        LDR      R2,[R0, #+184]
        ADDS     R2,R2,#+5
        STR      R2,[R0, #+192]
// 6730     }
// 6731 
// 6732     /* Adjust out_msg to make space for explicit IV, if used. */
// 6733     if( transform != NULL &&
// 6734         ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
??ssl_update_out_pointers_1:
        CMP      R1,#+0
        BEQ.N    ??ssl_update_out_pointers_2
        LDR      R2,[R0, #+20]
        CMP      R2,#+2
        BLT.N    ??ssl_update_out_pointers_2
// 6735     {
// 6736         ssl->out_msg = ssl->out_iv + transform->ivlen - transform->fixed_ivlen;
        LDR      R2,[R0, #+192]
        LDR      R3,[R1, #+12]
        ADD      R2,R2,R3
        LDR      R1,[R1, #+16]
        RSBS     R1,R1,#+0
        ADD      R1,R2,R1
        STR      R1,[R0, #+196]
        BX       LR
// 6737     }
// 6738     else
// 6739         ssl->out_msg = ssl->out_iv;
??ssl_update_out_pointers_2:
        LDR      R1,[R0, #+192]
        STR      R1,[R0, #+196]
// 6740 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock97
// 6741 
// 6742 /* Once ssl->in_hdr as the address of the beginning of the
// 6743  * next incoming record is set, deduce the other pointers.
// 6744  *
// 6745  * Note: For TLS, we save the implicit record sequence number
// 6746  *       (entering MAC computation) in the 8 bytes before ssl->in_hdr,
// 6747  *       and the caller has to make sure there's space for this.
// 6748  */
// 6749 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock98 Using cfiCommon0
          CFI Function ssl_update_in_pointers
          CFI NoCalls
        THUMB
// 6750 static void ssl_update_in_pointers( mbedtls_ssl_context *ssl,
// 6751                                     mbedtls_ssl_transform *transform )
// 6752 {
// 6753 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6754     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
ssl_update_in_pointers:
        LDR      R2,[R0, #+0]
        LDR      R2,[R2, #+204]
        UBFX     R2,R2,#+1,#+1
        CMP      R2,#+0
        LDR      R2,[R0, #+100]
        BEQ.N    ??ssl_update_in_pointers_0
// 6755     {
// 6756         ssl->in_ctr = ssl->in_hdr +  3;
        ADDS     R2,R2,#+3
        STR      R2,[R0, #+96]
// 6757         ssl->in_len = ssl->in_hdr + 11;
        LDR      R2,[R0, #+100]
        ADDS     R2,R2,#+11
        STR      R2,[R0, #+104]
// 6758         ssl->in_iv  = ssl->in_hdr + 13;
        LDR      R2,[R0, #+100]
        ADDS     R2,R2,#+13
        STR      R2,[R0, #+108]
        B.N      ??ssl_update_in_pointers_1
// 6759     }
// 6760     else
// 6761 #endif
// 6762     {
// 6763         ssl->in_ctr = ssl->in_hdr - 8;
??ssl_update_in_pointers_0:
        SUBS     R2,R2,#+8
        STR      R2,[R0, #+96]
// 6764         ssl->in_len = ssl->in_hdr + 3;
        LDR      R2,[R0, #+100]
        ADDS     R2,R2,#+3
        STR      R2,[R0, #+104]
// 6765         ssl->in_iv  = ssl->in_hdr + 5;
        LDR      R2,[R0, #+100]
        ADDS     R2,R2,#+5
        STR      R2,[R0, #+108]
// 6766     }
// 6767 
// 6768     /* Offset in_msg from in_iv to allow space for explicit IV, if used. */
// 6769     if( transform != NULL &&
// 6770         ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
??ssl_update_in_pointers_1:
        CMP      R1,#+0
        BEQ.N    ??ssl_update_in_pointers_2
        LDR      R2,[R0, #+20]
        CMP      R2,#+2
        BLT.N    ??ssl_update_in_pointers_2
// 6771     {
// 6772         ssl->in_msg = ssl->in_iv + transform->ivlen - transform->fixed_ivlen;
        LDR      R2,[R0, #+108]
        LDR      R3,[R1, #+12]
        ADD      R2,R2,R3
        LDR      R1,[R1, #+16]
        RSBS     R1,R1,#+0
        ADD      R1,R2,R1
        STR      R1,[R0, #+112]
        BX       LR
// 6773     }
// 6774     else
// 6775         ssl->in_msg = ssl->in_iv;
??ssl_update_in_pointers_2:
        LDR      R1,[R0, #+108]
        STR      R1,[R0, #+112]
// 6776 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock98
// 6777 
// 6778 /*
// 6779  * Initialize an SSL context
// 6780  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock99 Using cfiCommon0
          CFI Function mbedtls_ssl_init
        THUMB
// 6781 void mbedtls_ssl_init( mbedtls_ssl_context *ssl )
// 6782 {
// 6783     memset( ssl, 0, sizeof( mbedtls_ssl_context ) );
mbedtls_ssl_init:
        MOVS     R2,#+0
        MOV      R1,#+280
          CFI FunCall __aeabi_memset4
        B.W      __aeabi_memset4
// 6784 }
          CFI EndBlock cfiBlock99
// 6785 
// 6786 /*
// 6787  * Setup an SSL context
// 6788  */
// 6789 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock100 Using cfiCommon0
          CFI Function ssl_reset_in_out_pointers
        THUMB
// 6790 static void ssl_reset_in_out_pointers( mbedtls_ssl_context *ssl )
// 6791 {
ssl_reset_in_out_pointers:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 6792     /* Set the incoming and outgoing record pointers. */
// 6793 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6794     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        LDR      R0,[R4, #+176]
        BEQ.N    ??ssl_reset_in_out_pointers_0
// 6795     {
// 6796         ssl->out_hdr = ssl->out_buf;
        STR      R0,[R4, #+184]
// 6797         ssl->in_hdr  = ssl->in_buf;
        LDR      R0,[R4, #+92]
        STR      R0,[R4, #+100]
        B.N      ??ssl_reset_in_out_pointers_1
// 6798     }
// 6799     else
// 6800 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 6801     {
// 6802         ssl->out_hdr = ssl->out_buf + 8;
??ssl_reset_in_out_pointers_0:
        ADDS     R0,R0,#+8
        STR      R0,[R4, #+184]
// 6803         ssl->in_hdr  = ssl->in_buf  + 8;
        LDR      R0,[R4, #+92]
        ADDS     R0,R0,#+8
        STR      R0,[R4, #+100]
// 6804     }
// 6805 
// 6806     /* Derive other internal pointers. */
// 6807     ssl_update_out_pointers( ssl, NULL /* no transform enabled */ );
??ssl_reset_in_out_pointers_1:
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall ssl_update_out_pointers
        BL       ssl_update_out_pointers
// 6808     ssl_update_in_pointers ( ssl, NULL /* no transform enabled */ );
        MOVS     R1,#+0
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall ssl_update_in_pointers
        B.N      ssl_update_in_pointers
// 6809 }
          CFI EndBlock cfiBlock100
// 6810 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock101 Using cfiCommon0
          CFI Function mbedtls_ssl_setup
        THUMB
// 6811 int mbedtls_ssl_setup( mbedtls_ssl_context *ssl,
// 6812                        const mbedtls_ssl_config *conf )
// 6813 {
mbedtls_ssl_setup:
        PUSH     {R1-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        MOV      R5,R0
// 6814     int ret;
// 6815 
// 6816     ssl->conf = conf;
        STR      R1,[R5, #+0]
// 6817 
// 6818     /*
// 6819      * Prepare base structures
// 6820      */
// 6821 
// 6822     /* Set to NULL in case of an error condition */
// 6823     ssl->out_buf = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+176]
// 6824 
// 6825     ssl->in_buf = mbedtls_calloc( 1, MBEDTLS_SSL_IN_BUFFER_LEN );
        MOVW     R4,#+10573
        MOV      R1,R4
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R5, #+92]
// 6826     if( ssl->in_buf == NULL )
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_setup_0
// 6827     {
// 6828         MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed", MBEDTLS_SSL_IN_BUFFER_LEN) );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable72
        STR      R0,[SP, #+0]
        MOVW     R3,#+6828
        LDR.W    R2,??DataTable72_1
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 6829         ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
        LDR.W    R4,??DataTable71  ;; 0xffff8100
// 6830         goto error;
// 6831     }
// 6832 
// 6833     ssl->out_buf = mbedtls_calloc( 1, MBEDTLS_SSL_OUT_BUFFER_LEN );
// 6834     if( ssl->out_buf == NULL )
// 6835     {
// 6836         MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed", MBEDTLS_SSL_OUT_BUFFER_LEN) );
// 6837         ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
// 6838         goto error;
// 6839     }
// 6840 
// 6841     ssl_reset_in_out_pointers( ssl );
// 6842 
// 6843     if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
// 6844         goto error;
// 6845 
// 6846     return( 0 );
// 6847 
// 6848 error:
// 6849     mbedtls_free( ssl->in_buf );
??mbedtls_ssl_setup_1:
        LDR      R0,[R5, #+92]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6850     mbedtls_free( ssl->out_buf );
        LDR      R0,[R5, #+176]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6851 
// 6852     ssl->conf = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+0]
// 6853 
// 6854     ssl->in_buf = NULL;
        STR      R0,[R5, #+92]
// 6855     ssl->out_buf = NULL;
        STR      R0,[R5, #+176]
// 6856 
// 6857     ssl->in_hdr = NULL;
        STR      R0,[R5, #+100]
// 6858     ssl->in_ctr = NULL;
        STR      R0,[R5, #+96]
// 6859     ssl->in_len = NULL;
        STR      R0,[R5, #+104]
// 6860     ssl->in_iv = NULL;
        STR      R0,[R5, #+108]
// 6861     ssl->in_msg = NULL;
        STR      R0,[R5, #+112]
// 6862 
// 6863     ssl->out_hdr = NULL;
        STR      R0,[R5, #+184]
// 6864     ssl->out_ctr = NULL;
        STR      R0,[R5, #+180]
// 6865     ssl->out_len = NULL;
        STR      R0,[R5, #+188]
// 6866     ssl->out_iv = NULL;
        STR      R0,[R5, #+192]
// 6867     ssl->out_msg = NULL;
        STR      R0,[R5, #+196]
// 6868 
// 6869     return( ret );
        MOV      R0,R4
        POP      {R1-R5,PC}       ;; return
??mbedtls_ssl_setup_0:
        MOV      R1,R4
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R5, #+176]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_setup_2
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable72
        STR      R0,[SP, #+0]
        MOVW     R3,#+6836
        LDR.W    R2,??DataTable72_1
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R4,??DataTable71  ;; 0xffff8100
        B.N      ??mbedtls_ssl_setup_1
??mbedtls_ssl_setup_2:
        MOV      R0,R5
          CFI FunCall ssl_reset_in_out_pointers
        BL       ssl_reset_in_out_pointers
        MOV      R0,R5
          CFI FunCall ssl_handshake_init
        BL       ssl_handshake_init
        MOVS     R4,R0
        BNE.N    ??mbedtls_ssl_setup_1
        MOVS     R0,#+0
        POP      {R1-R5,PC}
// 6870 }
          CFI EndBlock cfiBlock101

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56:
        DATA32
        DC32     ?_211

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_1:
        DATA32
        DC32     ?_223

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_2:
        DATA32
        DC32     ?_226

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_3:
        DATA32
        DC32     ?_227

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_4:
        DATA32
        DC32     0xffff9480

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_5:
        DATA32
        DC32     ?_228

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_6:
        DATA32
        DC32     ?_229
// 6871 
// 6872 /*
// 6873  * Reset an initialized and used SSL context for re-use while retaining
// 6874  * all application-set variables, function pointers and data.
// 6875  *
// 6876  * If partial is non-zero, keep data in the input buffer and client ID.
// 6877  * (Use when a DTLS client reconnects from the same port.)
// 6878  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock102 Using cfiCommon0
          CFI Function ssl_session_reset_int
        THUMB
// 6879 static int ssl_session_reset_int( mbedtls_ssl_context *ssl, int partial )
// 6880 {
ssl_session_reset_int:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
        MOV      R4,R1
// 6881     int ret;
// 6882 
// 6883 #if !defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) ||     \ 
// 6884     !defined(MBEDTLS_SSL_SRV_C)
// 6885     ((void) partial);
// 6886 #endif
// 6887 
// 6888     ssl->state = MBEDTLS_SSL_HELLO_REQUEST;
        MOVS     R0,#+0
        STR      R0,[R5, #+4]
// 6889 
// 6890     /* Cancel any possibly running timer */
// 6891     ssl_set_timer( ssl, 0 );
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall ssl_set_timer
        BL       ssl_set_timer
// 6892 
// 6893 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 6894     ssl->renego_status = MBEDTLS_SSL_INITIAL_HANDSHAKE;
        MOVS     R0,#+0
        STR      R0,[R5, #+8]
// 6895     ssl->renego_records_seen = 0;
        STR      R0,[R5, #+12]
// 6896 
// 6897     ssl->verify_data_len = 0;
        STR      R0,[R5, #+248]
// 6898     memset( ssl->own_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );
        MOV      R2,R0
        MOVS     R1,#+12
        ADD      R0,R5,#+252
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 6899     memset( ssl->peer_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );
        MOVS     R2,#+0
        MOVS     R1,#+12
        ADD      R0,R5,#+264
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 6900 #endif
// 6901     ssl->secure_renegotiation = MBEDTLS_SSL_LEGACY_RENEGOTIATION;
        MOVS     R0,#+0
        STR      R0,[R5, #+244]
// 6902 
// 6903     ssl->in_offt = NULL;
        STR      R0,[R5, #+116]
// 6904     ssl_reset_in_out_pointers( ssl );
        MOV      R0,R5
          CFI FunCall ssl_reset_in_out_pointers
        BL       ssl_reset_in_out_pointers
// 6905 
// 6906     ssl->in_msgtype = 0;
        MOVS     R0,#+0
        STR      R0,[R5, #+120]
// 6907     ssl->in_msglen = 0;
        STR      R0,[R5, #+124]
// 6908 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 6909     ssl->next_record_offset = 0;
        STR      R0,[R5, #+136]
// 6910     ssl->in_epoch = 0;
        STRH     R0,[R5, #+132]
// 6911 #endif
// 6912 #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
// 6913     ssl_dtls_replay_reset( ssl );
        MOV      R0,R5
          CFI FunCall ssl_dtls_replay_reset
        BL       ssl_dtls_replay_reset
// 6914 #endif
// 6915 
// 6916     ssl->in_hslen = 0;
        MOVS     R0,#+0
        STR      R0,[R5, #+160]
// 6917     ssl->nb_zero = 0;
        STR      R0,[R5, #+164]
// 6918 
// 6919     ssl->keep_current_message = 0;
        STR      R0,[R5, #+168]
// 6920 
// 6921     ssl->out_msgtype = 0;
        STR      R0,[R5, #+200]
// 6922     ssl->out_msglen = 0;
        STR      R0,[R5, #+204]
// 6923     ssl->out_left = 0;
        STR      R0,[R5, #+208]
// 6924 #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
// 6925     if( ssl->split_done != MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED )
        LDRSB    R0,[R5, #+222]
        CMP      R0,#+0
        BEQ.N    ??ssl_session_reset_int_0
// 6926         ssl->split_done = 0;
        MOVS     R0,#+0
        STRB     R0,[R5, #+222]
// 6927 #endif
// 6928 
// 6929     memset( ssl->cur_out_ctr, 0, sizeof( ssl->cur_out_ctr ) );
??ssl_session_reset_int_0:
        MOVS     R2,#+0
        MOVS     R1,#+8
        ADD      R0,R5,#+212
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 6930 
// 6931     ssl->transform_in = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+64]
// 6932     ssl->transform_out = NULL;
        STR      R0,[R5, #+68]
// 6933 
// 6934     ssl->session_in = NULL;
        STR      R0,[R5, #+44]
// 6935     ssl->session_out = NULL;
        STR      R0,[R5, #+48]
// 6936 
// 6937     memset( ssl->out_buf, 0, MBEDTLS_SSL_OUT_BUFFER_LEN );
        MOVW     R6,#+10573
        MOV      R2,R0
        MOV      R1,R6
        LDR      R0,[R5, #+176]
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 6938 
// 6939 #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && defined(MBEDTLS_SSL_SRV_C)
// 6940     if( partial == 0 )
        CMP      R4,#+0
        BNE.N    ??ssl_session_reset_int_1
// 6941 #endif /* MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE && MBEDTLS_SSL_SRV_C */
// 6942     {
// 6943         ssl->in_left = 0;
        MOVS     R0,#+0
        STR      R0,[R5, #+128]
// 6944         memset( ssl->in_buf, 0, MBEDTLS_SSL_IN_BUFFER_LEN );
        MOV      R2,R0
        MOV      R1,R6
        LDR      R0,[R5, #+92]
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 6945     }
// 6946 
// 6947 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
// 6948     if( mbedtls_ssl_hw_record_reset != NULL )
// 6949     {
// 6950         MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_reset()" ) );
// 6951         if( ( ret = mbedtls_ssl_hw_record_reset( ssl ) ) != 0 )
// 6952         {
// 6953             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_reset", ret );
// 6954             return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
// 6955         }
// 6956     }
// 6957 #endif
// 6958 
// 6959     if( ssl->transform )
??ssl_session_reset_int_1:
        LDR      R0,[R5, #+72]
        CMP      R0,#+0
        BEQ.N    ??ssl_session_reset_int_2
// 6960     {
// 6961         mbedtls_ssl_transform_free( ssl->transform );
          CFI FunCall mbedtls_ssl_transform_free
        BL       mbedtls_ssl_transform_free
// 6962         mbedtls_free( ssl->transform );
        LDR      R0,[R5, #+72]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6963         ssl->transform = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+72]
// 6964     }
// 6965 
// 6966     if( ssl->session )
??ssl_session_reset_int_2:
        LDR      R0,[R5, #+52]
        CMP      R0,#+0
        BEQ.N    ??ssl_session_reset_int_3
// 6967     {
// 6968         mbedtls_ssl_session_free( ssl->session );
          CFI FunCall mbedtls_ssl_session_free
        BL       mbedtls_ssl_session_free
// 6969         mbedtls_free( ssl->session );
        LDR      R0,[R5, #+52]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6970         ssl->session = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+52]
// 6971     }
// 6972 
// 6973 #if defined(MBEDTLS_SSL_ALPN)
// 6974     ssl->alpn_chosen = NULL;
??ssl_session_reset_int_3:
        MOVS     R0,#+0
        STR      R0,[R5, #+232]
// 6975 #endif
// 6976 
// 6977 #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
// 6978 #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE)
// 6979     if( partial == 0 )
        CMP      R4,#+0
        BNE.N    ??ssl_session_reset_int_4
// 6980 #endif
// 6981     {
// 6982         mbedtls_free( ssl->cli_id );
        LDR      R0,[R5, #+236]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 6983         ssl->cli_id = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+236]
// 6984         ssl->cli_id_len = 0;
        STR      R0,[R5, #+240]
// 6985     }
// 6986 #endif
// 6987 
// 6988     if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
??ssl_session_reset_int_4:
        MOV      R0,R5
          CFI FunCall ssl_handshake_init
        BL       ssl_handshake_init
        CMP      R0,#+0
        BNE.N    ??ssl_session_reset_int_5
// 6989         return( ret );
// 6990 
// 6991     return( 0 );
        MOVS     R0,#+0
??ssl_session_reset_int_5:
        POP      {R4-R6,PC}       ;; return
// 6992 }
          CFI EndBlock cfiBlock102
// 6993 
// 6994 /*
// 6995  * Reset an initialized and used SSL context for re-use while retaining
// 6996  * all application-set variables, function pointers and data.
// 6997  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock103 Using cfiCommon0
          CFI Function mbedtls_ssl_session_reset
        THUMB
// 6998 int mbedtls_ssl_session_reset( mbedtls_ssl_context *ssl )
// 6999 {
// 7000     return( ssl_session_reset_int( ssl, 0 ) );
mbedtls_ssl_session_reset:
        MOVS     R1,#+0
          CFI FunCall ssl_session_reset_int
        B.N      ssl_session_reset_int
// 7001 }
          CFI EndBlock cfiBlock103
// 7002 
// 7003 /*
// 7004  * SSL set accessors
// 7005  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock104 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_endpoint
          CFI NoCalls
        THUMB
// 7006 void mbedtls_ssl_conf_endpoint( mbedtls_ssl_config *conf, int endpoint )
// 7007 {
// 7008     conf->endpoint   = endpoint;
mbedtls_ssl_conf_endpoint:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+0,#+1
        STR      R2,[R0, #+204]
// 7009 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock104
// 7010 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock105 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_transport
          CFI NoCalls
        THUMB
// 7011 void mbedtls_ssl_conf_transport( mbedtls_ssl_config *conf, int transport )
// 7012 {
// 7013     conf->transport = transport;
mbedtls_ssl_conf_transport:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+1,#+1
        STR      R2,[R0, #+204]
// 7014 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock105
// 7015 
// 7016 #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock106 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_dtls_anti_replay
          CFI NoCalls
        THUMB
// 7017 void mbedtls_ssl_conf_dtls_anti_replay( mbedtls_ssl_config *conf, char mode )
// 7018 {
// 7019     conf->anti_replay = mode;
mbedtls_ssl_conf_dtls_anti_replay:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+11,#+1
        STR      R2,[R0, #+204]
// 7020 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock106
// 7021 #endif
// 7022 
// 7023 #if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock107 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_dtls_badmac_limit
          CFI NoCalls
        THUMB
// 7024 void mbedtls_ssl_conf_dtls_badmac_limit( mbedtls_ssl_config *conf, unsigned limit )
// 7025 {
// 7026     conf->badmac_limit = limit;
mbedtls_ssl_conf_dtls_badmac_limit:
        STR      R1,[R0, #+192]
// 7027 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock107
// 7028 #endif
// 7029 
// 7030 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 7031 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock108 Using cfiCommon0
          CFI Function mbedtls_ssl_set_datagram_packing
          CFI NoCalls
        THUMB
// 7032 void mbedtls_ssl_set_datagram_packing( mbedtls_ssl_context *ssl,
// 7033                                        unsigned allow_packing )
// 7034 {
// 7035     ssl->disable_datagram_packing = !allow_packing;
mbedtls_ssl_set_datagram_packing:
        SUBS     R1,R1,#+1
        SBCS     R1,R1,R1
        LSRS     R1,R1,#+31
        STRB     R1,[R0, #+172]
// 7036 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock108
// 7037 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock109 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_handshake_timeout
          CFI NoCalls
        THUMB
// 7038 void mbedtls_ssl_conf_handshake_timeout( mbedtls_ssl_config *conf,
// 7039                                          uint32_t min, uint32_t max )
// 7040 {
// 7041     conf->hs_timeout_min = min;
mbedtls_ssl_conf_handshake_timeout:
        STR      R1,[R0, #+172]
// 7042     conf->hs_timeout_max = max;
        STR      R2,[R0, #+176]
// 7043 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock109
// 7044 #endif
// 7045 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock110 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_authmode
          CFI NoCalls
        THUMB
// 7046 void mbedtls_ssl_conf_authmode( mbedtls_ssl_config *conf, int authmode )
// 7047 {
// 7048     conf->authmode   = authmode;
mbedtls_ssl_conf_authmode:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+2,#+2
        STR      R2,[R0, #+204]
// 7049 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock110
// 7050 
// 7051 #if defined(MBEDTLS_X509_CRT_PARSE_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock111 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_verify
          CFI NoCalls
        THUMB
// 7052 void mbedtls_ssl_conf_verify( mbedtls_ssl_config *conf,
// 7053                      int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
// 7054                      void *p_vrfy )
// 7055 {
// 7056     conf->f_vrfy      = f_vrfy;
mbedtls_ssl_conf_verify:
        STR      R1,[R0, #+52]
// 7057     conf->p_vrfy      = p_vrfy;
        STR      R2,[R0, #+56]
// 7058 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock111
// 7059 #endif /* MBEDTLS_X509_CRT_PARSE_C */
// 7060 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock112 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_rng
          CFI NoCalls
        THUMB
// 7061 void mbedtls_ssl_conf_rng( mbedtls_ssl_config *conf,
// 7062                   int (*f_rng)(void *, unsigned char *, size_t),
// 7063                   void *p_rng )
// 7064 {
// 7065     conf->f_rng      = f_rng;
mbedtls_ssl_conf_rng:
        STR      R1,[R0, #+24]
// 7066     conf->p_rng      = p_rng;
        STR      R2,[R0, #+28]
// 7067 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock112
// 7068 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock113 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_dbg
          CFI NoCalls
        THUMB
// 7069 void mbedtls_ssl_conf_dbg( mbedtls_ssl_config *conf,
// 7070                   void (*f_dbg)(void *, int, const char *, int, const char *),
// 7071                   void  *p_dbg )
// 7072 {
// 7073     conf->f_dbg      = f_dbg;
mbedtls_ssl_conf_dbg:
        STR      R1,[R0, #+16]
// 7074     conf->p_dbg      = p_dbg;
        STR      R2,[R0, #+20]
// 7075 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock113
// 7076 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock114 Using cfiCommon0
          CFI Function mbedtls_ssl_set_bio
          CFI NoCalls
        THUMB
// 7077 void mbedtls_ssl_set_bio( mbedtls_ssl_context *ssl,
// 7078         void *p_bio,
// 7079         mbedtls_ssl_send_t *f_send,
// 7080         mbedtls_ssl_recv_t *f_recv,
// 7081         mbedtls_ssl_recv_timeout_t *f_recv_timeout )
// 7082 {
mbedtls_ssl_set_bio:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
        LDR      R4,[SP, #+4]
// 7083     ssl->p_bio          = p_bio;
        STR      R1,[R0, #+40]
// 7084     ssl->f_send         = f_send;
        STR      R2,[R0, #+28]
// 7085     ssl->f_recv         = f_recv;
        STR      R3,[R0, #+32]
// 7086     ssl->f_recv_timeout = f_recv_timeout;
        STR      R4,[R0, #+36]
// 7087 }
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock114
// 7088 
// 7089 #if defined(MBEDTLS_SSL_PROTO_DTLS)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock115 Using cfiCommon0
          CFI Function mbedtls_ssl_set_mtu
          CFI NoCalls
        THUMB
// 7090 void mbedtls_ssl_set_mtu( mbedtls_ssl_context *ssl, uint16_t mtu )
// 7091 {
// 7092     ssl->mtu = mtu;
mbedtls_ssl_set_mtu:
        STRH     R1,[R0, #+220]
// 7093 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock115
// 7094 #endif
// 7095 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock116 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_read_timeout
          CFI NoCalls
        THUMB
// 7096 void mbedtls_ssl_conf_read_timeout( mbedtls_ssl_config *conf, uint32_t timeout )
// 7097 {
// 7098     conf->read_timeout   = timeout;
mbedtls_ssl_conf_read_timeout:
        STR      R1,[R0, #+168]
// 7099 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock116
// 7100 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock117 Using cfiCommon0
          CFI Function mbedtls_ssl_set_timer_cb
        THUMB
// 7101 void mbedtls_ssl_set_timer_cb( mbedtls_ssl_context *ssl,
// 7102                                void *p_timer,
// 7103                                mbedtls_ssl_set_timer_t *f_set_timer,
// 7104                                mbedtls_ssl_get_timer_t *f_get_timer )
// 7105 {
// 7106     ssl->p_timer        = p_timer;
mbedtls_ssl_set_timer_cb:
        STR      R1,[R0, #+80]
// 7107     ssl->f_set_timer    = f_set_timer;
        STR      R2,[R0, #+84]
// 7108     ssl->f_get_timer    = f_get_timer;
        STR      R3,[R0, #+88]
// 7109 
// 7110     /* Make sure we start with no timer running */
// 7111     ssl_set_timer( ssl, 0 );
        MOVS     R1,#+0
          CFI FunCall ssl_set_timer
        B.W      ssl_set_timer
// 7112 }
          CFI EndBlock cfiBlock117
// 7113 
// 7114 #if defined(MBEDTLS_SSL_SRV_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock118 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_session_cache
          CFI NoCalls
        THUMB
// 7115 void mbedtls_ssl_conf_session_cache( mbedtls_ssl_config *conf,
// 7116         void *p_cache,
// 7117         int (*f_get_cache)(void *, mbedtls_ssl_session *),
// 7118         int (*f_set_cache)(void *, const mbedtls_ssl_session *) )
// 7119 {
// 7120     conf->p_cache = p_cache;
mbedtls_ssl_conf_session_cache:
        STR      R1,[R0, #+40]
// 7121     conf->f_get_cache = f_get_cache;
        STR      R2,[R0, #+32]
// 7122     conf->f_set_cache = f_set_cache;
        STR      R3,[R0, #+36]
// 7123 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock118
// 7124 #endif /* MBEDTLS_SSL_SRV_C */
// 7125 
// 7126 #if defined(MBEDTLS_SSL_CLI_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock119 Using cfiCommon0
          CFI Function mbedtls_ssl_set_session
        THUMB
// 7127 int mbedtls_ssl_set_session( mbedtls_ssl_context *ssl, const mbedtls_ssl_session *session )
// 7128 {
mbedtls_ssl_set_session:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
// 7129     int ret;
// 7130 
// 7131     if( ssl == NULL ||
// 7132         session == NULL ||
// 7133         ssl->session_negotiate == NULL ||
// 7134         ssl->conf->endpoint != MBEDTLS_SSL_IS_CLIENT )
        BEQ.N    ??mbedtls_ssl_set_session_0
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_set_session_0
        LDR      R0,[R4, #+56]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_set_session_0
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_set_session_1
// 7135     {
// 7136         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_set_session_0:
        LDR.W    R0,??DataTable74  ;; 0xffff8f00
        POP      {R4,PC}
// 7137     }
// 7138 
// 7139     if( ( ret = ssl_session_copy( ssl->session_negotiate, session ) ) != 0 )
??mbedtls_ssl_set_session_1:
        LDR      R0,[R4, #+56]
          CFI FunCall ssl_session_copy
        BL       ssl_session_copy
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_set_session_2
// 7140         return( ret );
// 7141 
// 7142     ssl->handshake->resume = 1;
        MOVS     R0,#+1
        LDR      R1,[R4, #+60]
        STR      R0,[R1, #+1728]
// 7143 
// 7144     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_set_session_2:
        POP      {R4,PC}          ;; return
// 7145 }
          CFI EndBlock cfiBlock119

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57:
        DATA32
        DC32     ?_230

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_1:
        DATA32
        DC32     ?_231

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_2:
        DATA32
        DC32     ?_232

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_3:
        DATA32
        DC32     ?_233
// 7146 #endif /* MBEDTLS_SSL_CLI_C */
// 7147 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock120 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_ciphersuites
          CFI NoCalls
        THUMB
// 7148 void mbedtls_ssl_conf_ciphersuites( mbedtls_ssl_config *conf,
// 7149                                    const int *ciphersuites )
// 7150 {
// 7151     conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] = ciphersuites;
mbedtls_ssl_conf_ciphersuites:
        STR      R1,[R0, #+0]
// 7152     conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] = ciphersuites;
        STR      R1,[R0, #+4]
// 7153     conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] = ciphersuites;
        STR      R1,[R0, #+8]
// 7154     conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] = ciphersuites;
        STR      R1,[R0, #+12]
// 7155 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock120
// 7156 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock121 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_ciphersuites_for_version
          CFI NoCalls
        THUMB
// 7157 void mbedtls_ssl_conf_ciphersuites_for_version( mbedtls_ssl_config *conf,
// 7158                                        const int *ciphersuites,
// 7159                                        int major, int minor )
// 7160 {
// 7161     if( major != MBEDTLS_SSL_MAJOR_VERSION_3 )
mbedtls_ssl_conf_ciphersuites_for_version:
        CMP      R2,#+3
        BNE.N    ??mbedtls_ssl_conf_ciphersuites_for_version_0
// 7162         return;
// 7163 
// 7164     if( minor < MBEDTLS_SSL_MINOR_VERSION_0 || minor > MBEDTLS_SSL_MINOR_VERSION_3 )
        CMP      R3,#+4
        BCS.N    ??mbedtls_ssl_conf_ciphersuites_for_version_0
// 7165         return;
// 7166 
// 7167     conf->ciphersuite_list[minor] = ciphersuites;
        STR      R1,[R0, R3, LSL #+2]
// 7168 }
??mbedtls_ssl_conf_ciphersuites_for_version_0:
        BX       LR               ;; return
          CFI EndBlock cfiBlock121
// 7169 
// 7170 #if defined(MBEDTLS_X509_CRT_PARSE_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock122 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_cert_profile
          CFI NoCalls
        THUMB
// 7171 void mbedtls_ssl_conf_cert_profile( mbedtls_ssl_config *conf,
// 7172                                     const mbedtls_x509_crt_profile *profile )
// 7173 {
// 7174     conf->cert_profile = profile;
mbedtls_ssl_conf_cert_profile:
        STR      R1,[R0, #+100]
// 7175 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock122
// 7176 
// 7177 /* Append a new keycert entry to a (possibly empty) list */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock123 Using cfiCommon0
          CFI Function ssl_append_key_cert
        THUMB
// 7178 static int ssl_append_key_cert( mbedtls_ssl_key_cert **head,
// 7179                                 mbedtls_x509_crt *cert,
// 7180                                 mbedtls_pk_context *key )
// 7181 {
ssl_append_key_cert:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
// 7182     mbedtls_ssl_key_cert *new_cert;
// 7183 
// 7184     new_cert = mbedtls_calloc( 1, sizeof( mbedtls_ssl_key_cert ) );
        MOVS     R1,#+12
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
// 7185     if( new_cert == NULL )
        CMP      R0,#+0
        BNE.N    ??ssl_append_key_cert_0
// 7186         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        LDR.W    R0,??DataTable71  ;; 0xffff8100
        POP      {R4-R6,PC}
// 7187 
// 7188     new_cert->cert = cert;
??ssl_append_key_cert_0:
        STR      R5,[R0, #+0]
// 7189     new_cert->key  = key;
        STR      R6,[R0, #+4]
// 7190     new_cert->next = NULL;
        MOVS     R1,#+0
        STR      R1,[R0, #+8]
// 7191 
// 7192     /* Update head is the list was null, else add to the end */
// 7193     if( *head == NULL )
        LDR      R1,[R4, #+0]
        CMP      R1,#+0
        BNE.N    ??ssl_append_key_cert_1
// 7194     {
// 7195         *head = new_cert;
        STR      R0,[R4, #+0]
        B.N      ??ssl_append_key_cert_2
// 7196     }
// 7197     else
// 7198     {
// 7199         mbedtls_ssl_key_cert *cur = *head;
??ssl_append_key_cert_1:
        MOV      R2,R1
        B.N      ??ssl_append_key_cert_3
// 7200         while( cur->next != NULL )
// 7201             cur = cur->next;
??ssl_append_key_cert_4:
        MOV      R2,R1
??ssl_append_key_cert_3:
        LDR      R1,[R2, #+8]
        CMP      R1,#+0
        BNE.N    ??ssl_append_key_cert_4
// 7202         cur->next = new_cert;
        STR      R0,[R2, #+8]
// 7203     }
// 7204 
// 7205     return( 0 );
??ssl_append_key_cert_2:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
// 7206 }
          CFI EndBlock cfiBlock123

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58:
        DATA32
        DC32     ?_234

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_1:
        DATA32
        DC32     ?_236

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_2:
        DATA32
        DC32     ?_237
// 7207 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock124 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_own_cert
        THUMB
// 7208 int mbedtls_ssl_conf_own_cert( mbedtls_ssl_config *conf,
// 7209                               mbedtls_x509_crt *own_cert,
// 7210                               mbedtls_pk_context *pk_key )
// 7211 {
// 7212     return( ssl_append_key_cert( &conf->key_cert, own_cert, pk_key ) );
mbedtls_ssl_conf_own_cert:
        ADDS     R0,R0,#+104
          CFI FunCall ssl_append_key_cert
        B.N      ssl_append_key_cert
// 7213 }
          CFI EndBlock cfiBlock124
// 7214 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock125 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_ca_chain
          CFI NoCalls
        THUMB
// 7215 void mbedtls_ssl_conf_ca_chain( mbedtls_ssl_config *conf,
// 7216                                mbedtls_x509_crt *ca_chain,
// 7217                                mbedtls_x509_crl *ca_crl )
// 7218 {
// 7219     conf->ca_chain   = ca_chain;
mbedtls_ssl_conf_ca_chain:
        STR      R1,[R0, #+108]
// 7220     conf->ca_crl     = ca_crl;
        STR      R2,[R0, #+112]
// 7221 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock125
// 7222 #endif /* MBEDTLS_X509_CRT_PARSE_C */
// 7223 
// 7224 #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock126 Using cfiCommon0
          CFI Function mbedtls_ssl_set_hs_own_cert
        THUMB
// 7225 int mbedtls_ssl_set_hs_own_cert( mbedtls_ssl_context *ssl,
// 7226                                  mbedtls_x509_crt *own_cert,
// 7227                                  mbedtls_pk_context *pk_key )
// 7228 {
// 7229     return( ssl_append_key_cert( &ssl->handshake->sni_key_cert,
// 7230                                  own_cert, pk_key ) );
mbedtls_ssl_set_hs_own_cert:
        LDR      R0,[R0, #+60]
        ADD      R0,R0,#+456
          CFI FunCall ssl_append_key_cert
        B.N      ssl_append_key_cert
// 7231 }
          CFI EndBlock cfiBlock126
// 7232 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock127 Using cfiCommon0
          CFI Function mbedtls_ssl_set_hs_ca_chain
          CFI NoCalls
        THUMB
// 7233 void mbedtls_ssl_set_hs_ca_chain( mbedtls_ssl_context *ssl,
// 7234                                   mbedtls_x509_crt *ca_chain,
// 7235                                   mbedtls_x509_crl *ca_crl )
// 7236 {
// 7237     ssl->handshake->sni_ca_chain   = ca_chain;
mbedtls_ssl_set_hs_ca_chain:
        LDR      R3,[R0, #+60]
        STR      R1,[R3, #+460]
// 7238     ssl->handshake->sni_ca_crl     = ca_crl;
        LDR      R0,[R0, #+60]
        STR      R2,[R0, #+464]
// 7239 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock127
// 7240 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock128 Using cfiCommon0
          CFI Function mbedtls_ssl_set_hs_authmode
          CFI NoCalls
        THUMB
// 7241 void mbedtls_ssl_set_hs_authmode( mbedtls_ssl_context *ssl,
// 7242                                   int authmode )
// 7243 {
// 7244     ssl->handshake->sni_authmode = authmode;
mbedtls_ssl_set_hs_authmode:
        LDR      R0,[R0, #+60]
        STR      R1,[R0, #+452]
// 7245 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock128
// 7246 #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
// 7247 
// 7248 #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
// 7249 /*
// 7250  * Set EC J-PAKE password for current handshake
// 7251  */
// 7252 int mbedtls_ssl_set_hs_ecjpake_password( mbedtls_ssl_context *ssl,
// 7253                                          const unsigned char *pw,
// 7254                                          size_t pw_len )
// 7255 {
// 7256     mbedtls_ecjpake_role role;
// 7257 
// 7258     if( ssl->handshake == NULL || ssl->conf == NULL )
// 7259         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 7260 
// 7261     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
// 7262         role = MBEDTLS_ECJPAKE_SERVER;
// 7263     else
// 7264         role = MBEDTLS_ECJPAKE_CLIENT;
// 7265 
// 7266     return( mbedtls_ecjpake_setup( &ssl->handshake->ecjpake_ctx,
// 7267                                    role,
// 7268                                    MBEDTLS_MD_SHA256,
// 7269                                    MBEDTLS_ECP_DP_SECP256R1,
// 7270                                    pw, pw_len ) );
// 7271 }
// 7272 #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
// 7273 
// 7274 #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock129 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_psk
        THUMB
// 7275 int mbedtls_ssl_conf_psk( mbedtls_ssl_config *conf,
// 7276                 const unsigned char *psk, size_t psk_len,
// 7277                 const unsigned char *psk_identity, size_t psk_identity_len )
// 7278 {
mbedtls_ssl_conf_psk:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOV      R7,R0
        MOV      R4,R1
        MOV      R8,R2
        MOV      R5,R3
// 7279     if( psk == NULL || psk_identity == NULL )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_conf_psk_0
        CMP      R5,#+0
        BEQ.N    ??mbedtls_ssl_conf_psk_0
// 7280         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 7281 
// 7282     if( psk_len > MBEDTLS_PSK_MAX_LEN )
        CMP      R8,#+33
        BCS.N    ??mbedtls_ssl_conf_psk_0
        LDR      R6,[SP, #+24]
// 7283         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 7284 
// 7285     /* Identity len will be encoded on two bytes */
// 7286     if( ( psk_identity_len >> 16 ) != 0 ||
// 7287         psk_identity_len > MBEDTLS_SSL_OUT_CONTENT_LEN )
        MOV      R0,R6
        LSRS     R0,R0,#+16
        BNE.N    ??mbedtls_ssl_conf_psk_0
        MOVW     R0,#+10241
        CMP      R6,R0
        BCC.N    ??mbedtls_ssl_conf_psk_1
// 7288     {
// 7289         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_conf_psk_0:
        LDR.W    R0,??DataTable74  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_conf_psk_2
// 7290     }
// 7291 
// 7292     if( conf->psk != NULL )
??mbedtls_ssl_conf_psk_1:
        LDR      R0,[R7, #+148]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_conf_psk_3
// 7293     {
// 7294         mbedtls_platform_zeroize( conf->psk, conf->psk_len );
        LDR      R1,[R7, #+152]
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 7295 
// 7296         mbedtls_free( conf->psk );
        LDR      R0,[R7, #+148]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 7297         conf->psk = NULL;
        MOVS     R0,#+0
        STR      R0,[R7, #+148]
// 7298         conf->psk_len = 0;
        STR      R0,[R7, #+152]
// 7299     }
// 7300     if( conf->psk_identity != NULL )
??mbedtls_ssl_conf_psk_3:
        LDR      R0,[R7, #+156]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_conf_psk_4
// 7301     {
// 7302         mbedtls_free( conf->psk_identity );
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 7303         conf->psk_identity = NULL;
        MOVS     R0,#+0
        STR      R0,[R7, #+156]
// 7304         conf->psk_identity_len = 0;
        STR      R0,[R7, #+160]
// 7305     }
// 7306 
// 7307     if( ( conf->psk = mbedtls_calloc( 1, psk_len ) ) == NULL ||
// 7308         ( conf->psk_identity = mbedtls_calloc( 1, psk_identity_len ) ) == NULL )
??mbedtls_ssl_conf_psk_4:
        MOV      R1,R8
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R7, #+148]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_conf_psk_5
        MOV      R1,R6
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R7, #+156]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_conf_psk_6
// 7309     {
// 7310         mbedtls_free( conf->psk );
??mbedtls_ssl_conf_psk_5:
        LDR      R0,[R7, #+148]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 7311         mbedtls_free( conf->psk_identity );
        LDR      R0,[R7, #+156]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 7312         conf->psk = NULL;
        MOVS     R0,#+0
        STR      R0,[R7, #+148]
// 7313         conf->psk_identity = NULL;
        STR      R0,[R7, #+156]
// 7314         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        LDR.W    R0,??DataTable71  ;; 0xffff8100
        B.N      ??mbedtls_ssl_conf_psk_2
// 7315     }
// 7316 
// 7317     conf->psk_len = psk_len;
??mbedtls_ssl_conf_psk_6:
        STR      R8,[R7, #+152]
// 7318     conf->psk_identity_len = psk_identity_len;
        STR      R6,[R7, #+160]
// 7319 
// 7320     memcpy( conf->psk, psk, conf->psk_len );
        LDR      R2,[R7, #+152]
        MOV      R1,R4
        LDR      R0,[R7, #+148]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 7321     memcpy( conf->psk_identity, psk_identity, conf->psk_identity_len );
        LDR      R2,[R7, #+160]
        MOV      R1,R5
        LDR      R0,[R7, #+156]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 7322 
// 7323     return( 0 );
        MOVS     R0,#+0
??mbedtls_ssl_conf_psk_2:
        POP      {R4-R8,PC}       ;; return
// 7324 }
          CFI EndBlock cfiBlock129

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59:
        DATA32
        DC32     ?_235

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59_1:
        DATA32
        DC32     ?_238
// 7325 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock130 Using cfiCommon0
          CFI Function mbedtls_ssl_set_hs_psk
        THUMB
// 7326 int mbedtls_ssl_set_hs_psk( mbedtls_ssl_context *ssl,
// 7327                             const unsigned char *psk, size_t psk_len )
// 7328 {
mbedtls_ssl_set_hs_psk:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
        MOV      R4,R1
        MOV      R6,R2
// 7329     if( psk == NULL || ssl->handshake == NULL )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_set_hs_psk_0
        LDR      R0,[R5, #+60]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_set_hs_psk_0
// 7330         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 7331 
// 7332     if( psk_len > MBEDTLS_PSK_MAX_LEN )
        CMP      R6,#+33
        BCC.N    ??mbedtls_ssl_set_hs_psk_1
// 7333         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_set_hs_psk_0:
        LDR.W    R0,??DataTable74  ;; 0xffff8f00
        POP      {R4-R6,PC}
// 7334 
// 7335     if( ssl->handshake->psk != NULL )
??mbedtls_ssl_set_hs_psk_1:
        LDR      R0,[R0, #+440]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_set_hs_psk_2
// 7336     {
// 7337         mbedtls_platform_zeroize( ssl->handshake->psk,
// 7338                                   ssl->handshake->psk_len );
        LDR      R0,[R5, #+60]
        LDR      R1,[R0, #+444]
        LDR      R0,[R0, #+440]
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 7339         mbedtls_free( ssl->handshake->psk );
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+440]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 7340         ssl->handshake->psk_len = 0;
        MOVS     R0,#+0
        LDR      R1,[R5, #+60]
        STR      R0,[R1, #+444]
// 7341     }
// 7342 
// 7343     if( ( ssl->handshake->psk = mbedtls_calloc( 1, psk_len ) ) == NULL )
??mbedtls_ssl_set_hs_psk_2:
        MOV      R1,R6
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        LDR      R1,[R5, #+60]
        STR      R0,[R1, #+440]
        LDR      R0,[R5, #+60]
        LDR      R0,[R0, #+440]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_set_hs_psk_3
// 7344         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        LDR.W    R0,??DataTable71  ;; 0xffff8100
        POP      {R4-R6,PC}
// 7345 
// 7346     ssl->handshake->psk_len = psk_len;
??mbedtls_ssl_set_hs_psk_3:
        LDR      R0,[R5, #+60]
        STR      R6,[R0, #+444]
// 7347     memcpy( ssl->handshake->psk, psk, ssl->handshake->psk_len );
        LDR      R0,[R5, #+60]
        LDR      R2,[R0, #+444]
        MOV      R1,R4
        LDR      R0,[R0, #+440]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 7348 
// 7349     return( 0 );
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
// 7350 }
          CFI EndBlock cfiBlock130

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60:
        DATA32
        DC32     ?_239

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_1:
        DATA32
        DC32     ?_240

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_2:
        DATA32
        DC32     ?_242
// 7351 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock131 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_psk_cb
          CFI NoCalls
        THUMB
// 7352 void mbedtls_ssl_conf_psk_cb( mbedtls_ssl_config *conf,
// 7353                      int (*f_psk)(void *, mbedtls_ssl_context *, const unsigned char *,
// 7354                      size_t),
// 7355                      void *p_psk )
// 7356 {
// 7357     conf->f_psk = f_psk;
mbedtls_ssl_conf_psk_cb:
        STR      R1,[R0, #+60]
// 7358     conf->p_psk = p_psk;
        STR      R2,[R0, #+64]
// 7359 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock131
// 7360 #endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */
// 7361 
// 7362 #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)
// 7363 
// 7364 #if !defined(MBEDTLS_DEPRECATED_REMOVED)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock132 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_dh_param
        THUMB
// 7365 int mbedtls_ssl_conf_dh_param( mbedtls_ssl_config *conf, const char *dhm_P, const char *dhm_G )
// 7366 {
mbedtls_ssl_conf_dh_param:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
        MOV      R6,R2
// 7367     int ret;
// 7368 
// 7369     if( ( ret = mbedtls_mpi_read_string( &conf->dhm_P, 16, dhm_P ) ) != 0 ||
// 7370         ( ret = mbedtls_mpi_read_string( &conf->dhm_G, 16, dhm_G ) ) != 0 )
        MOV      R2,R1
        MOVS     R1,#+16
        ADD      R0,R5,#+124
          CFI FunCall mbedtls_mpi_read_string
        BL       mbedtls_mpi_read_string
        MOVS     R4,R0
        BNE.N    ??mbedtls_ssl_conf_dh_param_0
        MOV      R2,R6
        MOVS     R1,#+16
        ADD      R0,R5,#+136
          CFI FunCall mbedtls_mpi_read_string
        BL       mbedtls_mpi_read_string
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_conf_dh_param_1
// 7371     {
// 7372         mbedtls_mpi_free( &conf->dhm_P );
??mbedtls_ssl_conf_dh_param_0:
        ADD      R0,R5,#+124
          CFI FunCall mbedtls_mpi_free
        BL       mbedtls_mpi_free
// 7373         mbedtls_mpi_free( &conf->dhm_G );
        ADD      R0,R5,#+136
          CFI FunCall mbedtls_mpi_free
        BL       mbedtls_mpi_free
// 7374         return( ret );
        MOV      R0,R4
        POP      {R4-R6,PC}
// 7375     }
// 7376 
// 7377     return( 0 );
??mbedtls_ssl_conf_dh_param_1:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
// 7378 }
          CFI EndBlock cfiBlock132
// 7379 #endif /* MBEDTLS_DEPRECATED_REMOVED */
// 7380 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock133 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_dh_param_bin
        THUMB
// 7381 int mbedtls_ssl_conf_dh_param_bin( mbedtls_ssl_config *conf,
// 7382                                    const unsigned char *dhm_P, size_t P_len,
// 7383                                    const unsigned char *dhm_G, size_t G_len )
// 7384 {
mbedtls_ssl_conf_dh_param_bin:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
        MOV      R6,R3
// 7385     int ret;
// 7386 
// 7387     if( ( ret = mbedtls_mpi_read_binary( &conf->dhm_P, dhm_P, P_len ) ) != 0 ||
// 7388         ( ret = mbedtls_mpi_read_binary( &conf->dhm_G, dhm_G, G_len ) ) != 0 )
        ADD      R0,R5,#+124
          CFI FunCall mbedtls_mpi_read_binary
        BL       mbedtls_mpi_read_binary
        MOVS     R4,R0
        BNE.N    ??mbedtls_ssl_conf_dh_param_bin_0
        LDR      R2,[SP, #+16]
        MOV      R1,R6
        ADD      R0,R5,#+136
          CFI FunCall mbedtls_mpi_read_binary
        BL       mbedtls_mpi_read_binary
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_conf_dh_param_bin_1
// 7389     {
// 7390         mbedtls_mpi_free( &conf->dhm_P );
??mbedtls_ssl_conf_dh_param_bin_0:
        ADD      R0,R5,#+124
          CFI FunCall mbedtls_mpi_free
        BL       mbedtls_mpi_free
// 7391         mbedtls_mpi_free( &conf->dhm_G );
        ADD      R0,R5,#+136
          CFI FunCall mbedtls_mpi_free
        BL       mbedtls_mpi_free
// 7392         return( ret );
        MOV      R0,R4
        POP      {R4-R6,PC}
// 7393     }
// 7394 
// 7395     return( 0 );
??mbedtls_ssl_conf_dh_param_bin_1:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
// 7396 }
          CFI EndBlock cfiBlock133
// 7397 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock134 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_dh_param_ctx
        THUMB
// 7398 int mbedtls_ssl_conf_dh_param_ctx( mbedtls_ssl_config *conf, mbedtls_dhm_context *dhm_ctx )
// 7399 {
mbedtls_ssl_conf_dh_param_ctx:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
        MOV      R6,R1
// 7400     int ret;
// 7401 
// 7402     if( ( ret = mbedtls_mpi_copy( &conf->dhm_P, &dhm_ctx->P ) ) != 0 ||
// 7403         ( ret = mbedtls_mpi_copy( &conf->dhm_G, &dhm_ctx->G ) ) != 0 )
        ADDS     R1,R6,#+4
        ADD      R0,R5,#+124
          CFI FunCall mbedtls_mpi_copy
        BL       mbedtls_mpi_copy
        MOVS     R4,R0
        BNE.N    ??mbedtls_ssl_conf_dh_param_ctx_0
        ADD      R1,R6,#+16
        ADD      R0,R5,#+136
          CFI FunCall mbedtls_mpi_copy
        BL       mbedtls_mpi_copy
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_conf_dh_param_ctx_1
// 7404     {
// 7405         mbedtls_mpi_free( &conf->dhm_P );
??mbedtls_ssl_conf_dh_param_ctx_0:
        ADD      R0,R5,#+124
          CFI FunCall mbedtls_mpi_free
        BL       mbedtls_mpi_free
// 7406         mbedtls_mpi_free( &conf->dhm_G );
        ADD      R0,R5,#+136
          CFI FunCall mbedtls_mpi_free
        BL       mbedtls_mpi_free
// 7407         return( ret );
        MOV      R0,R4
        POP      {R4-R6,PC}
// 7408     }
// 7409 
// 7410     return( 0 );
??mbedtls_ssl_conf_dh_param_ctx_1:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
// 7411 }
          CFI EndBlock cfiBlock134
// 7412 #endif /* MBEDTLS_DHM_C && MBEDTLS_SSL_SRV_C */
// 7413 
// 7414 #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)
// 7415 /*
// 7416  * Set the minimum length for Diffie-Hellman parameters
// 7417  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock135 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_dhm_min_bitlen
          CFI NoCalls
        THUMB
// 7418 void mbedtls_ssl_conf_dhm_min_bitlen( mbedtls_ssl_config *conf,
// 7419                                       unsigned int bitlen )
// 7420 {
// 7421     conf->dhm_min_bitlen = bitlen;
mbedtls_ssl_conf_dhm_min_bitlen:
        STR      R1,[R0, #+196]
// 7422 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock135
// 7423 #endif /* MBEDTLS_DHM_C && MBEDTLS_SSL_CLI_C */
// 7424 
// 7425 #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
// 7426 /*
// 7427  * Set allowed/preferred hashes for handshake signatures
// 7428  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock136 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_sig_hashes
          CFI NoCalls
        THUMB
// 7429 void mbedtls_ssl_conf_sig_hashes( mbedtls_ssl_config *conf,
// 7430                                   const int *hashes )
// 7431 {
// 7432     conf->sig_hashes = hashes;
mbedtls_ssl_conf_sig_hashes:
        STR      R1,[R0, #+116]
// 7433 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock136
// 7434 #endif /* MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
// 7435 
// 7436 #if defined(MBEDTLS_ECP_C)
// 7437 /*
// 7438  * Set the allowed elliptic curves
// 7439  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock137 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_curves
          CFI NoCalls
        THUMB
// 7440 void mbedtls_ssl_conf_curves( mbedtls_ssl_config *conf,
// 7441                              const mbedtls_ecp_group_id *curve_list )
// 7442 {
// 7443     conf->curve_list = curve_list;
mbedtls_ssl_conf_curves:
        STR      R1,[R0, #+120]
// 7444 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock137
// 7445 #endif /* MBEDTLS_ECP_C */
// 7446 
// 7447 #if defined(MBEDTLS_X509_CRT_PARSE_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock138 Using cfiCommon0
          CFI Function mbedtls_ssl_set_hostname
        THUMB
// 7448 int mbedtls_ssl_set_hostname( mbedtls_ssl_context *ssl, const char *hostname )
// 7449 {
mbedtls_ssl_set_hostname:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
        MOV      R4,R1
// 7450     /* Initialize to suppress unnecessary compiler warning */
// 7451     size_t hostname_len = 0;
        MOVS     R6,#+0
// 7452 
// 7453     /* Check if new hostname is valid before
// 7454      * making any change to current one */
// 7455     if( hostname != NULL )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_set_hostname_0
// 7456     {
// 7457         hostname_len = strlen( hostname );
        MOV      R0,R4
          CFI FunCall strlen
        BL       strlen
        MOV      R6,R0
// 7458 
// 7459         if( hostname_len > MBEDTLS_SSL_MAX_HOST_NAME_LEN )
        CMP      R6,#+256
        BCC.N    ??mbedtls_ssl_set_hostname_0
// 7460             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable74  ;; 0xffff8f00
        POP      {R4-R6,PC}
// 7461     }
// 7462 
// 7463     /* Now it's clear that we will overwrite the old hostname,
// 7464      * so we can free it safely */
// 7465 
// 7466     if( ssl->hostname != NULL )
??mbedtls_ssl_set_hostname_0:
        LDR      R0,[R5, #+228]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_set_hostname_1
// 7467     {
// 7468         mbedtls_platform_zeroize( ssl->hostname, strlen( ssl->hostname ) );
          CFI FunCall strlen
        BL       strlen
        MOV      R1,R0
        LDR      R0,[R5, #+228]
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 7469         mbedtls_free( ssl->hostname );
        LDR      R0,[R5, #+228]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 7470     }
// 7471 
// 7472     /* Passing NULL as hostname shall clear the old one */
// 7473 
// 7474     if( hostname == NULL )
??mbedtls_ssl_set_hostname_1:
        CMP      R4,#+0
        BNE.N    ??mbedtls_ssl_set_hostname_2
// 7475     {
// 7476         ssl->hostname = NULL;
        MOVS     R0,#+0
        STR      R0,[R5, #+228]
        POP      {R4-R6,PC}
// 7477     }
// 7478     else
// 7479     {
// 7480         ssl->hostname = mbedtls_calloc( 1, hostname_len + 1 );
??mbedtls_ssl_set_hostname_2:
        ADDS     R1,R6,#+1
        MOVS     R0,#+1
          CFI FunCall mbedtls_calloc
        BL       mbedtls_calloc
        STR      R0,[R5, #+228]
// 7481         if( ssl->hostname == NULL )
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_set_hostname_3
// 7482             return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        LDR.W    R0,??DataTable71  ;; 0xffff8100
        POP      {R4-R6,PC}
// 7483 
// 7484         memcpy( ssl->hostname, hostname, hostname_len );
??mbedtls_ssl_set_hostname_3:
        MOV      R2,R6
        MOV      R1,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 7485 
// 7486         ssl->hostname[hostname_len] = '\0';
        MOVS     R0,#+0
        LDR      R1,[R5, #+228]
        STRB     R0,[R1, R6]
// 7487     }
// 7488 
// 7489     return( 0 );
        POP      {R4-R6,PC}       ;; return
// 7490 }
          CFI EndBlock cfiBlock138

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable61:
        DATA32
        DC32     ?_241
// 7491 #endif /* MBEDTLS_X509_CRT_PARSE_C */
// 7492 
// 7493 #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock139 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_sni
          CFI NoCalls
        THUMB
// 7494 void mbedtls_ssl_conf_sni( mbedtls_ssl_config *conf,
// 7495                   int (*f_sni)(void *, mbedtls_ssl_context *,
// 7496                                 const unsigned char *, size_t),
// 7497                   void *p_sni )
// 7498 {
// 7499     conf->f_sni = f_sni;
mbedtls_ssl_conf_sni:
        STR      R1,[R0, #+44]
// 7500     conf->p_sni = p_sni;
        STR      R2,[R0, #+48]
// 7501 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock139
// 7502 #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
// 7503 
// 7504 #if defined(MBEDTLS_SSL_ALPN)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock140 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_alpn_protocols
        THUMB
// 7505 int mbedtls_ssl_conf_alpn_protocols( mbedtls_ssl_config *conf, const char **protos )
// 7506 {
mbedtls_ssl_conf_alpn_protocols:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R5,R1
// 7507     size_t cur_len, tot_len;
// 7508     const char **p;
// 7509 
// 7510     /*
// 7511      * RFC 7301 3.1: "Empty strings MUST NOT be included and byte strings
// 7512      * MUST NOT be truncated."
// 7513      * We check lengths now rather than later.
// 7514      */
// 7515     tot_len = 0;
        MOVS     R6,#+0
// 7516     for( p = protos; *p != NULL; p++ )
        MOV      R7,R5
??mbedtls_ssl_conf_alpn_protocols_0:
        LDR      R0,[R7, #+0]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_conf_alpn_protocols_1
// 7517     {
// 7518         cur_len = strlen( *p );
          CFI FunCall strlen
        BL       strlen
// 7519         tot_len += cur_len;
        ADDS     R6,R0,R6
// 7520 
// 7521         if( cur_len == 0 || cur_len > 255 || tot_len > 65535 )
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_conf_alpn_protocols_2
        CMP      R0,#+256
        BCS.N    ??mbedtls_ssl_conf_alpn_protocols_2
        CMP      R6,#+65536
        BCS.N    ??mbedtls_ssl_conf_alpn_protocols_2
        ADDS     R7,R7,#+4
        B.N      ??mbedtls_ssl_conf_alpn_protocols_0
// 7522             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 7523     }
// 7524 
// 7525     conf->alpn_list = protos;
??mbedtls_ssl_conf_alpn_protocols_1:
        STR      R5,[R4, #+164]
// 7526 
// 7527     return( 0 );
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
??mbedtls_ssl_conf_alpn_protocols_2:
        LDR.W    R0,??DataTable74  ;; 0xffff8f00
        POP      {R1,R4-R7,PC}
// 7528 }
          CFI EndBlock cfiBlock140

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62:
        DATA32
        DC32     ?_243

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable62_1:
        DATA32
        DC32     ?_244
// 7529 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock141 Using cfiCommon0
          CFI Function mbedtls_ssl_get_alpn_protocol
          CFI NoCalls
        THUMB
// 7530 const char *mbedtls_ssl_get_alpn_protocol( const mbedtls_ssl_context *ssl )
// 7531 {
// 7532     return( ssl->alpn_chosen );
mbedtls_ssl_get_alpn_protocol:
        LDR      R0,[R0, #+232]
        BX       LR               ;; return
// 7533 }
          CFI EndBlock cfiBlock141
// 7534 #endif /* MBEDTLS_SSL_ALPN */
// 7535 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock142 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_max_version
          CFI NoCalls
        THUMB
// 7536 void mbedtls_ssl_conf_max_version( mbedtls_ssl_config *conf, int major, int minor )
// 7537 {
// 7538     conf->max_major_ver = major;
mbedtls_ssl_conf_max_version:
        STRB     R1,[R0, #+200]
// 7539     conf->max_minor_ver = minor;
        STRB     R2,[R0, #+201]
// 7540 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock142
// 7541 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock143 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_min_version
          CFI NoCalls
        THUMB
// 7542 void mbedtls_ssl_conf_min_version( mbedtls_ssl_config *conf, int major, int minor )
// 7543 {
// 7544     conf->min_major_ver = major;
mbedtls_ssl_conf_min_version:
        STRB     R1,[R0, #+202]
// 7545     conf->min_minor_ver = minor;
        STRB     R2,[R0, #+203]
// 7546 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock143
// 7547 
// 7548 #if defined(MBEDTLS_SSL_FALLBACK_SCSV) && defined(MBEDTLS_SSL_CLI_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock144 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_fallback
          CFI NoCalls
        THUMB
// 7549 void mbedtls_ssl_conf_fallback( mbedtls_ssl_config *conf, char fallback )
// 7550 {
// 7551     conf->fallback = fallback;
mbedtls_ssl_conf_fallback:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+16,#+1
        STR      R2,[R0, #+204]
// 7552 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock144
// 7553 #endif
// 7554 
// 7555 #if defined(MBEDTLS_SSL_SRV_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock145 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_cert_req_ca_list
          CFI NoCalls
        THUMB
// 7556 void mbedtls_ssl_conf_cert_req_ca_list( mbedtls_ssl_config *conf,
// 7557                                           char cert_req_ca_list )
// 7558 {
// 7559     conf->cert_req_ca_list = cert_req_ca_list;
mbedtls_ssl_conf_cert_req_ca_list:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+17,#+1
        STR      R2,[R0, #+204]
// 7560 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock145
// 7561 #endif
// 7562 
// 7563 #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock146 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_encrypt_then_mac
          CFI NoCalls
        THUMB
// 7564 void mbedtls_ssl_conf_encrypt_then_mac( mbedtls_ssl_config *conf, char etm )
// 7565 {
// 7566     conf->encrypt_then_mac = etm;
mbedtls_ssl_conf_encrypt_then_mac:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+9,#+1
        STR      R2,[R0, #+204]
// 7567 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock146
// 7568 #endif
// 7569 
// 7570 #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock147 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_extended_master_secret
          CFI NoCalls
        THUMB
// 7571 void mbedtls_ssl_conf_extended_master_secret( mbedtls_ssl_config *conf, char ems )
// 7572 {
// 7573     conf->extended_ms = ems;
mbedtls_ssl_conf_extended_master_secret:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+10,#+1
        STR      R2,[R0, #+204]
// 7574 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock147
// 7575 #endif
// 7576 
// 7577 #if defined(MBEDTLS_ARC4_C)
// 7578 void mbedtls_ssl_conf_arc4_support( mbedtls_ssl_config *conf, char arc4 )
// 7579 {
// 7580     conf->arc4_disabled = arc4;
// 7581 }
// 7582 #endif
// 7583 
// 7584 #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock148 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_max_frag_len
        THUMB
// 7585 int mbedtls_ssl_conf_max_frag_len( mbedtls_ssl_config *conf, unsigned char mfl_code )
// 7586 {
mbedtls_ssl_conf_max_frag_len:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 7587     if( mfl_code >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID ||
// 7588         ssl_mfl_code_to_length( mfl_code ) > MBEDTLS_TLS_EXT_ADV_CONTENT_LEN )
        MOV      R0,R5
        CMP      R0,#+5
        BGE.N    ??mbedtls_ssl_conf_max_frag_len_0
          CFI FunCall ssl_mfl_code_to_length
        BL       ssl_mfl_code_to_length
        MOVW     R1,#+10241
        CMP      R0,R1
        BCC.N    ??mbedtls_ssl_conf_max_frag_len_1
// 7589     {
// 7590         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_conf_max_frag_len_0:
        LDR.W    R0,??DataTable74  ;; 0xffff8f00
        POP      {R1,R4,R5,PC}
// 7591     }
// 7592 
// 7593     conf->mfl_code = mfl_code;
??mbedtls_ssl_conf_max_frag_len_1:
        LDR      R0,[R4, #+204]
        BFI      R0,R5,#+6,#+3
        STR      R0,[R4, #+204]
// 7594 
// 7595     return( 0 );
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
// 7596 }
          CFI EndBlock cfiBlock148

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable63:
        DATA32
        DC32     ?_245

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable63_1:
        DATA32
        DC32     ?_246

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable63_2:
        DATA32
        DC32     ?_247
// 7597 #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
// 7598 
// 7599 #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock149 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_truncated_hmac
          CFI NoCalls
        THUMB
// 7600 void mbedtls_ssl_conf_truncated_hmac( mbedtls_ssl_config *conf, int truncate )
// 7601 {
// 7602     conf->trunc_hmac = truncate;
mbedtls_ssl_conf_truncated_hmac:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+14,#+1
        STR      R2,[R0, #+204]
// 7603 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock149
// 7604 #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
// 7605 
// 7606 #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock150 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_cbc_record_splitting
          CFI NoCalls
        THUMB
// 7607 void mbedtls_ssl_conf_cbc_record_splitting( mbedtls_ssl_config *conf, char split )
// 7608 {
// 7609     conf->cbc_record_splitting = split;
mbedtls_ssl_conf_cbc_record_splitting:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+12,#+1
        STR      R2,[R0, #+204]
// 7610 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock150
// 7611 #endif
// 7612 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock151 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_legacy_renegotiation
          CFI NoCalls
        THUMB
// 7613 void mbedtls_ssl_conf_legacy_renegotiation( mbedtls_ssl_config *conf, int allow_legacy )
// 7614 {
// 7615     conf->allow_legacy_renegotiation = allow_legacy;
mbedtls_ssl_conf_legacy_renegotiation:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+4,#+2
        STR      R2,[R0, #+204]
// 7616 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock151
// 7617 
// 7618 #if defined(MBEDTLS_SSL_RENEGOTIATION)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock152 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_renegotiation
          CFI NoCalls
        THUMB
// 7619 void mbedtls_ssl_conf_renegotiation( mbedtls_ssl_config *conf, int renegotiation )
// 7620 {
// 7621     conf->disable_renegotiation = renegotiation;
mbedtls_ssl_conf_renegotiation:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+13,#+1
        STR      R2,[R0, #+204]
// 7622 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock152
// 7623 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock153 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_renegotiation_enforced
          CFI NoCalls
        THUMB
// 7624 void mbedtls_ssl_conf_renegotiation_enforced( mbedtls_ssl_config *conf, int max_records )
// 7625 {
// 7626     conf->renego_max_records = max_records;
mbedtls_ssl_conf_renegotiation_enforced:
        STR      R1,[R0, #+180]
// 7627 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock153
// 7628 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock154 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_renegotiation_period
        THUMB
// 7629 void mbedtls_ssl_conf_renegotiation_period( mbedtls_ssl_config *conf,
// 7630                                    const unsigned char period[8] )
// 7631 {
// 7632     memcpy( conf->renego_period, period, 8 );
mbedtls_ssl_conf_renegotiation_period:
        MOVS     R2,#+8
        ADDS     R0,R0,#+184
          CFI FunCall __aeabi_memcpy
        B.W      __aeabi_memcpy
// 7633 }
          CFI EndBlock cfiBlock154
// 7634 #endif /* MBEDTLS_SSL_RENEGOTIATION */
// 7635 
// 7636 #if defined(MBEDTLS_SSL_SESSION_TICKETS)
// 7637 #if defined(MBEDTLS_SSL_CLI_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock155 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_session_tickets
          CFI NoCalls
        THUMB
// 7638 void mbedtls_ssl_conf_session_tickets( mbedtls_ssl_config *conf, int use_tickets )
// 7639 {
// 7640     conf->session_tickets = use_tickets;
mbedtls_ssl_conf_session_tickets:
        LDR      R2,[R0, #+204]
        BFI      R2,R1,#+15,#+1
        STR      R2,[R0, #+204]
// 7641 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock155
// 7642 #endif
// 7643 
// 7644 #if defined(MBEDTLS_SSL_SRV_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock156 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_session_tickets_cb
          CFI NoCalls
        THUMB
// 7645 void mbedtls_ssl_conf_session_tickets_cb( mbedtls_ssl_config *conf,
// 7646         mbedtls_ssl_ticket_write_t *f_ticket_write,
// 7647         mbedtls_ssl_ticket_parse_t *f_ticket_parse,
// 7648         void *p_ticket )
// 7649 {
// 7650     conf->f_ticket_write = f_ticket_write;
mbedtls_ssl_conf_session_tickets_cb:
        STR      R1,[R0, #+80]
// 7651     conf->f_ticket_parse = f_ticket_parse;
        STR      R2,[R0, #+84]
// 7652     conf->p_ticket       = p_ticket;
        STR      R3,[R0, #+88]
// 7653 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock156
// 7654 #endif
// 7655 #endif /* MBEDTLS_SSL_SESSION_TICKETS */
// 7656 
// 7657 #if defined(MBEDTLS_SSL_EXPORT_KEYS)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock157 Using cfiCommon0
          CFI Function mbedtls_ssl_conf_export_keys_cb
          CFI NoCalls
        THUMB
// 7658 void mbedtls_ssl_conf_export_keys_cb( mbedtls_ssl_config *conf,
// 7659         mbedtls_ssl_export_keys_t *f_export_keys,
// 7660         void *p_export_keys )
// 7661 {
// 7662     conf->f_export_keys = f_export_keys;
mbedtls_ssl_conf_export_keys_cb:
        STR      R1,[R0, #+92]
// 7663     conf->p_export_keys = p_export_keys;
        STR      R2,[R0, #+96]
// 7664 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock157
// 7665 #endif
// 7666 
// 7667 #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
// 7668 void mbedtls_ssl_conf_async_private_cb(
// 7669     mbedtls_ssl_config *conf,
// 7670     mbedtls_ssl_async_sign_t *f_async_sign,
// 7671     mbedtls_ssl_async_decrypt_t *f_async_decrypt,
// 7672     mbedtls_ssl_async_resume_t *f_async_resume,
// 7673     mbedtls_ssl_async_cancel_t *f_async_cancel,
// 7674     void *async_config_data )
// 7675 {
// 7676     conf->f_async_sign_start = f_async_sign;
// 7677     conf->f_async_decrypt_start = f_async_decrypt;
// 7678     conf->f_async_resume = f_async_resume;
// 7679     conf->f_async_cancel = f_async_cancel;
// 7680     conf->p_async_config_data = async_config_data;
// 7681 }
// 7682 
// 7683 void *mbedtls_ssl_conf_get_async_config_data( const mbedtls_ssl_config *conf )
// 7684 {
// 7685     return( conf->p_async_config_data );
// 7686 }
// 7687 
// 7688 void *mbedtls_ssl_get_async_operation_data( const mbedtls_ssl_context *ssl )
// 7689 {
// 7690     if( ssl->handshake == NULL )
// 7691         return( NULL );
// 7692     else
// 7693         return( ssl->handshake->user_async_ctx );
// 7694 }
// 7695 
// 7696 void mbedtls_ssl_set_async_operation_data( mbedtls_ssl_context *ssl,
// 7697                                  void *ctx )
// 7698 {
// 7699     if( ssl->handshake != NULL )
// 7700         ssl->handshake->user_async_ctx = ctx;
// 7701 }
// 7702 #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
// 7703 
// 7704 /*
// 7705  * SSL get accessors
// 7706  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock158 Using cfiCommon0
          CFI Function mbedtls_ssl_get_bytes_avail
          CFI NoCalls
        THUMB
// 7707 size_t mbedtls_ssl_get_bytes_avail( const mbedtls_ssl_context *ssl )
// 7708 {
// 7709     return( ssl->in_offt == NULL ? 0 : ssl->in_msglen );
mbedtls_ssl_get_bytes_avail:
        LDR      R1,[R0, #+116]
        CMP      R1,#+0
        BNE.N    ??mbedtls_ssl_get_bytes_avail_0
        MOVS     R0,#+0
        BX       LR
??mbedtls_ssl_get_bytes_avail_0:
        LDR      R0,[R0, #+124]
        BX       LR               ;; return
// 7710 }
          CFI EndBlock cfiBlock158
// 7711 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock159 Using cfiCommon0
          CFI Function mbedtls_ssl_check_pending
        THUMB
// 7712 int mbedtls_ssl_check_pending( const mbedtls_ssl_context *ssl )
// 7713 {
mbedtls_ssl_check_pending:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 7714     /*
// 7715      * Case A: We're currently holding back
// 7716      * a message for further processing.
// 7717      */
// 7718 
// 7719     if( ssl->keep_current_message == 1 )
        LDR      R1,[R0, #+168]
        CMP      R1,#+1
        BNE.N    ??mbedtls_ssl_check_pending_0
// 7720     {
// 7721         MBEDTLS_SSL_DEBUG_MSG( 3, ( "ssl_check_pending: record held back for processing" ) );
        LDR.W    R1,??DataTable77
        STR      R1,[SP, #+0]
        MOVW     R3,#+7721
        LDR.W    R2,??DataTable72_1
        MOVS     R1,#+3
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 7722         return( 1 );
        MOVS     R0,#+1
        POP      {R1,PC}
// 7723     }
// 7724 
// 7725     /*
// 7726      * Case B: Further records are pending in the current datagram.
// 7727      */
// 7728 
// 7729 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 7730     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 7731         ssl->in_left > ssl->next_record_offset )
??mbedtls_ssl_check_pending_0:
        LDR      R1,[R0, #+0]
        LDR      R1,[R1, #+204]
        UBFX     R1,R1,#+1,#+1
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_check_pending_1
        LDR      R1,[R0, #+136]
        LDR      R2,[R0, #+128]
        CMP      R1,R2
        BCS.N    ??mbedtls_ssl_check_pending_1
// 7732     {
// 7733         MBEDTLS_SSL_DEBUG_MSG( 3, ( "ssl_check_pending: more records within current datagram" ) );
        LDR.W    R1,??DataTable77_1
        STR      R1,[SP, #+0]
        MOVW     R3,#+7733
        LDR.W    R2,??DataTable72_1
        MOVS     R1,#+3
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 7734         return( 1 );
        MOVS     R0,#+1
        POP      {R1,PC}
// 7735     }
// 7736 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 7737 
// 7738     /*
// 7739      * Case C: A handshake message is being processed.
// 7740      */
// 7741 
// 7742     if( ssl->in_hslen > 0 && ssl->in_hslen < ssl->in_msglen )
??mbedtls_ssl_check_pending_1:
        LDR      R1,[R0, #+160]
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_check_pending_2
        LDR      R2,[R0, #+124]
        CMP      R1,R2
        BCS.N    ??mbedtls_ssl_check_pending_2
// 7743     {
// 7744         MBEDTLS_SSL_DEBUG_MSG( 3, ( "ssl_check_pending: more handshake messages within current record" ) );
        LDR.W    R1,??DataTable77_2
        STR      R1,[SP, #+0]
        MOV      R3,#+7744
        LDR.W    R2,??DataTable72_1
        MOVS     R1,#+3
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 7745         return( 1 );
        MOVS     R0,#+1
        POP      {R1,PC}
// 7746     }
// 7747 
// 7748     /*
// 7749      * Case D: An application data message is being processed
// 7750      */
// 7751     if( ssl->in_offt != NULL )
??mbedtls_ssl_check_pending_2:
        LDR      R1,[R0, #+116]
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_check_pending_3
// 7752     {
// 7753         MBEDTLS_SSL_DEBUG_MSG( 3, ( "ssl_check_pending: application data record is being processed" ) );
        LDR.W    R1,??DataTable77_3
        STR      R1,[SP, #+0]
        MOVW     R3,#+7753
        LDR.W    R2,??DataTable72_1
        MOVS     R1,#+3
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 7754         return( 1 );
        MOVS     R0,#+1
        POP      {R1,PC}
// 7755     }
// 7756 
// 7757     /*
// 7758      * In all other cases, the rest of the message can be dropped.
// 7759      * As in ssl_get_next_record, this needs to be adapted if
// 7760      * we implement support for multiple alerts in single records.
// 7761      */
// 7762 
// 7763     MBEDTLS_SSL_DEBUG_MSG( 3, ( "ssl_check_pending: nothing pending" ) );
??mbedtls_ssl_check_pending_3:
        LDR.W    R1,??DataTable78
        STR      R1,[SP, #+0]
        MOVW     R3,#+7763
        LDR.W    R2,??DataTable72_1
        MOVS     R1,#+3
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 7764     return( 0 );
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
// 7765 }
          CFI EndBlock cfiBlock159

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable64:
        DATA32
        DC32     ?_248

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable64_1:
        DATA32
        DC32     ?_249

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable64_2:
        DATA32
        DC32     ?_250
// 7766 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock160 Using cfiCommon0
          CFI Function mbedtls_ssl_get_verify_result
          CFI NoCalls
        THUMB
// 7767 uint32_t mbedtls_ssl_get_verify_result( const mbedtls_ssl_context *ssl )
// 7768 {
// 7769     if( ssl->session != NULL )
mbedtls_ssl_get_verify_result:
        LDR      R1,[R0, #+52]
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_get_verify_result_0
// 7770         return( ssl->session->verify_result );
        MOV      R0,R1
        LDR      R0,[R0, #+96]
        BX       LR
// 7771 
// 7772     if( ssl->session_negotiate != NULL )
??mbedtls_ssl_get_verify_result_0:
        LDR      R1,[R0, #+56]
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_get_verify_result_1
// 7773         return( ssl->session_negotiate->verify_result );
        MOV      R0,R1
        LDR      R0,[R0, #+96]
        BX       LR
// 7774 
// 7775     return( 0xFFFFFFFF );
??mbedtls_ssl_get_verify_result_1:
        MOV      R0,#-1
        BX       LR               ;; return
// 7776 }
          CFI EndBlock cfiBlock160
// 7777 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock161 Using cfiCommon0
          CFI Function mbedtls_ssl_get_ciphersuite
        THUMB
// 7778 const char *mbedtls_ssl_get_ciphersuite( const mbedtls_ssl_context *ssl )
// 7779 {
// 7780     if( ssl == NULL || ssl->session == NULL )
mbedtls_ssl_get_ciphersuite:
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_get_ciphersuite_0
        LDR      R1,[R0, #+52]
        CMP      R1,#+0
        BNE.N    ??mbedtls_ssl_get_ciphersuite_1
// 7781         return( NULL );
??mbedtls_ssl_get_ciphersuite_0:
        MOVS     R0,#+0
        BX       LR
// 7782 
// 7783     return mbedtls_ssl_get_ciphersuite_name( ssl->session->ciphersuite );
??mbedtls_ssl_get_ciphersuite_1:
        MOV      R0,R1
        LDR      R0,[R0, #+0]
          CFI FunCall mbedtls_ssl_get_ciphersuite_name
        B.W      mbedtls_ssl_get_ciphersuite_name
// 7784 }
          CFI EndBlock cfiBlock161
// 7785 

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock162 Using cfiCommon0
          CFI Function mbedtls_ssl_get_version
          CFI NoCalls
        THUMB
// 7786 const char *mbedtls_ssl_get_version( const mbedtls_ssl_context *ssl )
// 7787 {
// 7788 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 7789     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
mbedtls_ssl_get_version:
        LDR      R1,[R0, #+0]
        LDR      R1,[R1, #+204]
        UBFX     R1,R1,#+1,#+1
        CMP      R1,#+0
        LDR      R0,[R0, #+20]
        BEQ.N    ??mbedtls_ssl_get_version_1
// 7790     {
// 7791         switch( ssl->minor_ver )
        CMP      R0,#+2
        BEQ.N    ??mbedtls_ssl_get_version_2
        CMP      R0,#+3
        BEQ.N    ??mbedtls_ssl_get_version_3
        B.N      ??mbedtls_ssl_get_version_4
// 7792         {
// 7793             case MBEDTLS_SSL_MINOR_VERSION_2:
// 7794                 return( "DTLSv1.0" );
??mbedtls_ssl_get_version_2:
        LDR.W    R0,??DataTable78_1
        BX       LR
// 7795 
// 7796             case MBEDTLS_SSL_MINOR_VERSION_3:
// 7797                 return( "DTLSv1.2" );
??mbedtls_ssl_get_version_3:
        LDR.W    R0,??DataTable78_2
        BX       LR
// 7798 
// 7799             default:
// 7800                 return( "unknown (DTLS)" );
??mbedtls_ssl_get_version_4:
        LDR.W    R0,??DataTable78_3
        BX       LR
// 7801         }
// 7802     }
// 7803 #endif
// 7804 
// 7805     switch( ssl->minor_ver )
??mbedtls_ssl_get_version_1:
        CMP      R0,#+3
        BHI.N    ??mbedtls_ssl_get_version_5
        TBB      [PC, R0]
        DATA
??mbedtls_ssl_get_version_0:
        DC8      0x2,0x5,0x8,0xB
        THUMB
// 7806     {
// 7807         case MBEDTLS_SSL_MINOR_VERSION_0:
// 7808             return( "SSLv3.0" );
??mbedtls_ssl_get_version_6:
        LDR.W    R0,??DataTable78_4
        BX       LR
// 7809 
// 7810         case MBEDTLS_SSL_MINOR_VERSION_1:
// 7811             return( "TLSv1.0" );
??mbedtls_ssl_get_version_7:
        LDR.W    R0,??DataTable78_5
        BX       LR
// 7812 
// 7813         case MBEDTLS_SSL_MINOR_VERSION_2:
// 7814             return( "TLSv1.1" );
??mbedtls_ssl_get_version_8:
        LDR.W    R0,??DataTable78_6
        BX       LR
// 7815 
// 7816         case MBEDTLS_SSL_MINOR_VERSION_3:
// 7817             return( "TLSv1.2" );
??mbedtls_ssl_get_version_9:
        LDR.W    R0,??DataTable78_7
        BX       LR
// 7818 
// 7819         default:
// 7820             return( "unknown" );
??mbedtls_ssl_get_version_5:
        LDR.W    R0,??DataTable78_8
        BX       LR               ;; return
// 7821     }
// 7822 }
          CFI EndBlock cfiBlock162

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65:
        DATA32
        DC32     ?_207

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_1:
        DATA32
        DC32     ?_251

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_2:
        DATA32
        DC32     0xffff8900
// 7823 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock163 Using cfiCommon0
          CFI Function mbedtls_ssl_get_record_expansion
        THUMB
// 7824 int mbedtls_ssl_get_record_expansion( const mbedtls_ssl_context *ssl )
// 7825 {
mbedtls_ssl_get_record_expansion:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R5,R0
// 7826     size_t transform_expansion = 0;
// 7827     const mbedtls_ssl_transform *transform = ssl->transform_out;
        LDR      R4,[R5, #+68]
// 7828     unsigned block_size;
// 7829 
// 7830     if( transform == NULL )
        CMP      R4,#+0
        BNE.N    ??mbedtls_ssl_get_record_expansion_0
// 7831         return( (int) mbedtls_ssl_hdr_len( ssl ) );
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_ssl_hdr_len
        B.W      mbedtls_ssl_hdr_len
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 7832 
// 7833 #if defined(MBEDTLS_ZLIB_SUPPORT)
// 7834     if( ssl->session_out->compression != MBEDTLS_SSL_COMPRESS_NULL )
// 7835         return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
// 7836 #endif
// 7837 
// 7838     switch( mbedtls_cipher_get_cipher_mode( &transform->cipher_ctx_enc ) )
??mbedtls_ssl_get_record_expansion_0:
        ADD      R0,R4,#+80
          CFI FunCall mbedtls_cipher_get_cipher_mode
        BL       mbedtls_cipher_get_cipher_mode
        SUBS     R0,R0,#+2
        BEQ.N    ??mbedtls_ssl_get_record_expansion_1
        SUBS     R0,R0,#+4
        CMP      R0,#+2
        BLS.N    ??mbedtls_ssl_get_record_expansion_2
        SUBS     R0,R0,#+4
        BNE.N    ??mbedtls_ssl_get_record_expansion_3
// 7839     {
// 7840         case MBEDTLS_MODE_GCM:
// 7841         case MBEDTLS_MODE_CCM:
// 7842         case MBEDTLS_MODE_CHACHAPOLY:
// 7843         case MBEDTLS_MODE_STREAM:
// 7844             transform_expansion = transform->minlen;
??mbedtls_ssl_get_record_expansion_2:
        LDR      R4,[R4, #+8]
// 7845             break;
// 7846 
// 7847         case MBEDTLS_MODE_CBC:
// 7848 
// 7849             block_size = mbedtls_cipher_get_block_size(
// 7850                 &transform->cipher_ctx_enc );
// 7851 
// 7852             /* Expansion due to the addition of the MAC. */
// 7853             transform_expansion += transform->maclen;
// 7854 
// 7855             /* Expansion due to the addition of CBC padding;
// 7856              * Theoretically up to 256 bytes, but we never use
// 7857              * more than the block size of the underlying cipher. */
// 7858             transform_expansion += block_size;
// 7859 
// 7860             /* For TLS 1.1 or higher, an explicit IV is added
// 7861              * after the record header. */
// 7862 #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 7863             if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
// 7864                 transform_expansion += block_size;
// 7865 #endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */
// 7866 
// 7867             break;
// 7868 
// 7869         default:
// 7870             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 7871             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 7872     }
// 7873 
// 7874     return( (int)( mbedtls_ssl_hdr_len( ssl ) + transform_expansion ) );
??mbedtls_ssl_get_record_expansion_4:
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_hdr_len
        BL       mbedtls_ssl_hdr_len
        ADDS     R4,R4,R0
        MOV      R0,R4
        POP      {R1,R4,R5,PC}    ;; return
??mbedtls_ssl_get_record_expansion_1:
        ADD      R0,R4,#+80
          CFI FunCall mbedtls_cipher_get_block_size
        BL       mbedtls_cipher_get_block_size
        LDR      R4,[R4, #+20]
        ADDS     R4,R0,R4
        LDR      R1,[R5, #+20]
        CMP      R1,#+2
        BLT.N    ??mbedtls_ssl_get_record_expansion_4
        ADDS     R4,R0,R4
        B.N      ??mbedtls_ssl_get_record_expansion_4
??mbedtls_ssl_get_record_expansion_3:
        LDR.W    R0,??DataTable78_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+7870
        LDR.N    R2,??DataTable72_1
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable79  ;; 0xffff9400
        POP      {R1,R4,R5,PC}
// 7875 }
          CFI EndBlock cfiBlock163

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable66:
        DATA32
        DC32     0xffff8180
// 7876 
// 7877 #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock164 Using cfiCommon0
          CFI Function mbedtls_ssl_get_max_frag_len
        THUMB
// 7878 size_t mbedtls_ssl_get_max_frag_len( const mbedtls_ssl_context *ssl )
// 7879 {
mbedtls_ssl_get_max_frag_len:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 7880     size_t max_len;
// 7881 
// 7882     /*
// 7883      * Assume mfl_code is correct since it was checked when set
// 7884      */
// 7885     max_len = ssl_mfl_code_to_length( ssl->conf->mfl_code );
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+6,#+3
          CFI FunCall ssl_mfl_code_to_length
        BL       ssl_mfl_code_to_length
        MOV      R5,R0
// 7886 
// 7887     /* Check if a smaller max length was negotiated */
// 7888     if( ssl->session_out != NULL &&
// 7889         ssl_mfl_code_to_length( ssl->session_out->mfl_code ) < max_len )
        LDR      R0,[R4, #+48]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_get_max_frag_len_0
        LDRB     R0,[R0, #+112]
          CFI FunCall ssl_mfl_code_to_length
        BL       ssl_mfl_code_to_length
        CMP      R0,R5
        BCS.N    ??mbedtls_ssl_get_max_frag_len_0
// 7890     {
// 7891         max_len = ssl_mfl_code_to_length( ssl->session_out->mfl_code );
        LDR      R0,[R4, #+48]
        LDRB     R0,[R0, #+112]
          CFI FunCall ssl_mfl_code_to_length
        BL       ssl_mfl_code_to_length
        MOV      R5,R0
// 7892     }
// 7893 
// 7894     /* During a handshake, use the value being negotiated */
// 7895     if( ssl->session_negotiate != NULL &&
// 7896         ssl_mfl_code_to_length( ssl->session_negotiate->mfl_code ) < max_len )
??mbedtls_ssl_get_max_frag_len_0:
        LDR      R0,[R4, #+56]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_get_max_frag_len_1
        LDRB     R0,[R0, #+112]
          CFI FunCall ssl_mfl_code_to_length
        BL       ssl_mfl_code_to_length
        CMP      R0,R5
        BCS.N    ??mbedtls_ssl_get_max_frag_len_1
// 7897     {
// 7898         max_len = ssl_mfl_code_to_length( ssl->session_negotiate->mfl_code );
        LDR      R0,[R4, #+56]
        LDRB     R0,[R0, #+112]
          CFI FunCall ssl_mfl_code_to_length
        BL       ssl_mfl_code_to_length
        MOV      R5,R0
// 7899     }
// 7900 
// 7901     return( max_len );
??mbedtls_ssl_get_max_frag_len_1:
        MOV      R0,R5
        POP      {R1,R4,R5,PC}    ;; return
// 7902 }
          CFI EndBlock cfiBlock164
// 7903 #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
// 7904 
// 7905 #if defined(MBEDTLS_SSL_PROTO_DTLS)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock165 Using cfiCommon0
          CFI Function ssl_get_current_mtu
          CFI NoCalls
        THUMB
// 7906 static size_t ssl_get_current_mtu( const mbedtls_ssl_context *ssl )
// 7907 {
// 7908     if( ssl->handshake == NULL || ssl->handshake->mtu == 0 )
ssl_get_current_mtu:
        LDR      R1,[R0, #+60]
        CMP      R1,#+0
        BEQ.N    ??ssl_get_current_mtu_0
        LDRH     R1,[R1, #+588]
        CMP      R1,#+0
        BNE.N    ??ssl_get_current_mtu_1
// 7909         return( ssl->mtu );
??ssl_get_current_mtu_0:
        LDRH     R0,[R0, #+220]
        BX       LR
// 7910 
// 7911     if( ssl->mtu == 0 )
??ssl_get_current_mtu_1:
        LDRH     R1,[R0, #+220]
        CMP      R1,#+0
        BNE.N    ??ssl_get_current_mtu_2
// 7912         return( ssl->handshake->mtu );
        LDR      R0,[R0, #+60]
        LDRH     R0,[R0, #+588]
        BX       LR
// 7913 
// 7914     return( ssl->mtu < ssl->handshake->mtu ?
// 7915             ssl->mtu : ssl->handshake->mtu );
??ssl_get_current_mtu_2:
        LDR      R2,[R0, #+60]
        LDRH     R2,[R2, #+588]
        CMP      R1,R2
        BCS.N    ??ssl_get_current_mtu_3
        MOV      R0,R1
        BX       LR
??ssl_get_current_mtu_3:
        MOV      R0,R2
        BX       LR               ;; return
// 7916 }
          CFI EndBlock cfiBlock165
// 7917 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 7918 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock166 Using cfiCommon0
          CFI Function mbedtls_ssl_get_max_out_record_payload
        THUMB
// 7919 int mbedtls_ssl_get_max_out_record_payload( const mbedtls_ssl_context *ssl )
// 7920 {
mbedtls_ssl_get_max_out_record_payload:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
// 7921     size_t max_len = MBEDTLS_SSL_OUT_CONTENT_LEN;
        MOV      R5,#+10240
// 7922 
// 7923 #if !defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH) && \ 
// 7924     !defined(MBEDTLS_SSL_PROTO_DTLS)
// 7925     (void) ssl;
// 7926 #endif
// 7927 
// 7928 #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
// 7929     const size_t mfl = mbedtls_ssl_get_max_frag_len( ssl );
          CFI FunCall mbedtls_ssl_get_max_frag_len
        BL       mbedtls_ssl_get_max_frag_len
// 7930 
// 7931     if( max_len > mfl )
        CMP      R0,#+10240
        BCS.N    ??mbedtls_ssl_get_max_out_record_payload_0
// 7932         max_len = mfl;
        MOV      R5,R0
// 7933 #endif
// 7934 
// 7935 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 7936     if( ssl_get_current_mtu( ssl ) != 0 )
??mbedtls_ssl_get_max_out_record_payload_0:
        MOV      R0,R4
          CFI FunCall ssl_get_current_mtu
        BL       ssl_get_current_mtu
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_get_max_out_record_payload_1
// 7937     {
// 7938         const size_t mtu = ssl_get_current_mtu( ssl );
        MOV      R0,R4
          CFI FunCall ssl_get_current_mtu
        BL       ssl_get_current_mtu
        MOV      R6,R0
// 7939         const int ret = mbedtls_ssl_get_record_expansion( ssl );
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_get_record_expansion
        BL       mbedtls_ssl_get_record_expansion
// 7940         const size_t overhead = (size_t) ret;
// 7941 
// 7942         if( ret < 0 )
        CMP      R0,#+0
        BMI.N    ??mbedtls_ssl_get_max_out_record_payload_2
// 7943             return( ret );
// 7944 
// 7945         if( mtu <= overhead )
        CMP      R0,R6
        BCC.N    ??mbedtls_ssl_get_max_out_record_payload_3
// 7946         {
// 7947             MBEDTLS_SSL_DEBUG_MSG( 1, ( "MTU too low for record expansion" ) );
        LDR.W    R0,??DataTable78_10
        STR      R0,[SP, #+0]
        MOVW     R3,#+7947
        LDR.N    R2,??DataTable72_1
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 7948             return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
        LDR.W    R0,??DataTable79_1  ;; 0xffff8f80
        POP      {R1,R2,R4-R6,PC}
// 7949         }
// 7950 
// 7951         if( max_len > mtu - overhead )
??mbedtls_ssl_get_max_out_record_payload_3:
        SUBS     R1,R6,R0
        CMP      R1,R5
        BCS.N    ??mbedtls_ssl_get_max_out_record_payload_1
// 7952             max_len = mtu - overhead;
        MOV      R5,R0
        SUBS     R5,R6,R5
// 7953     }
// 7954 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 7955 
// 7956 #if !defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH) &&        \ 
// 7957     !defined(MBEDTLS_SSL_PROTO_DTLS)
// 7958     ((void) ssl);
// 7959 #endif
// 7960 
// 7961     return( (int) max_len );
??mbedtls_ssl_get_max_out_record_payload_1:
        MOV      R0,R5
??mbedtls_ssl_get_max_out_record_payload_2:
        POP      {R1,R2,R4-R6,PC}  ;; return
// 7962 }
          CFI EndBlock cfiBlock166

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67:
        DATA32
        DC32     ?_252
// 7963 
// 7964 #if defined(MBEDTLS_X509_CRT_PARSE_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock167 Using cfiCommon0
          CFI Function mbedtls_ssl_get_peer_cert
          CFI NoCalls
        THUMB
// 7965 const mbedtls_x509_crt *mbedtls_ssl_get_peer_cert( const mbedtls_ssl_context *ssl )
// 7966 {
// 7967     if( ssl == NULL || ssl->session == NULL )
mbedtls_ssl_get_peer_cert:
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_get_peer_cert_0
        LDR      R1,[R0, #+52]
        CMP      R1,#+0
        BNE.N    ??mbedtls_ssl_get_peer_cert_1
// 7968         return( NULL );
??mbedtls_ssl_get_peer_cert_0:
        MOVS     R0,#+0
        BX       LR
// 7969 
// 7970     return( ssl->session->peer_cert );
??mbedtls_ssl_get_peer_cert_1:
        MOV      R0,R1
        LDR      R0,[R0, #+92]
        BX       LR               ;; return
// 7971 }
          CFI EndBlock cfiBlock167
// 7972 #endif /* MBEDTLS_X509_CRT_PARSE_C */
// 7973 
// 7974 #if defined(MBEDTLS_SSL_CLI_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock168 Using cfiCommon0
          CFI Function mbedtls_ssl_get_session
        THUMB
// 7975 int mbedtls_ssl_get_session( const mbedtls_ssl_context *ssl, mbedtls_ssl_session *dst )
// 7976 {
mbedtls_ssl_get_session:
        MOV      R2,R1
// 7977     if( ssl == NULL ||
// 7978         dst == NULL ||
// 7979         ssl->session == NULL ||
// 7980         ssl->conf->endpoint != MBEDTLS_SSL_IS_CLIENT )
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_get_session_0
        CMP      R2,#+0
        BEQ.N    ??mbedtls_ssl_get_session_0
        LDR      R1,[R0, #+52]
        CMP      R1,#+0
        BEQ.N    ??mbedtls_ssl_get_session_0
        LDR      R1,[R0, #+0]
        LDRB     R1,[R1, #+204]
        LSLS     R1,R1,#+31
        BPL.N    ??mbedtls_ssl_get_session_1
// 7981     {
// 7982         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_get_session_0:
        LDR.W    R0,??DataTable80  ;; 0xffff8f00
        BX       LR
// 7983     }
// 7984 
// 7985     return( ssl_session_copy( dst, ssl->session ) );
??mbedtls_ssl_get_session_1:
        LDR      R1,[R0, #+52]
        MOV      R0,R2
          CFI FunCall ssl_session_copy
        B.W      ssl_session_copy
// 7986 }
          CFI EndBlock cfiBlock168

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68:
        DATA32
        DC32     ssl_update_checksum_start
// 7987 #endif /* MBEDTLS_SSL_CLI_C */
// 7988 
// 7989 /*
// 7990  * Perform a single step of the SSL handshake
// 7991  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock169 Using cfiCommon0
          CFI Function mbedtls_ssl_handshake_step
        THUMB
// 7992 int mbedtls_ssl_handshake_step( mbedtls_ssl_context *ssl )
// 7993 {
mbedtls_ssl_handshake_step:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 7994     int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
        LDR.N    R0,??DataTable71_1  ;; 0xffff8f80
// 7995 
// 7996     if( ssl == NULL || ssl->conf == NULL )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_handshake_step_0
        LDR      R1,[R4, #+0]
        CMP      R1,#+0
        BNE.N    ??mbedtls_ssl_handshake_step_1
// 7997         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_handshake_step_0:
        LDR.W    R0,??DataTable80  ;; 0xffff8f00
        POP      {R4,PC}
// 7998 
// 7999 #if defined(MBEDTLS_SSL_CLI_C)
// 8000     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
??mbedtls_ssl_handshake_step_1:
        LDRB     R1,[R1, #+204]
        LSLS     R1,R1,#+31
        BMI.N    ??mbedtls_ssl_handshake_step_2
// 8001         ret = mbedtls_ssl_handshake_client_step( ssl );
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_handshake_client_step
        BL       mbedtls_ssl_handshake_client_step
// 8002 #endif
// 8003 #if defined(MBEDTLS_SSL_SRV_C)
// 8004     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
??mbedtls_ssl_handshake_step_2:
        LDR      R1,[R4, #+0]
        LDRB     R1,[R1, #+204]
        LSLS     R1,R1,#+31
        BPL.N    ??mbedtls_ssl_handshake_step_3
// 8005         ret = mbedtls_ssl_handshake_server_step( ssl );
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_ssl_handshake_server_step
        B.W      mbedtls_ssl_handshake_server_step
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 8006 #endif
// 8007 
// 8008     return( ret );
??mbedtls_ssl_handshake_step_3:
        POP      {R4,PC}          ;; return
// 8009 }
          CFI EndBlock cfiBlock169

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable69:
        DATA32
        DC32     ?_253
// 8010 
// 8011 /*
// 8012  * Perform the SSL handshake
// 8013  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock170 Using cfiCommon0
          CFI Function mbedtls_ssl_handshake
        THUMB
// 8014 int mbedtls_ssl_handshake( mbedtls_ssl_context *ssl )
// 8015 {
mbedtls_ssl_handshake:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R5,R0
// 8016     int ret = 0;
        MOVS     R4,#+0
// 8017 
// 8018     if( ssl == NULL || ssl->conf == NULL )
        CMP      R5,#+0
        BEQ.N    ??mbedtls_ssl_handshake_0
        LDR      R0,[R5, #+0]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_handshake_1
// 8019         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_handshake_0:
        LDR.N    R0,??DataTable74  ;; 0xffff8f00
        POP      {R1,R2,R4-R6,PC}
// 8020 
// 8021     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> handshake" ) );
??mbedtls_ssl_handshake_1:
        LDR.N    R6,??DataTable72_1
        LDR.W    R0,??DataTable79_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+8021
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8022 
// 8023     while( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
??mbedtls_ssl_handshake_2:
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BEQ.N    ??mbedtls_ssl_handshake_3
// 8024     {
// 8025         ret = mbedtls_ssl_handshake_step( ssl );
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_handshake_step
        BL       mbedtls_ssl_handshake_step
        MOVS     R4,R0
// 8026 
// 8027         if( ret != 0 )
        BEQ.N    ??mbedtls_ssl_handshake_2
// 8028             break;
// 8029     }
// 8030 
// 8031     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= handshake" ) );
??mbedtls_ssl_handshake_3:
        LDR.W    R0,??DataTable80_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+8031
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8032 
// 8033     return( ret );
        MOV      R0,R4
        POP      {R1,R2,R4-R6,PC}  ;; return
// 8034 }
          CFI EndBlock cfiBlock170
// 8035 
// 8036 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 8037 #if defined(MBEDTLS_SSL_SRV_C)
// 8038 /*
// 8039  * Write HelloRequest to request renegotiation on server
// 8040  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock171 Using cfiCommon0
          CFI Function ssl_write_hello_request
        THUMB
// 8041 static int ssl_write_hello_request( mbedtls_ssl_context *ssl )
// 8042 {
ssl_write_hello_request:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R5,R0
// 8043     int ret;
// 8044 
// 8045     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write hello request" ) );
        LDR.N    R6,??DataTable72_1
        LDR.W    R0,??DataTable79_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+8045
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8046 
// 8047     ssl->out_msglen  = 4;
        MOVS     R0,#+4
        STR      R0,[R5, #+204]
// 8048     ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
        MOVS     R0,#+22
        STR      R0,[R5, #+200]
// 8049     ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_REQUEST;
        MOVS     R0,#+0
        LDR      R1,[R5, #+196]
        STRB     R0,[R1, #+0]
// 8050 
// 8051     if( ( ret = mbedtls_ssl_write_handshake_msg( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_write_handshake_msg
        BL       mbedtls_ssl_write_handshake_msg
        MOVS     R4,R0
        BEQ.N    ??ssl_write_hello_request_0
// 8052     {
// 8053         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_handshake_msg", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable79_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+8053
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8054         return( ret );
        MOV      R0,R4
        POP      {R1,R2,R4-R6,PC}
// 8055     }
// 8056 
// 8057     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write hello request" ) );
??ssl_write_hello_request_0:
        LDR.W    R0,??DataTable80_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+8057
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8058 
// 8059     return( 0 );
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
// 8060 }
          CFI EndBlock cfiBlock171

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71:
        DATA32
        DC32     0xffff8100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_1:
        DATA32
        DC32     0xffff8f80
// 8061 #endif /* MBEDTLS_SSL_SRV_C */
// 8062 
// 8063 /*
// 8064  * Actually renegotiate current connection, triggered by either:
// 8065  * - any side: calling mbedtls_ssl_renegotiate(),
// 8066  * - client: receiving a HelloRequest during mbedtls_ssl_read(),
// 8067  * - server: receiving any handshake message on server during mbedtls_ssl_read() after
// 8068  *   the initial handshake is completed.
// 8069  * If the handshake doesn't complete due to waiting for I/O, it will continue
// 8070  * during the next calls to mbedtls_ssl_renegotiate() or mbedtls_ssl_read() respectively.
// 8071  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock172 Using cfiCommon0
          CFI Function ssl_start_renegotiation
        THUMB
// 8072 static int ssl_start_renegotiation( mbedtls_ssl_context *ssl )
// 8073 {
ssl_start_renegotiation:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R5,R0
// 8074     int ret;
// 8075 
// 8076     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> renegotiate" ) );
        LDR.N    R6,??DataTable72_1
        LDR.W    R0,??DataTable80_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+8076
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8077 
// 8078     if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall ssl_handshake_init
        BL       ssl_handshake_init
        CMP      R0,#+0
        BNE.N    ??ssl_start_renegotiation_0
// 8079         return( ret );
// 8080 
// 8081     /* RFC 6347 4.2.2: "[...] the HelloRequest will have message_seq = 0 and
// 8082      * the ServerHello will have message_seq = 1" */
// 8083 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 8084     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 8085         ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_start_renegotiation_1
        LDR      R0,[R5, #+8]
        CMP      R0,#+3
        BNE.N    ??ssl_start_renegotiation_1
// 8086     {
// 8087         if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??ssl_start_renegotiation_2
// 8088             ssl->handshake->out_msg_seq = 1;
        MOVS     R0,#+1
        LDR      R1,[R5, #+60]
        STR      R0,[R1, #+468]
        B.N      ??ssl_start_renegotiation_1
// 8089         else
// 8090             ssl->handshake->in_msg_seq = 1;
??ssl_start_renegotiation_2:
        MOVS     R0,#+1
        LDR      R1,[R5, #+60]
        STR      R0,[R1, #+472]
// 8091     }
// 8092 #endif
// 8093 
// 8094     ssl->state = MBEDTLS_SSL_HELLO_REQUEST;
??ssl_start_renegotiation_1:
        MOVS     R0,#+0
        STR      R0,[R5, #+4]
// 8095     ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS;
        MOVS     R0,#+1
        STR      R0,[R5, #+8]
// 8096 
// 8097     if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_handshake
        BL       mbedtls_ssl_handshake
        MOVS     R4,R0
        BEQ.N    ??ssl_start_renegotiation_3
// 8098     {
// 8099         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable80_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+8099
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8100         return( ret );
        MOV      R0,R4
        POP      {R1,R2,R4-R6,PC}
// 8101     }
// 8102 
// 8103     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= renegotiate" ) );
??ssl_start_renegotiation_3:
        LDR.W    R0,??DataTable80_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+8103
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8104 
// 8105     return( 0 );
        MOVS     R0,#+0
??ssl_start_renegotiation_0:
        POP      {R1,R2,R4-R6,PC}  ;; return
// 8106 }
          CFI EndBlock cfiBlock172

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable72:
        DATA32
        DC32     ?_210

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable72_1:
        DATA32
        DC32     ?_0
// 8107 
// 8108 /*
// 8109  * Renegotiate current connection on client,
// 8110  * or request renegotiation on server
// 8111  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock173 Using cfiCommon0
          CFI Function mbedtls_ssl_renegotiate
        THUMB
// 8112 int mbedtls_ssl_renegotiate( mbedtls_ssl_context *ssl )
// 8113 {
mbedtls_ssl_renegotiate:
        PUSH     {R1-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        MOVS     R5,R0
// 8114     int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
// 8115 
// 8116     if( ssl == NULL || ssl->conf == NULL )
        BEQ.N    ??mbedtls_ssl_renegotiate_0
        LDR      R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_renegotiate_0
// 8117         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 8118 
// 8119 #if defined(MBEDTLS_SSL_SRV_C)
// 8120     /* On server, just send the request */
// 8121     if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_renegotiate_1
// 8122     {
// 8123         if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BNE.N    ??mbedtls_ssl_renegotiate_0
// 8124             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
// 8125 
// 8126         ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_PENDING;
        MOVS     R0,#+3
        STR      R0,[R5, #+8]
// 8127 
// 8128         /* Did we already try/start sending HelloRequest? */
// 8129         if( ssl->out_left != 0 )
        LDR      R0,[R5, #+208]
        CMP      R0,#+0
        MOV      R0,R5
        BEQ.N    ??mbedtls_ssl_renegotiate_2
// 8130             return( mbedtls_ssl_flush_output( ssl ) );
        POP      {R1-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_ssl_flush_output
        B.W      mbedtls_ssl_flush_output
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
// 8131 
// 8132         return( ssl_write_hello_request( ssl ) );
??mbedtls_ssl_renegotiate_2:
        POP      {R1-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall ssl_write_hello_request
        B.N      ssl_write_hello_request
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
// 8133     }
// 8134 #endif /* MBEDTLS_SSL_SRV_C */
// 8135 
// 8136 #if defined(MBEDTLS_SSL_CLI_C)
// 8137     /*
// 8138      * On client, either start the renegotiation process or,
// 8139      * if already in progress, continue the handshake
// 8140      */
// 8141     if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
??mbedtls_ssl_renegotiate_1:
        LDR      R0,[R5, #+8]
        CMP      R0,#+1
        BEQ.N    ??mbedtls_ssl_renegotiate_3
// 8142     {
// 8143         if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BEQ.N    ??mbedtls_ssl_renegotiate_4
// 8144             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_renegotiate_0:
        LDR.N    R0,??DataTable74  ;; 0xffff8f00
        POP      {R1-R5,PC}
// 8145 
// 8146         if( ( ret = ssl_start_renegotiation( ssl ) ) != 0 )
??mbedtls_ssl_renegotiate_4:
        MOV      R0,R5
          CFI FunCall ssl_start_renegotiation
        BL       ssl_start_renegotiation
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_renegotiate_5
// 8147         {
// 8148             MBEDTLS_SSL_DEBUG_RET( 1, "ssl_start_renegotiation", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable80_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+8148
        LDR.W    R2,??DataTable80_7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8149             return( ret );
        MOV      R0,R4
        POP      {R1-R5,PC}
// 8150         }
// 8151     }
// 8152     else
// 8153     {
// 8154         if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )
??mbedtls_ssl_renegotiate_3:
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_handshake
        BL       mbedtls_ssl_handshake
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_renegotiate_5
// 8155         {
// 8156             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable80_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+8156
        LDR.W    R2,??DataTable80_7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8157             return( ret );
        MOV      R0,R4
        POP      {R1-R5,PC}
// 8158         }
// 8159     }
// 8160 #endif /* MBEDTLS_SSL_CLI_C */
// 8161 
// 8162     return( ret );
??mbedtls_ssl_renegotiate_5:
        MOV      R0,R4
        POP      {R1-R5,PC}       ;; return
// 8163 }
          CFI EndBlock cfiBlock173
// 8164 
// 8165 /*
// 8166  * Check record counters and renegotiate if they're above the limit.
// 8167  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock174 Using cfiCommon0
          CFI Function ssl_check_ctr_renegotiate
        THUMB
// 8168 static int ssl_check_ctr_renegotiate( mbedtls_ssl_context *ssl )
// 8169 {
ssl_check_ctr_renegotiate:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
// 8170     size_t ep_len = ssl_ep_len( ssl );
          CFI FunCall ssl_ep_len
        BL       ssl_ep_len
        MOV      R5,R0
// 8171     int in_ctr_cmp;
// 8172     int out_ctr_cmp;
// 8173 
// 8174     if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER ||
// 8175         ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING ||
// 8176         ssl->conf->disable_renegotiation == MBEDTLS_SSL_RENEGOTIATION_DISABLED )
        LDR      R0,[R4, #+4]
        CMP      R0,#+16
        BNE.N    ??ssl_check_ctr_renegotiate_0
        LDR      R0,[R4, #+8]
        CMP      R0,#+3
        BEQ.N    ??ssl_check_ctr_renegotiate_0
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+13,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_check_ctr_renegotiate_0
// 8177     {
// 8178         return( 0 );
// 8179     }
// 8180 
// 8181     in_ctr_cmp = memcmp( ssl->in_ctr + ep_len,
// 8182                         ssl->conf->renego_period + ep_len, 8 - ep_len );
        RSB      R2,R5,#+8
        LDR      R0,[R4, #+0]
        ADD      R0,R0,R5
        ADD      R1,R0,#+184
        LDR      R0,[R4, #+96]
        ADD      R0,R0,R5
          CFI FunCall memcmp
        BL       memcmp
        MOV      R6,R0
// 8183     out_ctr_cmp = memcmp( ssl->cur_out_ctr + ep_len,
// 8184                           ssl->conf->renego_period + ep_len, 8 - ep_len );
        RSB      R2,R5,#+8
        LDR      R0,[R4, #+0]
        ADD      R0,R0,R5
        ADD      R1,R0,#+184
        ADDS     R0,R4,R5
        ADDS     R0,R0,#+212
          CFI FunCall memcmp
        BL       memcmp
// 8185 
// 8186     if( in_ctr_cmp <= 0 && out_ctr_cmp <= 0 )
        CMP      R6,#+1
        BGE.N    ??ssl_check_ctr_renegotiate_1
        CMP      R0,#+1
        BGE.N    ??ssl_check_ctr_renegotiate_1
// 8187     {
// 8188         return( 0 );
??ssl_check_ctr_renegotiate_0:
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}
// 8189     }
// 8190 
// 8191     MBEDTLS_SSL_DEBUG_MSG( 1, ( "record counter limit reached: renegotiate" ) );
??ssl_check_ctr_renegotiate_1:
        LDR.W    R0,??DataTable80_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+8191
        LDR.W    R2,??DataTable80_7
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8192     return( mbedtls_ssl_renegotiate( ssl ) );
        MOV      R0,R4
        POP      {R1,R2,R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_ssl_renegotiate
        B.N      mbedtls_ssl_renegotiate
// 8193 }
          CFI EndBlock cfiBlock174

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable74:
        DATA32
        DC32     0xffff8f00
// 8194 #endif /* MBEDTLS_SSL_RENEGOTIATION */
// 8195 
// 8196 /*
// 8197  * Receive application data decrypted from the SSL layer
// 8198  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock175 Using cfiCommon0
          CFI Function mbedtls_ssl_read
        THUMB
// 8199 int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
// 8200 {
mbedtls_ssl_read:
        PUSH     {R1-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+40
        MOV      R5,R0
        MOV      R7,R1
        MOV      R6,R2
// 8201     int ret;
// 8202     size_t n;
// 8203 
// 8204     if( ssl == NULL || ssl->conf == NULL )
        CMP      R5,#+0
        BEQ.N    ??mbedtls_ssl_read_0
        LDR      R0,[R5, #+0]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_1
// 8205         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_read_0:
        LDR.W    R0,??DataTable80  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_read_2
// 8206 
// 8207     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> read" ) );
??mbedtls_ssl_read_1:
        LDR.W    R8,??DataTable80_7
        LDR.W    R0,??DataTable80_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+8207
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8208 
// 8209 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 8210     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_read_3
// 8211     {
// 8212         if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_flush_output
        BL       mbedtls_ssl_flush_output
        CMP      R0,#+0
        BNE.W    ??mbedtls_ssl_read_2
// 8213             return( ret );
// 8214 
// 8215         if( ssl->handshake != NULL &&
// 8216             ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )
        LDR      R0,[R5, #+60]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_read_3
        LDRB     R0,[R0, #+488]
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_read_3
// 8217         {
// 8218             if( ( ret = mbedtls_ssl_flight_transmit( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_flight_transmit
        BL       mbedtls_ssl_flight_transmit
        CMP      R0,#+0
        BNE.W    ??mbedtls_ssl_read_2
// 8219                 return( ret );
// 8220         }
// 8221     }
// 8222 #endif
// 8223 
// 8224     /*
// 8225      * Check if renegotiation is necessary and/or handshake is
// 8226      * in process. If yes, perform/continue, and fall through
// 8227      * if an unexpected packet is received while the client
// 8228      * is waiting for the ServerHello.
// 8229      *
// 8230      * (There is no equivalent to the last condition on
// 8231      *  the server-side as it is not treated as within
// 8232      *  a handshake while waiting for the ClientHello
// 8233      *  after a renegotiation request.)
// 8234      */
// 8235 
// 8236 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 8237     ret = ssl_check_ctr_renegotiate( ssl );
??mbedtls_ssl_read_3:
        MOV      R0,R5
          CFI FunCall ssl_check_ctr_renegotiate
        BL       ssl_check_ctr_renegotiate
        MOV      R4,R0
// 8238     if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
// 8239         ret != 0 )
        LDR.W    R9,??DataTable81  ;; 0xffff9500
        CMP      R4,R9
        BEQ.N    ??mbedtls_ssl_read_4
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_read_4
// 8240     {
// 8241         MBEDTLS_SSL_DEBUG_RET( 1, "ssl_check_ctr_renegotiate", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable81_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+8241
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8242         return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_read_2
// 8243     }
// 8244 #endif
// 8245 
// 8246     if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
??mbedtls_ssl_read_4:
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BEQ.N    ??mbedtls_ssl_read_5
// 8247     {
// 8248         ret = mbedtls_ssl_handshake( ssl );
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_handshake
        BL       mbedtls_ssl_handshake
        MOV      R4,R0
// 8249         if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
// 8250             ret != 0 )
        CMP      R4,R9
        BEQ.N    ??mbedtls_ssl_read_5
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_read_5
// 8251         {
// 8252             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable80_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+8252
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8253             return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_read_2
// 8254         }
// 8255     }
// 8256 
// 8257     /* Loop as long as no application data record is available */
// 8258     while( ssl->in_offt == NULL )
// 8259     {
// 8260         /* Start timer if not already running */
// 8261         if( ssl->f_get_timer != NULL &&
// 8262             ssl->f_get_timer( ssl->p_timer ) == -1 )
// 8263         {
// 8264             ssl_set_timer( ssl, ssl->conf->read_timeout );
// 8265         }
// 8266 
// 8267         if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )
// 8268         {
// 8269             if( ret == MBEDTLS_ERR_SSL_CONN_EOF )
// 8270                 return( 0 );
// 8271 
// 8272             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
??mbedtls_ssl_read_6:
        STR      R4,[SP, #+4]
        LDR.W    R1,??DataTable81_2
        STR      R1,[SP, #+0]
        MOVW     R3,#+8272
        MOV      R2,R8
        MOVS     R1,#+1
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8273             return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_read_2
// 8274         }
// 8275 
// 8276         if( ssl->in_msglen  == 0 &&
// 8277             ssl->in_msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA )
??mbedtls_ssl_read_7:
        LDR      R0,[R5, #+124]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_8
        LDR      R0,[R5, #+120]
        CMP      R0,#+23
        BNE.N    ??mbedtls_ssl_read_8
// 8278         {
// 8279             /*
// 8280              * OpenSSL sends empty messages to randomize the IV
// 8281              */
// 8282             if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_read_record
        BL       mbedtls_ssl_read_record
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_read_8
// 8283             {
// 8284                 if( ret == MBEDTLS_ERR_SSL_CONN_EOF )
        CMN      R4,#+29312
        BNE.N    ??mbedtls_ssl_read_9
// 8285                     return( 0 );
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_read_2
// 8286 
// 8287                 MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
??mbedtls_ssl_read_9:
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable81_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+8287
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8288                 return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_read_2
// 8289             }
// 8290         }
// 8291 
// 8292         if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
??mbedtls_ssl_read_8:
        LDR      R0,[R5, #+120]
        CMP      R0,#+22
        BNE.W    ??mbedtls_ssl_read_10
// 8293         {
// 8294             MBEDTLS_SSL_DEBUG_MSG( 1, ( "received handshake message" ) );
        LDR.W    R0,??DataTable82
        STR      R0,[SP, #+0]
        MOVW     R3,#+8294
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8295 
// 8296             /*
// 8297              * - For client-side, expect SERVER_HELLO_REQUEST.
// 8298              * - For server-side, expect CLIENT_HELLO.
// 8299              * - Fail (TLS) or silently drop record (DTLS) in other cases.
// 8300              */
// 8301 
// 8302 #if defined(MBEDTLS_SSL_CLI_C)
// 8303             if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
// 8304                 ( ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_REQUEST ||
// 8305                   ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) ) )
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BMI.N    ??mbedtls_ssl_read_11
        LDR      R0,[R5, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_12
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_hs_hdr_len
        BL       mbedtls_ssl_hs_hdr_len
        LDR      R1,[R5, #+160]
        CMP      R1,R0
        BEQ.N    ??mbedtls_ssl_read_11
// 8306             {
// 8307                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake received (not HelloRequest)" ) );
??mbedtls_ssl_read_12:
        LDR.W    R0,??DataTable82_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+8307
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8308 
// 8309                 /* With DTLS, drop the packet (probably from last handshake) */
// 8310 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 8311                 if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_read_13
// 8312                 {
// 8313                     continue;
// 8314                 }
// 8315 #endif
// 8316                 return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
// 8317             }
??mbedtls_ssl_read_5:
        LDR      R0,[R5, #+116]
        CMP      R0,#+0
        BNE.W    ??mbedtls_ssl_read_14
        LDR      R0,[R5, #+88]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_read_15
        LDR      R0,[R5, #+80]
        LDR      R1,[R5, #+88]
          CFI FunCall
        BLX      R1
        CMN      R0,#+1
        BNE.N    ??mbedtls_ssl_read_15
        LDR      R0,[R5, #+0]
        LDR      R1,[R0, #+168]
        MOV      R0,R5
          CFI FunCall ssl_set_timer
        BL       ssl_set_timer
??mbedtls_ssl_read_15:
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_read_record
        BL       mbedtls_ssl_read_record
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_read_7
        MOV      R0,R5
        CMN      R4,#+29312
        BNE.N    ??mbedtls_ssl_read_6
        MOVS     R0,#+0
        B.N      ??mbedtls_ssl_read_2
// 8318 #endif /* MBEDTLS_SSL_CLI_C */
// 8319 
// 8320 #if defined(MBEDTLS_SSL_SRV_C)
// 8321             if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
// 8322                 ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )
??mbedtls_ssl_read_11:
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.N    ??mbedtls_ssl_read_16
        LDR      R0,[R5, #+112]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??mbedtls_ssl_read_16
// 8323             {
// 8324                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake received (not ClientHello)" ) );
        LDR.W    R0,??DataTable82_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+8324
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8325 
// 8326                 /* With DTLS, drop the packet (probably from last handshake) */
// 8327 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 8328                 if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_5
// 8329                 {
// 8330                     continue;
// 8331                 }
// 8332 #endif
// 8333                 return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
??mbedtls_ssl_read_13:
        LDR.W    R0,??DataTable82_3  ;; 0xffff8900
        B.N      ??mbedtls_ssl_read_2
// 8334             }
// 8335 #endif /* MBEDTLS_SSL_SRV_C */
// 8336 
// 8337 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 8338             /* Determine whether renegotiation attempt should be accepted */
// 8339             if( ! ( ssl->conf->disable_renegotiation == MBEDTLS_SSL_RENEGOTIATION_DISABLED ||
// 8340                     ( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
// 8341                       ssl->conf->allow_legacy_renegotiation ==
// 8342                                                    MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION ) ) )
??mbedtls_ssl_read_16:
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+13,#+1
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_read_17
        LDR      R0,[R5, #+244]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_read_18
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+4,#+2
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_read_17
// 8343             {
// 8344                 /*
// 8345                  * Accept renegotiation request
// 8346                  */
// 8347 
// 8348                 /* DTLS clients need to know renego is server-initiated */
// 8349 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 8350                 if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
// 8351                     ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
??mbedtls_ssl_read_18:
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+204]
        AND      R0,R0,#0x3
        CMP      R0,#+2
        BNE.N    ??mbedtls_ssl_read_19
// 8352                 {
// 8353                     ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_PENDING;
        MOVS     R0,#+3
        STR      R0,[R5, #+8]
// 8354                 }
// 8355 #endif
// 8356                 ret = ssl_start_renegotiation( ssl );
??mbedtls_ssl_read_19:
        MOV      R0,R5
          CFI FunCall ssl_start_renegotiation
        BL       ssl_start_renegotiation
        MOV      R4,R0
// 8357                 if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
// 8358                     ret != 0 )
        CMP      R4,R9
        BEQ.N    ??mbedtls_ssl_read_5
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_read_5
// 8359                 {
// 8360                     MBEDTLS_SSL_DEBUG_RET( 1, "ssl_start_renegotiation", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable80_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+8360
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8361                     return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_read_2
// 8362                 }
// 8363             }
// 8364             else
// 8365 #endif /* MBEDTLS_SSL_RENEGOTIATION */
// 8366             {
// 8367                 /*
// 8368                  * Refuse renegotiation
// 8369                  */
// 8370 
// 8371                 MBEDTLS_SSL_DEBUG_MSG( 3, ( "refusing renegotiation, sending alert" ) );
??mbedtls_ssl_read_17:
        LDR.W    R0,??DataTable83
        STR      R0,[SP, #+0]
        MOVW     R3,#+8371
        MOV      R2,R8
        MOVS     R1,#+3
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8372 
// 8373 #if defined(MBEDTLS_SSL_PROTO_SSL3)
// 8374                 if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
// 8375                 {
// 8376                     /* SSLv3 does not have a "no_renegotiation" warning, so
// 8377                        we send a fatal alert and abort the connection. */
// 8378                     mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 8379                                                     MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
// 8380                     return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
// 8381                 }
// 8382                 else
// 8383 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
// 8384 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ 
// 8385     defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 8386                 if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 )
        LDR      R0,[R5, #+20]
        CMP      R0,#+1
        BLT.W    ??mbedtls_ssl_read_20
// 8387                 {
// 8388                     if( ( ret = mbedtls_ssl_send_alert_message( ssl,
// 8389                                     MBEDTLS_SSL_ALERT_LEVEL_WARNING,
// 8390                                     MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION ) ) != 0 )
        MOVS     R2,#+100
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
        CMP      R0,#+0
        BEQ.W    ??mbedtls_ssl_read_5
// 8391                     {
// 8392                         return( ret );
        B.N      ??mbedtls_ssl_read_2
// 8393                     }
// 8394                 }
// 8395                 else
// 8396 #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 ||
// 8397           MBEDTLS_SSL_PROTO_TLS1_2 */
// 8398                 {
// 8399                     MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
// 8400                     return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
// 8401                 }
// 8402             }
// 8403 
// 8404             /* At this point, we don't know whether the renegotiation has been
// 8405              * completed or not. The cases to consider are the following:
// 8406              * 1) The renegotiation is complete. In this case, no new record
// 8407              *    has been read yet.
// 8408              * 2) The renegotiation is incomplete because the client received
// 8409              *    an application data record while awaiting the ServerHello.
// 8410              * 3) The renegotiation is incomplete because the client received
// 8411              *    a non-handshake, non-application data message while awaiting
// 8412              *    the ServerHello.
// 8413              * In each of these case, looping will be the proper action:
// 8414              * - For 1), the next iteration will read a new record and check
// 8415              *   if it's application data.
// 8416              * - For 2), the loop condition isn't satisfied as application data
// 8417              *   is present, hence continue is the same as break
// 8418              * - For 3), the loop condition is satisfied and read_record
// 8419              *   will re-deliver the message that was held back by the client
// 8420              *   when expecting the ServerHello.
// 8421              */
// 8422             continue;
// 8423         }
// 8424 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 8425         else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )
??mbedtls_ssl_read_10:
        LDR      R0,[R5, #+8]
        CMP      R0,#+3
        BNE.N    ??mbedtls_ssl_read_21
// 8426         {
// 8427             if( ssl->conf->renego_max_records >= 0 )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+180]
        CMP      R0,#+0
        BMI.N    ??mbedtls_ssl_read_21
// 8428             {
// 8429                 if( ++ssl->renego_records_seen > ssl->conf->renego_max_records )
        LDR      R0,[R5, #+12]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+12]
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+180]
        LDR      R1,[R5, #+12]
        CMP      R0,R1
        BLT.N    ??mbedtls_ssl_read_22
// 8430                 {
// 8431                     MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation requested, "
// 8432                                         "but not honored by client" ) );
// 8433                     return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
// 8434                 }
// 8435             }
// 8436         }
// 8437 #endif /* MBEDTLS_SSL_RENEGOTIATION */
// 8438 
// 8439         /* Fatal and closure alerts handled by mbedtls_ssl_read_record() */
// 8440         if( ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT )
??mbedtls_ssl_read_21:
        LDR      R0,[R5, #+120]
        CMP      R0,#+21
        BEQ.N    ??mbedtls_ssl_read_23
// 8441         {
// 8442             MBEDTLS_SSL_DEBUG_MSG( 2, ( "ignoring non-fatal non-closure alert" ) );
// 8443             return( MBEDTLS_ERR_SSL_WANT_READ );
// 8444         }
// 8445 
// 8446         if( ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
        CMP      R0,#+23
        BNE.N    ??mbedtls_ssl_read_24
// 8447         {
// 8448             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad application data message" ) );
// 8449             return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
// 8450         }
// 8451 
// 8452         ssl->in_offt = ssl->in_msg;
        LDR      R0,[R5, #+112]
        STR      R0,[R5, #+116]
// 8453 
// 8454         /* We're going to return something now, cancel timer,
// 8455          * except if handshake (renegotiation) is in progress */
// 8456         if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
        LDR      R0,[R5, #+4]
        CMP      R0,#+16
        BNE.N    ??mbedtls_ssl_read_25
// 8457             ssl_set_timer( ssl, 0 );
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall ssl_set_timer
        BL       ssl_set_timer
// 8458 
// 8459 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 8460         /* If we requested renego but received AppData, resend HelloRequest.
// 8461          * Do it now, after setting in_offt, to avoid taking this branch
// 8462          * again if ssl_write_hello_request() returns WANT_WRITE */
// 8463 #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_RENEGOTIATION)
// 8464         if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
// 8465             ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )
??mbedtls_ssl_read_25:
        LDR      R0,[R5, #+0]
        LDRB     R0,[R0, #+204]
        LSLS     R0,R0,#+31
        BPL.W    ??mbedtls_ssl_read_5
        LDR      R0,[R5, #+8]
        CMP      R0,#+3
        BNE.W    ??mbedtls_ssl_read_5
// 8466         {
// 8467             if( ( ret = ssl_resend_hello_request( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall ssl_resend_hello_request
        BL       ssl_resend_hello_request
        MOVS     R4,R0
        BEQ.W    ??mbedtls_ssl_read_5
// 8468             {
// 8469                 MBEDTLS_SSL_DEBUG_RET( 1, "ssl_resend_hello_request", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable83_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+8469
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8470                 return( ret );
        MOV      R0,R4
        B.N      ??mbedtls_ssl_read_2
// 8471             }
// 8472         }
??mbedtls_ssl_read_22:
        LDR.W    R0,??DataTable83_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+8432
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable82_3  ;; 0xffff8900
        B.N      ??mbedtls_ssl_read_2
??mbedtls_ssl_read_23:
        LDR.W    R0,??DataTable83_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+8442
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable83_4  ;; 0xffff9700
        B.N      ??mbedtls_ssl_read_2
??mbedtls_ssl_read_24:
        LDR.W    R0,??DataTable83_5
        STR      R0,[SP, #+0]
        MOV      R3,#+8448
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable82_3  ;; 0xffff8900
        B.N      ??mbedtls_ssl_read_2
// 8473 #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_RENEGOTIATION */
// 8474 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 8475     }
// 8476 
// 8477     n = ( len < ssl->in_msglen )
// 8478         ? len : ssl->in_msglen;
// 8479 
// 8480     memcpy( buf, ssl->in_offt, n );
// 8481     ssl->in_msglen -= n;
// 8482 
// 8483     if( ssl->in_msglen == 0 )
// 8484     {
// 8485         /* all bytes consumed */
// 8486         ssl->in_offt = NULL;
// 8487         ssl->keep_current_message = 0;
// 8488     }
// 8489     else
// 8490     {
// 8491         /* more data available */
// 8492         ssl->in_offt += n;
??mbedtls_ssl_read_26:
        LDR      R0,[R5, #+116]
        ADD      R0,R0,R4
        STR      R0,[R5, #+116]
// 8493     }
// 8494 
// 8495     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= read" ) );
??mbedtls_ssl_read_27:
        LDR.W    R0,??DataTable84
        STR      R0,[SP, #+0]
        MOVW     R3,#+8495
        MOV      R2,R8
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8496 
// 8497     return( (int) n );
        MOV      R0,R4
??mbedtls_ssl_read_2:
        POP      {R1-R9,PC}       ;; return
??mbedtls_ssl_read_14:
        MOV      R4,R6
        MOV      R0,R7
        LDR      R1,[R5, #+124]
        CMP      R4,R1
        BLS.N    ??mbedtls_ssl_read_28
        MOV      R4,R1
??mbedtls_ssl_read_28:
        MOV      R2,R4
        LDR      R1,[R5, #+116]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR      R0,[R5, #+124]
        SUBS     R0,R0,R4
        STR      R0,[R5, #+124]
        BNE.N    ??mbedtls_ssl_read_26
        MOVS     R0,#+0
        STR      R0,[R5, #+116]
        STR      R0,[R5, #+168]
        B.N      ??mbedtls_ssl_read_27
??mbedtls_ssl_read_20:
        LDR.N    R0,??DataTable78_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+8399
        MOV      R2,R8
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
        LDR.W    R0,??DataTable79  ;; 0xffff9400
        B.N      ??mbedtls_ssl_read_2
// 8498 }
          CFI EndBlock cfiBlock175
// 8499 
// 8500 /*
// 8501  * Send application data to be encrypted by the SSL layer, taking care of max
// 8502  * fragment length and buffer size.
// 8503  *
// 8504  * According to RFC 5246 Section 6.2.1:
// 8505  *
// 8506  *      Zero-length fragments of Application data MAY be sent as they are
// 8507  *      potentially useful as a traffic analysis countermeasure.
// 8508  *
// 8509  * Therefore, it is possible that the input message length is 0 and the
// 8510  * corresponding return code is 0 on success.
// 8511  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock176 Using cfiCommon0
          CFI Function ssl_write_real
        THUMB
// 8512 static int ssl_write_real( mbedtls_ssl_context *ssl,
// 8513                            const unsigned char *buf, size_t len )
// 8514 {
ssl_write_real:
        PUSH     {R1-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+32
        MOV      R5,R0
        MOV      R4,R1
        MOV      R6,R2
// 8515     int ret = mbedtls_ssl_get_max_out_record_payload( ssl );
          CFI FunCall mbedtls_ssl_get_max_out_record_payload
        BL       mbedtls_ssl_get_max_out_record_payload
        MOVS     R7,R0
// 8516     const size_t max_len = (size_t) ret;
// 8517 
// 8518     if( ret < 0 )
        BPL.N    ??ssl_write_real_0
// 8519     {
// 8520         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_get_max_out_record_payload", ret );
        STR      R7,[SP, #+4]
        LDR.W    R0,??DataTable84_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+8520
        LDR.W    R2,??DataTable80_7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8521         return( ret );
        MOV      R0,R7
        POP      {R1-R7,PC}
// 8522     }
// 8523 
// 8524     if( len > max_len )
??ssl_write_real_0:
        CMP      R7,R6
        BCS.N    ??ssl_write_real_1
// 8525     {
// 8526 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 8527         if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        LDR      R0,[R5, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+1,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_write_real_2
// 8528         {
// 8529             MBEDTLS_SSL_DEBUG_MSG( 1, ( "fragment larger than the (negotiated) "
// 8530                                 "maximum fragment length: %d > %d",
// 8531                                 len, max_len ) );
        STR      R7,[SP, #+8]
        STR      R6,[SP, #+4]
        LDR.W    R0,??DataTable84_2
        STR      R0,[SP, #+0]
        MOVW     R3,#+8531
        LDR.W    R2,??DataTable80_7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8532             return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        LDR.W    R0,??DataTable80  ;; 0xffff8f00
        POP      {R1-R7,PC}
// 8533         }
// 8534         else
// 8535 #endif
// 8536             len = max_len;
??ssl_write_real_2:
        MOV      R6,R7
// 8537     }
// 8538 
// 8539     if( ssl->out_left != 0 )
??ssl_write_real_1:
        LDR      R0,[R5, #+208]
        CMP      R0,#+0
        BEQ.N    ??ssl_write_real_3
// 8540     {
// 8541         /*
// 8542          * The user has previously tried to send the data and
// 8543          * MBEDTLS_ERR_SSL_WANT_WRITE or the message was only partially
// 8544          * written. In this case, we expect the high-level write function
// 8545          * (e.g. mbedtls_ssl_write()) to be called with the same parameters
// 8546          */
// 8547         if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_flush_output
        BL       mbedtls_ssl_flush_output
        MOVS     R4,R0
        BEQ.N    ??ssl_write_real_4
// 8548         {
// 8549             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_flush_output", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable84_3
        STR      R0,[SP, #+0]
        MOVW     R3,#+8549
        LDR.W    R2,??DataTable80_7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8550             return( ret );
        MOV      R0,R4
        POP      {R1-R7,PC}
// 8551         }
// 8552     }
// 8553     else
// 8554     {
// 8555         /*
// 8556          * The user is trying to send a message the first time, so we need to
// 8557          * copy the data into the internal buffers and setup the data structure
// 8558          * to keep track of partial writes
// 8559          */
// 8560         ssl->out_msglen  = len;
??ssl_write_real_3:
        STR      R6,[R5, #+204]
// 8561         ssl->out_msgtype = MBEDTLS_SSL_MSG_APPLICATION_DATA;
        MOVS     R0,#+23
        STR      R0,[R5, #+200]
// 8562         memcpy( ssl->out_msg, buf, len );
        MOV      R2,R6
        MOV      R1,R4
        LDR      R0,[R5, #+196]
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 8563 
// 8564         if( ( ret = mbedtls_ssl_write_record( ssl, SSL_FORCE_FLUSH ) ) != 0 )
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_write_record
        BL       mbedtls_ssl_write_record
        MOVS     R4,R0
        BEQ.N    ??ssl_write_real_4
// 8565         {
// 8566             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
        STR      R4,[SP, #+4]
        LDR.W    R0,??DataTable84_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+8566
        LDR.W    R2,??DataTable80_7
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8567             return( ret );
        MOV      R0,R4
        POP      {R1-R7,PC}
// 8568         }
// 8569     }
// 8570 
// 8571     return( (int) len );
??ssl_write_real_4:
        MOV      R0,R6
        POP      {R1-R7,PC}       ;; return
// 8572 }
          CFI EndBlock cfiBlock176
// 8573 
// 8574 /*
// 8575  * Write application data, doing 1/n-1 splitting if necessary.
// 8576  *
// 8577  * With non-blocking I/O, ssl_write_real() may return WANT_WRITE,
// 8578  * then the caller will call us again with the same arguments, so
// 8579  * remember whether we already did the split or not.
// 8580  */
// 8581 #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock177 Using cfiCommon0
          CFI Function ssl_write_split
        THUMB
// 8582 static int ssl_write_split( mbedtls_ssl_context *ssl,
// 8583                             const unsigned char *buf, size_t len )
// 8584 {
ssl_write_split:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
// 8585     int ret;
// 8586 
// 8587     if( ssl->conf->cbc_record_splitting ==
// 8588             MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED ||
// 8589         len <= 1 ||
// 8590         ssl->minor_ver > MBEDTLS_SSL_MINOR_VERSION_1 ||
// 8591         mbedtls_cipher_get_cipher_mode( &ssl->transform_out->cipher_ctx_enc )
// 8592                                 != MBEDTLS_MODE_CBC )
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+204]
        UBFX     R0,R0,#+12,#+1
        CMP      R0,#+0
        BEQ.N    ??ssl_write_split_0
        CMP      R6,#+2
        BCC.N    ??ssl_write_split_0
        LDR      R0,[R4, #+20]
        CMP      R0,#+2
        BGE.N    ??ssl_write_split_0
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+80
          CFI FunCall mbedtls_cipher_get_cipher_mode
        BL       mbedtls_cipher_get_cipher_mode
        CMP      R0,#+2
        BEQ.N    ??ssl_write_split_1
// 8593     {
// 8594         return( ssl_write_real( ssl, buf, len ) );
??ssl_write_split_0:
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall ssl_write_real
        B.N      ssl_write_real
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 8595     }
// 8596 
// 8597     if( ssl->split_done == 0 )
??ssl_write_split_1:
        LDRSB    R0,[R4, #+222]
        CMP      R0,#+0
        BNE.N    ??ssl_write_split_2
// 8598     {
// 8599         if( ( ret = ssl_write_real( ssl, buf, 1 ) ) <= 0 )
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall ssl_write_real
        BL       ssl_write_real
        CMP      R0,#+1
        BLT.N    ??ssl_write_split_3
// 8600             return( ret );
// 8601         ssl->split_done = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+222]
// 8602     }
// 8603 
// 8604     if( ( ret = ssl_write_real( ssl, buf + 1, len - 1 ) ) <= 0 )
??ssl_write_split_2:
        SUBS     R6,R6,#+1
        MOV      R2,R6
        ADDS     R1,R5,#+1
        MOV      R0,R4
          CFI FunCall ssl_write_real
        BL       ssl_write_real
        CMP      R0,#+1
        BLT.N    ??ssl_write_split_3
// 8605         return( ret );
// 8606     ssl->split_done = 0;
        MOVS     R1,#+0
        STRB     R1,[R4, #+222]
// 8607 
// 8608     return( ret + 1 );
        ADDS     R0,R0,#+1
??ssl_write_split_3:
        POP      {R4-R6,PC}       ;; return
// 8609 }
          CFI EndBlock cfiBlock177
// 8610 #endif /* MBEDTLS_SSL_CBC_RECORD_SPLITTING */
// 8611 
// 8612 /*
// 8613  * Write application data (public-facing wrapper)
// 8614  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock178 Using cfiCommon0
          CFI Function mbedtls_ssl_write
        THUMB
// 8615 int mbedtls_ssl_write( mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len )
// 8616 {
mbedtls_ssl_write:
        PUSH     {R2-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R7,R1
        MOV      R8,R2
// 8617     int ret;
// 8618 
// 8619     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write" ) );
        LDR.W    R6,??DataTable80_7
        LDR.W    R0,??DataTable84_5
        STR      R0,[SP, #+0]
        MOVW     R3,#+8619
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8620 
// 8621     if( ssl == NULL || ssl->conf == NULL )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_write_0
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_write_1
// 8622         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_write_0:
        LDR.W    R0,??DataTable80  ;; 0xffff8f00
        B.N      ??mbedtls_ssl_write_2
// 8623 
// 8624 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 8625     if( ( ret = ssl_check_ctr_renegotiate( ssl ) ) != 0 )
??mbedtls_ssl_write_1:
        MOV      R0,R4
          CFI FunCall ssl_check_ctr_renegotiate
        BL       ssl_check_ctr_renegotiate
        MOVS     R5,R0
        BEQ.N    ??mbedtls_ssl_write_3
// 8626     {
// 8627         MBEDTLS_SSL_DEBUG_RET( 1, "ssl_check_ctr_renegotiate", ret );
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable81_1
        STR      R0,[SP, #+0]
        MOVW     R3,#+8627
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8628         return( ret );
        MOV      R0,R5
        B.N      ??mbedtls_ssl_write_2
// 8629     }
// 8630 #endif
// 8631 
// 8632     if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
??mbedtls_ssl_write_3:
        LDR      R0,[R4, #+4]
        CMP      R0,#+16
        BEQ.N    ??mbedtls_ssl_write_4
// 8633     {
// 8634         if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_handshake
        BL       mbedtls_ssl_handshake
        MOVS     R5,R0
        BEQ.N    ??mbedtls_ssl_write_4
// 8635         {
// 8636             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable80_4
        STR      R0,[SP, #+0]
        MOVW     R3,#+8636
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8637             return( ret );
        MOV      R0,R5
        B.N      ??mbedtls_ssl_write_2
// 8638         }
// 8639     }
// 8640 
// 8641 #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
// 8642     ret = ssl_write_split( ssl, buf, len );
??mbedtls_ssl_write_4:
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R4
          CFI FunCall ssl_write_split
        BL       ssl_write_split
        MOV      R5,R0
// 8643 #else
// 8644     ret = ssl_write_real( ssl, buf, len );
// 8645 #endif
// 8646 
// 8647     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write" ) );
        LDR.W    R0,??DataTable84_6
        STR      R0,[SP, #+0]
        MOVW     R3,#+8647
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8648 
// 8649     return( ret );
        MOV      R0,R5
??mbedtls_ssl_write_2:
        POP      {R1,R2,R4-R8,PC}  ;; return
// 8650 }
          CFI EndBlock cfiBlock178

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable77:
        DATA32
        DC32     ?_254

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable77_1:
        DATA32
        DC32     ?_255

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable77_2:
        DATA32
        DC32     ?_256

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable77_3:
        DATA32
        DC32     ?_257
// 8651 
// 8652 /*
// 8653  * Notify the peer that the connection is being closed
// 8654  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock179 Using cfiCommon0
          CFI Function mbedtls_ssl_close_notify
        THUMB
// 8655 int mbedtls_ssl_close_notify( mbedtls_ssl_context *ssl )
// 8656 {
mbedtls_ssl_close_notify:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOVS     R4,R0
// 8657     int ret;
// 8658 
// 8659     if( ssl == NULL || ssl->conf == NULL )
        BEQ.N    ??mbedtls_ssl_close_notify_0
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_close_notify_1
// 8660         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
??mbedtls_ssl_close_notify_0:
        LDR.W    R0,??DataTable80  ;; 0xffff8f00
        POP      {R1,R2,R4-R6,PC}
// 8661 
// 8662     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write close notify" ) );
??mbedtls_ssl_close_notify_1:
        LDR.W    R6,??DataTable80_7
        LDR.W    R0,??DataTable84_7
        STR      R0,[SP, #+0]
        MOVW     R3,#+8662
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8663 
// 8664     if( ssl->out_left != 0 )
        LDR      R0,[R4, #+208]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_close_notify_2
// 8665         return( mbedtls_ssl_flush_output( ssl ) );
        MOV      R0,R4
        POP      {R1,R2,R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_ssl_flush_output
        B.W      mbedtls_ssl_flush_output
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
// 8666 
// 8667     if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
??mbedtls_ssl_close_notify_2:
        LDR      R0,[R4, #+4]
        CMP      R0,#+16
        BNE.N    ??mbedtls_ssl_close_notify_3
// 8668     {
// 8669         if( ( ret = mbedtls_ssl_send_alert_message( ssl,
// 8670                         MBEDTLS_SSL_ALERT_LEVEL_WARNING,
// 8671                         MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY ) ) != 0 )
        MOVS     R2,#+0
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
        MOVS     R5,R0
        BEQ.N    ??mbedtls_ssl_close_notify_3
// 8672         {
// 8673             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_send_alert_message", ret );
        STR      R5,[SP, #+4]
        LDR.W    R0,??DataTable84_8
        STR      R0,[SP, #+0]
        MOVW     R3,#+8673
        MOV      R2,R6
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 8674             return( ret );
        MOV      R0,R5
        POP      {R1,R2,R4-R6,PC}
// 8675         }
// 8676     }
// 8677 
// 8678     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write close notify" ) );
??mbedtls_ssl_close_notify_3:
        LDR.W    R0,??DataTable84_9
        STR      R0,[SP, #+0]
        MOVW     R3,#+8678
        MOV      R2,R6
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8679 
// 8680     return( 0 );
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
// 8681 }
          CFI EndBlock cfiBlock179

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78:
        DATA32
        DC32     ?_258

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_1:
        DATA32
        DC32     ?_259

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_2:
        DATA32
        DC32     ?_260

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_3:
        DATA32
        DC32     ?_261

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_4:
        DATA32
        DC32     ?_262

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_5:
        DATA32
        DC32     ?_263

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_6:
        DATA32
        DC32     ?_264

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_7:
        DATA32
        DC32     ?_265

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_8:
        DATA32
        DC32     ?_266

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_9:
        DATA32
        DC32     ?_7

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_10:
        DATA32
        DC32     ?_267
// 8682 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock180 Using cfiCommon0
          CFI Function mbedtls_ssl_transform_free
        THUMB
// 8683 void mbedtls_ssl_transform_free( mbedtls_ssl_transform *transform )
// 8684 {
mbedtls_ssl_transform_free:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
// 8685     if( transform == NULL )
        BEQ.N    ??mbedtls_ssl_transform_free_0
// 8686         return;
// 8687 
// 8688 #if defined(MBEDTLS_ZLIB_SUPPORT)
// 8689     deflateEnd( &transform->ctx_deflate );
// 8690     inflateEnd( &transform->ctx_inflate );
// 8691 #endif
// 8692 
// 8693     mbedtls_cipher_free( &transform->cipher_ctx_enc );
        ADD      R0,R4,#+80
          CFI FunCall mbedtls_cipher_free
        BL       mbedtls_cipher_free
// 8694     mbedtls_cipher_free( &transform->cipher_ctx_dec );
        ADD      R0,R4,#+144
          CFI FunCall mbedtls_cipher_free
        BL       mbedtls_cipher_free
// 8695 
// 8696     mbedtls_md_free( &transform->md_ctx_enc );
        ADD      R0,R4,#+56
          CFI FunCall mbedtls_md_free
        BL       mbedtls_md_free
// 8697     mbedtls_md_free( &transform->md_ctx_dec );
        ADD      R0,R4,#+68
          CFI FunCall mbedtls_md_free
        BL       mbedtls_md_free
// 8698 
// 8699     mbedtls_platform_zeroize( transform, sizeof( mbedtls_ssl_transform ) );
        MOVS     R1,#+208
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_platform_zeroize
        B.W      mbedtls_platform_zeroize
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??mbedtls_ssl_transform_free_0:
        POP      {R4,PC}          ;; return
// 8700 }
          CFI EndBlock cfiBlock180
// 8701 
// 8702 #if defined(MBEDTLS_X509_CRT_PARSE_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock181 Using cfiCommon0
          CFI Function ssl_key_cert_free
        THUMB
// 8703 static void ssl_key_cert_free( mbedtls_ssl_key_cert *key_cert )
// 8704 {
ssl_key_cert_free:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 8705     mbedtls_ssl_key_cert *cur = key_cert, *next;
        CMP      R0,#+0
        B.N      ??ssl_key_cert_free_0
// 8706 
// 8707     while( cur != NULL )
// 8708     {
// 8709         next = cur->next;
??ssl_key_cert_free_1:
        LDR      R4,[R0, #+8]
// 8710         mbedtls_free( cur );
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8711         cur = next;
        MOVS     R0,R4
// 8712     }
??ssl_key_cert_free_0:
        BNE.N    ??ssl_key_cert_free_1
// 8713 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock181
// 8714 #endif /* MBEDTLS_X509_CRT_PARSE_C */
// 8715 
// 8716 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 8717 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock182 Using cfiCommon0
          CFI Function ssl_buffering_free
        THUMB
// 8718 static void ssl_buffering_free( mbedtls_ssl_context *ssl )
// 8719 {
ssl_buffering_free:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 8720     unsigned offset;
// 8721     mbedtls_ssl_handshake_params * const hs = ssl->handshake;
// 8722 
// 8723     if( hs == NULL )
        LDR      R0,[R4, #+60]
        CMP      R0,#+0
        BEQ.N    ??ssl_buffering_free_0
// 8724         return;
// 8725 
// 8726     ssl_free_buffered_record( ssl );
        MOV      R0,R4
          CFI FunCall ssl_free_buffered_record
        BL       ssl_free_buffered_record
// 8727 
// 8728     for( offset = 0; offset < MBEDTLS_SSL_MAX_BUFFERED_HS; offset++ )
        MOVS     R5,#+0
        B.N      ??ssl_buffering_free_1
// 8729         ssl_buffering_free_slot( ssl, offset );
??ssl_buffering_free_2:
        MOV      R1,R5
        UXTB     R1,R1
        MOV      R0,R4
          CFI FunCall ssl_buffering_free_slot
        BL       ssl_buffering_free_slot
        ADDS     R5,R5,#+1
??ssl_buffering_free_1:
        CMP      R5,#+4
        BCC.N    ??ssl_buffering_free_2
// 8730 }
??ssl_buffering_free_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock182
// 8731 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock183 Using cfiCommon0
          CFI Function ssl_buffering_free_slot
        THUMB
// 8732 static void ssl_buffering_free_slot( mbedtls_ssl_context *ssl,
// 8733                                      uint8_t slot )
// 8734 {
ssl_buffering_free_slot:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 8735     mbedtls_ssl_handshake_params * const hs = ssl->handshake;
        LDR      R2,[R0, #+60]
// 8736     mbedtls_ssl_hs_buffer * const hs_buf = &hs->buffering.hs[slot];
        MOV      R0,R1
        ADD      R3,R0,R0, LSL #+1
        ADD      R0,R2,R3, LSL #+2
        ADD      R4,R0,#+528
// 8737 
// 8738     if( slot >= MBEDTLS_SSL_MAX_BUFFERED_HS )
        CMP      R1,#+4
        BGE.N    ??ssl_buffering_free_slot_0
// 8739         return;
// 8740 
// 8741     if( hs_buf->is_valid == 1 )
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??ssl_buffering_free_slot_0
// 8742     {
// 8743         hs->buffering.total_bytes_buffered -= hs_buf->data_len;
        LDR      R1,[R2, #+520]
        LDR      R0,[R4, #+8]
        SUBS     R1,R1,R0
        STR      R1,[R2, #+520]
// 8744         mbedtls_free( hs_buf->data );
        LDR      R0,[R4, #+4]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8745         memset( hs_buf, 0, sizeof( mbedtls_ssl_hs_buffer ) );
        MOVS     R2,#+0
        MOVS     R1,#+12
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_memset4
        B.W      __aeabi_memset4
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 8746     }
// 8747 }
??ssl_buffering_free_slot_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock183
// 8748 
// 8749 #endif /* MBEDTLS_SSL_PROTO_DTLS */
// 8750 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock184 Using cfiCommon0
          CFI Function mbedtls_ssl_handshake_free
        THUMB
// 8751 void mbedtls_ssl_handshake_free( mbedtls_ssl_context *ssl )
// 8752 {
mbedtls_ssl_handshake_free:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
// 8753     mbedtls_ssl_handshake_params *handshake = ssl->handshake;
        LDR      R4,[R5, #+60]
// 8754 
// 8755     if( handshake == NULL )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_handshake_free_0
// 8756         return;
// 8757 
// 8758 #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
// 8759     if( ssl->conf->f_async_cancel != NULL && handshake->async_in_progress != 0 )
// 8760     {
// 8761         ssl->conf->f_async_cancel( ssl );
// 8762         handshake->async_in_progress = 0;
// 8763     }
// 8764 #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
// 8765 
// 8766 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ 
// 8767     defined(MBEDTLS_SSL_PROTO_TLS1_1)
// 8768     mbedtls_md5_free(    &handshake->fin_md5  );
        ADD      R0,R4,#+592
          CFI FunCall mbedtls_md5_free
        BL       mbedtls_md5_free
// 8769     mbedtls_sha1_free(   &handshake->fin_sha1 );
        ADD      R0,R4,#+680
          CFI FunCall mbedtls_sha1_free
        BL       mbedtls_sha1_free
// 8770 #endif
// 8771 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 8772 #if defined(MBEDTLS_SHA256_C)
// 8773     mbedtls_sha256_free(   &handshake->fin_sha256    );
        ADD      R0,R4,#+772
          CFI FunCall mbedtls_sha256_free
        BL       mbedtls_sha256_free
// 8774 #endif
// 8775 #if defined(MBEDTLS_SHA512_C)
// 8776     mbedtls_sha512_free(   &handshake->fin_sha512    );
        ADD      R0,R4,#+880
          CFI FunCall mbedtls_sha512_free
        BL       mbedtls_sha512_free
// 8777 #endif
// 8778 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 8779 
// 8780 #if defined(MBEDTLS_DHM_C)
// 8781     mbedtls_dhm_free( &handshake->dhm_ctx );
        ADDS     R0,R4,#+4
          CFI FunCall mbedtls_dhm_free
        BL       mbedtls_dhm_free
// 8782 #endif
// 8783 #if defined(MBEDTLS_ECDH_C)
// 8784     mbedtls_ecdh_free( &handshake->ecdh_ctx );
        ADD      R0,R4,#+128
          CFI FunCall mbedtls_ecdh_free
        BL       mbedtls_ecdh_free
// 8785 #endif
// 8786 #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
// 8787     mbedtls_ecjpake_free( &handshake->ecjpake_ctx );
// 8788 #if defined(MBEDTLS_SSL_CLI_C)
// 8789     mbedtls_free( handshake->ecjpake_cache );
// 8790     handshake->ecjpake_cache = NULL;
// 8791     handshake->ecjpake_cache_len = 0;
// 8792 #endif
// 8793 #endif
// 8794 
// 8795 #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \ 
// 8796     defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
// 8797     /* explicit void pointer cast for buggy MS compiler */
// 8798     mbedtls_free( (void *) handshake->curves );
        LDR      R0,[R4, #+436]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8799 #endif
// 8800 
// 8801 #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
// 8802     if( handshake->psk != NULL )
        LDR      R0,[R4, #+440]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handshake_free_1
// 8803     {
// 8804         mbedtls_platform_zeroize( handshake->psk, handshake->psk_len );
        LDR      R1,[R4, #+444]
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 8805         mbedtls_free( handshake->psk );
        LDR      R0,[R4, #+440]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8806     }
// 8807 #endif
// 8808 
// 8809 #if defined(MBEDTLS_X509_CRT_PARSE_C) && \ 
// 8810     defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
// 8811     /*
// 8812      * Free only the linked list wrapper, not the keys themselves
// 8813      * since the belong to the SNI callback
// 8814      */
// 8815     if( handshake->sni_key_cert != NULL )
??mbedtls_ssl_handshake_free_1:
        LDR      R0,[R4, #+456]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_handshake_free_2
// 8816     {
// 8817         mbedtls_ssl_key_cert *cur = handshake->sni_key_cert, *next;
        B.N      ??mbedtls_ssl_handshake_free_3
// 8818 
// 8819         while( cur != NULL )
// 8820         {
// 8821             next = cur->next;
??mbedtls_ssl_handshake_free_4:
        LDR      R6,[R0, #+8]
// 8822             mbedtls_free( cur );
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8823             cur = next;
        MOVS     R0,R6
// 8824         }
??mbedtls_ssl_handshake_free_3:
        BNE.N    ??mbedtls_ssl_handshake_free_4
// 8825     }
// 8826 #endif /* MBEDTLS_X509_CRT_PARSE_C && MBEDTLS_SSL_SERVER_NAME_INDICATION */
// 8827 
// 8828 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 8829     mbedtls_free( handshake->verify_cookie );
??mbedtls_ssl_handshake_free_2:
        LDR      R0,[R4, #+476]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8830     ssl_flight_free( handshake->flight );
        LDR      R0,[R4, #+492]
          CFI FunCall ssl_flight_free
        BL       ssl_flight_free
// 8831     ssl_buffering_free( ssl );
        MOV      R0,R5
          CFI FunCall ssl_buffering_free
        BL       ssl_buffering_free
// 8832 #endif
// 8833 
// 8834     mbedtls_platform_zeroize( handshake,
// 8835                               sizeof( mbedtls_ssl_handshake_params ) );
        MOV      R1,#+1752
        MOV      R0,R4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_platform_zeroize
        B.W      mbedtls_platform_zeroize
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mbedtls_ssl_handshake_free_0:
        POP      {R4-R6,PC}       ;; return
// 8836 }
          CFI EndBlock cfiBlock184
// 8837 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock185 Using cfiCommon0
          CFI Function mbedtls_ssl_session_free
        THUMB
// 8838 void mbedtls_ssl_session_free( mbedtls_ssl_session *session )
// 8839 {
mbedtls_ssl_session_free:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
// 8840     if( session == NULL )
        BEQ.N    ??mbedtls_ssl_session_free_0
// 8841         return;
// 8842 
// 8843 #if defined(MBEDTLS_X509_CRT_PARSE_C)
// 8844     if( session->peer_cert != NULL )
        LDR      R0,[R4, #+92]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_session_free_1
// 8845     {
// 8846         mbedtls_x509_crt_free( session->peer_cert );
          CFI FunCall mbedtls_x509_crt_free
        BL       mbedtls_x509_crt_free
// 8847         mbedtls_free( session->peer_cert );
        LDR      R0,[R4, #+92]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8848     }
// 8849 #endif
// 8850 
// 8851 #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
// 8852     mbedtls_free( session->ticket );
??mbedtls_ssl_session_free_1:
        LDR      R0,[R4, #+100]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8853 #endif
// 8854 
// 8855     mbedtls_platform_zeroize( session, sizeof( mbedtls_ssl_session ) );
        MOVS     R1,#+124
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_platform_zeroize
        B.W      mbedtls_platform_zeroize
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??mbedtls_ssl_session_free_0:
        POP      {R4,PC}          ;; return
// 8856 }
          CFI EndBlock cfiBlock185
// 8857 
// 8858 /*
// 8859  * Free an SSL context
// 8860  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock186 Using cfiCommon0
          CFI Function mbedtls_ssl_free
        THUMB
// 8861 void mbedtls_ssl_free( mbedtls_ssl_context *ssl )
// 8862 {
mbedtls_ssl_free:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
// 8863     if( ssl == NULL )
        BEQ.N    ??mbedtls_ssl_free_0
// 8864         return;
// 8865 
// 8866     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> free" ) );
        LDR.N    R5,??DataTable80_7
        LDR.W    R0,??DataTable84_10
        STR      R0,[SP, #+0]
        MOVW     R3,#+8866
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8867 
// 8868     if( ssl->out_buf != NULL )
        LDR      R0,[R4, #+176]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_free_1
// 8869     {
// 8870         mbedtls_platform_zeroize( ssl->out_buf, MBEDTLS_SSL_OUT_BUFFER_LEN );
        MOVW     R1,#+10573
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 8871         mbedtls_free( ssl->out_buf );
        LDR      R0,[R4, #+176]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8872     }
// 8873 
// 8874     if( ssl->in_buf != NULL )
??mbedtls_ssl_free_1:
        LDR      R0,[R4, #+92]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_free_2
// 8875     {
// 8876         mbedtls_platform_zeroize( ssl->in_buf, MBEDTLS_SSL_IN_BUFFER_LEN );
        MOVW     R1,#+10573
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 8877         mbedtls_free( ssl->in_buf );
        LDR      R0,[R4, #+92]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8878     }
// 8879 
// 8880 #if defined(MBEDTLS_ZLIB_SUPPORT)
// 8881     if( ssl->compress_buf != NULL )
// 8882     {
// 8883         mbedtls_platform_zeroize( ssl->compress_buf, MBEDTLS_SSL_COMPRESS_BUFFER_LEN );
// 8884         mbedtls_free( ssl->compress_buf );
// 8885     }
// 8886 #endif
// 8887 
// 8888     if( ssl->transform )
??mbedtls_ssl_free_2:
        LDR      R0,[R4, #+72]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_free_3
// 8889     {
// 8890         mbedtls_ssl_transform_free( ssl->transform );
          CFI FunCall mbedtls_ssl_transform_free
        BL       mbedtls_ssl_transform_free
// 8891         mbedtls_free( ssl->transform );
        LDR      R0,[R4, #+72]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8892     }
// 8893 
// 8894     if( ssl->handshake )
??mbedtls_ssl_free_3:
        LDR      R0,[R4, #+60]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_free_4
// 8895     {
// 8896         mbedtls_ssl_handshake_free( ssl );
        MOV      R0,R4
          CFI FunCall mbedtls_ssl_handshake_free
        BL       mbedtls_ssl_handshake_free
// 8897         mbedtls_ssl_transform_free( ssl->transform_negotiate );
        LDR      R0,[R4, #+76]
          CFI FunCall mbedtls_ssl_transform_free
        BL       mbedtls_ssl_transform_free
// 8898         mbedtls_ssl_session_free( ssl->session_negotiate );
        LDR      R0,[R4, #+56]
          CFI FunCall mbedtls_ssl_session_free
        BL       mbedtls_ssl_session_free
// 8899 
// 8900         mbedtls_free( ssl->handshake );
        LDR      R0,[R4, #+60]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8901         mbedtls_free( ssl->transform_negotiate );
        LDR      R0,[R4, #+76]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8902         mbedtls_free( ssl->session_negotiate );
        LDR      R0,[R4, #+56]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8903     }
// 8904 
// 8905     if( ssl->session )
??mbedtls_ssl_free_4:
        LDR      R0,[R4, #+52]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_free_5
// 8906     {
// 8907         mbedtls_ssl_session_free( ssl->session );
          CFI FunCall mbedtls_ssl_session_free
        BL       mbedtls_ssl_session_free
// 8908         mbedtls_free( ssl->session );
        LDR      R0,[R4, #+52]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8909     }
// 8910 
// 8911 #if defined(MBEDTLS_X509_CRT_PARSE_C)
// 8912     if( ssl->hostname != NULL )
??mbedtls_ssl_free_5:
        LDR      R0,[R4, #+228]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_free_6
// 8913     {
// 8914         mbedtls_platform_zeroize( ssl->hostname, strlen( ssl->hostname ) );
          CFI FunCall strlen
        BL       strlen
        MOV      R1,R0
        LDR      R0,[R4, #+228]
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 8915         mbedtls_free( ssl->hostname );
        LDR      R0,[R4, #+228]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8916     }
// 8917 #endif
// 8918 
// 8919 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
// 8920     if( mbedtls_ssl_hw_record_finish != NULL )
// 8921     {
// 8922         MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_finish()" ) );
// 8923         mbedtls_ssl_hw_record_finish( ssl );
// 8924     }
// 8925 #endif
// 8926 
// 8927 #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
// 8928     mbedtls_free( ssl->cli_id );
??mbedtls_ssl_free_6:
        LDR      R0,[R4, #+236]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 8929 #endif
// 8930 
// 8931     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= free" ) );
        LDR.W    R0,??DataTable84_11
        STR      R0,[SP, #+0]
        MOVW     R3,#+8931
        MOV      R2,R5
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall mbedtls_debug_print_msg
        BL       mbedtls_debug_print_msg
// 8932 
// 8933     /* Actually clear after last debug message */
// 8934     mbedtls_platform_zeroize( ssl, sizeof( mbedtls_ssl_context ) );
        MOV      R1,#+280
        MOV      R0,R4
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_platform_zeroize
        B.W      mbedtls_platform_zeroize
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mbedtls_ssl_free_0:
        POP      {R0,R4,R5,PC}    ;; return
// 8935 }
          CFI EndBlock cfiBlock186

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable79:
        DATA32
        DC32     0xffff9400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable79_1:
        DATA32
        DC32     0xffff8f80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable79_2:
        DATA32
        DC32     ?_268

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable79_3:
        DATA32
        DC32     ?_270

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable79_4:
        DATA32
        DC32     ?_203
// 8936 
// 8937 /*
// 8938  * Initialze mbedtls_ssl_config
// 8939  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock187 Using cfiCommon0
          CFI Function mbedtls_ssl_config_init
        THUMB
// 8940 void mbedtls_ssl_config_init( mbedtls_ssl_config *conf )
// 8941 {
// 8942     memset( conf, 0, sizeof( mbedtls_ssl_config ) );
mbedtls_ssl_config_init:
        MOVS     R2,#+0
        MOVS     R1,#+208
          CFI FunCall __aeabi_memset4
        B.W      __aeabi_memset4
// 8943 }
          CFI EndBlock cfiBlock187
// 8944 
// 8945 #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
// 8946 static int ssl_preset_default_hashes[] = {
ssl_preset_default_hashes:
        DATA32
        DC32 8, 7, 6, 5, 4, 0
// 8947 #if defined(MBEDTLS_SHA512_C)
// 8948     MBEDTLS_MD_SHA512,
// 8949     MBEDTLS_MD_SHA384,
// 8950 #endif
// 8951 #if defined(MBEDTLS_SHA256_C)
// 8952     MBEDTLS_MD_SHA256,
// 8953     MBEDTLS_MD_SHA224,
// 8954 #endif
// 8955 #if defined(MBEDTLS_SHA1_C) && defined(MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_KEY_EXCHANGE)
// 8956     MBEDTLS_MD_SHA1,
// 8957 #endif
// 8958     MBEDTLS_MD_NONE
// 8959 };
// 8960 #endif
// 8961 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
// 8962 static int ssl_preset_suiteb_ciphersuites[] = {
ssl_preset_suiteb_ciphersuites:
        DATA32
        DC32 49195, 49196, 0
// 8963     MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
// 8964     MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
// 8965     0
// 8966 };
// 8967 
// 8968 #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
// 8969 static int ssl_preset_suiteb_hashes[] = {
ssl_preset_suiteb_hashes:
        DATA32
        DC32 6, 7, 0
// 8970     MBEDTLS_MD_SHA256,
// 8971     MBEDTLS_MD_SHA384,
// 8972     MBEDTLS_MD_NONE
// 8973 };
// 8974 #endif
// 8975 
// 8976 #if defined(MBEDTLS_ECP_C)

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
// 8977 static mbedtls_ecp_group_id ssl_preset_suiteb_curves[] = {
ssl_preset_suiteb_curves:
        DATA8
        DC8 3, 4, 0, 0
// 8978     MBEDTLS_ECP_DP_SECP256R1,
// 8979     MBEDTLS_ECP_DP_SECP384R1,
// 8980     MBEDTLS_ECP_DP_NONE
// 8981 };
// 8982 #endif
// 8983 
// 8984 /*
// 8985  * Load default in mbedtls_ssl_config
// 8986  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock188 Using cfiCommon0
          CFI Function mbedtls_ssl_config_defaults
        THUMB
// 8987 int mbedtls_ssl_config_defaults( mbedtls_ssl_config *conf,
// 8988                                  int endpoint, int transport, int preset )
// 8989 {
mbedtls_ssl_config_defaults:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R5,R0
        MOV      R4,R1
        MOV      R6,R2
        MOV      R7,R3
// 8990 #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)
// 8991     int ret;
// 8992 #endif
// 8993 
// 8994     /* Use the functions here so that they are covered in tests,
// 8995      * but otherwise access member directly for efficiency */
// 8996     mbedtls_ssl_conf_endpoint( conf, endpoint );
          CFI FunCall mbedtls_ssl_conf_endpoint
        BL       mbedtls_ssl_conf_endpoint
// 8997     mbedtls_ssl_conf_transport( conf, transport );
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_conf_transport
        BL       mbedtls_ssl_conf_transport
// 8998 
// 8999     /*
// 9000      * Things that are common to all presets
// 9001      */
// 9002 #if defined(MBEDTLS_SSL_CLI_C)
// 9003     if( endpoint == MBEDTLS_SSL_IS_CLIENT )
        CMP      R4,#+0
        BNE.N    ??mbedtls_ssl_config_defaults_0
// 9004     {
// 9005         conf->authmode = MBEDTLS_SSL_VERIFY_REQUIRED;
        MOVS     R0,#+2
        LDR      R1,[R5, #+204]
        BFI      R1,R0,#+2,#+2
        STR      R1,[R5, #+204]
// 9006 #if defined(MBEDTLS_SSL_SESSION_TICKETS)
// 9007         conf->session_tickets = MBEDTLS_SSL_SESSION_TICKETS_ENABLED;
        MOV      R0,R1
        ORR      R0,R0,#0x8000
        STR      R0,[R5, #+204]
// 9008 #endif
// 9009     }
// 9010 #endif
// 9011 
// 9012 #if defined(MBEDTLS_ARC4_C)
// 9013     conf->arc4_disabled = MBEDTLS_SSL_ARC4_DISABLED;
// 9014 #endif
// 9015 
// 9016 #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
// 9017     conf->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
??mbedtls_ssl_config_defaults_0:
        LDR      R0,[R5, #+204]
        ORR      R0,R0,#0x200
        STR      R0,[R5, #+204]
// 9018 #endif
// 9019 
// 9020 #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
// 9021     conf->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
        LDR      R0,[R5, #+204]
        ORR      R0,R0,#0x400
        STR      R0,[R5, #+204]
// 9022 #endif
// 9023 
// 9024 #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
// 9025     conf->cbc_record_splitting = MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED;
        ORR      R0,R0,#0x1000
        STR      R0,[R5, #+204]
// 9026 #endif
// 9027 
// 9028 #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
// 9029     conf->f_cookie_write = ssl_cookie_write_dummy;
        LDR.W    R0,??DataTable84_12
        STR      R0,[R5, #+68]
// 9030     conf->f_cookie_check = ssl_cookie_check_dummy;
        LDR.W    R0,??DataTable84_13
        STR      R0,[R5, #+72]
// 9031 #endif
// 9032 
// 9033 #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
// 9034     conf->anti_replay = MBEDTLS_SSL_ANTI_REPLAY_ENABLED;
        LDR      R0,[R5, #+204]
        ORR      R0,R0,#0x800
        STR      R0,[R5, #+204]
// 9035 #endif
// 9036 
// 9037 #if defined(MBEDTLS_SSL_SRV_C)
// 9038     conf->cert_req_ca_list = MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED;
        LDR      R0,[R5, #+204]
        ORR      R0,R0,#0x20000
        STR      R0,[R5, #+204]
// 9039 #endif
// 9040 
// 9041 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 9042     conf->hs_timeout_min = MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN;
        MOV      R0,#+1000
        STR      R0,[R5, #+172]
// 9043     conf->hs_timeout_max = MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX;
        MOVW     R0,#+60000
        STR      R0,[R5, #+176]
// 9044 #endif
// 9045 
// 9046 #if defined(MBEDTLS_SSL_RENEGOTIATION)
// 9047     conf->renego_max_records = MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT;
        MOVS     R0,#+16
        STR      R0,[R5, #+180]
// 9048     memset( conf->renego_period,     0x00, 2 );
        MOVS     R2,#+0
        MOVS     R1,#+2
        ADD      R0,R5,#+184
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 9049     memset( conf->renego_period + 2, 0xFF, 6 );
        MOVS     R2,#+255
        MOVS     R1,#+6
        ADD      R0,R5,#+186
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 9050 #endif
// 9051 
// 9052 #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)
// 9053             if( endpoint == MBEDTLS_SSL_IS_SERVER )
        CMP      R4,#+1
        BNE.N    ??mbedtls_ssl_config_defaults_1
// 9054             {
// 9055                 const unsigned char dhm_p[] =
// 9056                     MBEDTLS_DHM_RFC3526_MODP_2048_P_BIN;
// 9057                 const unsigned char dhm_g[] =
// 9058                     MBEDTLS_DHM_RFC3526_MODP_2048_G_BIN;
// 9059 
// 9060                 if ( ( ret = mbedtls_ssl_conf_dh_param_bin( conf,
// 9061                                                dhm_p, sizeof( dhm_p ),
// 9062                                                dhm_g, sizeof( dhm_g ) ) ) != 0 )
        MOVS     R0,#+1
        STR      R0,[SP, #+0]
        LDR.W    R3,??DataTable84_14
        MOV      R2,#+256
        LDR.W    R1,??DataTable84_15
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_conf_dh_param_bin
        BL       mbedtls_ssl_conf_dh_param_bin
        CMP      R0,#+0
        BNE.N    ??mbedtls_ssl_config_defaults_2
// 9063                 {
// 9064                     return( ret );
// 9065                 }
// 9066             }
// 9067 #endif
// 9068 
// 9069     /*
// 9070      * Preset-specific defaults
// 9071      */
// 9072     switch( preset )
??mbedtls_ssl_config_defaults_1:
        CMP      R7,#+2
        BNE.N    ??mbedtls_ssl_config_defaults_3
// 9073     {
// 9074         /*
// 9075          * NSA Suite B
// 9076          */
// 9077         case MBEDTLS_SSL_PRESET_SUITEB:
// 9078             conf->min_major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;
        MOVS     R0,#+3
        STRB     R0,[R5, #+202]
// 9079             conf->min_minor_ver = MBEDTLS_SSL_MINOR_VERSION_3; /* TLS 1.2 */
        STRB     R0,[R5, #+203]
// 9080             conf->max_major_ver = MBEDTLS_SSL_MAX_MAJOR_VERSION;
        STRB     R0,[R5, #+200]
// 9081             conf->max_minor_ver = MBEDTLS_SSL_MAX_MINOR_VERSION;
        STRB     R0,[R5, #+201]
// 9082 
// 9083             conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] =
// 9084             conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] =
// 9085             conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] =
// 9086             conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] =
// 9087                                    ssl_preset_suiteb_ciphersuites;
        LDR.W    R0,??DataTable84_16
        STR      R0,[R5, #+12]
        STR      R0,[R5, #+8]
        STR      R0,[R5, #+4]
        STR      R0,[R5, #+0]
// 9088 
// 9089 #if defined(MBEDTLS_X509_CRT_PARSE_C)
// 9090             conf->cert_profile = &mbedtls_x509_crt_profile_suiteb;
        LDR.W    R0,??DataTable84_17
        STR      R0,[R5, #+100]
// 9091 #endif
// 9092 
// 9093 #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
// 9094             conf->sig_hashes = ssl_preset_suiteb_hashes;
        LDR.W    R0,??DataTable84_18
        STR      R0,[R5, #+116]
// 9095 #endif
// 9096 
// 9097 #if defined(MBEDTLS_ECP_C)
// 9098             conf->curve_list = ssl_preset_suiteb_curves;
        LDR.W    R0,??DataTable84_19
        STR      R0,[R5, #+120]
// 9099 #endif
// 9100             break;
        B.N      ??mbedtls_ssl_config_defaults_4
// 9101 
// 9102         /*
// 9103          * Default
// 9104          */
// 9105         default:
// 9106             conf->min_major_ver = ( MBEDTLS_SSL_MIN_MAJOR_VERSION >
// 9107                                     MBEDTLS_SSL_MIN_VALID_MAJOR_VERSION ) ?
// 9108                                     MBEDTLS_SSL_MIN_MAJOR_VERSION :
// 9109                                     MBEDTLS_SSL_MIN_VALID_MAJOR_VERSION;
??mbedtls_ssl_config_defaults_3:
        MOVS     R0,#+3
        STRB     R0,[R5, #+202]
// 9110             conf->min_minor_ver = ( MBEDTLS_SSL_MIN_MINOR_VERSION >
// 9111                                     MBEDTLS_SSL_MIN_VALID_MINOR_VERSION ) ?
// 9112                                     MBEDTLS_SSL_MIN_MINOR_VERSION :
// 9113                                     MBEDTLS_SSL_MIN_VALID_MINOR_VERSION;
        MOVS     R0,#+1
        STRB     R0,[R5, #+203]
// 9114             conf->max_major_ver = MBEDTLS_SSL_MAX_MAJOR_VERSION;
        MOVS     R0,#+3
        STRB     R0,[R5, #+200]
// 9115             conf->max_minor_ver = MBEDTLS_SSL_MAX_MINOR_VERSION;
        STRB     R0,[R5, #+201]
// 9116 
// 9117 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 9118             if( transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        CMP      R6,#+1
        BNE.N    ??mbedtls_ssl_config_defaults_5
// 9119                 conf->min_minor_ver = MBEDTLS_SSL_MINOR_VERSION_2;
        MOVS     R0,#+2
        STRB     R0,[R5, #+203]
// 9120 #endif
// 9121 
// 9122             conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] =
// 9123             conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] =
// 9124             conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] =
// 9125             conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] =
// 9126                                    mbedtls_ssl_list_ciphersuites();
??mbedtls_ssl_config_defaults_5:
          CFI FunCall mbedtls_ssl_list_ciphersuites
        BL       mbedtls_ssl_list_ciphersuites
        STR      R0,[R5, #+12]
        STR      R0,[R5, #+8]
        STR      R0,[R5, #+4]
        STR      R0,[R5, #+0]
// 9127 
// 9128 #if defined(MBEDTLS_X509_CRT_PARSE_C)
// 9129             conf->cert_profile = &mbedtls_x509_crt_profile_default;
        LDR.W    R0,??DataTable84_20
        STR      R0,[R5, #+100]
// 9130 #endif
// 9131 
// 9132 #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
// 9133             conf->sig_hashes = ssl_preset_default_hashes;
        LDR.W    R0,??DataTable84_21
        STR      R0,[R5, #+116]
// 9134 #endif
// 9135 
// 9136 #if defined(MBEDTLS_ECP_C)
// 9137             conf->curve_list = mbedtls_ecp_grp_id_list();
          CFI FunCall mbedtls_ecp_grp_id_list
        BL       mbedtls_ecp_grp_id_list
        STR      R0,[R5, #+120]
// 9138 #endif
// 9139 
// 9140 #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)
// 9141             conf->dhm_min_bitlen = 1024;
        MOV      R0,#+1024
        STR      R0,[R5, #+196]
// 9142 #endif
// 9143     }
// 9144 
// 9145     return( 0 );
??mbedtls_ssl_config_defaults_4:
        MOVS     R0,#+0
??mbedtls_ssl_config_defaults_2:
        POP      {R1,R4-R7,PC}    ;; return
// 9146 }
          CFI EndBlock cfiBlock188

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80:
        DATA32
        DC32     0xffff8f00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80_1:
        DATA32
        DC32     ?_269

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80_2:
        DATA32
        DC32     ?_271

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80_3:
        DATA32
        DC32     ?_272

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80_4:
        DATA32
        DC32     ?_273

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80_5:
        DATA32
        DC32     ?_274

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80_6:
        DATA32
        DC32     ?_275

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80_7:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80_8:
        DATA32
        DC32     ?_276

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable80_9:
        DATA32
        DC32     ?_277

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_0:
        DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
        DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
        DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
        DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
        DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
        DC8 30H, 5CH, 6DH, 62H, 65H, 64H, 74H, 6CH
        DC8 73H, 5CH, 6CH, 69H, 62H, 72H, 61H, 72H
        DC8 79H, 5CH, 73H, 73H, 6CH, 5FH, 74H, 6CH
        DC8 73H, 2EH, 63H, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_1:
        DC8 "set_timer to %d ms"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_2:
        DC8 "timer expired"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_3:
        DC8 "update timeout value to %d millisecs"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_4:
        DC8 "=> derive keys"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_5:
        DC8 "cipher info for %d not found"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_6:
        DC8 "mbedtls_md info for %d not found"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_7:
        DC8 "should never happen"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_8:
        DC8 "premaster secret"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_9:
        DC8 "using extended master secret"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_10:
        DC8 "session hash"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_11:
        DC8 "extended master secret"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
        DC8 "prf"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_13:
        DC8 "master secret"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_14:
        DC8 "no premaster (session resumed)"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_15:
        DC8 "key expansion"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_16:
        DC8 "ciphersuite = %s"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_17:
        DC8 "random bytes"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_18:
        DC8 "key block"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_19:
        DC8 "mbedtls_md_setup"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_20:
        DC8 "keylen: %d, minlen: %d, ivlen: %d, maclen: %d"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_21:
        DC8 "mbedtls_cipher_setup"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_22:
        DC8 "mbedtls_cipher_setkey"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_23:
        DC8 "mbedtls_cipher_set_padding_mode"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_24:
        DC8 "<= derive keys"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_25:
        DC8 "=> calc verify tls"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_26:
        DC8 "calculated verify result"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_27:
        DC8 "<= calc verify"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_28:
        DC8 "=> calc verify sha256"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_29:
        DC8 "=> calc verify sha384"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_30:
        DC8 "mbedtls_dhm_calc_secret"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_31:
        DC8 "DHM: K "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_32:
        DC8 "mbedtls_ecdh_calc_secret"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_33:
        DC8 "ECDH: z"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_34:
        DC8 "=> encrypt buf"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_35:
        DC8 "before encrypt: output payload"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_36:
        DC8 "computed mac"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_37:
        DC8 "additional data for AEAD"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_38:
        DC8 "IV used (internal)"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_39:
        DC8 "IV used (transmitted)"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_40:
        DC8 62H, 65H, 66H, 6FH, 72H, 65H, 20H, 65H
        DC8 6EH, 63H, 72H, 79H, 70H, 74H, 3AH, 20H
        DC8 6DH, 73H, 67H, 6CH, 65H, 6EH, 20H, 3DH
        DC8 20H, 25H, 64H, 2CH, 20H, 69H, 6EH, 63H
        DC8 6CH, 75H, 64H, 69H, 6EH, 67H, 20H, 30H
        DC8 20H, 62H, 79H, 74H, 65H, 73H, 20H, 6FH
        DC8 66H, 20H, 70H, 61H, 64H, 64H, 69H, 6EH
        DC8 67H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_41:
        DC8 "mbedtls_cipher_auth_encrypt"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_42:
        DC8 "after encrypt: tag"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_43:
        DC8 62H, 65H, 66H, 6FH, 72H, 65H, 20H, 65H
        DC8 6EH, 63H, 72H, 79H, 70H, 74H, 3AH, 20H
        DC8 6DH, 73H, 67H, 6CH, 65H, 6EH, 20H, 3DH
        DC8 20H, 25H, 64H, 2CH, 20H, 69H, 6EH, 63H
        DC8 6CH, 75H, 64H, 69H, 6EH, 67H, 20H, 25H
        DC8 64H, 20H, 62H, 79H, 74H, 65H, 73H, 20H
        DC8 6FH, 66H, 20H, 49H, 56H, 20H, 61H, 6EH
        DC8 64H, 20H, 25H, 64H, 20H, 62H, 79H, 74H
        DC8 65H, 73H, 20H, 6FH, 66H, 20H, 70H, 61H
        DC8 64H, 64H, 69H, 6EH, 67H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_44:
        DC8 "mbedtls_cipher_crypt"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_45:
        DC8 "using encrypt then mac"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_46:
        DC8 "MAC'd meta-data"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_47:
        DC8 "<= encrypt buf"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_48:
        DC8 "=> decrypt buf"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_49:
        DC8 "in_msglen (%d) < minlen (%d)"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_50:
        DC8 "msglen (%d) < explicit_iv_len (%d) + taglen (%d)"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_51:
        DC8 "IV used"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_52:
        DC8 "TAG used"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_53:
        DC8 "mbedtls_cipher_auth_decrypt"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_54:
        DC8 6DH, 73H, 67H, 6CH, 65H, 6EH, 20H, 28H
        DC8 25H, 64H, 29H, 20H, 3CH, 20H, 6DH, 61H
        DC8 78H, 28H, 20H, 69H, 76H, 6CH, 65H, 6EH
        DC8 28H, 25H, 64H, 29H, 2CH, 20H, 6DH, 61H
        DC8 63H, 6CH, 65H, 6EH, 20H, 28H, 25H, 64H
        DC8 29H, 20H, 2BH, 20H, 31H, 20H, 29H, 20H
        DC8 28H, 20H, 2BH, 20H, 65H, 78H, 70H, 6CH
        DC8 20H, 49H, 56H, 20H, 29H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_55:
        DC8 "message  mac"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_56:
        DC8 "expected mac"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_57:
        DC8 "message mac does not match"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_58:
        DC8 "msglen (%d) %% ivlen (%d) != 0"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_59:
        DC8 "invalid zero-length message type: %d"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_60:
        DC8 72H, 65H, 63H, 65H, 69H, 76H, 65H, 64H
        DC8 20H, 66H, 6FH, 75H, 72H, 20H, 63H, 6FH
        DC8 6EH, 73H, 65H, 63H, 75H, 74H, 69H, 76H
        DC8 65H, 20H, 65H, 6DH, 70H, 74H, 79H, 20H
        DC8 6DH, 65H, 73H, 73H, 61H, 67H, 65H, 73H
        DC8 2CH, 20H, 70H, 6FH, 73H, 73H, 69H, 62H
        DC8 6CH, 65H, 20H, 44H, 6FH, 53H, 20H, 61H
        DC8 74H, 74H, 61H, 63H, 6BH, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_61:
        DC8 "incoming message counter would wrap"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_62:
        DC8 "<= decrypt buf"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_63:
        DC8 "no longer retransmitting hello request"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_64:
        DC8 "=> fetch input"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_65:
        DC8 42H, 61H, 64H, 20H, 75H, 73H, 61H, 67H
        DC8 65H, 20H, 6FH, 66H, 20H, 6DH, 62H, 65H
        DC8 64H, 74H, 6CH, 73H, 5FH, 73H, 73H, 6CH
        DC8 5FH, 73H, 65H, 74H, 5FH, 62H, 69H, 6FH
        DC8 28H, 29H, 20H, 6FH, 72H, 20H, 6DH, 62H
        DC8 65H, 64H, 74H, 6CH, 73H, 5FH, 73H, 73H
        DC8 6CH, 5FH, 73H, 65H, 74H, 5FH, 62H, 69H
        DC8 6FH, 28H, 29H, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_66:
        DC8 "requesting more data than fits"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_67:
        DC8 "You must use mbedtls_ssl_set_timer_cb() for DTLS"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_68:
        DC8 "next record in same datagram, offset: %d"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_69:
        DC8 "in_left: %d, nb_want: %d"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_70:
        DC8 "<= fetch input"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_71:
        DC8 "timer has expired"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_72:
        DC8 "f_recv_timeout: %u ms"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_73:
        DC8 "ssl->f_recv(_timeout)"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_74:
        DC8 "timeout"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_75:
        DC8 "handshake timeout"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_76:
        DC8 "mbedtls_ssl_resend"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_77:
        DC8 "ssl_resend_hello_request"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_78:
        DC8 66H, 5FH, 72H, 65H, 63H, 76H, 20H, 72H
        DC8 65H, 74H, 75H, 72H, 6EH, 65H, 64H, 20H
        DC8 25H, 64H, 20H, 62H, 79H, 74H, 65H, 73H
        DC8 20H, 62H, 75H, 74H, 20H, 6FH, 6EH, 6CH
        DC8 79H, 20H, 25H, 6CH, 75H, 20H, 77H, 65H
        DC8 72H, 65H, 20H, 72H, 65H, 71H, 75H, 65H
        DC8 73H, 74H, 65H, 64H, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_79:
        DC8 "=> flush output"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_80:
        DC8 "<= flush output"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_81:
        DC8 "message length: %d, out_left: %d"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_82:
        DC8 "ssl->f_send"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_83:
        DC8 66H, 5FH, 73H, 65H, 6EH, 64H, 20H, 72H
        DC8 65H, 74H, 75H, 72H, 6EH, 65H, 64H, 20H
        DC8 25H, 64H, 20H, 62H, 79H, 74H, 65H, 73H
        DC8 20H, 62H, 75H, 74H, 20H, 6FH, 6EH, 6CH
        DC8 79H, 20H, 25H, 6CH, 75H, 20H, 62H, 79H
        DC8 74H, 65H, 73H, 20H, 77H, 65H, 72H, 65H
        DC8 20H, 73H, 65H, 6EH, 74H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_84:
        DC8 "=> ssl_flight_append"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_85:
        DC8 "message appended to flight"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_86:
        DC8 "alloc %d bytes failed"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_87:
        DC8 "<= ssl_flight_append"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_88:
        DC8 "skip swap epochs"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_89:
        DC8 "swap epochs"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_90:
        DC8 "=> mbedtls_ssl_resend"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_91:
        DC8 "<= mbedtls_ssl_resend"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_92:
        DC8 "=> mbedtls_ssl_flight_transmit"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_93:
        DC8 "initialise flight transmission"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_94:
        DC8 "swap epochs to send finished message"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_95:
        DC8 "fragmenting handshake message (%u > %u)"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_96:
        DC8 "handshake header"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_97:
        DC8 "mbedtls_ssl_write_record"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_98:
        DC8 "<= mbedtls_ssl_flight_transmit"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_99:
        DC8 "=> write handshake message"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_100:
        DC8 "Record too large: size %u, maximum %u"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_101:
        DC8 44H, 54H, 4CH, 53H, 20H, 68H, 61H, 6EH
        DC8 64H, 73H, 68H, 61H, 6BH, 65H, 20H, 6DH
        DC8 65H, 73H, 73H, 61H, 67H, 65H, 20H, 74H
        DC8 6FH, 6FH, 20H, 6CH, 61H, 72H, 67H, 65H
        DC8 3AH, 20H, 73H, 69H, 7AH, 65H, 20H, 25H
        DC8 75H, 2CH, 20H, 6DH, 61H, 78H, 69H, 6DH
        DC8 75H, 6DH, 20H, 25H, 75H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_102:
        DC8 "ssl_flight_append"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_103:
        DC8 "ssl_write_record"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_104:
        DC8 "<= write handshake message"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_105:
        DC8 "=> write record"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_106:
        DC8 "ssl_encrypt_buf"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_107:
        DC8 6FH, 75H, 74H, 70H, 75H, 74H, 20H, 72H
        DC8 65H, 63H, 6FH, 72H, 64H, 3AH, 20H, 6DH
        DC8 73H, 67H, 74H, 79H, 70H, 65H, 20H, 3DH
        DC8 20H, 25H, 64H, 2CH, 20H, 76H, 65H, 72H
        DC8 73H, 69H, 6FH, 6EH, 20H, 3DH, 20H, 5BH
        DC8 25H, 64H, 3AH, 25H, 64H, 5DH, 2CH, 20H
        DC8 6DH, 73H, 67H, 6CH, 65H, 6EH, 20H, 3DH
        DC8 20H, 25H, 64H, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_108:
        DC8 "output record sent to network"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_109:
        DC8 "outgoing message counter would wrap"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_110:
        DC8 "ssl_get_remaining_payload_in_datagram"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_111:
        DC8 "Still %u bytes available in current datagram"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_112:
        DC8 "mbedtls_ssl_flush_output"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_113:
        DC8 "<= write record"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
        DC8 0, 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_115:
        DC8 "handshake message too short: %d"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_116:
        DC8 68H, 61H, 6EH, 64H, 73H, 68H, 61H, 6BH
        DC8 65H, 20H, 6DH, 65H, 73H, 73H, 61H, 67H
        DC8 65H, 3AH, 20H, 6DH, 73H, 67H, 6CH, 65H
        DC8 6EH, 20H, 3DH, 20H, 25H, 64H, 2CH, 20H
        DC8 74H, 79H, 70H, 65H, 20H, 3DH, 20H, 25H
        DC8 64H, 2CH, 20H, 68H, 73H, 6CH, 65H, 6EH
        DC8 20H, 3DH, 20H, 25H, 64H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_117:
        DC8 "invalid handshake header"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_118:
        DC8 72H, 65H, 63H, 65H, 69H, 76H, 65H, 64H
        DC8 20H, 66H, 75H, 74H, 75H, 72H, 65H, 20H
        DC8 68H, 61H, 6EH, 64H, 73H, 68H, 61H, 6BH
        DC8 65H, 20H, 6DH, 65H, 73H, 73H, 61H, 67H
        DC8 65H, 20H, 6FH, 66H, 20H, 73H, 65H, 71H
        DC8 75H, 65H, 6EH, 63H, 65H, 20H, 6EH, 75H
        DC8 6DH, 62H, 65H, 72H, 20H, 25H, 75H, 20H
        DC8 28H, 6EH, 65H, 78H, 74H, 20H, 25H, 75H
        DC8 29H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_119:
        DC8 72H, 65H, 63H, 65H, 69H, 76H, 65H, 64H
        DC8 20H, 6DH, 65H, 73H, 73H, 61H, 67H, 65H
        DC8 20H, 66H, 72H, 6FH, 6DH, 20H, 6CH, 61H
        DC8 73H, 74H, 20H, 66H, 6CH, 69H, 67H, 68H
        DC8 74H, 2CH, 20H, 6DH, 65H, 73H, 73H, 61H
        DC8 67H, 65H, 5FH, 73H, 65H, 71H, 20H, 3DH
        DC8 20H, 25H, 64H, 2CH, 20H, 73H, 74H, 61H
        DC8 72H, 74H, 5FH, 6FH, 66H, 5FH, 66H, 6CH
        DC8 69H, 67H, 68H, 74H, 20H, 3DH, 20H, 25H
        DC8 64H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_120:
        DC8 64H, 72H, 6FH, 70H, 70H, 69H, 6EH, 67H
        DC8 20H, 6FH, 75H, 74H, 2DH, 6FH, 66H, 2DH
        DC8 73H, 65H, 71H, 75H, 65H, 6EH, 63H, 65H
        DC8 20H, 6DH, 65H, 73H, 73H, 61H, 67H, 65H
        DC8 3AH, 20H, 6DH, 65H, 73H, 73H, 61H, 67H
        DC8 65H, 5FH, 73H, 65H, 71H, 20H, 3DH, 20H
        DC8 25H, 64H, 2CH, 20H, 65H, 78H, 70H, 65H
        DC8 63H, 74H, 65H, 64H, 20H, 3DH, 20H, 25H
        DC8 64H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_121:
        DC8 "found fragmented DTLS handshake message"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_122:
        DC8 "TLS handshake fragmentation not supported"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_123:
        DC8 "ssl_check_dtls_clihlo_cookie"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_124:
        DC8 "reset"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_125:
        DC8 "input record header"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_126:
        DC8 69H, 6EH, 70H, 75H, 74H, 20H, 72H, 65H
        DC8 63H, 6FH, 72H, 64H, 3AH, 20H, 6DH, 73H
        DC8 67H, 74H, 79H, 70H, 65H, 20H, 3DH, 20H
        DC8 25H, 64H, 2CH, 20H, 76H, 65H, 72H, 73H
        DC8 69H, 6FH, 6EH, 20H, 3DH, 20H, 5BH, 25H
        DC8 64H, 3AH, 25H, 64H, 5DH, 2CH, 20H, 6DH
        DC8 73H, 67H, 6CH, 65H, 6EH, 20H, 3DH, 20H
        DC8 25H, 64H, 0
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_127:
        DC8 "unknown record type"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_128:
        DC8 "major version mismatch"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_129:
        DC8 "minor version mismatch"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_130:
        DC8 "bad message length"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_131:
        DC8 72H, 65H, 63H, 6FH, 72H, 64H, 20H, 66H
        DC8 72H, 6FH, 6DH, 20H, 61H, 6EH, 6FH, 74H
        DC8 68H, 65H, 72H, 20H, 65H, 70H, 6FH, 63H
        DC8 68H, 3AH, 20H, 65H, 78H, 70H, 65H, 63H
        DC8 74H, 65H, 64H, 20H, 25H, 64H, 2CH, 20H
        DC8 72H, 65H, 63H, 65H, 69H, 76H, 65H, 64H
        DC8 20H, 25H, 64H, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_132:
        DC8 "possible client reconnect from the same port"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_133:
        DC8 "Consider record for buffering"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_134:
        DC8 "replayed record"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_135:
        DC8 "dropping unexpected ApplicationData"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_136:
        DC8 "input record from network"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_137:
        DC8 "ssl_decrypt_buf"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_138:
        DC8 "input payload after decrypt"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_139:
        DC8 "=> read record"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_140:
        DC8 "ssl_get_next_record"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_141:
        DC8 "mbedtls_ssl_handle_message_type"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_142:
        DC8 "reuse previously read message"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_143:
        DC8 "<= read record"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_144:
        DC8 "=> ssl_load_buffered_messsage"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_145:
        DC8 "CCS not seen in the current flight"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_146:
        DC8 "Injecting buffered CCS message"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_147:
        DC8 46H, 75H, 74H, 75H, 72H, 65H, 20H, 6DH
        DC8 65H, 73H, 73H, 61H, 67H, 65H, 20H, 77H
        DC8 69H, 74H, 68H, 20H, 73H, 65H, 71H, 75H
        DC8 65H, 6EH, 63H, 65H, 20H, 6EH, 75H, 6DH
        DC8 62H, 65H, 72H, 20H, 25H, 75H, 20H, 25H
        DC8 73H, 20H, 62H, 75H, 66H, 66H, 65H, 72H
        DC8 65H, 64H, 2EH, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_148:
        DC8 "fully"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_149:
        DC8 "partially"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_150:
        DC8 "Next handshake message has been buffered - load"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_151:
        DC8 "Buffered handshake message (incl. header)"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_152:
        DC8 4EH, 65H, 78H, 74H, 20H, 68H, 61H, 6EH
        DC8 64H, 73H, 68H, 61H, 6BH, 65H, 20H, 6DH
        DC8 65H, 73H, 73H, 61H, 67H, 65H, 20H, 25H
        DC8 75H, 20H, 6EH, 6FH, 74H, 20H, 6FH, 72H
        DC8 20H, 6FH, 6EH, 6CH, 79H, 20H, 70H, 61H
        DC8 72H, 74H, 69H, 61H, 6CH, 6CH, 79H, 20H
        DC8 62H, 75H, 66H, 66H, 66H, 65H, 72H, 65H
        DC8 64H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_153:
        DC8 "<= ssl_load_buffered_message"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_154:
        DC8 41H, 74H, 74H, 65H, 6DH, 70H, 74H, 20H
        DC8 74H, 6FH, 20H, 66H, 72H, 65H, 65H, 20H
        DC8 62H, 75H, 66H, 66H, 65H, 72H, 65H, 64H
        DC8 20H, 6DH, 65H, 73H, 73H, 61H, 67H, 65H
        DC8 73H, 20H, 74H, 6FH, 20H, 68H, 61H, 76H
        DC8 65H, 20H, 25H, 75H, 20H, 62H, 79H, 74H
        DC8 65H, 73H, 20H, 61H, 76H, 61H, 69H, 6CH
        DC8 61H, 62H, 6CH, 65H, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_155:
        DC8 45H, 6EH, 6FH, 75H, 67H, 68H, 20H, 73H
        DC8 70H, 61H, 63H, 65H, 20H, 61H, 76H, 61H
        DC8 69H, 6CH, 61H, 62H, 6CH, 65H, 20H, 61H
        DC8 66H, 74H, 65H, 72H, 20H, 66H, 72H, 65H
        DC8 65H, 69H, 6EH, 67H, 20H, 66H, 75H, 74H
        DC8 75H, 72H, 65H, 20H, 65H, 70H, 6FH, 63H
        DC8 68H, 20H, 72H, 65H, 63H, 6FH, 72H, 64H
        DC8 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_156:
        DC8 46H, 72H, 65H, 65H, 20H, 62H, 75H, 66H
        DC8 66H, 65H, 72H, 69H, 6EH, 67H, 20H, 73H
        DC8 6CH, 6FH, 74H, 20H, 25H, 64H, 20H, 74H
        DC8 6FH, 20H, 6DH, 61H, 6BH, 65H, 20H, 73H
        DC8 70H, 61H, 63H, 65H, 20H, 66H, 6FH, 72H
        DC8 20H, 72H, 65H, 61H, 73H, 73H, 65H, 6DH
        DC8 62H, 6CH, 79H, 20H, 6FH, 66H, 20H, 6EH
        DC8 65H, 78H, 74H, 20H, 68H, 61H, 6EH, 64H
        DC8 73H, 68H, 61H, 6BH, 65H, 20H, 6DH, 65H
        DC8 73H, 73H, 61H, 67H, 65H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_157:
        DC8 45H, 6EH, 6FH, 75H, 67H, 68H, 20H, 73H
        DC8 70H, 61H, 63H, 65H, 20H, 61H, 76H, 61H
        DC8 69H, 6CH, 61H, 62H, 6CH, 65H, 20H, 61H
        DC8 66H, 74H, 65H, 72H, 20H, 66H, 72H, 65H
        DC8 65H, 69H, 6EH, 67H, 20H, 62H, 75H, 66H
        DC8 66H, 65H, 72H, 65H, 64H, 20H, 48H, 53H
        DC8 20H, 6DH, 65H, 73H, 73H, 61H, 67H, 65H
        DC8 73H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_158:
        DC8 "=> ssl_buffer_message"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_159:
        DC8 "Remember CCS message"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_160:
        DC8 49H, 67H, 6EH, 6FH, 72H, 65H, 20H, 66H
        DC8 75H, 74H, 75H, 72H, 65H, 20H, 48H, 53H
        DC8 20H, 6DH, 65H, 73H, 73H, 61H, 67H, 65H
        DC8 20H, 77H, 69H, 74H, 68H, 20H, 73H, 65H
        DC8 71H, 75H, 65H, 6EH, 63H, 65H, 20H, 6EH
        DC8 75H, 6DH, 62H, 65H, 72H, 20H, 25H, 75H
        DC8 2CH, 20H, 62H, 75H, 66H, 66H, 65H, 72H
        DC8 69H, 6EH, 67H, 20H, 77H, 69H, 6EH, 64H
        DC8 6FH, 77H, 20H, 25H, 75H, 20H, 2DH, 20H
        DC8 25H, 75H, 0
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_161:
        DC8 42H, 75H, 66H, 66H, 65H, 72H, 69H, 6EH
        DC8 67H, 20H, 48H, 53H, 20H, 6DH, 65H, 73H
        DC8 73H, 61H, 67H, 65H, 20H, 77H, 69H, 74H
        DC8 68H, 20H, 73H, 65H, 71H, 75H, 65H, 6EH
        DC8 63H, 65H, 20H, 6EH, 75H, 6DH, 62H, 65H
        DC8 72H, 20H, 25H, 75H, 2CH, 20H, 6FH, 66H
        DC8 66H, 73H, 65H, 74H, 20H, 25H, 75H, 20H
        DC8 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_162:
        DC8 42H, 75H, 66H, 66H, 65H, 72H, 69H, 6EH
        DC8 67H, 20H, 6FH, 66H, 20H, 66H, 75H, 74H
        DC8 75H, 72H, 65H, 20H, 6DH, 65H, 73H, 73H
        DC8 61H, 67H, 65H, 20H, 6FH, 66H, 20H, 73H
        DC8 69H, 7AH, 65H, 20H, 25H, 75H, 20H, 77H
        DC8 6FH, 75H, 6CH, 64H, 20H, 65H, 78H, 63H
        DC8 65H, 65H, 64H, 20H, 74H, 68H, 65H, 20H
        DC8 63H, 6FH, 6DH, 70H, 69H, 6CH, 65H, 2DH
        DC8 74H, 69H, 6DH, 65H, 20H, 6CH, 69H, 6DH
        DC8 69H, 74H, 20H, 25H, 75H, 20H, 28H, 61H
        DC8 6CH, 72H, 65H, 61H, 64H, 79H, 20H, 25H
        DC8 75H, 20H, 62H, 79H, 74H, 65H, 73H, 20H
        DC8 62H, 75H, 66H, 66H, 65H, 72H, 65H, 64H
        DC8 29H, 20H, 2DH, 2DH, 20H, 69H, 67H, 6EH
        DC8 6FH, 72H, 65H, 0AH, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_163:
        DC8 42H, 75H, 66H, 66H, 65H, 72H, 69H, 6EH
        DC8 67H, 20H, 6FH, 66H, 20H, 66H, 75H, 74H
        DC8 75H, 72H, 65H, 20H, 6DH, 65H, 73H, 73H
        DC8 61H, 67H, 65H, 20H, 6FH, 66H, 20H, 73H
        DC8 69H, 7AH, 65H, 20H, 25H, 75H, 20H, 77H
        DC8 6FH, 75H, 6CH, 64H, 20H, 65H, 78H, 63H
        DC8 65H, 65H, 64H, 20H, 74H, 68H, 65H, 20H
        DC8 63H, 6FH, 6DH, 70H, 69H, 6CH, 65H, 2DH
        DC8 74H, 69H, 6DH, 65H, 20H, 6CH, 69H, 6DH
        DC8 69H, 74H, 20H, 25H, 75H, 20H, 28H, 61H
        DC8 6CH, 72H, 65H, 61H, 64H, 79H, 20H, 25H
        DC8 75H, 20H, 62H, 79H, 74H, 65H, 73H, 20H
        DC8 62H, 75H, 66H, 66H, 65H, 72H, 65H, 64H
        DC8 29H, 20H, 2DH, 2DH, 20H, 61H, 74H, 74H
        DC8 65H, 6DH, 70H, 74H, 20H, 74H, 6FH, 20H
        DC8 6DH, 61H, 6BH, 65H, 20H, 73H, 70H, 61H
        DC8 63H, 65H, 20H, 62H, 79H, 20H, 66H, 72H
        DC8 65H, 65H, 69H, 6EH, 67H, 20H, 62H, 75H
        DC8 66H, 66H, 65H, 72H, 65H, 64H, 20H, 66H
        DC8 75H, 74H, 75H, 72H, 65H, 20H, 6DH, 65H
        DC8 73H, 73H, 61H, 67H, 65H, 73H, 0AH, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_164:
        DC8 52H, 65H, 61H, 73H, 73H, 65H, 6DH, 62H
        DC8 6CH, 79H, 20H, 6FH, 66H, 20H, 6EH, 65H
        DC8 78H, 74H, 20H, 6DH, 65H, 73H, 73H, 61H
        DC8 67H, 65H, 20H, 6FH, 66H, 20H, 73H, 69H
        DC8 7AH, 65H, 20H, 25H, 75H, 20H, 28H, 25H
        DC8 75H, 20H, 77H, 69H, 74H, 68H, 20H, 62H
        DC8 69H, 74H, 6DH, 61H, 70H, 29H, 20H, 77H
        DC8 6FH, 75H, 6CH, 64H, 20H, 65H, 78H, 63H
        DC8 65H, 65H, 64H, 20H, 74H, 68H, 65H, 20H
        DC8 63H, 6FH, 6DH, 70H, 69H, 6CH, 65H, 2DH
        DC8 74H, 69H, 6DH, 65H, 20H, 6CH, 69H, 6DH
        DC8 69H, 74H, 20H, 25H, 75H, 20H, 28H, 61H
        DC8 6CH, 72H, 65H, 61H, 64H, 79H, 20H, 25H
        DC8 75H, 20H, 62H, 79H, 74H, 65H, 73H, 20H
        DC8 62H, 75H, 66H, 66H, 65H, 72H, 65H, 64H
        DC8 29H, 20H, 2DH, 2DH, 20H, 66H, 61H, 69H
        DC8 6CH, 0AH, 0
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_165:
        DC8 "initialize reassembly, total length = %d"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_166:
        DC8 "Fragment header mismatch - ignore"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_167:
        DC8 "adding fragment, offset = %d, length = %d"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_168:
        DC8 "message %scomplete"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(0)
        DATA
        DC8 ""

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_170:
        DC8 "not yet "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_171:
        DC8 "<= ssl_buffer_message"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_172:
        DC8 "remaining content in record"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_173:
        DC8 "=> ssl_load_buffered_record"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_174:
        DC8 "Buffered record not from current epoch."

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_175:
        DC8 "Found buffered record from current epoch - load"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_176:
        DC8 "<= ssl_load_buffered_record"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_177:
        DC8 42H, 75H, 66H, 66H, 65H, 72H, 69H, 6EH
        DC8 67H, 20H, 6FH, 66H, 20H, 66H, 75H, 74H
        DC8 75H, 72H, 65H, 20H, 65H, 70H, 6FH, 63H
        DC8 68H, 20H, 72H, 65H, 63H, 6FH, 72H, 64H
        DC8 20H, 6FH, 66H, 20H, 73H, 69H, 7AH, 65H
        DC8 20H, 25H, 75H, 20H, 77H, 6FH, 75H, 6CH
        DC8 64H, 20H, 65H, 78H, 63H, 65H, 65H, 64H
        DC8 20H, 74H, 68H, 65H, 20H, 63H, 6FH, 6DH
        DC8 70H, 69H, 6CH, 65H, 2DH, 74H, 69H, 6DH
        DC8 65H, 20H, 6CH, 69H, 6DH, 69H, 74H, 20H
        DC8 25H, 75H, 20H, 28H, 61H, 6CH, 72H, 65H
        DC8 61H, 64H, 79H, 20H, 25H, 75H, 20H, 62H
        DC8 79H, 74H, 65H, 73H, 20H, 62H, 75H, 66H
        DC8 66H, 65H, 72H, 65H, 64H, 29H, 20H, 2DH
        DC8 2DH, 20H, 69H, 67H, 6EH, 6FH, 72H, 65H
        DC8 0AH, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_178:
        DC8 "Buffer record from epoch %u"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_179:
        DC8 "Buffered record"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_180:
        DC8 "mbedtls_ssl_fetch_input"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_181:
        DC8 "discarding unexpected record (header)"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_182:
        DC8 "discarding invalid record (header)"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_183:
        DC8 "more than one record within datagram"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_184:
        DC8 "too many records with bad MAC"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_185:
        DC8 "discarding invalid record (mac)"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_186:
        DC8 "invalid CCS message, len: %d"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_187:
        DC8 "invalid CCS message, content: %02x"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_188:
        DC8 "dropping ChangeCipherSpec outside handshake"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_189:
        DC8 "received out-of-order ChangeCipherSpec - remember"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_190:
        DC8 "invalid alert message, len: %d"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_191:
        DC8 "got an alert message, type: [%d:%d]"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_192:
        DC8 "is a fatal alert message (msg %d)"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_193:
        DC8 "is a close notify message"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_194:
        DC8 "is a SSLv3 no renegotiation alert"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_195:
        DC8 "=> send alert message"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_196:
        DC8 "send alert level=%u message=%u"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_197:
        DC8 "<= send alert message"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_198:
        DC8 "=> write certificate"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_199:
        DC8 "<= skip write certificate"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_200:
        DC8 "got no certificate to send"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_201:
        DC8 "own certificate"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_202:
        DC8 "certificate too large, %d > %d"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_203:
        DC8 "mbedtls_ssl_write_handshake_msg"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_204:
        DC8 "<= write certificate"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_205:
        DC8 "=> parse certificate"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_206:
        DC8 "<= skip parse certificate"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_207:
        DC8 "mbedtls_ssl_read_record"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_208:
        DC8 "TLSv1 client has no certificate"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_209:
        DC8 "bad certificate message"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_210:
        DC8 "alloc(%d bytes) failed"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_211:
        DC8 " mbedtls_x509_crt_parse_der"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_212:
        DC8 "peer certificate"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_213:
        DC8 "new server cert during renegotiation"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_214:
        DC8 "server cert changed during renegotiation"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_215:
        DC8 "x509_verify_cert"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_216:
        DC8 "bad certificate (EC key curve)"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_217:
        DC8 "bad certificate (usage extensions)"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_218:
        DC8 "got no CA chain"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_219:
        DC8 "! Certificate verification flags %x"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_220:
        DC8 "Certificate verification flags clear"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_221:
        DC8 "<= parse certificate"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_222:
        DC8 "=> write change cipher spec"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_223:
        DC8 "<= write change cipher spec"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_224:
        DC8 "=> parse change cipher spec"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_225:
        DC8 "bad change cipher spec message"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_226:
        DC8 "switching to new transform spec for inbound data"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_227:
        DC8 "DTLS epoch would wrap"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_228:
        DC8 "<= parse change cipher spec"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_229:
        DC8 "=> calc  finished tls"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_230:
        DC8 "finished  md5 state"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_231:
        DC8 "finished sha1 state"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_232:
        DC8 "client finished"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_233:
        DC8 "server finished"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_234:
        DC8 "calc finished result"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_235:
        DC8 "<= calc  finished"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_236:
        DC8 "=> calc  finished tls sha256"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_237:
        DC8 "finished sha2 state"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_238:
        DC8 "=> calc  finished tls sha384"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_239:
        DC8 "finished sha512 state"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_240:
        DC8 "=> handshake wrapup: final free"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_241:
        DC8 "<= handshake wrapup: final free"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_242:
        DC8 "=> handshake wrapup"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_243:
        DC8 "cache did not store session"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_244:
        DC8 "skip freeing handshake and transform"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_245:
        DC8 "<= handshake wrapup"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_246:
        DC8 "=> write finished"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_247:
        DC8 "switching to new transform spec for outbound data"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_248:
        DC8 "mbedtls_ssl_flight_transmit"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_249:
        DC8 "<= write finished"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_250:
        DC8 "=> parse finished"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_251:
        DC8 "bad finished message"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_252:
        DC8 "<= parse finished"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_253:
        DC8 "alloc() of ssl sub-contexts failed"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_254:
        DC8 73H, 73H, 6CH, 5FH, 63H, 68H, 65H, 63H
        DC8 6BH, 5FH, 70H, 65H, 6EH, 64H, 69H, 6EH
        DC8 67H, 3AH, 20H, 72H, 65H, 63H, 6FH, 72H
        DC8 64H, 20H, 68H, 65H, 6CH, 64H, 20H, 62H
        DC8 61H, 63H, 6BH, 20H, 66H, 6FH, 72H, 20H
        DC8 70H, 72H, 6FH, 63H, 65H, 73H, 73H, 69H
        DC8 6EH, 67H, 0
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_255:
        DC8 73H, 73H, 6CH, 5FH, 63H, 68H, 65H, 63H
        DC8 6BH, 5FH, 70H, 65H, 6EH, 64H, 69H, 6EH
        DC8 67H, 3AH, 20H, 6DH, 6FH, 72H, 65H, 20H
        DC8 72H, 65H, 63H, 6FH, 72H, 64H, 73H, 20H
        DC8 77H, 69H, 74H, 68H, 69H, 6EH, 20H, 63H
        DC8 75H, 72H, 72H, 65H, 6EH, 74H, 20H, 64H
        DC8 61H, 74H, 61H, 67H, 72H, 61H, 6DH, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_256:
        DC8 73H, 73H, 6CH, 5FH, 63H, 68H, 65H, 63H
        DC8 6BH, 5FH, 70H, 65H, 6EH, 64H, 69H, 6EH
        DC8 67H, 3AH, 20H, 6DH, 6FH, 72H, 65H, 20H
        DC8 68H, 61H, 6EH, 64H, 73H, 68H, 61H, 6BH
        DC8 65H, 20H, 6DH, 65H, 73H, 73H, 61H, 67H
        DC8 65H, 73H, 20H, 77H, 69H, 74H, 68H, 69H
        DC8 6EH, 20H, 63H, 75H, 72H, 72H, 65H, 6EH
        DC8 74H, 20H, 72H, 65H, 63H, 6FH, 72H, 64H
        DC8 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_257:
        DC8 73H, 73H, 6CH, 5FH, 63H, 68H, 65H, 63H
        DC8 6BH, 5FH, 70H, 65H, 6EH, 64H, 69H, 6EH
        DC8 67H, 3AH, 20H, 61H, 70H, 70H, 6CH, 69H
        DC8 63H, 61H, 74H, 69H, 6FH, 6EH, 20H, 64H
        DC8 61H, 74H, 61H, 20H, 72H, 65H, 63H, 6FH
        DC8 72H, 64H, 20H, 69H, 73H, 20H, 62H, 65H
        DC8 69H, 6EH, 67H, 20H, 70H, 72H, 6FH, 63H
        DC8 65H, 73H, 73H, 65H, 64H, 0
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_258:
        DC8 "ssl_check_pending: nothing pending"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_259:
        DC8 "DTLSv1.0"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_260:
        DC8 "DTLSv1.2"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_261:
        DC8 "unknown (DTLS)"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_262:
        DC8 "SSLv3.0"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_263:
        DC8 "TLSv1.0"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_264:
        DC8 "TLSv1.1"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_265:
        DC8 "TLSv1.2"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_266:
        DC8 "unknown"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_267:
        DC8 "MTU too low for record expansion"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_268:
        DC8 "=> handshake"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_269:
        DC8 "<= handshake"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_270:
        DC8 "=> write hello request"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_271:
        DC8 "<= write hello request"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_272:
        DC8 "=> renegotiate"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_273:
        DC8 "mbedtls_ssl_handshake"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_274:
        DC8 "<= renegotiate"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_275:
        DC8 "ssl_start_renegotiation"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_276:
        DC8 "record counter limit reached: renegotiate"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_277:
        DC8 "=> read"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_278:
        DC8 "ssl_check_ctr_renegotiate"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_279:
        DC8 "received handshake message"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_280:
        DC8 "handshake received (not HelloRequest)"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_281:
        DC8 "handshake received (not ClientHello)"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_282:
        DC8 "refusing renegotiation, sending alert"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_283:
        DC8 72H, 65H, 6EH, 65H, 67H, 6FH, 74H, 69H
        DC8 61H, 74H, 69H, 6FH, 6EH, 20H, 72H, 65H
        DC8 71H, 75H, 65H, 73H, 74H, 65H, 64H, 2CH
        DC8 20H, 62H, 75H, 74H, 20H, 6EH, 6FH, 74H
        DC8 20H, 68H, 6FH, 6EH, 6FH, 72H, 65H, 64H
        DC8 20H, 62H, 79H, 20H, 63H, 6CH, 69H, 65H
        DC8 6EH, 74H, 0
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_284:
        DC8 "ignoring non-fatal non-closure alert"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_285:
        DC8 "bad application data message"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_286:
        DC8 "<= read"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_287:
        DC8 "mbedtls_ssl_get_max_out_record_payload"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_288:
        DC8 66H, 72H, 61H, 67H, 6DH, 65H, 6EH, 74H
        DC8 20H, 6CH, 61H, 72H, 67H, 65H, 72H, 20H
        DC8 74H, 68H, 61H, 6EH, 20H, 74H, 68H, 65H
        DC8 20H, 28H, 6EH, 65H, 67H, 6FH, 74H, 69H
        DC8 61H, 74H, 65H, 64H, 29H, 20H, 6DH, 61H
        DC8 78H, 69H, 6DH, 75H, 6DH, 20H, 66H, 72H
        DC8 61H, 67H, 6DH, 65H, 6EH, 74H, 20H, 6CH
        DC8 65H, 6EH, 67H, 74H, 68H, 3AH, 20H, 25H
        DC8 64H, 20H, 3EH, 20H, 25H, 64H, 0
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_289:
        DC8 "=> write"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_290:
        DC8 "<= write"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_291:
        DC8 "=> write close notify"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_292:
        DC8 "mbedtls_ssl_send_alert_message"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_293:
        DC8 "<= write close notify"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_294:
        DC8 "=> free"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_295:
        DC8 "<= free"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_296:
        DC8 "+\006\001\005\005\007\003\001"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_297:
        DC8 "+\006\001\005\005\007\003\002"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_298:
        DC8 "mbedtls_md5_starts_ret"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_299:
        DC8 "mbedtls_md5_update_ret"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_300:
        DC8 "mbedtls_md5_finish_ret"
        DATA8
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_301:
        DC8 "mbedtls_sha1_starts_ret"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_302:
        DC8 "mbedtls_sha1_update_ret"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_303:
        DC8 "mbedtls_sha1_finish_ret"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_304:
        DC8 "mbedtls_md_starts"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_305:
        DC8 "mbedtls_md_update"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_306:
        DC8 "mbedtls_md_finish"
        DATA16
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
`mbedtls_ssl_config_defaults{2}{3}::dhm_p`:
        DATA8
        DC8 255, 255, 255, 255, 255, 255, 255, 255, 201, 15, 218, 162, 33, 104
        DC8 194, 52, 196, 198, 98, 139, 128, 220, 28, 209, 41, 2, 78, 8, 138
        DC8 103, 204, 116, 2, 11, 190, 166, 59, 19, 155, 34, 81, 74, 8, 121
        DC8 142, 52, 4, 221, 239, 149, 25, 179, 205, 58, 67, 27, 48, 43, 10
        DC8 109, 242, 95, 20, 55, 79, 225, 53, 109, 109, 81, 194, 69, 228, 133
        DC8 181, 118, 98, 94, 126, 198, 244, 76, 66, 233, 166, 55, 237, 107, 11
        DC8 255, 92, 182, 244, 6, 183, 237, 238, 56, 107, 251, 90, 137, 159
        DC8 165, 174, 159, 36, 17, 124, 75, 31, 230, 73, 40, 102, 81, 236, 228
        DC8 91, 61, 194, 0, 124, 184, 161, 99, 191, 5, 152, 218, 72, 54, 28, 85
        DC8 211, 154, 105, 22, 63, 168, 253, 36, 207, 95, 131, 101, 93, 35, 220
        DC8 163, 173, 150, 28, 98, 243, 86, 32, 133, 82, 187, 158, 213, 41, 7
        DC8 112, 150, 150, 109, 103, 12, 53, 78, 74, 188, 152, 4, 241, 116, 108
        DC8 8, 202, 24, 33, 124, 50, 144, 94, 70, 46, 54, 206, 59, 227, 158
        DC8 119, 44, 24, 14, 134, 3, 155, 39, 131, 162, 236, 7, 162, 143, 181
        DC8 197, 93, 240, 111, 76, 82, 201, 222, 43, 203, 246, 149, 88, 23, 24
        DC8 57, 149, 73, 124, 234, 149, 106, 229, 21, 210, 38, 24, 152, 250, 5
        DC8 16, 21, 114, 142, 90, 138, 172, 170, 104, 255, 255, 255, 255, 255
        DC8 255, 255, 255

        SECTION `.rodata`:CONST:REORDER:NOROOT(0)
        DATA
`mbedtls_ssl_config_defaults{2}{3}::dhm_g`:
        DATA8
        DC8 2
// 9147 
// 9148 /*
// 9149  * Free mbedtls_ssl_config
// 9150  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock189 Using cfiCommon0
          CFI Function mbedtls_ssl_config_free
        THUMB
// 9151 void mbedtls_ssl_config_free( mbedtls_ssl_config *conf )
// 9152 {
mbedtls_ssl_config_free:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 9153 #if defined(MBEDTLS_DHM_C)
// 9154     mbedtls_mpi_free( &conf->dhm_P );
        ADD      R0,R4,#+124
          CFI FunCall mbedtls_mpi_free
        BL       mbedtls_mpi_free
// 9155     mbedtls_mpi_free( &conf->dhm_G );
        ADD      R0,R4,#+136
          CFI FunCall mbedtls_mpi_free
        BL       mbedtls_mpi_free
// 9156 #endif
// 9157 
// 9158 #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
// 9159     if( conf->psk != NULL )
        LDR      R0,[R4, #+148]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_config_free_0
// 9160     {
// 9161         mbedtls_platform_zeroize( conf->psk, conf->psk_len );
        LDR      R1,[R4, #+152]
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 9162         mbedtls_free( conf->psk );
        LDR      R0,[R4, #+148]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 9163         conf->psk = NULL;
        MOVS     R0,#+0
        STR      R0,[R4, #+148]
// 9164         conf->psk_len = 0;
        STR      R0,[R4, #+152]
// 9165     }
// 9166 
// 9167     if( conf->psk_identity != NULL )
??mbedtls_ssl_config_free_0:
        LDR      R0,[R4, #+156]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_config_free_1
// 9168     {
// 9169         mbedtls_platform_zeroize( conf->psk_identity, conf->psk_identity_len );
        LDR      R1,[R4, #+160]
          CFI FunCall mbedtls_platform_zeroize
        BL       mbedtls_platform_zeroize
// 9170         mbedtls_free( conf->psk_identity );
        LDR      R0,[R4, #+156]
          CFI FunCall mbedtls_free
        BL       mbedtls_free
// 9171         conf->psk_identity = NULL;
        MOVS     R0,#+0
        STR      R0,[R4, #+156]
// 9172         conf->psk_identity_len = 0;
        STR      R0,[R4, #+160]
// 9173     }
// 9174 #endif
// 9175 
// 9176 #if defined(MBEDTLS_X509_CRT_PARSE_C)
// 9177     ssl_key_cert_free( conf->key_cert );
??mbedtls_ssl_config_free_1:
        LDR      R0,[R4, #+104]
          CFI FunCall ssl_key_cert_free
        BL       ssl_key_cert_free
// 9178 #endif
// 9179 
// 9180     mbedtls_platform_zeroize( conf, sizeof( mbedtls_ssl_config ) );
        MOVS     R1,#+208
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mbedtls_platform_zeroize
        B.W      mbedtls_platform_zeroize
// 9181 }
          CFI EndBlock cfiBlock189
// 9182 
// 9183 #if defined(MBEDTLS_PK_C) && \ 
// 9184     ( defined(MBEDTLS_RSA_C) || defined(MBEDTLS_ECDSA_C) )
// 9185 /*
// 9186  * Convert between MBEDTLS_PK_XXX and SSL_SIG_XXX
// 9187  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock190 Using cfiCommon0
          CFI Function mbedtls_ssl_sig_from_pk
        THUMB
// 9188 unsigned char mbedtls_ssl_sig_from_pk( mbedtls_pk_context *pk )
// 9189 {
mbedtls_ssl_sig_from_pk:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 9190 #if defined(MBEDTLS_RSA_C)
// 9191     if( mbedtls_pk_can_do( pk, MBEDTLS_PK_RSA ) )
        MOVS     R1,#+1
          CFI FunCall mbedtls_pk_can_do
        BL       mbedtls_pk_can_do
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_sig_from_pk_0
// 9192         return( MBEDTLS_SSL_SIG_RSA );
        MOVS     R0,#+1
        POP      {R4,PC}
// 9193 #endif
// 9194 #if defined(MBEDTLS_ECDSA_C)
// 9195     if( mbedtls_pk_can_do( pk, MBEDTLS_PK_ECDSA ) )
??mbedtls_ssl_sig_from_pk_0:
        MOVS     R1,#+4
        MOV      R0,R4
          CFI FunCall mbedtls_pk_can_do
        BL       mbedtls_pk_can_do
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_sig_from_pk_1
// 9196         return( MBEDTLS_SSL_SIG_ECDSA );
        MOVS     R0,#+3
        POP      {R4,PC}
// 9197 #endif
// 9198     return( MBEDTLS_SSL_SIG_ANON );
??mbedtls_ssl_sig_from_pk_1:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
// 9199 }
          CFI EndBlock cfiBlock190
// 9200 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock191 Using cfiCommon0
          CFI Function mbedtls_ssl_sig_from_pk_alg
          CFI NoCalls
        THUMB
// 9201 unsigned char mbedtls_ssl_sig_from_pk_alg( mbedtls_pk_type_t type )
// 9202 {
// 9203     switch( type ) {
mbedtls_ssl_sig_from_pk_alg:
        CMP      R0,#+1
        BEQ.N    ??mbedtls_ssl_sig_from_pk_alg_0
        CMP      R0,#+2
        BEQ.N    ??mbedtls_ssl_sig_from_pk_alg_1
        CMP      R0,#+4
        BEQ.N    ??mbedtls_ssl_sig_from_pk_alg_1
        B.N      ??mbedtls_ssl_sig_from_pk_alg_2
// 9204         case MBEDTLS_PK_RSA:
// 9205             return( MBEDTLS_SSL_SIG_RSA );
??mbedtls_ssl_sig_from_pk_alg_0:
        MOVS     R0,#+1
        BX       LR
// 9206         case MBEDTLS_PK_ECDSA:
// 9207         case MBEDTLS_PK_ECKEY:
// 9208             return( MBEDTLS_SSL_SIG_ECDSA );
??mbedtls_ssl_sig_from_pk_alg_1:
        MOVS     R0,#+3
        BX       LR
// 9209         default:
// 9210             return( MBEDTLS_SSL_SIG_ANON );
??mbedtls_ssl_sig_from_pk_alg_2:
        MOVS     R0,#+0
        BX       LR               ;; return
// 9211     }
// 9212 }
          CFI EndBlock cfiBlock191
// 9213 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock192 Using cfiCommon0
          CFI Function mbedtls_ssl_pk_alg_from_sig
          CFI NoCalls
        THUMB
// 9214 mbedtls_pk_type_t mbedtls_ssl_pk_alg_from_sig( unsigned char sig )
// 9215 {
// 9216     switch( sig )
mbedtls_ssl_pk_alg_from_sig:
        CMP      R0,#+1
        BEQ.N    ??mbedtls_ssl_pk_alg_from_sig_0
        CMP      R0,#+3
        BEQ.N    ??mbedtls_ssl_pk_alg_from_sig_1
        B.N      ??mbedtls_ssl_pk_alg_from_sig_2
// 9217     {
// 9218 #if defined(MBEDTLS_RSA_C)
// 9219         case MBEDTLS_SSL_SIG_RSA:
// 9220             return( MBEDTLS_PK_RSA );
??mbedtls_ssl_pk_alg_from_sig_0:
        MOVS     R0,#+1
        BX       LR
// 9221 #endif
// 9222 #if defined(MBEDTLS_ECDSA_C)
// 9223         case MBEDTLS_SSL_SIG_ECDSA:
// 9224             return( MBEDTLS_PK_ECDSA );
??mbedtls_ssl_pk_alg_from_sig_1:
        MOVS     R0,#+4
        BX       LR
// 9225 #endif
// 9226         default:
// 9227             return( MBEDTLS_PK_NONE );
??mbedtls_ssl_pk_alg_from_sig_2:
        MOVS     R0,#+0
        BX       LR               ;; return
// 9228     }
// 9229 }
          CFI EndBlock cfiBlock192
// 9230 #endif /* MBEDTLS_PK_C && ( MBEDTLS_RSA_C || MBEDTLS_ECDSA_C ) */
// 9231 
// 9232 #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \ 
// 9233     defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
// 9234 
// 9235 /* Find an entry in a signature-hash set matching a given hash algorithm. */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock193 Using cfiCommon0
          CFI Function mbedtls_ssl_sig_hash_set_find
          CFI NoCalls
        THUMB
// 9236 mbedtls_md_type_t mbedtls_ssl_sig_hash_set_find( mbedtls_ssl_sig_hash_set_t *set,
// 9237                                                  mbedtls_pk_type_t sig_alg )
// 9238 {
// 9239     switch( sig_alg )
mbedtls_ssl_sig_hash_set_find:
        CMP      R1,#+1
        BEQ.N    ??mbedtls_ssl_sig_hash_set_find_0
        CMP      R1,#+4
        BEQ.N    ??mbedtls_ssl_sig_hash_set_find_1
        B.N      ??mbedtls_ssl_sig_hash_set_find_2
// 9240     {
// 9241         case MBEDTLS_PK_RSA:
// 9242             return( set->rsa );
??mbedtls_ssl_sig_hash_set_find_0:
        LDRB     R0,[R0, #+0]
        BX       LR
// 9243         case MBEDTLS_PK_ECDSA:
// 9244             return( set->ecdsa );
??mbedtls_ssl_sig_hash_set_find_1:
        LDRB     R0,[R0, #+1]
        BX       LR
// 9245         default:
// 9246             return( MBEDTLS_MD_NONE );
??mbedtls_ssl_sig_hash_set_find_2:
        MOVS     R0,#+0
        BX       LR               ;; return
// 9247     }
// 9248 }
          CFI EndBlock cfiBlock193
// 9249 
// 9250 /* Add a signature-hash-pair to a signature-hash set */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock194 Using cfiCommon0
          CFI Function mbedtls_ssl_sig_hash_set_add
          CFI NoCalls
        THUMB
// 9251 void mbedtls_ssl_sig_hash_set_add( mbedtls_ssl_sig_hash_set_t *set,
// 9252                                    mbedtls_pk_type_t sig_alg,
// 9253                                    mbedtls_md_type_t md_alg )
// 9254 {
// 9255     switch( sig_alg )
mbedtls_ssl_sig_hash_set_add:
        CMP      R1,#+1
        BEQ.N    ??mbedtls_ssl_sig_hash_set_add_0
        CMP      R1,#+4
        BEQ.N    ??mbedtls_ssl_sig_hash_set_add_1
        BX       LR
// 9256     {
// 9257         case MBEDTLS_PK_RSA:
// 9258             if( set->rsa == MBEDTLS_MD_NONE )
??mbedtls_ssl_sig_hash_set_add_0:
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        BNE.N    ??mbedtls_ssl_sig_hash_set_add_2
// 9259                 set->rsa = md_alg;
        STRB     R2,[R0, #+0]
        BX       LR
// 9260             break;
// 9261 
// 9262         case MBEDTLS_PK_ECDSA:
// 9263             if( set->ecdsa == MBEDTLS_MD_NONE )
??mbedtls_ssl_sig_hash_set_add_1:
        LDRB     R1,[R0, #+1]
        CMP      R1,#+0
        BNE.N    ??mbedtls_ssl_sig_hash_set_add_2
// 9264                 set->ecdsa = md_alg;
        STRB     R2,[R0, #+1]
// 9265             break;
// 9266 
// 9267         default:
// 9268             break;
// 9269     }
// 9270 }
??mbedtls_ssl_sig_hash_set_add_2:
        BX       LR               ;; return
          CFI EndBlock cfiBlock194
// 9271 
// 9272 /* Allow exactly one hash algorithm for each signature. */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock195 Using cfiCommon0
          CFI Function mbedtls_ssl_sig_hash_set_const_hash
          CFI NoCalls
        THUMB
// 9273 void mbedtls_ssl_sig_hash_set_const_hash( mbedtls_ssl_sig_hash_set_t *set,
// 9274                                           mbedtls_md_type_t md_alg )
// 9275 {
// 9276     set->rsa   = md_alg;
mbedtls_ssl_sig_hash_set_const_hash:
        STRB     R1,[R0, #+0]
// 9277     set->ecdsa = md_alg;
        STRB     R1,[R0, #+1]
// 9278 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock195
// 9279 
// 9280 #endif /* MBEDTLS_SSL_PROTO_TLS1_2) &&
// 9281           MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
// 9282 
// 9283 /*
// 9284  * Convert from MBEDTLS_SSL_HASH_XXX to MBEDTLS_MD_XXX
// 9285  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock196 Using cfiCommon0
          CFI Function mbedtls_ssl_md_alg_from_hash
          CFI NoCalls
        THUMB
// 9286 mbedtls_md_type_t mbedtls_ssl_md_alg_from_hash( unsigned char hash )
// 9287 {
// 9288     switch( hash )
mbedtls_ssl_md_alg_from_hash:
        SUBS     R0,R0,#+1
        CMP      R0,#+5
        BHI.N    ??mbedtls_ssl_md_alg_from_hash_1
        TBB      [PC, R0]
        DATA
??mbedtls_ssl_md_alg_from_hash_0:
        DC8      0x3,0x5,0x7,0x9
        DC8      0xB,0xD
        THUMB
// 9289     {
// 9290 #if defined(MBEDTLS_MD5_C)
// 9291         case MBEDTLS_SSL_HASH_MD5:
// 9292             return( MBEDTLS_MD_MD5 );
??mbedtls_ssl_md_alg_from_hash_2:
        MOVS     R0,#+3
        BX       LR
// 9293 #endif
// 9294 #if defined(MBEDTLS_SHA1_C)
// 9295         case MBEDTLS_SSL_HASH_SHA1:
// 9296             return( MBEDTLS_MD_SHA1 );
??mbedtls_ssl_md_alg_from_hash_3:
        MOVS     R0,#+4
        BX       LR
// 9297 #endif
// 9298 #if defined(MBEDTLS_SHA256_C)
// 9299         case MBEDTLS_SSL_HASH_SHA224:
// 9300             return( MBEDTLS_MD_SHA224 );
??mbedtls_ssl_md_alg_from_hash_4:
        MOVS     R0,#+5
        BX       LR
// 9301         case MBEDTLS_SSL_HASH_SHA256:
// 9302             return( MBEDTLS_MD_SHA256 );
??mbedtls_ssl_md_alg_from_hash_5:
        MOVS     R0,#+6
        BX       LR
// 9303 #endif
// 9304 #if defined(MBEDTLS_SHA512_C)
// 9305         case MBEDTLS_SSL_HASH_SHA384:
// 9306             return( MBEDTLS_MD_SHA384 );
??mbedtls_ssl_md_alg_from_hash_6:
        MOVS     R0,#+7
        BX       LR
// 9307         case MBEDTLS_SSL_HASH_SHA512:
// 9308             return( MBEDTLS_MD_SHA512 );
??mbedtls_ssl_md_alg_from_hash_7:
        MOVS     R0,#+8
        BX       LR
// 9309 #endif
// 9310         default:
// 9311             return( MBEDTLS_MD_NONE );
??mbedtls_ssl_md_alg_from_hash_1:
        MOVS     R0,#+0
        BX       LR               ;; return
// 9312     }
// 9313 }
          CFI EndBlock cfiBlock196
// 9314 
// 9315 /*
// 9316  * Convert from MBEDTLS_MD_XXX to MBEDTLS_SSL_HASH_XXX
// 9317  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock197 Using cfiCommon0
          CFI Function mbedtls_ssl_hash_from_md_alg
          CFI NoCalls
        THUMB
// 9318 unsigned char mbedtls_ssl_hash_from_md_alg( int md )
// 9319 {
// 9320     switch( md )
mbedtls_ssl_hash_from_md_alg:
        SUBS     R0,R0,#+3
        CMP      R0,#+5
        BHI.N    ??mbedtls_ssl_hash_from_md_alg_1
        TBB      [PC, R0]
        DATA
??mbedtls_ssl_hash_from_md_alg_0:
        DC8      0x3,0x5,0x7,0x9
        DC8      0xB,0xD
        THUMB
// 9321     {
// 9322 #if defined(MBEDTLS_MD5_C)
// 9323         case MBEDTLS_MD_MD5:
// 9324             return( MBEDTLS_SSL_HASH_MD5 );
??mbedtls_ssl_hash_from_md_alg_2:
        MOVS     R0,#+1
        BX       LR
// 9325 #endif
// 9326 #if defined(MBEDTLS_SHA1_C)
// 9327         case MBEDTLS_MD_SHA1:
// 9328             return( MBEDTLS_SSL_HASH_SHA1 );
??mbedtls_ssl_hash_from_md_alg_3:
        MOVS     R0,#+2
        BX       LR
// 9329 #endif
// 9330 #if defined(MBEDTLS_SHA256_C)
// 9331         case MBEDTLS_MD_SHA224:
// 9332             return( MBEDTLS_SSL_HASH_SHA224 );
??mbedtls_ssl_hash_from_md_alg_4:
        MOVS     R0,#+3
        BX       LR
// 9333         case MBEDTLS_MD_SHA256:
// 9334             return( MBEDTLS_SSL_HASH_SHA256 );
??mbedtls_ssl_hash_from_md_alg_5:
        MOVS     R0,#+4
        BX       LR
// 9335 #endif
// 9336 #if defined(MBEDTLS_SHA512_C)
// 9337         case MBEDTLS_MD_SHA384:
// 9338             return( MBEDTLS_SSL_HASH_SHA384 );
??mbedtls_ssl_hash_from_md_alg_6:
        MOVS     R0,#+5
        BX       LR
// 9339         case MBEDTLS_MD_SHA512:
// 9340             return( MBEDTLS_SSL_HASH_SHA512 );
??mbedtls_ssl_hash_from_md_alg_7:
        MOVS     R0,#+6
        BX       LR
// 9341 #endif
// 9342         default:
// 9343             return( MBEDTLS_SSL_HASH_NONE );
??mbedtls_ssl_hash_from_md_alg_1:
        MOVS     R0,#+0
        BX       LR               ;; return
// 9344     }
// 9345 }
          CFI EndBlock cfiBlock197
// 9346 
// 9347 #if defined(MBEDTLS_ECP_C)
// 9348 /*
// 9349  * Check if a curve proposed by the peer is in our list.
// 9350  * Return 0 if we're willing to use it, -1 otherwise.
// 9351  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock198 Using cfiCommon0
          CFI Function mbedtls_ssl_check_curve
          CFI NoCalls
        THUMB
// 9352 int mbedtls_ssl_check_curve( const mbedtls_ssl_context *ssl, mbedtls_ecp_group_id grp_id )
// 9353 {
// 9354     const mbedtls_ecp_group_id *gid;
// 9355 
// 9356     if( ssl->conf->curve_list == NULL )
mbedtls_ssl_check_curve:
        LDR      R2,[R0, #+0]
        LDR      R2,[R2, #+120]
        CMP      R2,#+0
        BEQ.N    ??mbedtls_ssl_check_curve_0
// 9357         return( -1 );
// 9358 
// 9359     for( gid = ssl->conf->curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )
        MOV      R3,R1
        B.N      ??mbedtls_ssl_check_curve_1
??mbedtls_ssl_check_curve_2:
        ADDS     R2,R2,#+1
??mbedtls_ssl_check_curve_1:
        LDRB     R0,[R2, #+0]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_check_curve_0
// 9360         if( *gid == grp_id )
        CMP      R0,R3
        BNE.N    ??mbedtls_ssl_check_curve_2
// 9361             return( 0 );
        MOVS     R0,#+0
        BX       LR
// 9362 
// 9363     return( -1 );
??mbedtls_ssl_check_curve_0:
        MOV      R0,#-1
        BX       LR               ;; return
// 9364 }
          CFI EndBlock cfiBlock198
// 9365 #endif /* MBEDTLS_ECP_C */
// 9366 
// 9367 #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
// 9368 /*
// 9369  * Check if a hash proposed by the peer is in our list.
// 9370  * Return 0 if we're willing to use it, -1 otherwise.
// 9371  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock199 Using cfiCommon0
          CFI Function mbedtls_ssl_check_sig_hash
          CFI NoCalls
        THUMB
// 9372 int mbedtls_ssl_check_sig_hash( const mbedtls_ssl_context *ssl,
// 9373                                 mbedtls_md_type_t md )
// 9374 {
// 9375     const int *cur;
// 9376 
// 9377     if( ssl->conf->sig_hashes == NULL )
mbedtls_ssl_check_sig_hash:
        LDR      R2,[R0, #+0]
        LDR      R2,[R2, #+116]
        CMP      R2,#+0
        BEQ.N    ??mbedtls_ssl_check_sig_hash_0
// 9378         return( -1 );
// 9379 
// 9380     for( cur = ssl->conf->sig_hashes; *cur != MBEDTLS_MD_NONE; cur++ )
        MOV      R3,R1
        B.N      ??mbedtls_ssl_check_sig_hash_1
??mbedtls_ssl_check_sig_hash_2:
        ADDS     R2,R2,#+4
??mbedtls_ssl_check_sig_hash_1:
        LDR      R0,[R2, #+0]
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_check_sig_hash_0
// 9381         if( *cur == (int) md )
        CMP      R0,R3
        BNE.N    ??mbedtls_ssl_check_sig_hash_2
// 9382             return( 0 );
        MOVS     R0,#+0
        BX       LR
// 9383 
// 9384     return( -1 );
??mbedtls_ssl_check_sig_hash_0:
        MOV      R0,#-1
        BX       LR               ;; return
// 9385 }
          CFI EndBlock cfiBlock199
// 9386 #endif /* MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
// 9387 
// 9388 #if defined(MBEDTLS_X509_CRT_PARSE_C)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock200 Using cfiCommon0
          CFI Function mbedtls_ssl_check_cert_usage
        THUMB
// 9389 int mbedtls_ssl_check_cert_usage( const mbedtls_x509_crt *cert,
// 9390                           const mbedtls_ssl_ciphersuite_t *ciphersuite,
// 9391                           int cert_endpoint,
// 9392                           uint32_t *flags )
// 9393 {
mbedtls_ssl_check_cert_usage:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R7,R2
        MOV      R5,R3
// 9394     int ret = 0;
        MOVS     R6,#+0
// 9395 #if defined(MBEDTLS_X509_CHECK_KEY_USAGE)
// 9396     int usage = 0;
        MOV      R0,R6
// 9397 #endif
// 9398 #if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)
// 9399     const char *ext_oid;
// 9400     size_t ext_len;
// 9401 #endif
// 9402 
// 9403 #if !defined(MBEDTLS_X509_CHECK_KEY_USAGE) &&          \ 
// 9404     !defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)
// 9405     ((void) cert);
// 9406     ((void) cert_endpoint);
// 9407     ((void) flags);
// 9408 #endif
// 9409 
// 9410 #if defined(MBEDTLS_X509_CHECK_KEY_USAGE)
// 9411     if( cert_endpoint == MBEDTLS_SSL_IS_SERVER )
        CMP      R7,#+1
        BNE.N    ??mbedtls_ssl_check_cert_usage_0
// 9412     {
// 9413         /* Server part of the key exchange */
// 9414         switch( ciphersuite->key_exchange )
        LDRB     R1,[R1, #+10]
        SUBS     R1,R1,#+1
        BEQ.N    ??mbedtls_ssl_check_cert_usage_1
        SUBS     R1,R1,#+1
        CMP      R1,#+2
        BLS.N    ??mbedtls_ssl_check_cert_usage_0
        SUBS     R1,R1,#+5
        BEQ.N    ??mbedtls_ssl_check_cert_usage_1
        SUBS     R1,R1,#+2
        CMP      R1,#+1
        BLS.N    ??mbedtls_ssl_check_cert_usage_2
        B.N      ??mbedtls_ssl_check_cert_usage_3
// 9415         {
// 9416             case MBEDTLS_KEY_EXCHANGE_RSA:
// 9417             case MBEDTLS_KEY_EXCHANGE_RSA_PSK:
// 9418                 usage = MBEDTLS_X509_KU_KEY_ENCIPHERMENT;
??mbedtls_ssl_check_cert_usage_1:
        MOVS     R0,#+32
// 9419                 break;
        B.N      ??mbedtls_ssl_check_cert_usage_3
// 9420 
// 9421             case MBEDTLS_KEY_EXCHANGE_DHE_RSA:
// 9422             case MBEDTLS_KEY_EXCHANGE_ECDHE_RSA:
// 9423             case MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
// 9424                 usage = MBEDTLS_X509_KU_DIGITAL_SIGNATURE;
// 9425                 break;
// 9426 
// 9427             case MBEDTLS_KEY_EXCHANGE_ECDH_RSA:
// 9428             case MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA:
// 9429                 usage = MBEDTLS_X509_KU_KEY_AGREEMENT;
??mbedtls_ssl_check_cert_usage_2:
        MOVS     R0,#+8
// 9430                 break;
        B.N      ??mbedtls_ssl_check_cert_usage_3
// 9431 
// 9432             /* Don't use default: we want warnings when adding new values */
// 9433             case MBEDTLS_KEY_EXCHANGE_NONE:
// 9434             case MBEDTLS_KEY_EXCHANGE_PSK:
// 9435             case MBEDTLS_KEY_EXCHANGE_DHE_PSK:
// 9436             case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
// 9437             case MBEDTLS_KEY_EXCHANGE_ECJPAKE:
// 9438                 usage = 0;
// 9439         }
// 9440     }
// 9441     else
// 9442     {
// 9443         /* Client auth: we only implement rsa_sign and mbedtls_ecdsa_sign for now */
// 9444         usage = MBEDTLS_X509_KU_DIGITAL_SIGNATURE;
??mbedtls_ssl_check_cert_usage_0:
        MOVS     R0,#+128
// 9445     }
// 9446 
// 9447     if( mbedtls_x509_crt_check_key_usage( cert, usage ) != 0 )
??mbedtls_ssl_check_cert_usage_3:
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall mbedtls_x509_crt_check_key_usage
        BL       mbedtls_x509_crt_check_key_usage
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_check_cert_usage_4
// 9448     {
// 9449         *flags |= MBEDTLS_X509_BADCERT_KEY_USAGE;
        LDR      R0,[R5, #+0]
        ORR      R0,R0,#0x800
        STR      R0,[R5, #+0]
// 9450         ret = -1;
        MOV      R6,#-1
// 9451     }
// 9452 #else
// 9453     ((void) ciphersuite);
// 9454 #endif /* MBEDTLS_X509_CHECK_KEY_USAGE */
// 9455 
// 9456 #if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)
// 9457     if( cert_endpoint == MBEDTLS_SSL_IS_SERVER )
??mbedtls_ssl_check_cert_usage_4:
        CMP      R7,#+1
        BNE.N    ??mbedtls_ssl_check_cert_usage_5
// 9458     {
// 9459         ext_oid = MBEDTLS_OID_SERVER_AUTH;
        LDR.W    R1,??DataTable84_22
// 9460         ext_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_SERVER_AUTH );
        B.N      ??mbedtls_ssl_check_cert_usage_6
// 9461     }
// 9462     else
// 9463     {
// 9464         ext_oid = MBEDTLS_OID_CLIENT_AUTH;
??mbedtls_ssl_check_cert_usage_5:
        LDR.W    R1,??DataTable84_23
// 9465         ext_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_CLIENT_AUTH );
// 9466     }
// 9467 
// 9468     if( mbedtls_x509_crt_check_extended_key_usage( cert, ext_oid, ext_len ) != 0 )
??mbedtls_ssl_check_cert_usage_6:
        MOVS     R2,#+8
        MOV      R0,R4
          CFI FunCall mbedtls_x509_crt_check_extended_key_usage
        BL       mbedtls_x509_crt_check_extended_key_usage
        CMP      R0,#+0
        BEQ.N    ??mbedtls_ssl_check_cert_usage_7
// 9469     {
// 9470         *flags |= MBEDTLS_X509_BADCERT_EXT_KEY_USAGE;
        LDR      R0,[R5, #+0]
        ORR      R0,R0,#0x1000
        STR      R0,[R5, #+0]
// 9471         ret = -1;
        MOV      R6,#-1
// 9472     }
// 9473 #endif /* MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE */
// 9474 
// 9475     return( ret );
??mbedtls_ssl_check_cert_usage_7:
        MOV      R0,R6
        POP      {R1,R4-R7,PC}    ;; return
// 9476 }
          CFI EndBlock cfiBlock200

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable81:
        DATA32
        DC32     0xffff9500

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable81_1:
        DATA32
        DC32     ?_278

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable81_2:
        DATA32
        DC32     ?_207
// 9477 #endif /* MBEDTLS_X509_CRT_PARSE_C */
// 9478 
// 9479 /*
// 9480  * Convert version numbers to/from wire format
// 9481  * and, for DTLS, to/from TLS equivalent.
// 9482  *
// 9483  * For TLS this is the identity.
// 9484  * For DTLS, use 1's complement (v -> 255 - v, and then map as follows:
// 9485  * 1.0 <-> 3.2      (DTLS 1.0 is based on TLS 1.1)
// 9486  * 1.x <-> 3.x+1    for x != 0 (DTLS 1.2 based on TLS 1.2)
// 9487  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock201 Using cfiCommon0
          CFI Function mbedtls_ssl_write_version
          CFI NoCalls
        THUMB
// 9488 void mbedtls_ssl_write_version( int major, int minor, int transport,
// 9489                         unsigned char ver[2] )
// 9490 {
// 9491 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 9492     if( transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
mbedtls_ssl_write_version:
        CMP      R2,#+1
        BNE.N    ??mbedtls_ssl_write_version_0
// 9493     {
// 9494         if( minor == MBEDTLS_SSL_MINOR_VERSION_2 )
        CMP      R1,#+2
        BNE.N    ??mbedtls_ssl_write_version_1
// 9495             --minor; /* DTLS 1.0 stored as TLS 1.1 internally */
        MOVS     R1,#+1
// 9496 
// 9497         ver[0] = (unsigned char)( 255 - ( major - 2 ) );
??mbedtls_ssl_write_version_1:
        RSB      R0,R0,#+1
        STRB     R0,[R3, #+0]
// 9498         ver[1] = (unsigned char)( 255 - ( minor - 1 ) );
        RSBS     R1,R1,#+0
        STRB     R1,[R3, #+1]
        BX       LR
// 9499     }
// 9500     else
// 9501 #else
// 9502     ((void) transport);
// 9503 #endif
// 9504     {
// 9505         ver[0] = (unsigned char) major;
??mbedtls_ssl_write_version_0:
        STRB     R0,[R3, #+0]
// 9506         ver[1] = (unsigned char) minor;
        STRB     R1,[R3, #+1]
// 9507     }
// 9508 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock201
// 9509 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock202 Using cfiCommon0
          CFI Function mbedtls_ssl_read_version
          CFI NoCalls
        THUMB
// 9510 void mbedtls_ssl_read_version( int *major, int *minor, int transport,
// 9511                        const unsigned char ver[2] )
// 9512 {
mbedtls_ssl_read_version:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
// 9513 #if defined(MBEDTLS_SSL_PROTO_DTLS)
// 9514     if( transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        CMP      R2,#+1
        BNE.N    ??mbedtls_ssl_read_version_0
// 9515     {
// 9516         *major = 255 - ver[0] + 2;
        MOVW     R4,#+257
        LDRB     R2,[R3, #+0]
        SUBS     R4,R4,R2
        STR      R4,[R0, #+0]
// 9517         *minor = 255 - ver[1] + 1;
        LDRB     R0,[R3, #+1]
        RSB      R0,R0,#+256
        STR      R0,[R1, #+0]
// 9518 
// 9519         if( *minor == MBEDTLS_SSL_MINOR_VERSION_1 )
        CMP      R0,#+1
        BNE.N    ??mbedtls_ssl_read_version_1
// 9520             ++*minor; /* DTLS 1.0 stored as TLS 1.1 internally */
        ADDS     R0,R0,#+1
        STR      R0,[R1, #+0]
        B.N      ??mbedtls_ssl_read_version_1
// 9521     }
// 9522     else
// 9523 #else
// 9524     ((void) transport);
// 9525 #endif
// 9526     {
// 9527         *major = ver[0];
??mbedtls_ssl_read_version_0:
        LDRB     R2,[R3, #+0]
        STR      R2,[R0, #+0]
// 9528         *minor = ver[1];
        LDRB     R0,[R3, #+1]
        STR      R0,[R1, #+0]
// 9529     }
// 9530 }
??mbedtls_ssl_read_version_1:
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock202
// 9531 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock203 Using cfiCommon0
          CFI Function mbedtls_ssl_set_calc_verify_md
          CFI NoCalls
        THUMB
// 9532 int mbedtls_ssl_set_calc_verify_md( mbedtls_ssl_context *ssl, int md )
// 9533 {
// 9534 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
// 9535     if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )
mbedtls_ssl_set_calc_verify_md:
        LDR      R2,[R0, #+20]
        CMP      R2,#+3
        BNE.N    ??mbedtls_ssl_set_calc_verify_md_0
// 9536         return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;
// 9537 
// 9538     switch( md )
        CMP      R1,#+2
        BEQ.N    ??mbedtls_ssl_set_calc_verify_md_1
        CMP      R1,#+4
        BEQ.N    ??mbedtls_ssl_set_calc_verify_md_2
        CMP      R1,#+5
        BEQ.N    ??mbedtls_ssl_set_calc_verify_md_3
        B.N      ??mbedtls_ssl_set_calc_verify_md_0
// 9539     {
// 9540 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)
// 9541 #if defined(MBEDTLS_MD5_C)
// 9542         case MBEDTLS_SSL_HASH_MD5:
// 9543             return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;
// 9544 #endif
// 9545 #if defined(MBEDTLS_SHA1_C)
// 9546         case MBEDTLS_SSL_HASH_SHA1:
// 9547             ssl->handshake->calc_verify = ssl_calc_verify_tls;
??mbedtls_ssl_set_calc_verify_md_1:
        LDR.N    R1,??DataTable84_24
        LDR      R0,[R0, #+60]
        STR      R1,[R0, #+1100]
// 9548             break;
// 9549 #endif
// 9550 #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 */
// 9551 #if defined(MBEDTLS_SHA512_C)
// 9552         case MBEDTLS_SSL_HASH_SHA384:
// 9553             ssl->handshake->calc_verify = ssl_calc_verify_tls_sha384;
// 9554             break;
// 9555 #endif
// 9556 #if defined(MBEDTLS_SHA256_C)
// 9557         case MBEDTLS_SSL_HASH_SHA256:
// 9558             ssl->handshake->calc_verify = ssl_calc_verify_tls_sha256;
// 9559             break;
// 9560 #endif
// 9561         default:
// 9562             return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;
// 9563     }
// 9564 
// 9565     return 0;
??mbedtls_ssl_set_calc_verify_md_4:
        MOVS     R0,#+0
        BX       LR               ;; return
??mbedtls_ssl_set_calc_verify_md_3:
        LDR.N    R1,??DataTable84_25
        LDR      R0,[R0, #+60]
        STR      R1,[R0, #+1100]
        B.N      ??mbedtls_ssl_set_calc_verify_md_4
??mbedtls_ssl_set_calc_verify_md_2:
        LDR.N    R1,??DataTable84_26
        LDR      R0,[R0, #+60]
        STR      R1,[R0, #+1100]
        B.N      ??mbedtls_ssl_set_calc_verify_md_4
??mbedtls_ssl_set_calc_verify_md_0:
        LDR.N    R0,??DataTable84_27  ;; 0xffff9a00
        BX       LR
// 9566 #else /* !MBEDTLS_SSL_PROTO_TLS1_2 */
// 9567     (void) ssl;
// 9568     (void) md;
// 9569 
// 9570     return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;
// 9571 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
// 9572 }
          CFI EndBlock cfiBlock203

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable82:
        DATA32
        DC32     ?_279

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable82_1:
        DATA32
        DC32     ?_280

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable82_2:
        DATA32
        DC32     ?_281

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable82_3:
        DATA32
        DC32     0xffff8900
// 9573 
// 9574 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ 
// 9575     defined(MBEDTLS_SSL_PROTO_TLS1_1)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock204 Using cfiCommon0
          CFI Function mbedtls_ssl_get_key_exchange_md_ssl_tls
        THUMB
// 9576 int mbedtls_ssl_get_key_exchange_md_ssl_tls( mbedtls_ssl_context *ssl,
// 9577                                         unsigned char *output,
// 9578                                         unsigned char *data, size_t data_len )
// 9579 {
mbedtls_ssl_get_key_exchange_md_ssl_tls:
        PUSH     {R3-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+28
        SUB      SP,SP,#+188
          CFI CFA R13+216
        MOV      R5,R0
        MOV      R6,R1
        MOV      R7,R2
        MOV      R8,R3
// 9580     int ret = 0;
// 9581     mbedtls_md5_context mbedtls_md5;
// 9582     mbedtls_sha1_context mbedtls_sha1;
// 9583 
// 9584     mbedtls_md5_init( &mbedtls_md5 );
        ADD      R0,SP,#+100
          CFI FunCall mbedtls_md5_init
        BL       mbedtls_md5_init
// 9585     mbedtls_sha1_init( &mbedtls_sha1 );
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_sha1_init
        BL       mbedtls_sha1_init
// 9586 
// 9587     /*
// 9588      * digitally-signed struct {
// 9589      *     opaque md5_hash[16];
// 9590      *     opaque sha_hash[20];
// 9591      * };
// 9592      *
// 9593      * md5_hash
// 9594      *     MD5(ClientHello.random + ServerHello.random
// 9595      *                            + ServerParams);
// 9596      * sha_hash
// 9597      *     SHA(ClientHello.random + ServerHello.random
// 9598      *                            + ServerParams);
// 9599      */
// 9600     if( ( ret = mbedtls_md5_starts_ret( &mbedtls_md5 ) ) != 0 )
        ADD      R0,SP,#+100
          CFI FunCall mbedtls_md5_starts_ret
        BL       mbedtls_md5_starts_ret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_ssl_tls_0
// 9601     {
// 9602         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md5_starts_ret", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_28
        STR      R0,[SP, #+0]
        MOVW     R3,#+9602
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9603         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_ssl_tls_1
// 9604     }
// 9605     if( ( ret = mbedtls_md5_update_ret( &mbedtls_md5,
// 9606                                         ssl->handshake->randbytes, 64 ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_ssl_tls_0:
        MOVS     R2,#+64
        LDR      R0,[R5, #+60]
        ADDW     R1,R0,#+1116
        ADD      R0,SP,#+100
          CFI FunCall mbedtls_md5_update_ret
        BL       mbedtls_md5_update_ret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_ssl_tls_2
// 9607     {
// 9608         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md5_update_ret", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_30
        STR      R0,[SP, #+0]
        MOVW     R3,#+9608
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9609         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_ssl_tls_1
// 9610     }
// 9611     if( ( ret = mbedtls_md5_update_ret( &mbedtls_md5, data, data_len ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_ssl_tls_2:
        MOV      R2,R8
        MOV      R1,R7
        ADD      R0,SP,#+100
          CFI FunCall mbedtls_md5_update_ret
        BL       mbedtls_md5_update_ret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_ssl_tls_3
// 9612     {
// 9613         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md5_update_ret", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_30
        STR      R0,[SP, #+0]
        MOVW     R3,#+9613
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9614         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_ssl_tls_1
// 9615     }
// 9616     if( ( ret = mbedtls_md5_finish_ret( &mbedtls_md5, output ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_ssl_tls_3:
        MOV      R1,R6
        ADD      R0,SP,#+100
          CFI FunCall mbedtls_md5_finish_ret
        BL       mbedtls_md5_finish_ret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_ssl_tls_4
// 9617     {
// 9618         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md5_finish_ret", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_31
        STR      R0,[SP, #+0]
        MOVW     R3,#+9618
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9619         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_ssl_tls_1
// 9620     }
// 9621 
// 9622     if( ( ret = mbedtls_sha1_starts_ret( &mbedtls_sha1 ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_ssl_tls_4:
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_sha1_starts_ret
        BL       mbedtls_sha1_starts_ret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_ssl_tls_5
// 9623     {
// 9624         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_sha1_starts_ret", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_32
        STR      R0,[SP, #+0]
        MOVW     R3,#+9624
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9625         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_ssl_tls_1
// 9626     }
// 9627     if( ( ret = mbedtls_sha1_update_ret( &mbedtls_sha1,
// 9628                                          ssl->handshake->randbytes, 64 ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_ssl_tls_5:
        MOVS     R2,#+64
        LDR      R0,[R5, #+60]
        ADDW     R1,R0,#+1116
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_sha1_update_ret
        BL       mbedtls_sha1_update_ret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_ssl_tls_6
// 9629     {
// 9630         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_sha1_update_ret", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_33
        STR      R0,[SP, #+0]
        MOVW     R3,#+9630
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9631         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_ssl_tls_1
// 9632     }
// 9633     if( ( ret = mbedtls_sha1_update_ret( &mbedtls_sha1, data,
// 9634                                          data_len ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_ssl_tls_6:
        MOV      R2,R8
        MOV      R1,R7
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_sha1_update_ret
        BL       mbedtls_sha1_update_ret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_ssl_tls_7
// 9635     {
// 9636         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_sha1_update_ret", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_33
        STR      R0,[SP, #+0]
        MOVW     R3,#+9636
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9637         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_ssl_tls_1
// 9638     }
// 9639     if( ( ret = mbedtls_sha1_finish_ret( &mbedtls_sha1,
// 9640                                          output + 16 ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_ssl_tls_7:
        ADD      R1,R6,#+16
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_sha1_finish_ret
        BL       mbedtls_sha1_finish_ret
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_ssl_tls_1
// 9641     {
// 9642         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_sha1_finish_ret", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_34
        STR      R0,[SP, #+0]
        MOVW     R3,#+9642
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9643         goto exit;
// 9644     }
// 9645 
// 9646 exit:
// 9647     mbedtls_md5_free( &mbedtls_md5 );
??mbedtls_ssl_get_key_exchange_md_ssl_tls_1:
        ADD      R0,SP,#+100
          CFI FunCall mbedtls_md5_free
        BL       mbedtls_md5_free
// 9648     mbedtls_sha1_free( &mbedtls_sha1 );
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_sha1_free
        BL       mbedtls_sha1_free
// 9649 
// 9650     if( ret != 0 )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_ssl_tls_8
// 9651         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 9652                                         MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
        MOVS     R2,#+80
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 9653 
// 9654     return( ret );
??mbedtls_ssl_get_key_exchange_md_ssl_tls_8:
        MOV      R0,R4
        ADD      SP,SP,#+192
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
// 9655 
// 9656 }
          CFI EndBlock cfiBlock204

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable83:
        DATA32
        DC32     ?_282

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable83_1:
        DATA32
        DC32     ?_77

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable83_2:
        DATA32
        DC32     ?_283

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable83_3:
        DATA32
        DC32     ?_284

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable83_4:
        DATA32
        DC32     0xffff9700

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable83_5:
        DATA32
        DC32     ?_285
// 9657 #endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \ 
// 9658           MBEDTLS_SSL_PROTO_TLS1_1 */
// 9659 
// 9660 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ 
// 9661     defined(MBEDTLS_SSL_PROTO_TLS1_2)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock205 Using cfiCommon0
          CFI Function mbedtls_ssl_get_key_exchange_md_tls1_2
        THUMB
// 9662 int mbedtls_ssl_get_key_exchange_md_tls1_2( mbedtls_ssl_context *ssl,
// 9663                                             unsigned char *hash, size_t *hashlen,
// 9664                                             unsigned char *data, size_t data_len,
// 9665                                             mbedtls_md_type_t md_alg )
// 9666 {
mbedtls_ssl_get_key_exchange_md_tls1_2:
        PUSH     {R3-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+28
        SUB      SP,SP,#+20
          CFI CFA R13+48
        MOV      R5,R0
        MOV      R6,R1
        MOV      R4,R2
        MOV      R7,R3
        LDR      R0,[SP, #+52]
// 9667     int ret = 0;
// 9668     mbedtls_md_context_t ctx;
// 9669     const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
          CFI FunCall mbedtls_md_info_from_type
        BL       mbedtls_md_info_from_type
        MOV      R8,R0
// 9670     *hashlen = mbedtls_md_get_size( md_info );
          CFI FunCall mbedtls_md_get_size
        BL       mbedtls_md_get_size
        STR      R0,[R4, #+0]
// 9671 
// 9672     mbedtls_md_init( &ctx );
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_md_init
        BL       mbedtls_md_init
// 9673 
// 9674     /*
// 9675      * digitally-signed struct {
// 9676      *     opaque client_random[32];
// 9677      *     opaque server_random[32];
// 9678      *     ServerDHParams params;
// 9679      * };
// 9680      */
// 9681     if( ( ret = mbedtls_md_setup( &ctx, md_info, 0 ) ) != 0 )
        MOVS     R2,#+0
        MOV      R1,R8
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_md_setup
        BL       mbedtls_md_setup
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_0
// 9682     {
// 9683         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_setup", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_35
        STR      R0,[SP, #+0]
        MOVW     R3,#+9683
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9684         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_tls1_2_1
// 9685     }
// 9686     if( ( ret = mbedtls_md_starts( &ctx ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_tls1_2_0:
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_md_starts
        BL       mbedtls_md_starts
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_2
// 9687     {
// 9688         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_starts", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_36
        STR      R0,[SP, #+0]
        MOVW     R3,#+9688
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9689         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_tls1_2_1
// 9690     }
// 9691     if( ( ret = mbedtls_md_update( &ctx, ssl->handshake->randbytes, 64 ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_tls1_2_2:
        MOVS     R2,#+64
        LDR      R0,[R5, #+60]
        ADDW     R1,R0,#+1116
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_md_update
        BL       mbedtls_md_update
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_3
// 9692     {
// 9693         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_update", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_37
        STR      R0,[SP, #+0]
        MOVW     R3,#+9693
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9694         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_tls1_2_1
// 9695     }
??mbedtls_ssl_get_key_exchange_md_tls1_2_3:
        LDR      R2,[SP, #+48]
// 9696     if( ( ret = mbedtls_md_update( &ctx, data, data_len ) ) != 0 )
        MOV      R1,R7
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_md_update
        BL       mbedtls_md_update
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_4
// 9697     {
// 9698         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_update", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_37
        STR      R0,[SP, #+0]
        MOVW     R3,#+9698
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9699         goto exit;
        B.N      ??mbedtls_ssl_get_key_exchange_md_tls1_2_1
// 9700     }
// 9701     if( ( ret = mbedtls_md_finish( &ctx, hash ) ) != 0 )
??mbedtls_ssl_get_key_exchange_md_tls1_2_4:
        MOV      R1,R6
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_md_finish
        BL       mbedtls_md_finish
        MOVS     R4,R0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_1
// 9702     {
// 9703         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_finish", ret );
        STR      R4,[SP, #+4]
        LDR.N    R0,??DataTable84_38
        STR      R0,[SP, #+0]
        MOVW     R3,#+9703
        LDR.N    R2,??DataTable84_29
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall mbedtls_debug_print_ret
        BL       mbedtls_debug_print_ret
// 9704         goto exit;
// 9705     }
// 9706 
// 9707 exit:
// 9708     mbedtls_md_free( &ctx );
??mbedtls_ssl_get_key_exchange_md_tls1_2_1:
        ADD      R0,SP,#+8
          CFI FunCall mbedtls_md_free
        BL       mbedtls_md_free
// 9709 
// 9710     if( ret != 0 )
        CMP      R4,#+0
        BEQ.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_5
// 9711         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
// 9712                                         MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
        MOVS     R2,#+80
        MOVS     R1,#+2
        MOV      R0,R5
          CFI FunCall mbedtls_ssl_send_alert_message
        BL       mbedtls_ssl_send_alert_message
// 9713 
// 9714     return( ret );
??mbedtls_ssl_get_key_exchange_md_tls1_2_5:
        MOV      R0,R4
        ADD      SP,SP,#+24
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
// 9715 }
          CFI EndBlock cfiBlock205

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84:
        DATA32
        DC32     ?_286

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_1:
        DATA32
        DC32     ?_287

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_2:
        DATA32
        DC32     ?_288

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_3:
        DATA32
        DC32     ?_112

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_4:
        DATA32
        DC32     ?_97

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_5:
        DATA32
        DC32     ?_289

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_6:
        DATA32
        DC32     ?_290

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_7:
        DATA32
        DC32     ?_291

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_8:
        DATA32
        DC32     ?_292

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_9:
        DATA32
        DC32     ?_293

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_10:
        DATA32
        DC32     ?_294

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_11:
        DATA32
        DC32     ?_295

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_12:
        DATA32
        DC32     ssl_cookie_write_dummy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_13:
        DATA32
        DC32     ssl_cookie_check_dummy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_14:
        DATA32
        DC32     `mbedtls_ssl_config_defaults{2}{3}::dhm_g`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_15:
        DATA32
        DC32     `mbedtls_ssl_config_defaults{2}{3}::dhm_p`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_16:
        DATA32
        DC32     ssl_preset_suiteb_ciphersuites

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_17:
        DATA32
        DC32     mbedtls_x509_crt_profile_suiteb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_18:
        DATA32
        DC32     ssl_preset_suiteb_hashes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_19:
        DATA32
        DC32     ssl_preset_suiteb_curves

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_20:
        DATA32
        DC32     mbedtls_x509_crt_profile_default

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_21:
        DATA32
        DC32     ssl_preset_default_hashes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_22:
        DATA32
        DC32     ?_296

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_23:
        DATA32
        DC32     ?_297

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_24:
        DATA32
        DC32     ssl_calc_verify_tls

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_25:
        DATA32
        DC32     ssl_calc_verify_tls_sha384

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_26:
        DATA32
        DC32     ssl_calc_verify_tls_sha256

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_27:
        DATA32
        DC32     0xffff9a00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_28:
        DATA32
        DC32     ?_298

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_29:
        DATA32
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_30:
        DATA32
        DC32     ?_299

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_31:
        DATA32
        DC32     ?_300

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_32:
        DATA32
        DC32     ?_301

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_33:
        DATA32
        DC32     ?_302

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_34:
        DATA32
        DC32     ?_303

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_35:
        DATA32
        DC32     ?_19

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_36:
        DATA32
        DC32     ?_304

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_37:
        DATA32
        DC32     ?_305

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable84_38:
        DATA32
        DC32     ?_306

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
// 9716 #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \ 
// 9717           MBEDTLS_SSL_PROTO_TLS1_2 */
// 9718 
// 9719 #endif /* MBEDTLS_SSL_TLS_C */
// 
//     52 bytes in section .data
//  9 698 bytes in section .rodata
// 30 876 bytes in section .text
// 
// 30 876 bytes of CODE  memory
//  9 698 bytes of CONST memory
//     52 bytes of DATA  memory
//
//Errors: none
//Warnings: none
