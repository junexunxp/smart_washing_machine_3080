###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         05/Jun/2019  15:49:48
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\devices\MIMXRT1052\drivers\fsl_flexio_spi.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWCD97.tmp
#        (C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\devices\MIMXRT1052\drivers\fsl_flexio_spi.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\list
#        -lA
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../boards\evkbimxrt1050\rtos_examples\csdk\app_preinclude.h
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../rtos/amazon-freertos/lib/FreeRTOS/portable/IAR/ARM_CM4F\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/..\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../..\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../CMSIS/Include\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../rtos/amazon-freertos/lib/include\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../rtos/amazon-freertos/lib/include/private\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/drivers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/utilities\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/utilities/str\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/utilities/debug_console\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/uart\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/serial_manager\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/kv\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/kv/include\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/drivers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/lists\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/drivers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/drivers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/xip\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../xip\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\atm\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_model\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_sign\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\infra\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\mqtt\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\wrappers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\wrappers\external_libs\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\wifi\mk3060\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\coap_cloud\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\coap_server\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\coap_server\server\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_bind\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_bind\impl\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_bind\impl\awss_reset\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\mbedtls\include\mbedtls\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\mbedtls\include\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\mbedtls\port\ksdk\
#        -Om)
#    Locale       =  C
#    List file    =  
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\list\fsl_flexio_spi.lst
#    Object file  =  
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\obj\fsl_flexio_spi.o
#
###############################################################################

C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\devices\MIMXRT1052\drivers\fsl_flexio_spi.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           * All rights reserved.
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           */
      8          
      9          #include "fsl_flexio_spi.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xD408             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xF000 0x011F      AND      R1,R0,#0x1F
   \        0xA   0x408A             LSLS     R2,R2,R1
   \        0xC   0x....'....        LDR.W    R1,??DataTable15  ;; 0xe000e100
   \       0x10   0x0940             LSRS     R0,R0,#+5
   \       0x12   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_ControlGate(clock_ip_name_t, clock_gate_value_t)
   \                     CLOCK_ControlGate: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4626             MOV      R6,R4
   \        0x8   0x0A36             LSRS     R6,R6,#+8
   \        0xA   0xF004 0x041F      AND      R4,R4,#0x1F
   \        0xE   0x2E07             CMP      R6,#+7
   \       0x10   0xD309             BCC.N    ??CLOCK_ControlGate_0
   \       0x12   0xF44F 0x6282      MOV      R2,#+1040
   \       0x16   0x....'....        LDR.W    R1,??DataTable14
   \       0x1A   0x....'....        LDR.W    R0,??DataTable14_1
   \       0x1E   0x....'....        BL       __aeabi_assert
   \       0x22   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??CLOCK_ControlGate_0: (+1)
   \       0x26   0x....'....        LDR.W    R0,??DataTable15_1  ;; 0x400fc068
   \       0x2A   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0x2203             MOVS     R2,#+3
   \       0x32   0x40A2             LSLS     R2,R2,R4
   \       0x34   0x4391             BICS     R1,R1,R2
   \       0x36   0xFA05 0xF404      LSL      R4,R5,R4
   \       0x3A   0x430C             ORRS     R4,R4,R1
   \       0x3C   0x6004             STR      R4,[R0, #+0]
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \        0x0   0x2103             MOVS     R1,#+3
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int32_t EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0xF06F 0x027F      MVN      R2,#+127
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD101             BNE.N    ??EnableIRQ_0
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xBD02             POP      {R1,PC}
   \                     ??EnableIRQ_0: (+1)
   \       0x10   0x....'....        BL       __NVIC_EnableIRQ
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXIO_EnableShifterStatusInterrupts(FLEXIO_Type *, uint32_t)
   \                     FLEXIO_EnableShifterStatusInterrupts: (+1)
   \        0x0   0x6A02             LDR      R2,[R0, #+32]
   \        0x2   0x4311             ORRS     R1,R1,R2
   \        0x4   0x6201             STR      R1,[R0, #+32]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXIO_DisableShifterStatusInterrupts(FLEXIO_Type *, uint32_t)
   \                     FLEXIO_DisableShifterStatusInterrupts: (+1)
   \        0x0   0x6A02             LDR      R2,[R0, #+32]
   \        0x2   0xEA22 0x0101      BIC      R1,R2,R1
   \        0x6   0x6201             STR      R1,[R0, #+32]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t FLEXIO_GetShifterStatusFlags(FLEXIO_Type *)
   \                     FLEXIO_GetShifterStatusFlags: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0xF000 0x000F      AND      R0,R0,#0xF
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXIO_ClearShifterStatusFlags(FLEXIO_Type *, uint32_t)
   \                     FLEXIO_ClearShifterStatusFlags: (+1)
   \        0x0   0x6101             STR      R1,[R0, #+16]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXIO_EnableShifterStatusDMA(FLEXIO_Type *, uint32_t, bool)
   \                     FLEXIO_EnableShifterStatusDMA: (+1)
   \        0x0   0x2A00             CMP      R2,#+0
   \        0x2   0x6B02             LDR      R2,[R0, #+48]
   \        0x4   0xD002             BEQ.N    ??FLEXIO_EnableShifterStatusDMA_0
   \        0x6   0x4311             ORRS     R1,R1,R2
   \        0x8   0x6301             STR      R1,[R0, #+48]
   \        0xA   0x4770             BX       LR
   \                     ??FLEXIO_EnableShifterStatusDMA_0: (+1)
   \        0xC   0xEA22 0x0101      BIC      R1,R2,R1
   \       0x10   0x6301             STR      R1,[R0, #+48]
   \       0x12   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXIO_SPI_WriteData(FLEXIO_SPI_Type *, flexio_spi_shift_direction_t, uint16_t)
   \                     FLEXIO_SPI_WriteData: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x7A00             LDRB     R0,[R0, #+8]
   \        0x6   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \        0xA   0xD102             BNE.N    ??FLEXIO_SPI_WriteData_0
   \        0xC   0xF8C0 0x2380      STR      R2,[R0, #+896]
   \       0x10   0x4770             BX       LR
   \                     ??FLEXIO_SPI_WriteData_0: (+1)
   \       0x12   0xF8C0 0x2200      STR      R2,[R0, #+512]
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint16_t FLEXIO_SPI_ReadData(FLEXIO_SPI_Type *, flexio_spi_shift_direction_t)
   \                     FLEXIO_SPI_ReadData: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x7A40             LDRB     R0,[R0, #+9]
   \        0x6   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \        0xA   0xD103             BNE.N    ??FLEXIO_SPI_ReadData_0
   \        0xC   0xF8D0 0x0280      LDR      R0,[R0, #+640]
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0x4770             BX       LR
   \                     ??FLEXIO_SPI_ReadData_0: (+1)
   \       0x14   0xF8D0 0x0300      LDR      R0,[R0, #+768]
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void FLEXIO_SPI_SlaveTransferAbort(FLEXIO_SPI_Type *, flexio_spi_slave_handle_t *)
   \                     FLEXIO_SPI_SlaveTransferAbort: (+1)
   \        0x0   0x....'....        B.W      FLEXIO_SPI_MasterTransferAbort
     10          
     11          /*******************************************************************************
     12           * Definitions
     13           ******************************************************************************/
     14          
     15          /* Component ID definition, used by tools. */
     16          #ifndef FSL_COMPONENT_ID
     17          #define FSL_COMPONENT_ID "platform.drivers.flexio_spi"
     18          #endif
     19          
     20          /*! @brief FLEXIO SPI transfer state, which is used for SPI transactiaonl APIs' internal state. */
     21          enum _flexio_spi_transfer_states
     22          {
     23              kFLEXIO_SPI_Idle = 0x0U, /*!< Nothing in the transmitter/receiver's queue. */
     24              kFLEXIO_SPI_Busy,        /*!< Transmiter/Receive's queue is not finished. */
     25          };
     26          
     27          /*******************************************************************************
     28           * Prototypes
     29           ******************************************************************************/
     30          
     31          /*!
     32           * @brief Send a piece of data for SPI.
     33           *
     34           * This function computes the number of data to be written into D register or Tx FIFO,
     35           * and write the data into it. At the same time, this function updates the values in
     36           * master handle structure.
     37           *
     38           * @param base pointer to FLEXIO_SPI_Type structure
     39           * @param handle Pointer to SPI master handle structure.
     40           */
     41          static void FLEXIO_SPI_TransferSendTransaction(FLEXIO_SPI_Type *base, flexio_spi_master_handle_t *handle);
     42          
     43          /*!
     44           * @brief Receive a piece of data for SPI master.
     45           *
     46           * This function computes the number of data to receive from D register or Rx FIFO,
     47           * and write the data to destination address. At the same time, this function updates
     48           * the values in master handle structure.
     49           *
     50           * @param base pointer to FLEXIO_SPI_Type structure
     51           * @param handle Pointer to SPI master handle structure.
     52           */
     53          static void FLEXIO_SPI_TransferReceiveTransaction(FLEXIO_SPI_Type *base, flexio_spi_master_handle_t *handle);
     54          
     55          /*******************************************************************************
     56           * Variables
     57           ******************************************************************************/
     58          
     59          /*******************************************************************************
     60           * Codes
     61           ******************************************************************************/
     62          

   \                                 In section .text, align 2, keep-with-next
     63          static uint32_t FLEXIO_SPI_GetInstance(FLEXIO_SPI_Type *base)
     64          {
     65              return FLEXIO_GetInstance(base->flexioBase);
   \                     FLEXIO_SPI_GetInstance: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x....'....        B.W      FLEXIO_GetInstance
     66          }
     67          

   \                                 In section .text, align 2, keep-with-next
     68          static void FLEXIO_SPI_TransferSendTransaction(FLEXIO_SPI_Type *base, flexio_spi_master_handle_t *handle)
     69          {
   \                     FLEXIO_SPI_TransferSendTransaction: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
     70              uint16_t tmpData = FLEXIO_SPI_DUMMYDATA;
   \        0x6   0xF64F 0x72FF      MOVW     R2,#+65535
     71          
     72              if (handle->txData != NULL)
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD019             BEQ.N    ??FLEXIO_SPI_TransferSendTransaction_0
     73              {
     74                  /* Transmit data and update tx size/buff. */
     75                  if (handle->bytePerFrame == 1U)
   \       0x10   0x7E28             LDRB     R0,[R5, #+24]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD104             BNE.N    ??FLEXIO_SPI_TransferSendTransaction_1
     76                  {
     77                      tmpData = *(handle->txData);
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x7802             LDRB     R2,[R0, #+0]
     78                      handle->txData++;
   \       0x1A   0x1C40             ADDS     R0,R0,#+1
   \       0x1C   0x6028             STR      R0,[R5, #+0]
   \       0x1E   0xE011             B.N      ??FLEXIO_SPI_TransferSendTransaction_0
     79                  }
     80                  else
     81                  {
     82                      if (handle->direction == kFLEXIO_SPI_MsbFirst)
   \                     ??FLEXIO_SPI_TransferSendTransaction_1: (+1)
   \       0x20   0x7E68             LDRB     R0,[R5, #+25]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0x6828             LDR      R0,[R5, #+0]
   \       0x26   0xD105             BNE.N    ??FLEXIO_SPI_TransferSendTransaction_2
     83                      {
     84                          tmpData = (uint32_t)(handle->txData[0]) << 8U;
     85                          tmpData += handle->txData[1];
   \       0x28   0x7800             LDRB     R0,[R0, #+0]
   \       0x2A   0x6829             LDR      R1,[R5, #+0]
   \       0x2C   0x7849             LDRB     R1,[R1, #+1]
   \       0x2E   0xEB11 0x2200      ADDS     R2,R1,R0, LSL #+8
   \       0x32   0xE004             B.N      ??FLEXIO_SPI_TransferSendTransaction_3
     86                      }
     87                      else
     88                      {
     89                          tmpData = (uint32_t)(handle->txData[1]) << 8U;
     90                          tmpData += handle->txData[0];
   \                     ??FLEXIO_SPI_TransferSendTransaction_2: (+1)
   \       0x34   0x7840             LDRB     R0,[R0, #+1]
   \       0x36   0x6829             LDR      R1,[R5, #+0]
   \       0x38   0x7809             LDRB     R1,[R1, #+0]
   \       0x3A   0xEB11 0x2200      ADDS     R2,R1,R0, LSL #+8
     91                      }
     92                      handle->txData += 2U;
   \                     ??FLEXIO_SPI_TransferSendTransaction_3: (+1)
   \       0x3E   0x6828             LDR      R0,[R5, #+0]
   \       0x40   0x1C80             ADDS     R0,R0,#+2
   \       0x42   0x6028             STR      R0,[R5, #+0]
     93                  }
     94              }
     95              else
     96              {
     97                  tmpData = FLEXIO_SPI_DUMMYDATA;
     98              }
     99          
    100              handle->txRemainingBytes -= handle->bytePerFrame;
   \                     ??FLEXIO_SPI_TransferSendTransaction_0: (+1)
   \       0x44   0x68E9             LDR      R1,[R5, #+12]
   \       0x46   0x7E28             LDRB     R0,[R5, #+24]
   \       0x48   0x1A09             SUBS     R1,R1,R0
   \       0x4A   0x60E9             STR      R1,[R5, #+12]
    101          
    102              FLEXIO_SPI_WriteData(base, handle->direction, tmpData);
   \       0x4C   0xB292             UXTH     R2,R2
   \       0x4E   0x7E69             LDRB     R1,[R5, #+25]
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0x....'....        BL       FLEXIO_SPI_WriteData
    103          
    104              if (!handle->txRemainingBytes)
   \       0x56   0x68E8             LDR      R0,[R5, #+12]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD104             BNE.N    ??FLEXIO_SPI_TransferSendTransaction_4
    105              {
    106                  FLEXIO_SPI_DisableInterrupts(base, kFLEXIO_SPI_TxEmptyInterruptEnable);
   \       0x5C   0x2101             MOVS     R1,#+1
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x64   0x....             B.N      FLEXIO_SPI_DisableInterrupts
    107              }
    108          }
   \                     ??FLEXIO_SPI_TransferSendTransaction_4: (+1)
   \       0x66   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    109          

   \                                 In section .text, align 2, keep-with-next
    110          static void FLEXIO_SPI_TransferReceiveTransaction(FLEXIO_SPI_Type *base, flexio_spi_master_handle_t *handle)
    111          {
   \                     FLEXIO_SPI_TransferReceiveTransaction: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    112              uint16_t tmpData;
    113          
    114              tmpData = FLEXIO_SPI_ReadData(base, handle->direction);
   \        0x4   0x7E61             LDRB     R1,[R4, #+25]
   \        0x6   0x....'....        BL       FLEXIO_SPI_ReadData
   \        0xA   0x4601             MOV      R1,R0
    115          
    116              if (handle->rxData != NULL)
   \        0xC   0x6860             LDR      R0,[R4, #+4]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD019             BEQ.N    ??FLEXIO_SPI_TransferReceiveTransaction_0
    117              {
    118                  if (handle->bytePerFrame == 1U)
   \       0x12   0x7E20             LDRB     R0,[R4, #+24]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD105             BNE.N    ??FLEXIO_SPI_TransferReceiveTransaction_1
    119                  {
    120                      *handle->rxData = tmpData;
   \       0x18   0x6860             LDR      R0,[R4, #+4]
   \       0x1A   0x7001             STRB     R1,[R0, #+0]
    121                      handle->rxData++;
   \       0x1C   0x6860             LDR      R0,[R4, #+4]
   \       0x1E   0x1C40             ADDS     R0,R0,#+1
   \       0x20   0x6060             STR      R0,[R4, #+4]
   \       0x22   0xE010             B.N      ??FLEXIO_SPI_TransferReceiveTransaction_0
    122                  }
    123                  else
    124                  {
    125                      if (handle->direction == kFLEXIO_SPI_MsbFirst)
   \                     ??FLEXIO_SPI_TransferReceiveTransaction_1: (+1)
   \       0x24   0x7E60             LDRB     R0,[R4, #+25]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE.N    ??FLEXIO_SPI_TransferReceiveTransaction_2
    126                      {
    127                          *((uint16_t *)(handle->rxData)) = tmpData;
   \       0x2A   0x6860             LDR      R0,[R4, #+4]
   \       0x2C   0x8001             STRH     R1,[R0, #+0]
   \       0x2E   0xE007             B.N      ??FLEXIO_SPI_TransferReceiveTransaction_3
    128                      }
    129                      else
    130                      {
    131                          *((uint16_t *)(handle->rxData)) = (((tmpData << 8) & 0xff00U) | ((tmpData >> 8) & 0x00ffU));
   \                     ??FLEXIO_SPI_TransferReceiveTransaction_2: (+1)
   \       0x30   0x4608             MOV      R0,R1
   \       0x32   0x1200             ASRS     R0,R0,#+8
   \       0x34   0xF000 0x00FF      AND      R0,R0,#0xFF
   \       0x38   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \       0x3C   0x6861             LDR      R1,[R4, #+4]
   \       0x3E   0x8008             STRH     R0,[R1, #+0]
    132                      }
    133                      handle->rxData += 2U;
   \                     ??FLEXIO_SPI_TransferReceiveTransaction_3: (+1)
   \       0x40   0x6860             LDR      R0,[R4, #+4]
   \       0x42   0x1C80             ADDS     R0,R0,#+2
   \       0x44   0x6060             STR      R0,[R4, #+4]
    134                  }
    135              }
    136              handle->rxRemainingBytes -= handle->bytePerFrame;
   \                     ??FLEXIO_SPI_TransferReceiveTransaction_0: (+1)
   \       0x46   0x6921             LDR      R1,[R4, #+16]
   \       0x48   0x7E20             LDRB     R0,[R4, #+24]
   \       0x4A   0x1A09             SUBS     R1,R1,R0
   \       0x4C   0x6121             STR      R1,[R4, #+16]
    137          }
   \       0x4E   0xBD10             POP      {R4,PC}          ;; return
    138          
    139          /*!
    140           * brief Ungates the FlexIO clock, resets the FlexIO module, configures the FlexIO SPI master hardware,
    141           * and configures the FlexIO SPI with FlexIO SPI master configuration. The
    142           * configuration structure can be filled by the user, or be set with default values
    143           * by the FLEXIO_SPI_MasterGetDefaultConfig().
    144           *
    145           * note FlexIO SPI master only support CPOL = 0, which means clock inactive low.
    146           *
    147           * Example
    148             code
    149             FLEXIO_SPI_Type spiDev = {
    150             .flexioBase = FLEXIO,
    151             .SDOPinIndex = 0,
    152             .SDIPinIndex = 1,
    153             .SCKPinIndex = 2,
    154             .CSnPinIndex = 3,
    155             .shifterIndex = {0,1},
    156             .timerIndex = {0,1}
    157             };
    158             flexio_spi_master_config_t config = {
    159             .enableMaster = true,
    160             .enableInDoze = false,
    161             .enableInDebug = true,
    162             .enableFastAccess = false,
    163             .baudRate_Bps = 500000,
    164             .phase = kFLEXIO_SPI_ClockPhaseFirstEdge,
    165             .direction = kFLEXIO_SPI_MsbFirst,
    166             .dataMode = kFLEXIO_SPI_8BitMode
    167             };
    168             FLEXIO_SPI_MasterInit(&spiDev, &config, srcClock_Hz);
    169             endcode
    170           *
    171           * param base Pointer to the FLEXIO_SPI_Type structure.
    172           * param masterConfig Pointer to the flexio_spi_master_config_t structure.
    173           * param srcClock_Hz FlexIO source clock in Hz.
    174          */

   \                                 In section .text, align 2, keep-with-next
    175          void FLEXIO_SPI_MasterInit(FLEXIO_SPI_Type *base, flexio_spi_master_config_t *masterConfig, uint32_t srcClock_Hz)
    176          {
   \                     FLEXIO_SPI_MasterInit: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB08D             SUB      SP,SP,#+52
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    177              assert(base);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD108             BNE.N    ??FLEXIO_SPI_MasterInit_0
   \        0xE   0x22B1             MOVS     R2,#+177
   \       0x10   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x14   0x....'....        LDR.W    R0,??DataTable15_3
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
    178              assert(masterConfig);
   \                     ??FLEXIO_SPI_MasterInit_0: (+1)
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD108             BNE.N    ??FLEXIO_SPI_MasterInit_1
   \       0x24   0x22B2             MOVS     R2,#+178
   \       0x26   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x2A   0x....'....        LDR.W    R0,??DataTable15_4
   \       0x2E   0x....'....        BL       __aeabi_assert
   \       0x32   0x....'....        BL       __iar_EmptyStepPoint
    179          
    180              flexio_shifter_config_t shifterConfig;
    181              flexio_timer_config_t timerConfig;
    182              uint32_t ctrlReg  = 0;
    183              uint16_t timerDiv = 0;
    184              uint16_t timerCmp = 0;
    185          
    186              /* Clear the shifterConfig & timerConfig struct. */
    187              memset(&shifterConfig, 0, sizeof(shifterConfig));
   \                     ??FLEXIO_SPI_MasterInit_1: (+1)
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0x2118             MOVS     R1,#+24
   \       0x3A   0xA807             ADD      R0,SP,#+28
   \       0x3C   0x....'....        BL       __aeabi_memset4
    188              memset(&timerConfig, 0, sizeof(timerConfig));
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x211C             MOVS     R1,#+28
   \       0x44   0x4668             MOV      R0,SP
   \       0x46   0x....'....        BL       __aeabi_memset4
    189          
    190          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    191              /* Ungate flexio clock. */
    192              CLOCK_EnableClock(s_flexioClocks[FLEXIO_SPI_GetInstance(base)]);
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x....'....        BL       FLEXIO_SPI_GetInstance
   \       0x50   0x....'....        LDR.W    R1,??DataTable15_5
   \       0x54   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x58   0x....'....        BL       CLOCK_EnableClock
    193          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    194          
    195              /* Configure FLEXIO SPI Master */
    196              ctrlReg = base->flexioBase->CTRL;
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6881             LDR      R1,[R0, #+8]
    197              ctrlReg &= ~(FLEXIO_CTRL_DOZEN_MASK | FLEXIO_CTRL_DBGE_MASK | FLEXIO_CTRL_FASTACC_MASK | FLEXIO_CTRL_FLEXEN_MASK);
    198              ctrlReg |= (FLEXIO_CTRL_DBGE(masterConfig->enableInDebug) | FLEXIO_CTRL_FASTACC(masterConfig->enableFastAccess) |
    199                          FLEXIO_CTRL_FLEXEN(masterConfig->enableMaster));
   \       0x60   0x....'....        LDR.W    R0,??DataTable15_6  ;; 0x3ffffffa
   \       0x64   0x4001             ANDS     R1,R0,R1
   \       0x66   0x78A8             LDRB     R0,[R5, #+2]
   \       0x68   0xEA41 0x7180      ORR      R1,R1,R0, LSL #+30
   \       0x6C   0x78E8             LDRB     R0,[R5, #+3]
   \       0x6E   0xEA41 0x0180      ORR      R1,R1,R0, LSL #+2
   \       0x72   0x7828             LDRB     R0,[R5, #+0]
   \       0x74   0x4301             ORRS     R1,R0,R1
    200              if (!masterConfig->enableInDoze)
   \       0x76   0x7868             LDRB     R0,[R5, #+1]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD101             BNE.N    ??FLEXIO_SPI_MasterInit_2
    201              {
    202                  ctrlReg |= FLEXIO_CTRL_DOZEN_MASK;
   \       0x7C   0xF041 0x4100      ORR      R1,R1,#0x80000000
    203              }
    204          
    205              base->flexioBase->CTRL = ctrlReg;
   \                     ??FLEXIO_SPI_MasterInit_2: (+1)
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6081             STR      R1,[R0, #+8]
    206          
    207              /* Do hardware configuration. */
    208              /* 1. Configure the shifter 0 for tx. */
    209              shifterConfig.timerSelect = base->timerIndex[0];
   \       0x84   0x7AA0             LDRB     R0,[R4, #+10]
   \       0x86   0x9007             STR      R0,[SP, #+28]
    210              shifterConfig.pinConfig   = kFLEXIO_PinConfigOutput;
   \       0x88   0x2003             MOVS     R0,#+3
   \       0x8A   0xF88D 0x0021      STRB     R0,[SP, #+33]
    211              shifterConfig.pinSelect   = base->SDOPinIndex;
   \       0x8E   0x7920             LDRB     R0,[R4, #+4]
   \       0x90   0x9009             STR      R0,[SP, #+36]
    212              shifterConfig.pinPolarity = kFLEXIO_PinActiveHigh;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xF88D 0x0028      STRB     R0,[SP, #+40]
    213              shifterConfig.shifterMode = kFLEXIO_ShifterModeTransmit;
   \       0x98   0x2002             MOVS     R0,#+2
   \       0x9A   0xF88D 0x0029      STRB     R0,[SP, #+41]
    214              shifterConfig.inputSource = kFLEXIO_ShifterInputFromPin;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xF88D 0x0030      STRB     R0,[SP, #+48]
    215              if (masterConfig->phase == kFLEXIO_SPI_ClockPhaseFirstEdge)
   \       0xA4   0x7A28             LDRB     R0,[R5, #+8]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD108             BNE.N    ??FLEXIO_SPI_MasterInit_3
    216              {
    217                  shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnNegitive;
   \       0xAA   0x2001             MOVS     R0,#+1
   \       0xAC   0xF88D 0x0020      STRB     R0,[SP, #+32]
    218                  shifterConfig.shifterStop   = kFLEXIO_ShifterStopBitDisable;
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0xF88D 0x0031      STRB     R0,[SP, #+49]
    219                  shifterConfig.shifterStart  = kFLEXIO_ShifterStartBitDisabledLoadDataOnEnable;
   \       0xB6   0xF88D 0x0032      STRB     R0,[SP, #+50]
   \       0xBA   0xE008             B.N      ??FLEXIO_SPI_MasterInit_4
    220              }
    221              else
    222              {
    223                  shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnPositive;
   \                     ??FLEXIO_SPI_MasterInit_3: (+1)
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xF88D 0x0020      STRB     R0,[SP, #+32]
    224                  shifterConfig.shifterStop   = kFLEXIO_ShifterStopBitLow;
   \       0xC2   0x2002             MOVS     R0,#+2
   \       0xC4   0xF88D 0x0031      STRB     R0,[SP, #+49]
    225                  shifterConfig.shifterStart  = kFLEXIO_ShifterStartBitDisabledLoadDataOnShift;
   \       0xC8   0x2001             MOVS     R0,#+1
   \       0xCA   0xF88D 0x0032      STRB     R0,[SP, #+50]
    226              }
    227          
    228              FLEXIO_SetShifterConfig(base->flexioBase, base->shifterIndex[0], &shifterConfig);
   \                     ??FLEXIO_SPI_MasterInit_4: (+1)
   \       0xCE   0xAA07             ADD      R2,SP,#+28
   \       0xD0   0x7A21             LDRB     R1,[R4, #+8]
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x....'....        BL       FLEXIO_SetShifterConfig
    229          
    230              /* 2. Configure the shifter 1 for rx. */
    231              shifterConfig.timerSelect  = base->timerIndex[0];
   \       0xD8   0x7AA0             LDRB     R0,[R4, #+10]
   \       0xDA   0x9007             STR      R0,[SP, #+28]
    232              shifterConfig.pinConfig    = kFLEXIO_PinConfigOutputDisabled;
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0xF88D 0x0021      STRB     R0,[SP, #+33]
    233              shifterConfig.pinSelect    = base->SDIPinIndex;
   \       0xE2   0x7960             LDRB     R0,[R4, #+5]
   \       0xE4   0x9009             STR      R0,[SP, #+36]
    234              shifterConfig.pinPolarity  = kFLEXIO_PinActiveHigh;
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xF88D 0x0028      STRB     R0,[SP, #+40]
    235              shifterConfig.shifterMode  = kFLEXIO_ShifterModeReceive;
   \       0xEC   0x2001             MOVS     R0,#+1
   \       0xEE   0xF88D 0x0029      STRB     R0,[SP, #+41]
    236              shifterConfig.inputSource  = kFLEXIO_ShifterInputFromPin;
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0xF8AD 0x0030      STRH     R0,[SP, #+48]
    237              shifterConfig.shifterStop  = kFLEXIO_ShifterStopBitDisable;
    238              shifterConfig.shifterStart = kFLEXIO_ShifterStartBitDisabledLoadDataOnEnable;
   \       0xF8   0xF88D 0x0032      STRB     R0,[SP, #+50]
    239              if (masterConfig->phase == kFLEXIO_SPI_ClockPhaseFirstEdge)
   \       0xFC   0x7A28             LDRB     R0,[R5, #+8]
   \       0xFE   0x1E40             SUBS     R0,R0,#+1
   \      0x100   0x4180             SBCS     R0,R0,R0
   \      0x102   0x43C0             MVNS     R0,R0
   \      0x104   0x0FC0             LSRS     R0,R0,#+31
   \      0x106   0xF88D 0x0020      STRB     R0,[SP, #+32]
    240              {
    241                  shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnPositive;
    242              }
    243              else
    244              {
    245                  shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnNegitive;
    246              }
    247          
    248              FLEXIO_SetShifterConfig(base->flexioBase, base->shifterIndex[1], &shifterConfig);
   \      0x10A   0xAA07             ADD      R2,SP,#+28
   \      0x10C   0x7A61             LDRB     R1,[R4, #+9]
   \      0x10E   0x6820             LDR      R0,[R4, #+0]
   \      0x110   0x....'....        BL       FLEXIO_SetShifterConfig
    249          
    250              /*3. Configure the timer 0 for SCK. */
    251              timerConfig.triggerSelect   = FLEXIO_TIMER_TRIGGER_SEL_SHIFTnSTAT(base->shifterIndex[0]);
   \      0x114   0x7A20             LDRB     R0,[R4, #+8]
   \      0x116   0x0080             LSLS     R0,R0,#+2
   \      0x118   0xF040 0x0001      ORR      R0,R0,#0x1
   \      0x11C   0x9000             STR      R0,[SP, #+0]
    252              timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveLow;
   \      0x11E   0x2001             MOVS     R0,#+1
   \      0x120   0xF88D 0x0004      STRB     R0,[SP, #+4]
    253              timerConfig.triggerSource   = kFLEXIO_TimerTriggerSourceInternal;
   \      0x124   0xF88D 0x0005      STRB     R0,[SP, #+5]
    254              timerConfig.pinConfig       = kFLEXIO_PinConfigOutput;
   \      0x128   0x2003             MOVS     R0,#+3
   \      0x12A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    255              timerConfig.pinSelect       = base->SCKPinIndex;
   \      0x12E   0x79A0             LDRB     R0,[R4, #+6]
   \      0x130   0x9002             STR      R0,[SP, #+8]
    256              timerConfig.pinPolarity     = kFLEXIO_PinActiveHigh;
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0xF88D 0x000C      STRB     R0,[SP, #+12]
    257              timerConfig.timerMode       = kFLEXIO_TimerModeDual8BitBaudBit;
   \      0x138   0x2001             MOVS     R0,#+1
   \      0x13A   0xF88D 0x000D      STRB     R0,[SP, #+13]
    258              timerConfig.timerOutput     = kFLEXIO_TimerOutputZeroNotAffectedByReset;
   \      0x13E   0xF88D 0x000E      STRB     R0,[SP, #+14]
    259              timerConfig.timerDecrement  = kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput;
   \      0x142   0x2000             MOVS     R0,#+0
   \      0x144   0xF88D 0x000F      STRB     R0,[SP, #+15]
    260              timerConfig.timerReset      = kFLEXIO_TimerResetNever;
   \      0x148   0xF88D 0x0010      STRB     R0,[SP, #+16]
    261              timerConfig.timerDisable    = kFLEXIO_TimerDisableOnTimerCompare;
   \      0x14C   0x2002             MOVS     R0,#+2
   \      0x14E   0xF88D 0x0011      STRB     R0,[SP, #+17]
    262              timerConfig.timerEnable     = kFLEXIO_TimerEnableOnTriggerHigh;
   \      0x152   0xF88D 0x0012      STRB     R0,[SP, #+18]
    263              timerConfig.timerStop       = kFLEXIO_TimerStopBitEnableOnTimerDisable;
   \      0x156   0xF88D 0x0013      STRB     R0,[SP, #+19]
    264              timerConfig.timerStart      = kFLEXIO_TimerStartBitEnabled;
   \      0x15A   0x2001             MOVS     R0,#+1
   \      0x15C   0xF88D 0x0014      STRB     R0,[SP, #+20]
    265          
    266              timerDiv = srcClock_Hz / masterConfig->baudRate_Bps;
    267              timerDiv = timerDiv / 2 - 1;
    268          
    269              timerCmp = ((uint32_t)(masterConfig->dataMode * 2 - 1U)) << 8U;
    270              timerCmp |= timerDiv;
    271          
    272              timerConfig.timerCompare = timerCmp;
   \      0x160   0xF64F 0x77FF      MOVW     R7,#+65535
   \      0x164   0x7A68             LDRB     R0,[R5, #+9]
   \      0x166   0xEB07 0x0040      ADD      R0,R7,R0, LSL #+1
   \      0x16A   0x6869             LDR      R1,[R5, #+4]
   \      0x16C   0xFBB6 0xF1F1      UDIV     R1,R6,R1
   \      0x170   0xB289             UXTH     R1,R1
   \      0x172   0xEB07 0x0151      ADD      R1,R7,R1, LSR #+1
   \      0x176   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \      0x17A   0xB289             UXTH     R1,R1
   \      0x17C   0x9106             STR      R1,[SP, #+24]
    273          
    274              FLEXIO_SetTimerConfig(base->flexioBase, base->timerIndex[0], &timerConfig);
   \      0x17E   0x466A             MOV      R2,SP
   \      0x180   0x7AA1             LDRB     R1,[R4, #+10]
   \      0x182   0x6820             LDR      R0,[R4, #+0]
   \      0x184   0x....'....        BL       FLEXIO_SetTimerConfig
    275          
    276              /* 4. Configure the timer 1 for CSn. */
    277              timerConfig.triggerSelect   = FLEXIO_TIMER_TRIGGER_SEL_TIMn(base->timerIndex[0]);
   \      0x188   0x7AA0             LDRB     R0,[R4, #+10]
   \      0x18A   0x0080             LSLS     R0,R0,#+2
   \      0x18C   0xF040 0x0003      ORR      R0,R0,#0x3
   \      0x190   0x9000             STR      R0,[SP, #+0]
    278              timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveHigh;
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0xF88D 0x0004      STRB     R0,[SP, #+4]
    279              timerConfig.triggerSource   = kFLEXIO_TimerTriggerSourceInternal;
   \      0x198   0x2001             MOVS     R0,#+1
   \      0x19A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    280              timerConfig.pinConfig       = kFLEXIO_PinConfigOutput;
   \      0x19E   0x2003             MOVS     R0,#+3
   \      0x1A0   0xF88D 0x0006      STRB     R0,[SP, #+6]
    281              timerConfig.pinSelect       = base->CSnPinIndex;
   \      0x1A4   0x79E0             LDRB     R0,[R4, #+7]
   \      0x1A6   0x9002             STR      R0,[SP, #+8]
    282              timerConfig.pinPolarity     = kFLEXIO_PinActiveLow;
   \      0x1A8   0x2001             MOVS     R0,#+1
   \      0x1AA   0xF88D 0x000C      STRB     R0,[SP, #+12]
    283              timerConfig.timerMode       = kFLEXIO_TimerModeSingle16Bit;
   \      0x1AE   0x2003             MOVS     R0,#+3
   \      0x1B0   0xF88D 0x000D      STRB     R0,[SP, #+13]
    284              timerConfig.timerOutput     = kFLEXIO_TimerOutputOneNotAffectedByReset;
   \      0x1B4   0x2000             MOVS     R0,#+0
   \      0x1B6   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    285              timerConfig.timerDecrement  = kFLEXIO_TimerDecSrcOnFlexIOClockShiftTimerOutput;
    286              timerConfig.timerReset      = kFLEXIO_TimerResetNever;
   \      0x1BA   0xF88D 0x0010      STRB     R0,[SP, #+16]
    287              timerConfig.timerDisable    = kFLEXIO_TimerDisableOnPreTimerDisable;
   \      0x1BE   0x2001             MOVS     R0,#+1
   \      0x1C0   0xF88D 0x0011      STRB     R0,[SP, #+17]
    288              timerConfig.timerEnable     = kFLEXIO_TimerEnableOnPrevTimerEnable;
   \      0x1C4   0xF88D 0x0012      STRB     R0,[SP, #+18]
    289              timerConfig.timerStop       = kFLEXIO_TimerStopBitDisabled;
   \      0x1C8   0x2000             MOVS     R0,#+0
   \      0x1CA   0xF88D 0x0013      STRB     R0,[SP, #+19]
    290              timerConfig.timerStart      = kFLEXIO_TimerStartBitDisabled;
   \      0x1CE   0xF88D 0x0014      STRB     R0,[SP, #+20]
    291          
    292              timerConfig.timerCompare = 0xFFFFU;
   \      0x1D2   0x9706             STR      R7,[SP, #+24]
    293          
    294              FLEXIO_SetTimerConfig(base->flexioBase, base->timerIndex[1], &timerConfig);
   \      0x1D4   0x466A             MOV      R2,SP
   \      0x1D6   0x7AE1             LDRB     R1,[R4, #+11]
   \      0x1D8   0x6820             LDR      R0,[R4, #+0]
   \      0x1DA   0x....'....        BL       FLEXIO_SetTimerConfig
    295          }
   \      0x1DE   0xB00D             ADD      SP,SP,#+52
   \      0x1E0   0xBDF0             POP      {R4-R7,PC}       ;; return
    296          
    297          /*!
    298           * brief Resets the FlexIO SPI timer and shifter config.
    299           *
    300           * param base Pointer to the FLEXIO_SPI_Type.
    301           */

   \                                 In section .text, align 2, keep-with-next
    302          void FLEXIO_SPI_MasterDeinit(FLEXIO_SPI_Type *base)
    303          {
    304              base->flexioBase->SHIFTCFG[base->shifterIndex[0]] = 0;
   \                     FLEXIO_SPI_MasterDeinit: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x7A02             LDRB     R2,[R0, #+8]
   \        0x4   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0xF8C1 0x2100      STR      R2,[R1, #+256]
    305              base->flexioBase->SHIFTCTL[base->shifterIndex[0]] = 0;
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x7A02             LDRB     R2,[R0, #+8]
   \       0x12   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0xF8C1 0x2080      STR      R2,[R1, #+128]
    306              base->flexioBase->SHIFTCFG[base->shifterIndex[1]] = 0;
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0x7A42             LDRB     R2,[R0, #+9]
   \       0x20   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0xF8C1 0x2100      STR      R2,[R1, #+256]
    307              base->flexioBase->SHIFTCTL[base->shifterIndex[1]] = 0;
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x7A42             LDRB     R2,[R0, #+9]
   \       0x2E   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0xF8C1 0x2080      STR      R2,[R1, #+128]
    308              base->flexioBase->TIMCFG[base->timerIndex[0]]     = 0;
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x7A82             LDRB     R2,[R0, #+10]
   \       0x3C   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0xF8C1 0x2480      STR      R2,[R1, #+1152]
    309              base->flexioBase->TIMCMP[base->timerIndex[0]]     = 0;
   \       0x46   0x6801             LDR      R1,[R0, #+0]
   \       0x48   0x7A82             LDRB     R2,[R0, #+10]
   \       0x4A   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0x4E   0x2200             MOVS     R2,#+0
   \       0x50   0xF8C1 0x2500      STR      R2,[R1, #+1280]
    310              base->flexioBase->TIMCTL[base->timerIndex[0]]     = 0;
   \       0x54   0x6801             LDR      R1,[R0, #+0]
   \       0x56   0x7A82             LDRB     R2,[R0, #+10]
   \       0x58   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0x5C   0x2200             MOVS     R2,#+0
   \       0x5E   0xF8C1 0x2400      STR      R2,[R1, #+1024]
    311              base->flexioBase->TIMCFG[base->timerIndex[1]]     = 0;
   \       0x62   0x6801             LDR      R1,[R0, #+0]
   \       0x64   0x7AC2             LDRB     R2,[R0, #+11]
   \       0x66   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0xF8C1 0x2480      STR      R2,[R1, #+1152]
    312              base->flexioBase->TIMCMP[base->timerIndex[1]]     = 0;
   \       0x70   0x6801             LDR      R1,[R0, #+0]
   \       0x72   0x7AC2             LDRB     R2,[R0, #+11]
   \       0x74   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0x78   0x2200             MOVS     R2,#+0
   \       0x7A   0xF8C1 0x2500      STR      R2,[R1, #+1280]
    313              base->flexioBase->TIMCTL[base->timerIndex[1]]     = 0;
   \       0x7E   0x6801             LDR      R1,[R0, #+0]
   \       0x80   0x7AC0             LDRB     R0,[R0, #+11]
   \       0x82   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \       0x86   0x4611             MOV      R1,R2
   \       0x88   0xF8C0 0x1400      STR      R1,[R0, #+1024]
    314          }
   \       0x8C   0x4770             BX       LR               ;; return
    315          
    316          /*!
    317           * brief Gets the default configuration to configure the FlexIO SPI master. The configuration
    318           * can be used directly by calling the FLEXIO_SPI_MasterConfigure().
    319           * Example:
    320             code
    321             flexio_spi_master_config_t masterConfig;
    322             FLEXIO_SPI_MasterGetDefaultConfig(&masterConfig);
    323             endcode
    324           * param masterConfig Pointer to the flexio_spi_master_config_t structure.
    325          */

   \                                 In section .text, align 2, keep-with-next
    326          void FLEXIO_SPI_MasterGetDefaultConfig(flexio_spi_master_config_t *masterConfig)
    327          {
   \                     FLEXIO_SPI_MasterGetDefaultConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    328              assert(masterConfig);
   \        0x4   0xD109             BNE.N    ??FLEXIO_SPI_MasterGetDefaultConfig_0
   \        0x6   0xF44F 0x72A4      MOV      R2,#+328
   \        0xA   0x....'....        LDR.W    R1,??DataTable15_2
   \        0xE   0x....'....        LDR.W    R0,??DataTable15_4
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
    329          
    330              /* Initializes the configure structure to zero. */
    331              memset(masterConfig, 0, sizeof(*masterConfig));
   \                     ??FLEXIO_SPI_MasterGetDefaultConfig_0: (+1)
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x210C             MOVS     R1,#+12
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x....'....        BL       __aeabi_memset4
    332          
    333              masterConfig->enableMaster     = true;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x7020             STRB     R0,[R4, #+0]
    334              masterConfig->enableInDoze     = false;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x7060             STRB     R0,[R4, #+1]
    335              masterConfig->enableInDebug    = true;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x70A0             STRB     R0,[R4, #+2]
    336              masterConfig->enableFastAccess = false;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x70E0             STRB     R0,[R4, #+3]
    337              /* Default baud rate 500kbps. */
    338              masterConfig->baudRate_Bps = 500000U;
   \       0x34   0x....'....        LDR.W    R0,??DataTable15_7  ;; 0x7a120
   \       0x38   0x6060             STR      R0,[R4, #+4]
    339              /* Default CPHA = 0. */
    340              masterConfig->phase = kFLEXIO_SPI_ClockPhaseFirstEdge;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x7220             STRB     R0,[R4, #+8]
    341              /* Default bit count at 8. */
    342              masterConfig->dataMode = kFLEXIO_SPI_8BitMode;
   \       0x3E   0x2008             MOVS     R0,#+8
   \       0x40   0x7260             STRB     R0,[R4, #+9]
    343          }
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
    344          
    345          /*!
    346           * brief Ungates the FlexIO clock, resets the FlexIO module, configures the FlexIO SPI slave hardware
    347           * configuration, and configures the FlexIO SPI with FlexIO SPI slave configuration. The
    348           * configuration structure can be filled by the user, or be set with default values
    349           * by the FLEXIO_SPI_SlaveGetDefaultConfig().
    350           *
    351           * note Only one timer is needed in the FlexIO SPI slave. As a result, the second timer index is ignored.
    352           * FlexIO SPI slave only support CPOL = 0, which means clock inactive low.
    353           * Example
    354             code
    355             FLEXIO_SPI_Type spiDev = {
    356             .flexioBase = FLEXIO,
    357             .SDOPinIndex = 0,
    358             .SDIPinIndex = 1,
    359             .SCKPinIndex = 2,
    360             .CSnPinIndex = 3,
    361             .shifterIndex = {0,1},
    362             .timerIndex = {0}
    363             };
    364             flexio_spi_slave_config_t config = {
    365             .enableSlave = true,
    366             .enableInDoze = false,
    367             .enableInDebug = true,
    368             .enableFastAccess = false,
    369             .phase = kFLEXIO_SPI_ClockPhaseFirstEdge,
    370             .direction = kFLEXIO_SPI_MsbFirst,
    371             .dataMode = kFLEXIO_SPI_8BitMode
    372             };
    373             FLEXIO_SPI_SlaveInit(&spiDev, &config);
    374             endcode
    375           * param base Pointer to the FLEXIO_SPI_Type structure.
    376           * param slaveConfig Pointer to the flexio_spi_slave_config_t structure.
    377          */

   \                                 In section .text, align 2, keep-with-next
    378          void FLEXIO_SPI_SlaveInit(FLEXIO_SPI_Type *base, flexio_spi_slave_config_t *slaveConfig)
    379          {
   \                     FLEXIO_SPI_SlaveInit: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB08D             SUB      SP,SP,#+52
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
    380              assert(base && slaveConfig);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??FLEXIO_SPI_SlaveInit_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD109             BNE.N    ??FLEXIO_SPI_SlaveInit_1
   \                     ??FLEXIO_SPI_SlaveInit_0: (+1)
   \       0x10   0xF44F 0x72BE      MOV      R2,#+380
   \       0x14   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x18   0x....'....        LDR.W    R0,??DataTable15_8
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    381          
    382              flexio_shifter_config_t shifterConfig;
    383              flexio_timer_config_t timerConfig;
    384              uint32_t ctrlReg = 0;
    385          
    386              /* Clear the shifterConfig & timerConfig struct. */
    387              memset(&shifterConfig, 0, sizeof(shifterConfig));
   \                     ??FLEXIO_SPI_SlaveInit_1: (+1)
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x2118             MOVS     R1,#+24
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x....'....        BL       __aeabi_memset4
    388              memset(&timerConfig, 0, sizeof(timerConfig));
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x211C             MOVS     R1,#+28
   \       0x32   0xA806             ADD      R0,SP,#+24
   \       0x34   0x....'....        BL       __aeabi_memset4
    389          
    390          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    391              /* Ungate flexio clock. */
    392              CLOCK_EnableClock(s_flexioClocks[FLEXIO_SPI_GetInstance(base)]);
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x....'....        BL       FLEXIO_SPI_GetInstance
   \       0x3E   0x....'....        LDR.W    R1,??DataTable15_5
   \       0x42   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x46   0x....'....        BL       CLOCK_EnableClock
    393          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    394          
    395              /* Configure FLEXIO SPI Slave */
    396              ctrlReg = base->flexioBase->CTRL;
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6881             LDR      R1,[R0, #+8]
    397              ctrlReg &= ~(FLEXIO_CTRL_DOZEN_MASK | FLEXIO_CTRL_DBGE_MASK | FLEXIO_CTRL_FASTACC_MASK | FLEXIO_CTRL_FLEXEN_MASK);
    398              ctrlReg |= (FLEXIO_CTRL_DBGE(slaveConfig->enableInDebug) | FLEXIO_CTRL_FASTACC(slaveConfig->enableFastAccess) |
    399                          FLEXIO_CTRL_FLEXEN(slaveConfig->enableSlave));
   \       0x4E   0x....'....        LDR.W    R0,??DataTable15_6  ;; 0x3ffffffa
   \       0x52   0x4001             ANDS     R1,R0,R1
   \       0x54   0x78A8             LDRB     R0,[R5, #+2]
   \       0x56   0xEA41 0x7180      ORR      R1,R1,R0, LSL #+30
   \       0x5A   0x78E8             LDRB     R0,[R5, #+3]
   \       0x5C   0xEA41 0x0180      ORR      R1,R1,R0, LSL #+2
   \       0x60   0x7828             LDRB     R0,[R5, #+0]
   \       0x62   0x4301             ORRS     R1,R0,R1
    400              if (!slaveConfig->enableInDoze)
   \       0x64   0x7868             LDRB     R0,[R5, #+1]
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD101             BNE.N    ??FLEXIO_SPI_SlaveInit_2
    401              {
    402                  ctrlReg |= FLEXIO_CTRL_DOZEN_MASK;
   \       0x6A   0xF041 0x4100      ORR      R1,R1,#0x80000000
    403              }
    404          
    405              base->flexioBase->CTRL = ctrlReg;
   \                     ??FLEXIO_SPI_SlaveInit_2: (+1)
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6081             STR      R1,[R0, #+8]
    406          
    407              /* Do hardware configuration. */
    408              /* 1. Configure the shifter 0 for tx. */
    409              shifterConfig.timerSelect = base->timerIndex[0];
   \       0x72   0x7AA0             LDRB     R0,[R4, #+10]
   \       0x74   0x9000             STR      R0,[SP, #+0]
    410              shifterConfig.pinConfig   = kFLEXIO_PinConfigOutput;
   \       0x76   0x2003             MOVS     R0,#+3
   \       0x78   0xF88D 0x0005      STRB     R0,[SP, #+5]
    411              shifterConfig.pinSelect   = base->SDOPinIndex;
   \       0x7C   0x7920             LDRB     R0,[R4, #+4]
   \       0x7E   0x9002             STR      R0,[SP, #+8]
    412              shifterConfig.pinPolarity = kFLEXIO_PinActiveHigh;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xF88D 0x000C      STRB     R0,[SP, #+12]
    413              shifterConfig.shifterMode = kFLEXIO_ShifterModeTransmit;
   \       0x86   0x2002             MOVS     R0,#+2
   \       0x88   0xF88D 0x000D      STRB     R0,[SP, #+13]
    414              shifterConfig.inputSource = kFLEXIO_ShifterInputFromPin;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    415              shifterConfig.shifterStop = kFLEXIO_ShifterStopBitDisable;
    416              if (slaveConfig->phase == kFLEXIO_SPI_ClockPhaseFirstEdge)
   \       0x92   0x7928             LDRB     R0,[R5, #+4]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD106             BNE.N    ??FLEXIO_SPI_SlaveInit_3
    417              {
    418                  shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnNegitive;
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    419                  shifterConfig.shifterStart  = kFLEXIO_ShifterStartBitDisabledLoadDataOnEnable;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xF88D 0x0016      STRB     R0,[SP, #+22]
   \       0xA4   0xE005             B.N      ??FLEXIO_SPI_SlaveInit_4
    420              }
    421              else
    422              {
    423                  shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnPositive;
   \                     ??FLEXIO_SPI_SlaveInit_3: (+1)
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xF88D 0x0004      STRB     R0,[SP, #+4]
    424                  shifterConfig.shifterStart  = kFLEXIO_ShifterStartBitDisabledLoadDataOnShift;
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xF88D 0x0016      STRB     R0,[SP, #+22]
    425              }
    426          
    427              FLEXIO_SetShifterConfig(base->flexioBase, base->shifterIndex[0], &shifterConfig);
   \                     ??FLEXIO_SPI_SlaveInit_4: (+1)
   \       0xB2   0x466A             MOV      R2,SP
   \       0xB4   0x7A21             LDRB     R1,[R4, #+8]
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x....'....        BL       FLEXIO_SetShifterConfig
    428          
    429              /* 2. Configure the shifter 1 for rx. */
    430              shifterConfig.timerSelect  = base->timerIndex[0];
   \       0xBC   0x7AA0             LDRB     R0,[R4, #+10]
   \       0xBE   0x9000             STR      R0,[SP, #+0]
    431              shifterConfig.pinConfig    = kFLEXIO_PinConfigOutputDisabled;
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xF88D 0x0005      STRB     R0,[SP, #+5]
    432              shifterConfig.pinSelect    = base->SDIPinIndex;
   \       0xC6   0x7960             LDRB     R0,[R4, #+5]
   \       0xC8   0x9002             STR      R0,[SP, #+8]
    433              shifterConfig.pinPolarity  = kFLEXIO_PinActiveHigh;
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0xF88D 0x000C      STRB     R0,[SP, #+12]
    434              shifterConfig.shifterMode  = kFLEXIO_ShifterModeReceive;
   \       0xD0   0x2001             MOVS     R0,#+1
   \       0xD2   0xF88D 0x000D      STRB     R0,[SP, #+13]
    435              shifterConfig.inputSource  = kFLEXIO_ShifterInputFromPin;
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    436              shifterConfig.shifterStop  = kFLEXIO_ShifterStopBitDisable;
    437              shifterConfig.shifterStart = kFLEXIO_ShifterStartBitDisabledLoadDataOnEnable;
   \       0xDC   0xF88D 0x0016      STRB     R0,[SP, #+22]
    438              if (slaveConfig->phase == kFLEXIO_SPI_ClockPhaseFirstEdge)
   \       0xE0   0x7928             LDRB     R0,[R5, #+4]
   \       0xE2   0x1E40             SUBS     R0,R0,#+1
   \       0xE4   0x4180             SBCS     R0,R0,R0
   \       0xE6   0x43C0             MVNS     R0,R0
   \       0xE8   0x0FC0             LSRS     R0,R0,#+31
   \       0xEA   0xF88D 0x0004      STRB     R0,[SP, #+4]
    439              {
    440                  shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnPositive;
    441              }
    442              else
    443              {
    444                  shifterConfig.timerPolarity = kFLEXIO_ShifterTimerPolarityOnNegitive;
    445              }
    446          
    447              FLEXIO_SetShifterConfig(base->flexioBase, base->shifterIndex[1], &shifterConfig);
   \       0xEE   0x466A             MOV      R2,SP
   \       0xF0   0x7A61             LDRB     R1,[R4, #+9]
   \       0xF2   0x6820             LDR      R0,[R4, #+0]
   \       0xF4   0x....'....        BL       FLEXIO_SetShifterConfig
    448          
    449              /*3. Configure the timer 0 for shift clock. */
    450              timerConfig.triggerSelect   = FLEXIO_TIMER_TRIGGER_SEL_PININPUT(base->CSnPinIndex);
   \       0xF8   0x79E0             LDRB     R0,[R4, #+7]
   \       0xFA   0x0040             LSLS     R0,R0,#+1
   \       0xFC   0x9006             STR      R0,[SP, #+24]
    451              timerConfig.triggerPolarity = kFLEXIO_TimerTriggerPolarityActiveLow;
   \       0xFE   0x2001             MOVS     R0,#+1
   \      0x100   0xF88D 0x001C      STRB     R0,[SP, #+28]
    452              timerConfig.triggerSource   = kFLEXIO_TimerTriggerSourceInternal;
   \      0x104   0xF88D 0x001D      STRB     R0,[SP, #+29]
    453              timerConfig.pinConfig       = kFLEXIO_PinConfigOutputDisabled;
   \      0x108   0x2000             MOVS     R0,#+0
   \      0x10A   0xF88D 0x001E      STRB     R0,[SP, #+30]
    454              timerConfig.pinSelect       = base->SCKPinIndex;
   \      0x10E   0x79A0             LDRB     R0,[R4, #+6]
   \      0x110   0x9008             STR      R0,[SP, #+32]
    455              timerConfig.pinPolarity     = kFLEXIO_PinActiveHigh;
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0xF88D 0x0024      STRB     R0,[SP, #+36]
    456              timerConfig.timerMode       = kFLEXIO_TimerModeSingle16Bit;
   \      0x118   0x2003             MOVS     R0,#+3
   \      0x11A   0xF88D 0x0025      STRB     R0,[SP, #+37]
    457              timerConfig.timerOutput     = kFLEXIO_TimerOutputZeroNotAffectedByReset;
   \      0x11E   0x2001             MOVS     R0,#+1
   \      0x120   0xF88D 0x0026      STRB     R0,[SP, #+38]
    458              timerConfig.timerDecrement  = kFLEXIO_TimerDecSrcOnPinInputShiftPinInput;
   \      0x124   0x2002             MOVS     R0,#+2
   \      0x126   0xF88D 0x0027      STRB     R0,[SP, #+39]
    459              timerConfig.timerReset      = kFLEXIO_TimerResetNever;
   \      0x12A   0x2000             MOVS     R0,#+0
   \      0x12C   0xF88D 0x0028      STRB     R0,[SP, #+40]
    460              timerConfig.timerEnable     = kFLEXIO_TimerEnableOnTriggerRisingEdge;
   \      0x130   0x2006             MOVS     R0,#+6
   \      0x132   0xF88D 0x002A      STRB     R0,[SP, #+42]
    461              timerConfig.timerStop       = kFLEXIO_TimerStopBitDisabled;
   \      0x136   0x2000             MOVS     R0,#+0
   \      0x138   0xF88D 0x002B      STRB     R0,[SP, #+43]
    462              if (slaveConfig->phase == kFLEXIO_SPI_ClockPhaseFirstEdge)
   \      0x13C   0x7928             LDRB     R0,[R5, #+4]
   \      0x13E   0x2800             CMP      R0,#+0
   \      0x140   0xD106             BNE.N    ??FLEXIO_SPI_SlaveInit_5
    463              {
    464                  /* The configuration kFLEXIO_TimerDisableOnTimerCompare only support continuous
    465                  PCS access, change to kFLEXIO_TimerDisableNever to enable discontinuous PCS access. */
    466                  timerConfig.timerDisable = kFLEXIO_TimerDisableOnTimerCompare;
   \      0x142   0x2002             MOVS     R0,#+2
   \      0x144   0xF88D 0x0029      STRB     R0,[SP, #+41]
    467                  timerConfig.timerStart   = kFLEXIO_TimerStartBitDisabled;
   \      0x148   0x2000             MOVS     R0,#+0
   \      0x14A   0xF88D 0x002C      STRB     R0,[SP, #+44]
   \      0x14E   0xE005             B.N      ??FLEXIO_SPI_SlaveInit_6
    468              }
    469              else
    470              {
    471                  timerConfig.timerDisable = kFLEXIO_TimerDisableOnTriggerFallingEdge;
   \                     ??FLEXIO_SPI_SlaveInit_5: (+1)
   \      0x150   0x2006             MOVS     R0,#+6
   \      0x152   0xF88D 0x0029      STRB     R0,[SP, #+41]
    472                  timerConfig.timerStart   = kFLEXIO_TimerStartBitEnabled;
   \      0x156   0x2001             MOVS     R0,#+1
   \      0x158   0xF88D 0x002C      STRB     R0,[SP, #+44]
    473              }
    474          
    475              timerConfig.timerCompare = slaveConfig->dataMode * 2 - 1U;
   \                     ??FLEXIO_SPI_SlaveInit_6: (+1)
   \      0x15C   0x7968             LDRB     R0,[R5, #+5]
   \      0x15E   0x0040             LSLS     R0,R0,#+1
   \      0x160   0x1E40             SUBS     R0,R0,#+1
   \      0x162   0x900C             STR      R0,[SP, #+48]
    476          
    477              FLEXIO_SetTimerConfig(base->flexioBase, base->timerIndex[0], &timerConfig);
   \      0x164   0xAA06             ADD      R2,SP,#+24
   \      0x166   0x7AA1             LDRB     R1,[R4, #+10]
   \      0x168   0x6820             LDR      R0,[R4, #+0]
   \      0x16A   0x....'....        BL       FLEXIO_SetTimerConfig
    478          }
   \      0x16E   0xB00D             ADD      SP,SP,#+52
   \      0x170   0xBD30             POP      {R4,R5,PC}       ;; return
    479          
    480          /*!
    481           * brief Gates the FlexIO clock.
    482           *
    483           * param base Pointer to the FLEXIO_SPI_Type.
    484           */

   \                                 In section .text, align 2, keep-with-next
    485          void FLEXIO_SPI_SlaveDeinit(FLEXIO_SPI_Type *base)
    486          {
    487              FLEXIO_SPI_MasterDeinit(base);
   \                     FLEXIO_SPI_SlaveDeinit: (+1)
   \        0x0   0x....             B.N      FLEXIO_SPI_MasterDeinit
    488          }
    489          
    490          /*!
    491           * brief Gets the default configuration to configure the FlexIO SPI slave. The configuration
    492           * can be used directly for calling the FLEXIO_SPI_SlaveConfigure().
    493           * Example:
    494             code
    495             flexio_spi_slave_config_t slaveConfig;
    496             FLEXIO_SPI_SlaveGetDefaultConfig(&slaveConfig);
    497             endcode
    498           * param slaveConfig Pointer to the flexio_spi_slave_config_t structure.
    499          */

   \                                 In section .text, align 2, keep-with-next
    500          void FLEXIO_SPI_SlaveGetDefaultConfig(flexio_spi_slave_config_t *slaveConfig)
    501          {
   \                     FLEXIO_SPI_SlaveGetDefaultConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    502              assert(slaveConfig);
   \        0x4   0xD109             BNE.N    ??FLEXIO_SPI_SlaveGetDefaultConfig_0
   \        0x6   0xF44F 0x72FB      MOV      R2,#+502
   \        0xA   0x....'....        LDR.W    R1,??DataTable15_2
   \        0xE   0x....'....        LDR.W    R0,??DataTable15_9
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
    503          
    504              /* Initializes the configure structure to zero. */
    505              memset(slaveConfig, 0, sizeof(*slaveConfig));
   \                     ??FLEXIO_SPI_SlaveGetDefaultConfig_0: (+1)
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x2106             MOVS     R1,#+6
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x....'....        BL       __aeabi_memset
    506          
    507              slaveConfig->enableSlave      = true;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x7020             STRB     R0,[R4, #+0]
    508              slaveConfig->enableInDoze     = false;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x7060             STRB     R0,[R4, #+1]
    509              slaveConfig->enableInDebug    = true;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x70A0             STRB     R0,[R4, #+2]
    510              slaveConfig->enableFastAccess = false;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x70E0             STRB     R0,[R4, #+3]
    511              /* Default CPHA = 0. */
    512              slaveConfig->phase = kFLEXIO_SPI_ClockPhaseFirstEdge;
   \       0x34   0x7120             STRB     R0,[R4, #+4]
    513              /* Default bit count at 8. */
    514              slaveConfig->dataMode = kFLEXIO_SPI_8BitMode;
   \       0x36   0x2008             MOVS     R0,#+8
   \       0x38   0x7160             STRB     R0,[R4, #+5]
    515          }
   \       0x3A   0xBD10             POP      {R4,PC}          ;; return
    516          
    517          /*!
    518           * brief Enables the FlexIO SPI interrupt.
    519           *
    520           * This function enables the FlexIO SPI interrupt.
    521           *
    522           * param base Pointer to the FLEXIO_SPI_Type structure.
    523           * param mask interrupt source. The parameter can be any combination of the following values:
    524           *        arg kFLEXIO_SPI_RxFullInterruptEnable
    525           *        arg kFLEXIO_SPI_TxEmptyInterruptEnable
    526           */

   \                                 In section .text, align 2, keep-with-next
    527          void FLEXIO_SPI_EnableInterrupts(FLEXIO_SPI_Type *base, uint32_t mask)
    528          {
   \                     FLEXIO_SPI_EnableInterrupts: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    529              if (mask & kFLEXIO_SPI_TxEmptyInterruptEnable)
   \        0x6   0x07E8             LSLS     R0,R5,#+31
   \        0x8   0xD506             BPL.N    ??FLEXIO_SPI_EnableInterrupts_0
    530              {
    531                  FLEXIO_EnableShifterStatusInterrupts(base->flexioBase, 1 << base->shifterIndex[0]);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0xF994 0x0008      LDRSB    R0,[R4, #+8]
   \       0x10   0x4081             LSLS     R1,R1,R0
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x....'....        BL       FLEXIO_EnableShifterStatusInterrupts
    532              }
    533              if (mask & kFLEXIO_SPI_RxFullInterruptEnable)
   \                     ??FLEXIO_SPI_EnableInterrupts_0: (+1)
   \       0x18   0x07A8             LSLS     R0,R5,#+30
   \       0x1A   0xD507             BPL.N    ??FLEXIO_SPI_EnableInterrupts_1
    534              {
    535                  FLEXIO_EnableShifterStatusInterrupts(base->flexioBase, 1 << base->shifterIndex[1]);
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0xF994 0x0009      LDRSB    R0,[R4, #+9]
   \       0x22   0x4081             LSLS     R1,R1,R0
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x2A   0x....             B.N      FLEXIO_EnableShifterStatusInterrupts
    536              }
    537          }
   \                     ??FLEXIO_SPI_EnableInterrupts_1: (+1)
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    538          
    539          /*!
    540           * brief Disables the FlexIO SPI interrupt.
    541           *
    542           * This function disables the FlexIO SPI interrupt.
    543           *
    544           * param base Pointer to the FLEXIO_SPI_Type structure.
    545           * param mask interrupt source The parameter can be any combination of the following values:
    546           *        arg kFLEXIO_SPI_RxFullInterruptEnable
    547           *        arg kFLEXIO_SPI_TxEmptyInterruptEnable
    548           */

   \                                 In section .text, align 2, keep-with-next
    549          void FLEXIO_SPI_DisableInterrupts(FLEXIO_SPI_Type *base, uint32_t mask)
    550          {
   \                     FLEXIO_SPI_DisableInterrupts: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    551              if (mask & kFLEXIO_SPI_TxEmptyInterruptEnable)
   \        0x6   0x07E8             LSLS     R0,R5,#+31
   \        0x8   0xD506             BPL.N    ??FLEXIO_SPI_DisableInterrupts_0
    552              {
    553                  FLEXIO_DisableShifterStatusInterrupts(base->flexioBase, 1 << base->shifterIndex[0]);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0xF994 0x0008      LDRSB    R0,[R4, #+8]
   \       0x10   0x4081             LSLS     R1,R1,R0
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x....'....        BL       FLEXIO_DisableShifterStatusInterrupts
    554              }
    555              if (mask & kFLEXIO_SPI_RxFullInterruptEnable)
   \                     ??FLEXIO_SPI_DisableInterrupts_0: (+1)
   \       0x18   0x07A8             LSLS     R0,R5,#+30
   \       0x1A   0xD507             BPL.N    ??FLEXIO_SPI_DisableInterrupts_1
    556              {
    557                  FLEXIO_DisableShifterStatusInterrupts(base->flexioBase, 1 << base->shifterIndex[1]);
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0xF994 0x0009      LDRSB    R0,[R4, #+9]
   \       0x22   0x4081             LSLS     R1,R1,R0
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x2A   0x....             B.N      FLEXIO_DisableShifterStatusInterrupts
    558              }
    559          }
   \                     ??FLEXIO_SPI_DisableInterrupts_1: (+1)
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    560          
    561          /*!
    562           * brief Enables/disables the FlexIO SPI transmit DMA. This function enables/disables the FlexIO SPI Tx DMA,
    563           * which means that asserting the kFLEXIO_SPI_TxEmptyFlag does/doesn't trigger the DMA request.
    564           *
    565           * param base Pointer to the FLEXIO_SPI_Type structure.
    566           * param mask SPI DMA source.
    567           * param enable True means enable DMA, false means disable DMA.
    568           */

   \                                 In section .text, align 2, keep-with-next
    569          void FLEXIO_SPI_EnableDMA(FLEXIO_SPI_Type *base, uint32_t mask, bool enable)
    570          {
   \                     FLEXIO_SPI_EnableDMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    571              if (mask & kFLEXIO_SPI_TxDmaEnable)
   \        0x8   0x07E8             LSLS     R0,R5,#+31
   \        0xA   0xD505             BPL.N    ??FLEXIO_SPI_EnableDMA_0
    572              {
    573                  FLEXIO_EnableShifterStatusDMA(base->flexioBase, 1U << base->shifterIndex[0], enable);
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x7A20             LDRB     R0,[R4, #+8]
   \       0x10   0x4081             LSLS     R1,R1,R0
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x....'....        BL       FLEXIO_EnableShifterStatusDMA
    574              }
    575          
    576              if (mask & kFLEXIO_SPI_RxDmaEnable)
   \                     ??FLEXIO_SPI_EnableDMA_0: (+1)
   \       0x18   0x07A8             LSLS     R0,R5,#+30
   \       0x1A   0xD507             BPL.N    ??FLEXIO_SPI_EnableDMA_1
    577              {
    578                  FLEXIO_EnableShifterStatusDMA(base->flexioBase, 1U << base->shifterIndex[1], enable);
   \       0x1C   0x4632             MOV      R2,R6
   \       0x1E   0x2101             MOVS     R1,#+1
   \       0x20   0x7A60             LDRB     R0,[R4, #+9]
   \       0x22   0x4081             LSLS     R1,R1,R0
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x2A   0x....             B.N      FLEXIO_EnableShifterStatusDMA
    579              }
    580          }
   \                     ??FLEXIO_SPI_EnableDMA_1: (+1)
   \       0x2C   0xBD70             POP      {R4-R6,PC}       ;; return
    581          
    582          /*!
    583           * brief Gets FlexIO SPI status flags.
    584           *
    585           * param base Pointer to the FLEXIO_SPI_Type structure.
    586           * return status flag; Use the status flag to AND the following flag mask and get the status.
    587           *          arg kFLEXIO_SPI_TxEmptyFlag
    588           *          arg kFLEXIO_SPI_RxEmptyFlag
    589           */
    590          

   \                                 In section .text, align 2, keep-with-next
    591          uint32_t FLEXIO_SPI_GetStatusFlags(FLEXIO_SPI_Type *base)
    592          {
   \                     FLEXIO_SPI_GetStatusFlags: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    593              uint32_t shifterStatus = FLEXIO_GetShifterStatusFlags(base->flexioBase);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x....'....        BL       FLEXIO_GetShifterStatusFlags
   \        0xA   0x4601             MOV      R1,R0
    594              uint32_t status        = 0;
    595          
    596              status = ((shifterStatus & (1U << base->shifterIndex[0])) >> base->shifterIndex[0]);
    597              status |= (((shifterStatus & (1U << base->shifterIndex[1])) >> (base->shifterIndex[1])) << 1U);
    598          
    599              return status;
   \        0xC   0x2301             MOVS     R3,#+1
   \        0xE   0x7A20             LDRB     R0,[R4, #+8]
   \       0x10   0xFA03 0xF000      LSL      R0,R3,R0
   \       0x14   0x4008             ANDS     R0,R0,R1
   \       0x16   0x7A22             LDRB     R2,[R4, #+8]
   \       0x18   0x40D0             LSRS     R0,R0,R2
   \       0x1A   0x7A62             LDRB     R2,[R4, #+9]
   \       0x1C   0x4093             LSLS     R3,R3,R2
   \       0x1E   0x4019             ANDS     R1,R3,R1
   \       0x20   0x40D1             LSRS     R1,R1,R2
   \       0x22   0xEA40 0x0041      ORR      R0,R0,R1, LSL #+1
   \       0x26   0xBD10             POP      {R4,PC}          ;; return
    600          }
    601          
    602          /*!
    603           * brief Clears FlexIO SPI status flags.
    604           *
    605           * param base Pointer to the FLEXIO_SPI_Type structure.
    606           * param mask status flag
    607           *      The parameter can be any combination of the following values:
    608           *          arg kFLEXIO_SPI_TxEmptyFlag
    609           *          arg kFLEXIO_SPI_RxEmptyFlag
    610           */
    611          

   \                                 In section .text, align 2, keep-with-next
    612          void FLEXIO_SPI_ClearStatusFlags(FLEXIO_SPI_Type *base, uint32_t mask)
    613          {
   \                     FLEXIO_SPI_ClearStatusFlags: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    614              if (mask & kFLEXIO_SPI_TxBufferEmptyFlag)
   \        0x6   0x07E8             LSLS     R0,R5,#+31
   \        0x8   0xD505             BPL.N    ??FLEXIO_SPI_ClearStatusFlags_0
    615              {
    616                  FLEXIO_ClearShifterStatusFlags(base->flexioBase, 1U << base->shifterIndex[0]);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x7A20             LDRB     R0,[R4, #+8]
   \        0xE   0x4081             LSLS     R1,R1,R0
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x....'....        BL       FLEXIO_ClearShifterStatusFlags
    617              }
    618              if (mask & kFLEXIO_SPI_RxBufferFullFlag)
   \                     ??FLEXIO_SPI_ClearStatusFlags_0: (+1)
   \       0x16   0x07A8             LSLS     R0,R5,#+30
   \       0x18   0xD506             BPL.N    ??FLEXIO_SPI_ClearStatusFlags_1
    619              {
    620                  FLEXIO_ClearShifterStatusFlags(base->flexioBase, 1U << base->shifterIndex[1]);
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x7A60             LDRB     R0,[R4, #+9]
   \       0x1E   0x4081             LSLS     R1,R1,R0
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x26   0x....             B.N      FLEXIO_ClearShifterStatusFlags
    621              }
    622          }
   \                     ??FLEXIO_SPI_ClearStatusFlags_1: (+1)
   \       0x28   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    623          
    624          /*!
    625           * brief Sets baud rate for the FlexIO SPI transfer, which is only used for the master.
    626           *
    627           * param base Pointer to the FLEXIO_SPI_Type structure.
    628           * param baudRate_Bps Baud Rate needed in Hz.
    629           * param srcClockHz SPI source clock frequency in Hz.
    630           */

   \                                 In section .text, align 2, keep-with-next
    631          void FLEXIO_SPI_MasterSetBaudRate(FLEXIO_SPI_Type *base, uint32_t baudRate_Bps, uint32_t srcClockHz)
    632          {
   \                     FLEXIO_SPI_MasterSetBaudRate: (+1)
   \        0x0   0xB410             PUSH     {R4}
    633              uint16_t timerDiv       = 0;
    634              uint16_t timerCmp       = 0;
    635              FLEXIO_Type *flexioBase = base->flexioBase;
   \        0x2   0x6803             LDR      R3,[R0, #+0]
    636          
    637              /* Set TIMCMP[7:0] = (baud rate divider / 2) - 1.*/
    638              timerDiv = srcClockHz / baudRate_Bps;
    639              timerDiv = timerDiv / 2 - 1U;
    640          
    641              timerCmp = flexioBase->TIMCMP[base->timerIndex[0]];
   \        0x4   0x7A84             LDRB     R4,[R0, #+10]
   \        0x6   0xEB03 0x0484      ADD      R4,R3,R4, LSL #+2
   \        0xA   0xF8D4 0x4500      LDR      R4,[R4, #+1280]
    642              timerCmp &= 0xFF00U;
    643              timerCmp |= timerDiv;
    644          
    645              flexioBase->TIMCMP[base->timerIndex[0]] = timerCmp;
   \        0xE   0x7A80             LDRB     R0,[R0, #+10]
   \       0x10   0xEB03 0x0380      ADD      R3,R3,R0, LSL #+2
   \       0x14   0xF404 0x447F      AND      R4,R4,#0xFF00
   \       0x18   0xFBB2 0xF0F1      UDIV     R0,R2,R1
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0x0840             LSRS     R0,R0,#+1
   \       0x20   0x1E40             SUBS     R0,R0,#+1
   \       0x22   0x4304             ORRS     R4,R0,R4
   \       0x24   0xB2A4             UXTH     R4,R4
   \       0x26   0xF8C3 0x4500      STR      R4,[R3, #+1280]
    646          }
   \       0x2A   0xBC10             POP      {R4}
   \       0x2C   0x4770             BX       LR               ;; return
    647          
    648          /*!
    649           * brief Sends a buffer of data bytes.
    650           *
    651           * note This function blocks using the polling method until all bytes have been sent.
    652           *
    653           * param base Pointer to the FLEXIO_SPI_Type structure.
    654           * param direction Shift direction of MSB first or LSB first.
    655           * param buffer The data bytes to send.
    656           * param size The number of data bytes to send.
    657           */

   \                                 In section .text, align 2, keep-with-next
    658          void FLEXIO_SPI_WriteBlocking(FLEXIO_SPI_Type *base,
    659                                        flexio_spi_shift_direction_t direction,
    660                                        const uint8_t *buffer,
    661                                        size_t size)
    662          {
   \                     FLEXIO_SPI_WriteBlocking: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461C             MOV      R4,R3
    663              assert(buffer);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD109             BNE.N    ??FLEXIO_SPI_WriteBlocking_0
   \        0xE   0xF240 0x2297      MOVW     R2,#+663
   \       0x12   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x16   0x....'....        LDR.W    R0,??DataTable15_10
   \       0x1A   0x....'....        BL       __aeabi_assert
   \       0x1E   0x....'....        BL       __iar_EmptyStepPoint
    664              assert(size);
   \                     ??FLEXIO_SPI_WriteBlocking_0: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD115             BNE.N    ??FLEXIO_SPI_WriteBlocking_1
   \       0x26   0xF44F 0x7226      MOV      R2,#+664
   \       0x2A   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x2E   0x....'....        LDR.W    R0,??DataTable15_11
   \       0x32   0x....'....        BL       __aeabi_assert
   \       0x36   0x....'....        BL       __iar_EmptyStepPoint
   \       0x3A   0xE00A             B.N      ??FLEXIO_SPI_WriteBlocking_1
    665          
    666              while (size--)
    667              {
    668                  /* Wait until data transfer complete. */
    669                  while (!(FLEXIO_SPI_GetStatusFlags(base) & kFLEXIO_SPI_TxBufferEmptyFlag))
   \                     ??FLEXIO_SPI_WriteBlocking_2: (+1)
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x....'....        BL       FLEXIO_SPI_GetStatusFlags
   \       0x42   0x07C0             LSLS     R0,R0,#+31
   \       0x44   0xD5FA             BPL.N    ??FLEXIO_SPI_WriteBlocking_2
    670                  {
    671                  }
    672                  FLEXIO_SPI_WriteData(base, direction, *buffer++);
   \       0x46   0xF815 0x2B01      LDRB     R2,[R5], #+1
   \       0x4A   0x4639             MOV      R1,R7
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x....'....        BL       FLEXIO_SPI_WriteData
    673              }
   \                     ??FLEXIO_SPI_WriteBlocking_1: (+1)
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x1E44             SUBS     R4,R0,#+1
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD1F0             BNE.N    ??FLEXIO_SPI_WriteBlocking_2
    674          }
   \       0x5A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    675          
    676          /*!
    677           * brief Receives a buffer of bytes.
    678           *
    679           * note This function blocks using the polling method until all bytes have been received.
    680           *
    681           * param base Pointer to the FLEXIO_SPI_Type structure.
    682           * param direction Shift direction of MSB first or LSB first.
    683           * param buffer The buffer to store the received bytes.
    684           * param size The number of data bytes to be received.
    685           * param direction Shift direction of MSB first or LSB first.
    686           */

   \                                 In section .text, align 2, keep-with-next
    687          void FLEXIO_SPI_ReadBlocking(FLEXIO_SPI_Type *base,
    688                                       flexio_spi_shift_direction_t direction,
    689                                       uint8_t *buffer,
    690                                       size_t size)
    691          {
   \                     FLEXIO_SPI_ReadBlocking: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461C             MOV      R4,R3
    692              assert(buffer);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD109             BNE.N    ??FLEXIO_SPI_ReadBlocking_0
   \        0xE   0xF44F 0x722D      MOV      R2,#+692
   \       0x12   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x16   0x....'....        LDR.W    R0,??DataTable15_10
   \       0x1A   0x....'....        BL       __aeabi_assert
   \       0x1E   0x....'....        BL       __iar_EmptyStepPoint
    693              assert(size);
   \                     ??FLEXIO_SPI_ReadBlocking_0: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD115             BNE.N    ??FLEXIO_SPI_ReadBlocking_1
   \       0x26   0xF240 0x22B5      MOVW     R2,#+693
   \       0x2A   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x2E   0x....'....        LDR.W    R0,??DataTable15_11
   \       0x32   0x....'....        BL       __aeabi_assert
   \       0x36   0x....'....        BL       __iar_EmptyStepPoint
   \       0x3A   0xE00A             B.N      ??FLEXIO_SPI_ReadBlocking_1
    694          
    695              while (size--)
    696              {
    697                  /* Wait until data transfer complete. */
    698                  while (!(FLEXIO_SPI_GetStatusFlags(base) & kFLEXIO_SPI_RxBufferFullFlag))
   \                     ??FLEXIO_SPI_ReadBlocking_2: (+1)
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x....'....        BL       FLEXIO_SPI_GetStatusFlags
   \       0x42   0x0780             LSLS     R0,R0,#+30
   \       0x44   0xD5FA             BPL.N    ??FLEXIO_SPI_ReadBlocking_2
    699                  {
    700                  }
    701                  *buffer++ = FLEXIO_SPI_ReadData(base, direction);
   \       0x46   0x4639             MOV      R1,R7
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0x....'....        BL       FLEXIO_SPI_ReadData
   \       0x4E   0xF805 0x0B01      STRB     R0,[R5], #+1
    702              }
   \                     ??FLEXIO_SPI_ReadBlocking_1: (+1)
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x1E44             SUBS     R4,R0,#+1
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD1F0             BNE.N    ??FLEXIO_SPI_ReadBlocking_2
    703          }
   \       0x5A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    704          
    705          /*!
    706           * brief Receives a buffer of bytes.
    707           *
    708           * note This function blocks via polling until all bytes have been received.
    709           *
    710           * param base pointer to FLEXIO_SPI_Type structure
    711           * param xfer FlexIO SPI transfer structure, see #flexio_spi_transfer_t.
    712           */

   \                                 In section .text, align 2, keep-with-next
    713          void FLEXIO_SPI_MasterTransferBlocking(FLEXIO_SPI_Type *base, flexio_spi_transfer_t *xfer)
    714          {
   \                     FLEXIO_SPI_MasterTransferBlocking: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    715              flexio_spi_shift_direction_t direction;
    716              uint8_t bytesPerFrame;
    717              uint32_t dataMode = 0;
    718              uint16_t timerCmp = base->flexioBase->TIMCMP[base->timerIndex[0]];
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x7AA1             LDRB     R1,[R4, #+10]
   \        0xA   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \        0xE   0xF8D0 0x0500      LDR      R0,[R0, #+1280]
    719              uint16_t tmpData  = FLEXIO_SPI_DUMMYDATA;
    720          
    721              timerCmp &= 0x00FFU;
   \       0x12   0xF000 0x00FF      AND      R0,R0,#0xFF
    722              /* Configure the values in handle. */
    723              switch (xfer->flags)
   \       0x16   0x7B29             LDRB     R1,[R5, #+12]
   \       0x18   0x2902             CMP      R1,#+2
   \       0x1A   0xD004             BEQ.N    ??FLEXIO_SPI_MasterTransferBlocking_0
   \       0x1C   0x2909             CMP      R1,#+9
   \       0x1E   0xD007             BEQ.N    ??FLEXIO_SPI_MasterTransferBlocking_1
   \       0x20   0x290A             CMP      R1,#+10
   \       0x22   0xD00A             BEQ.N    ??FLEXIO_SPI_MasterTransferBlocking_2
   \       0x24   0xE00E             B.N      ??FLEXIO_SPI_MasterTransferBlocking_3
    724              {
    725                  case kFLEXIO_SPI_8bitMsb:
    726                      dataMode      = (8 * 2 - 1U) << 8U;
    727                      bytesPerFrame = 1;
    728                      direction     = kFLEXIO_SPI_MsbFirst;
    729                      break;
    730          
    731                  case kFLEXIO_SPI_8bitLsb:
    732                      dataMode      = (8 * 2 - 1U) << 8U;
   \                     ??FLEXIO_SPI_MasterTransferBlocking_0: (+1)
   \       0x26   0xF44F 0x6170      MOV      R1,#+3840
    733                      bytesPerFrame = 1;
   \       0x2A   0x2701             MOVS     R7,#+1
    734                      direction     = kFLEXIO_SPI_LsbFirst;
   \       0x2C   0x463E             MOV      R6,R7
    735                      break;
   \       0x2E   0xE00D             B.N      ??FLEXIO_SPI_MasterTransferBlocking_4
    736          
    737                  case kFLEXIO_SPI_16bitMsb:
    738                      dataMode      = (16 * 2 - 1U) << 8U;
   \                     ??FLEXIO_SPI_MasterTransferBlocking_1: (+1)
   \       0x30   0xF44F 0x51F8      MOV      R1,#+7936
    739                      bytesPerFrame = 2;
   \       0x34   0x2702             MOVS     R7,#+2
    740                      direction     = kFLEXIO_SPI_MsbFirst;
   \       0x36   0x2600             MOVS     R6,#+0
    741                      break;
   \       0x38   0xE008             B.N      ??FLEXIO_SPI_MasterTransferBlocking_4
    742          
    743                  case kFLEXIO_SPI_16bitLsb:
    744                      dataMode      = (16 * 2 - 1U) << 8U;
   \                     ??FLEXIO_SPI_MasterTransferBlocking_2: (+1)
   \       0x3A   0xF44F 0x51F8      MOV      R1,#+7936
    745                      bytesPerFrame = 2;
   \       0x3E   0x2702             MOVS     R7,#+2
    746                      direction     = kFLEXIO_SPI_LsbFirst;
   \       0x40   0x2601             MOVS     R6,#+1
    747                      break;
   \       0x42   0xE003             B.N      ??FLEXIO_SPI_MasterTransferBlocking_4
    748          
    749                  default:
    750                      dataMode      = (8 * 2 - 1U) << 8U;
   \                     ??FLEXIO_SPI_MasterTransferBlocking_3: (+1)
   \       0x44   0xF44F 0x6170      MOV      R1,#+3840
    751                      bytesPerFrame = 1;
   \       0x48   0x2701             MOVS     R7,#+1
    752                      direction     = kFLEXIO_SPI_MsbFirst;
   \       0x4A   0x2600             MOVS     R6,#+0
    753                      assert(true);
    754                      break;
    755              }
    756          
    757              dataMode |= timerCmp;
    758          
    759              /* Configure transfer size. */
    760              base->flexioBase->TIMCMP[base->timerIndex[0]] = dataMode;
   \                     ??FLEXIO_SPI_MasterTransferBlocking_4: (+1)
   \       0x4C   0x6822             LDR      R2,[R4, #+0]
   \       0x4E   0x7AA3             LDRB     R3,[R4, #+10]
   \       0x50   0xEB02 0x0283      ADD      R2,R2,R3, LSL #+2
   \       0x54   0x4308             ORRS     R0,R0,R1
   \       0x56   0xF8C2 0x0500      STR      R0,[R2, #+1280]
   \       0x5A   0xE003             B.N      ??FLEXIO_SPI_MasterTransferBlocking_5
    761          
    762              while (xfer->dataSize)
    763              {
    764                  /* Wait until data transfer complete. */
    765                  while (!(FLEXIO_SPI_GetStatusFlags(base) & kFLEXIO_SPI_TxBufferEmptyFlag))
    766                  {
    767                  }
    768                  if (xfer->txData != NULL)
    769                  {
    770                      /* Transmit data and update tx size/buff. */
    771                      if (bytesPerFrame == 1U)
    772                      {
    773                          tmpData = *(xfer->txData);
    774                          xfer->txData++;
    775                      }
    776                      else
    777                      {
    778                          if (direction == kFLEXIO_SPI_MsbFirst)
    779                          {
    780                              tmpData = (uint32_t)(xfer->txData[0]) << 8U;
    781                              tmpData += xfer->txData[1];
    782                          }
    783                          else
    784                          {
    785                              tmpData = (uint32_t)(xfer->txData[1]) << 8U;
    786                              tmpData += xfer->txData[0];
    787                          }
    788                          xfer->txData += 2U;
    789                      }
    790                  }
    791                  else
    792                  {
    793                      tmpData = FLEXIO_SPI_DUMMYDATA;
    794                  }
    795          
    796                  xfer->dataSize -= bytesPerFrame;
    797          
    798                  FLEXIO_SPI_WriteData(base, direction, tmpData);
    799          
    800                  while (!(FLEXIO_SPI_GetStatusFlags(base) & kFLEXIO_SPI_RxBufferFullFlag))
    801                  {
    802                  }
    803                  tmpData = FLEXIO_SPI_ReadData(base, direction);
    804          
    805                  if (xfer->rxData != NULL)
    806                  {
    807                      if (bytesPerFrame == 1U)
    808                      {
    809                          *xfer->rxData = tmpData;
   \                     ??FLEXIO_SPI_MasterTransferBlocking_6: (+1)
   \       0x5C   0x7001             STRB     R1,[R0, #+0]
    810                          xfer->rxData++;
   \       0x5E   0x6868             LDR      R0,[R5, #+4]
   \       0x60   0x1C40             ADDS     R0,R0,#+1
   \       0x62   0x6068             STR      R0,[R5, #+4]
    811                      }
   \                     ??FLEXIO_SPI_MasterTransferBlocking_5: (+1)
   \       0x64   0x68A8             LDR      R0,[R5, #+8]
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD047             BEQ.N    ??FLEXIO_SPI_MasterTransferBlocking_7
   \                     ??FLEXIO_SPI_MasterTransferBlocking_8: (+1)
   \       0x6A   0x4620             MOV      R0,R4
   \       0x6C   0x....'....        BL       FLEXIO_SPI_GetStatusFlags
   \       0x70   0x07C0             LSLS     R0,R0,#+31
   \       0x72   0xD5FA             BPL.N    ??FLEXIO_SPI_MasterTransferBlocking_8
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD017             BEQ.N    ??FLEXIO_SPI_MasterTransferBlocking_9
   \       0x7A   0x2F01             CMP      R7,#+1
   \       0x7C   0xD103             BNE.N    ??FLEXIO_SPI_MasterTransferBlocking_10
   \       0x7E   0x7802             LDRB     R2,[R0, #+0]
   \       0x80   0x1C40             ADDS     R0,R0,#+1
   \       0x82   0x6028             STR      R0,[R5, #+0]
   \       0x84   0xE013             B.N      ??FLEXIO_SPI_MasterTransferBlocking_11
   \                     ??FLEXIO_SPI_MasterTransferBlocking_10: (+1)
   \       0x86   0x0030             MOVS     R0,R6
   \       0x88   0x6828             LDR      R0,[R5, #+0]
   \       0x8A   0xD105             BNE.N    ??FLEXIO_SPI_MasterTransferBlocking_12
   \       0x8C   0x7800             LDRB     R0,[R0, #+0]
   \       0x8E   0x6829             LDR      R1,[R5, #+0]
   \       0x90   0x7849             LDRB     R1,[R1, #+1]
   \       0x92   0xEB11 0x2200      ADDS     R2,R1,R0, LSL #+8
   \       0x96   0xE004             B.N      ??FLEXIO_SPI_MasterTransferBlocking_13
   \                     ??FLEXIO_SPI_MasterTransferBlocking_12: (+1)
   \       0x98   0x7840             LDRB     R0,[R0, #+1]
   \       0x9A   0x6829             LDR      R1,[R5, #+0]
   \       0x9C   0x7809             LDRB     R1,[R1, #+0]
   \       0x9E   0xEB11 0x2200      ADDS     R2,R1,R0, LSL #+8
   \                     ??FLEXIO_SPI_MasterTransferBlocking_13: (+1)
   \       0xA2   0x6828             LDR      R0,[R5, #+0]
   \       0xA4   0x1C80             ADDS     R0,R0,#+2
   \       0xA6   0x6028             STR      R0,[R5, #+0]
   \       0xA8   0xE001             B.N      ??FLEXIO_SPI_MasterTransferBlocking_11
   \                     ??FLEXIO_SPI_MasterTransferBlocking_9: (+1)
   \       0xAA   0xF64F 0x72FF      MOVW     R2,#+65535
   \                     ??FLEXIO_SPI_MasterTransferBlocking_11: (+1)
   \       0xAE   0x68A8             LDR      R0,[R5, #+8]
   \       0xB0   0x1BC0             SUBS     R0,R0,R7
   \       0xB2   0x60A8             STR      R0,[R5, #+8]
   \       0xB4   0xB292             UXTH     R2,R2
   \       0xB6   0x4631             MOV      R1,R6
   \       0xB8   0x4620             MOV      R0,R4
   \       0xBA   0x....'....        BL       FLEXIO_SPI_WriteData
   \                     ??FLEXIO_SPI_MasterTransferBlocking_14: (+1)
   \       0xBE   0x4620             MOV      R0,R4
   \       0xC0   0x....'....        BL       FLEXIO_SPI_GetStatusFlags
   \       0xC4   0x0780             LSLS     R0,R0,#+30
   \       0xC6   0xD5FA             BPL.N    ??FLEXIO_SPI_MasterTransferBlocking_14
   \       0xC8   0x4631             MOV      R1,R6
   \       0xCA   0x4620             MOV      R0,R4
   \       0xCC   0x....'....        BL       FLEXIO_SPI_ReadData
   \       0xD0   0x4601             MOV      R1,R0
   \       0xD2   0x6868             LDR      R0,[R5, #+4]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD0C5             BEQ.N    ??FLEXIO_SPI_MasterTransferBlocking_5
   \       0xD8   0x2F01             CMP      R7,#+1
   \       0xDA   0xD0BF             BEQ.N    ??FLEXIO_SPI_MasterTransferBlocking_6
    812                      else
    813                      {
    814                          if (direction == kFLEXIO_SPI_MsbFirst)
   \       0xDC   0x0030             MOVS     R0,R6
   \       0xDE   0xD102             BNE.N    ??FLEXIO_SPI_MasterTransferBlocking_15
    815                          {
    816                              *((uint16_t *)(xfer->rxData)) = tmpData;
   \       0xE0   0x6868             LDR      R0,[R5, #+4]
   \       0xE2   0x8001             STRH     R1,[R0, #+0]
   \       0xE4   0xE005             B.N      ??FLEXIO_SPI_MasterTransferBlocking_16
    817                          }
    818                          else
    819                          {
    820                              *((uint16_t *)(xfer->rxData)) = (((tmpData << 8) & 0xff00U) | ((tmpData >> 8) & 0x00ffU));
   \                     ??FLEXIO_SPI_MasterTransferBlocking_15: (+1)
   \       0xE6   0x4608             MOV      R0,R1
   \       0xE8   0x0A00             LSRS     R0,R0,#+8
   \       0xEA   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \       0xEE   0x6869             LDR      R1,[R5, #+4]
   \       0xF0   0x8008             STRH     R0,[R1, #+0]
    821                          }
    822                          xfer->rxData += 2U;
   \                     ??FLEXIO_SPI_MasterTransferBlocking_16: (+1)
   \       0xF2   0x6868             LDR      R0,[R5, #+4]
   \       0xF4   0x1C80             ADDS     R0,R0,#+2
   \       0xF6   0x6068             STR      R0,[R5, #+4]
   \       0xF8   0xE7B4             B.N      ??FLEXIO_SPI_MasterTransferBlocking_5
    823                      }
    824                  }
    825              }
    826          }
   \                     ??FLEXIO_SPI_MasterTransferBlocking_7: (+1)
   \       0xFA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    827          
    828          /*!
    829           * brief Initializes the FlexIO SPI Master handle, which is used in transactional functions.
    830           *
    831           * param base Pointer to the FLEXIO_SPI_Type structure.
    832           * param handle Pointer to the flexio_spi_master_handle_t structure to store the transfer state.
    833           * param callback The callback function.
    834           * param userData The parameter of the callback function.
    835           * retval kStatus_Success Successfully create the handle.
    836           * retval kStatus_OutOfRange The FlexIO type/handle/ISR table out of range.
    837           */

   \                                 In section .text, align 2, keep-with-next
    838          status_t FLEXIO_SPI_MasterTransferCreateHandle(FLEXIO_SPI_Type *base,
    839                                                         flexio_spi_master_handle_t *handle,
    840                                                         flexio_spi_master_transfer_callback_t callback,
    841                                                         void *userData)
    842          {
   \                     FLEXIO_SPI_MasterTransferCreateHandle: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    843              assert(handle);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD109             BNE.N    ??FLEXIO_SPI_MasterTransferCreateHandle_0
   \        0xE   0xF240 0x324B      MOVW     R2,#+843
   \       0x12   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x16   0x....'....        LDR.W    R0,??DataTable15_12
   \       0x1A   0x....'....        BL       __aeabi_assert
   \       0x1E   0x....'....        BL       __iar_EmptyStepPoint
    844          
    845              IRQn_Type flexio_irqs[] = FLEXIO_IRQS;
   \                     ??FLEXIO_SPI_MasterTransferCreateHandle_0: (+1)
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x....'....        LDR.W    R1,??DataTable15_13
   \       0x28   0xE9D1 0x2300      LDRD     R2,R3,[R1, #+0]
   \       0x2C   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
    846          
    847              /* Zero the handle. */
    848              memset(handle, 0, sizeof(*handle));
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x2124             MOVS     R1,#+36
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       __aeabi_memset4
    849          
    850              /* Register callback and userData. */
    851              handle->callback = callback;
   \       0x3A   0x61E6             STR      R6,[R4, #+28]
    852              handle->userData = userData;
   \       0x3C   0x6227             STR      R7,[R4, #+32]
    853          
    854              /* Enable interrupt in NVIC. */
    855              EnableIRQ(flexio_irqs[FLEXIO_SPI_GetInstance(base)]);
   \       0x3E   0x4628             MOV      R0,R5
   \       0x40   0x....'....        BL       FLEXIO_SPI_GetInstance
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x4A   0x....'....        BL       EnableIRQ
    856          
    857              /* Save the context in global variables to support the double weak mechanism. */
    858              return FLEXIO_RegisterHandleIRQ(base, handle, FLEXIO_SPI_MasterTransferHandleIRQ);
   \       0x4E   0x....'....        ADR.W    R2,FLEXIO_SPI_MasterTransferHandleIRQ
   \       0x52   0x4621             MOV      R1,R4
   \       0x54   0x4628             MOV      R0,R5
   \       0x56   0x....'....        BL       FLEXIO_RegisterHandleIRQ
   \       0x5A   0xBDFE             POP      {R1-R7,PC}       ;; return
    859          }
    860          
    861          /*!
    862           * brief Master transfer data using IRQ.
    863           *
    864           * This function sends data using IRQ. This is a non-blocking function, which returns
    865           * right away. When all data is sent out/received, the callback function is called.
    866           *
    867           * param base Pointer to the FLEXIO_SPI_Type structure.
    868           * param handle Pointer to the flexio_spi_master_handle_t structure to store the transfer state.
    869           * param xfer FlexIO SPI transfer structure. See #flexio_spi_transfer_t.
    870           * retval kStatus_Success Successfully start a transfer.
    871           * retval kStatus_InvalidArgument Input argument is invalid.
    872           * retval kStatus_FLEXIO_SPI_Busy SPI is not idle, is running another transfer.
    873           */

   \                                 In section .text, align 2, keep-with-next
    874          status_t FLEXIO_SPI_MasterTransferNonBlocking(FLEXIO_SPI_Type *base,
    875                                                        flexio_spi_master_handle_t *handle,
    876                                                        flexio_spi_transfer_t *xfer)
    877          {
   \                     FLEXIO_SPI_MasterTransferNonBlocking: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
    878              assert(handle);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD109             BNE.N    ??FLEXIO_SPI_MasterTransferNonBlocking_0
   \        0xC   0xF240 0x326E      MOVW     R2,#+878
   \       0x10   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x14   0x....'....        LDR.W    R0,??DataTable15_12
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
    879              assert(xfer);
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_0: (+1)
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD109             BNE.N    ??FLEXIO_SPI_MasterTransferNonBlocking_1
   \       0x24   0xF240 0x326F      MOVW     R2,#+879
   \       0x28   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x2C   0x....'....        LDR.W    R0,??DataTable15_14
   \       0x30   0x....'....        BL       __aeabi_assert
   \       0x34   0x....'....        BL       __iar_EmptyStepPoint
    880          
    881              uint32_t dataMode = 0;
    882              uint16_t timerCmp = base->flexioBase->TIMCMP[base->timerIndex[0]];
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_1: (+1)
   \       0x38   0x6830             LDR      R0,[R6, #+0]
   \       0x3A   0x7AB1             LDRB     R1,[R6, #+10]
   \       0x3C   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \       0x40   0xF8D0 0x1500      LDR      R1,[R0, #+1280]
    883              uint16_t tmpData  = FLEXIO_SPI_DUMMYDATA;
   \       0x44   0xF64F 0x72FF      MOVW     R2,#+65535
    884          
    885              timerCmp &= 0x00FFU;
   \       0x48   0xF001 0x01FF      AND      R1,R1,#0xFF
    886          
    887              /* Check if SPI is busy. */
    888              if (handle->state == kFLEXIO_SPI_Busy)
   \       0x4C   0x6960             LDR      R0,[R4, #+20]
   \       0x4E   0x2801             CMP      R0,#+1
   \       0x50   0xD102             BNE.N    ??FLEXIO_SPI_MasterTransferNonBlocking_2
    889              {
    890                  return kStatus_FLEXIO_SPI_Busy;
   \       0x52   0xF240 0x10F5      MOVW     R0,#+501
   \       0x56   0xBDF2             POP      {R1,R4-R7,PC}
    891              }
    892          
    893              /* Check if the argument is legal. */
    894              if ((xfer->txData == NULL) && (xfer->rxData == NULL))
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_2: (+1)
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD104             BNE.N    ??FLEXIO_SPI_MasterTransferNonBlocking_3
   \       0x5E   0x6868             LDR      R0,[R5, #+4]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD101             BNE.N    ??FLEXIO_SPI_MasterTransferNonBlocking_3
    895              {
    896                  return kStatus_InvalidArgument;
   \       0x64   0x2004             MOVS     R0,#+4
   \       0x66   0xBDF2             POP      {R1,R4-R7,PC}
    897              }
    898          
    899              /* Configure the values in handle */
    900              switch (xfer->flags)
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_3: (+1)
   \       0x68   0x7B28             LDRB     R0,[R5, #+12]
   \       0x6A   0x2802             CMP      R0,#+2
   \       0x6C   0xD004             BEQ.N    ??FLEXIO_SPI_MasterTransferNonBlocking_4
   \       0x6E   0x2809             CMP      R0,#+9
   \       0x70   0xD008             BEQ.N    ??FLEXIO_SPI_MasterTransferNonBlocking_5
   \       0x72   0x280A             CMP      R0,#+10
   \       0x74   0xD00D             BEQ.N    ??FLEXIO_SPI_MasterTransferNonBlocking_6
   \       0x76   0xE013             B.N      ??FLEXIO_SPI_MasterTransferNonBlocking_7
    901              {
    902                  case kFLEXIO_SPI_8bitMsb:
    903                      dataMode             = (8 * 2 - 1U) << 8U;
    904                      handle->bytePerFrame = 1U;
    905                      handle->direction    = kFLEXIO_SPI_MsbFirst;
    906                      break;
    907                  case kFLEXIO_SPI_8bitLsb:
    908                      dataMode             = (8 * 2 - 1U) << 8U;
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_4: (+1)
   \       0x78   0xF44F 0x6070      MOV      R0,#+3840
    909                      handle->bytePerFrame = 1U;
   \       0x7C   0x2301             MOVS     R3,#+1
   \       0x7E   0x7623             STRB     R3,[R4, #+24]
    910                      handle->direction    = kFLEXIO_SPI_LsbFirst;
   \       0x80   0x7663             STRB     R3,[R4, #+25]
    911                      break;
   \       0x82   0xE013             B.N      ??FLEXIO_SPI_MasterTransferNonBlocking_8
    912                  case kFLEXIO_SPI_16bitMsb:
    913                      dataMode             = (16 * 2 - 1U) << 8U;
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_5: (+1)
   \       0x84   0xF44F 0x50F8      MOV      R0,#+7936
    914                      handle->bytePerFrame = 2U;
   \       0x88   0x2302             MOVS     R3,#+2
   \       0x8A   0x7623             STRB     R3,[R4, #+24]
    915                      handle->direction    = kFLEXIO_SPI_MsbFirst;
   \       0x8C   0x2300             MOVS     R3,#+0
   \       0x8E   0x7663             STRB     R3,[R4, #+25]
    916                      break;
   \       0x90   0xE00C             B.N      ??FLEXIO_SPI_MasterTransferNonBlocking_8
    917                  case kFLEXIO_SPI_16bitLsb:
    918                      dataMode             = (16 * 2 - 1U) << 8U;
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_6: (+1)
   \       0x92   0xF44F 0x50F8      MOV      R0,#+7936
    919                      handle->bytePerFrame = 2U;
   \       0x96   0x2302             MOVS     R3,#+2
   \       0x98   0x7623             STRB     R3,[R4, #+24]
    920                      handle->direction    = kFLEXIO_SPI_LsbFirst;
   \       0x9A   0x2301             MOVS     R3,#+1
   \       0x9C   0x7663             STRB     R3,[R4, #+25]
    921                      break;
   \       0x9E   0xE005             B.N      ??FLEXIO_SPI_MasterTransferNonBlocking_8
    922                  default:
    923                      dataMode             = (8 * 2 - 1U) << 8U;
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_7: (+1)
   \       0xA0   0xF44F 0x6070      MOV      R0,#+3840
    924                      handle->bytePerFrame = 1U;
   \       0xA4   0x2301             MOVS     R3,#+1
   \       0xA6   0x7623             STRB     R3,[R4, #+24]
    925                      handle->direction    = kFLEXIO_SPI_MsbFirst;
   \       0xA8   0x2300             MOVS     R3,#+0
   \       0xAA   0x7663             STRB     R3,[R4, #+25]
    926                      assert(true);
    927                      break;
    928              }
    929          
    930              dataMode |= timerCmp;
    931          
    932              /* Configure transfer size. */
    933              base->flexioBase->TIMCMP[base->timerIndex[0]] = dataMode;
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_8: (+1)
   \       0xAC   0x6833             LDR      R3,[R6, #+0]
   \       0xAE   0x7AB7             LDRB     R7,[R6, #+10]
   \       0xB0   0xEB03 0x0387      ADD      R3,R3,R7, LSL #+2
   \       0xB4   0x4301             ORRS     R1,R1,R0
   \       0xB6   0xF8C3 0x1500      STR      R1,[R3, #+1280]
    934          
    935              handle->state            = kFLEXIO_SPI_Busy;
   \       0xBA   0x2001             MOVS     R0,#+1
   \       0xBC   0x6160             STR      R0,[R4, #+20]
    936              handle->txData           = xfer->txData;
   \       0xBE   0x6828             LDR      R0,[R5, #+0]
   \       0xC0   0x6020             STR      R0,[R4, #+0]
    937              handle->rxData           = xfer->rxData;
   \       0xC2   0x6868             LDR      R0,[R5, #+4]
   \       0xC4   0x6060             STR      R0,[R4, #+4]
    938              handle->rxRemainingBytes = xfer->dataSize;
   \       0xC6   0x68A8             LDR      R0,[R5, #+8]
   \       0xC8   0x6120             STR      R0,[R4, #+16]
    939          
    940              /* Save total transfer size. */
    941              handle->transferSize = xfer->dataSize;
   \       0xCA   0x68A8             LDR      R0,[R5, #+8]
   \       0xCC   0x60A0             STR      R0,[R4, #+8]
    942          
    943              /* Send first byte of data to trigger the rx interrupt. */
    944              if (handle->txData != NULL)
   \       0xCE   0x6820             LDR      R0,[R4, #+0]
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xD019             BEQ.N    ??FLEXIO_SPI_MasterTransferNonBlocking_9
    945              {
    946                  /* Transmit data and update tx size/buff. */
    947                  if (handle->bytePerFrame == 1U)
   \       0xD4   0x7E20             LDRB     R0,[R4, #+24]
   \       0xD6   0x2801             CMP      R0,#+1
   \       0xD8   0xD104             BNE.N    ??FLEXIO_SPI_MasterTransferNonBlocking_10
    948                  {
    949                      tmpData = *(handle->txData);
   \       0xDA   0x6820             LDR      R0,[R4, #+0]
   \       0xDC   0x7802             LDRB     R2,[R0, #+0]
    950                      handle->txData++;
   \       0xDE   0x1C40             ADDS     R0,R0,#+1
   \       0xE0   0x6020             STR      R0,[R4, #+0]
   \       0xE2   0xE011             B.N      ??FLEXIO_SPI_MasterTransferNonBlocking_9
    951                  }
    952                  else
    953                  {
    954                      if (handle->direction == kFLEXIO_SPI_MsbFirst)
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_10: (+1)
   \       0xE4   0x7E60             LDRB     R0,[R4, #+25]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0x6820             LDR      R0,[R4, #+0]
   \       0xEA   0xD105             BNE.N    ??FLEXIO_SPI_MasterTransferNonBlocking_11
    955                      {
    956                          tmpData = (uint32_t)(handle->txData[0]) << 8U;
    957                          tmpData += handle->txData[1];
   \       0xEC   0x7800             LDRB     R0,[R0, #+0]
   \       0xEE   0x6821             LDR      R1,[R4, #+0]
   \       0xF0   0x7849             LDRB     R1,[R1, #+1]
   \       0xF2   0xEB11 0x2200      ADDS     R2,R1,R0, LSL #+8
   \       0xF6   0xE004             B.N      ??FLEXIO_SPI_MasterTransferNonBlocking_12
    958                      }
    959                      else
    960                      {
    961                          tmpData = (uint32_t)(handle->txData[1]) << 8U;
    962                          tmpData += handle->txData[0];
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_11: (+1)
   \       0xF8   0x7840             LDRB     R0,[R0, #+1]
   \       0xFA   0x6821             LDR      R1,[R4, #+0]
   \       0xFC   0x7809             LDRB     R1,[R1, #+0]
   \       0xFE   0xEB11 0x2200      ADDS     R2,R1,R0, LSL #+8
    963                      }
    964                      handle->txData += 2U;
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_12: (+1)
   \      0x102   0x6820             LDR      R0,[R4, #+0]
   \      0x104   0x1C80             ADDS     R0,R0,#+2
   \      0x106   0x6020             STR      R0,[R4, #+0]
    965                  }
    966              }
    967              else
    968              {
    969                  tmpData = FLEXIO_SPI_DUMMYDATA;
    970              }
    971          
    972              handle->txRemainingBytes = xfer->dataSize - handle->bytePerFrame;
   \                     ??FLEXIO_SPI_MasterTransferNonBlocking_9: (+1)
   \      0x108   0x68A9             LDR      R1,[R5, #+8]
   \      0x10A   0x7E20             LDRB     R0,[R4, #+24]
   \      0x10C   0x1A09             SUBS     R1,R1,R0
   \      0x10E   0x60E1             STR      R1,[R4, #+12]
    973          
    974              FLEXIO_SPI_WriteData(base, handle->direction, tmpData);
   \      0x110   0xB292             UXTH     R2,R2
   \      0x112   0x7E61             LDRB     R1,[R4, #+25]
   \      0x114   0x4630             MOV      R0,R6
   \      0x116   0x....'....        BL       FLEXIO_SPI_WriteData
    975          
    976              /* Enable transmit and receive interrupt to handle rx. */
    977              FLEXIO_SPI_EnableInterrupts(base, kFLEXIO_SPI_RxFullInterruptEnable);
   \      0x11A   0x2102             MOVS     R1,#+2
   \      0x11C   0x4630             MOV      R0,R6
   \      0x11E   0x....'....        BL       FLEXIO_SPI_EnableInterrupts
    978          
    979              return kStatus_Success;
   \      0x122   0x2000             MOVS     R0,#+0
   \      0x124   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    980          }
    981          
    982          /*!
    983           * brief Gets the data transfer status which used IRQ.
    984           *
    985           * param base Pointer to the FLEXIO_SPI_Type structure.
    986           * param handle Pointer to the flexio_spi_master_handle_t structure to store the transfer state.
    987           * param count Number of bytes transferred so far by the non-blocking transaction.
    988           * retval kStatus_InvalidArgument count is Invalid.
    989           * retval kStatus_Success Successfully return the count.
    990           */

   \                                 In section .text, align 2, keep-with-next
    991          status_t FLEXIO_SPI_MasterTransferGetCount(FLEXIO_SPI_Type *base, flexio_spi_master_handle_t *handle, size_t *count)
    992          {
   \                     FLEXIO_SPI_MasterTransferGetCount: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4614             MOV      R4,R2
    993              assert(handle);
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD107             BNE.N    ??FLEXIO_SPI_MasterTransferGetCount_0
   \        0xA   0xF240 0x32E1      MOVW     R2,#+993
   \        0xE   0x....             LDR.N    R1,??DataTable15_2
   \       0x10   0x....             LDR.N    R0,??DataTable15_12
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
    994          
    995              if (!count)
   \                     ??FLEXIO_SPI_MasterTransferGetCount_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD101             BNE.N    ??FLEXIO_SPI_MasterTransferGetCount_1
    996              {
    997                  return kStatus_InvalidArgument;
   \       0x1E   0x2004             MOVS     R0,#+4
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
    998              }
    999          
   1000              /* Return remaing bytes in different cases. */
   1001              if (handle->rxData)
   \                     ??FLEXIO_SPI_MasterTransferGetCount_1: (+1)
   \       0x22   0x6868             LDR      R0,[R5, #+4]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0x68A9             LDR      R1,[R5, #+8]
   \       0x28   0xD003             BEQ.N    ??FLEXIO_SPI_MasterTransferGetCount_2
   1002              {
   1003                  *count = handle->transferSize - handle->rxRemainingBytes;
   \       0x2A   0x6928             LDR      R0,[R5, #+16]
   \       0x2C   0x1A09             SUBS     R1,R1,R0
   \       0x2E   0x6021             STR      R1,[R4, #+0]
   \       0x30   0xE002             B.N      ??FLEXIO_SPI_MasterTransferGetCount_3
   1004              }
   1005              else
   1006              {
   1007                  *count = handle->transferSize - handle->txRemainingBytes;
   \                     ??FLEXIO_SPI_MasterTransferGetCount_2: (+1)
   \       0x32   0x68E8             LDR      R0,[R5, #+12]
   \       0x34   0x1A09             SUBS     R1,R1,R0
   \       0x36   0x6021             STR      R1,[R4, #+0]
   1008              }
   1009          
   1010              return kStatus_Success;
   \                     ??FLEXIO_SPI_MasterTransferGetCount_3: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1011          }
   1012          
   1013          /*!
   1014           * brief Aborts the master data transfer, which used IRQ.
   1015           *
   1016           * param base Pointer to the FLEXIO_SPI_Type structure.
   1017           * param handle Pointer to the flexio_spi_master_handle_t structure to store the transfer state.
   1018           */

   \                                 In section .text, align 2, keep-with-next
   1019          void FLEXIO_SPI_MasterTransferAbort(FLEXIO_SPI_Type *base, flexio_spi_master_handle_t *handle)
   1020          {
   \                     FLEXIO_SPI_MasterTransferAbort: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1021              assert(handle);
   \        0x6   0xD107             BNE.N    ??FLEXIO_SPI_MasterTransferAbort_0
   \        0x8   0xF240 0x32FD      MOVW     R2,#+1021
   \        0xC   0x....             LDR.N    R1,??DataTable15_2
   \        0xE   0x....             LDR.N    R0,??DataTable15_12
   \       0x10   0x....'....        BL       __aeabi_assert
   \       0x14   0x....'....        BL       __iar_EmptyStepPoint
   1022          
   1023              FLEXIO_SPI_DisableInterrupts(base, kFLEXIO_SPI_RxFullInterruptEnable);
   \                     ??FLEXIO_SPI_MasterTransferAbort_0: (+1)
   \       0x18   0x2102             MOVS     R1,#+2
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x....'....        BL       FLEXIO_SPI_DisableInterrupts
   1024              FLEXIO_SPI_DisableInterrupts(base, kFLEXIO_SPI_TxEmptyInterruptEnable);
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0x....'....        BL       FLEXIO_SPI_DisableInterrupts
   1025          
   1026              /* Transfer finished, set the state to idle. */
   1027              handle->state = kFLEXIO_SPI_Idle;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6160             STR      R0,[R4, #+20]
   1028          
   1029              /* Clear the internal state. */
   1030              handle->rxRemainingBytes = 0;
   \       0x2C   0x6120             STR      R0,[R4, #+16]
   1031              handle->txRemainingBytes = 0;
   \       0x2E   0x60E0             STR      R0,[R4, #+12]
   1032          }
   \       0x30   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1033          
   1034          /*!
   1035           * brief FlexIO SPI master IRQ handler function.
   1036           *
   1037           * param spiType Pointer to the FLEXIO_SPI_Type structure.
   1038           * param spiHandle Pointer to the flexio_spi_master_handle_t structure to store the transfer state.
   1039           */

   \                                 In section .text, align 4, keep-with-next
   1040          void FLEXIO_SPI_MasterTransferHandleIRQ(void *spiType, void *spiHandle)
   1041          {
   \                     FLEXIO_SPI_MasterTransferHandleIRQ: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1042              assert(spiHandle);
   \        0x6   0xD107             BNE.N    ??FLEXIO_SPI_MasterTransferHandleIRQ_0
   \        0x8   0xF240 0x4212      MOVW     R2,#+1042
   \        0xC   0x....             LDR.N    R1,??DataTable15_2
   \        0xE   0x....             LDR.N    R0,??DataTable15_15
   \       0x10   0x....'....        BL       __aeabi_assert
   \       0x14   0x....'....        BL       __iar_EmptyStepPoint
   1043          
   1044              flexio_spi_master_handle_t *handle = (flexio_spi_master_handle_t *)spiHandle;
   1045              FLEXIO_SPI_Type *base;
   1046              uint32_t status;
   1047          
   1048              if (handle->state == kFLEXIO_SPI_Idle)
   \                     ??FLEXIO_SPI_MasterTransferHandleIRQ_0: (+1)
   \       0x18   0x6960             LDR      R0,[R4, #+20]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD029             BEQ.N    ??FLEXIO_SPI_MasterTransferHandleIRQ_1
   1049              {
   1050                  return;
   1051              }
   1052          
   1053              base   = (FLEXIO_SPI_Type *)spiType;
   1054              status = FLEXIO_SPI_GetStatusFlags(base);
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x....'....        BL       FLEXIO_SPI_GetStatusFlags
   \       0x24   0x4606             MOV      R6,R0
   1055          
   1056              /* Handle rx. */
   1057              if ((status & kFLEXIO_SPI_RxBufferFullFlag) && (handle->rxRemainingBytes))
   \       0x26   0x07B0             LSLS     R0,R6,#+30
   \       0x28   0xD506             BPL.N    ??FLEXIO_SPI_MasterTransferHandleIRQ_2
   \       0x2A   0x6920             LDR      R0,[R4, #+16]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD003             BEQ.N    ??FLEXIO_SPI_MasterTransferHandleIRQ_2
   1058              {
   1059                  FLEXIO_SPI_TransferReceiveTransaction(base, handle);
   \       0x30   0x4621             MOV      R1,R4
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0x....'....        BL       FLEXIO_SPI_TransferReceiveTransaction
   1060              }
   1061          
   1062              /* Handle tx. */
   1063              if ((status & kFLEXIO_SPI_TxBufferEmptyFlag) && (handle->txRemainingBytes))
   \                     ??FLEXIO_SPI_MasterTransferHandleIRQ_2: (+1)
   \       0x38   0x07F0             LSLS     R0,R6,#+31
   \       0x3A   0xD506             BPL.N    ??FLEXIO_SPI_MasterTransferHandleIRQ_3
   \       0x3C   0x68E0             LDR      R0,[R4, #+12]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD003             BEQ.N    ??FLEXIO_SPI_MasterTransferHandleIRQ_3
   1064              {
   1065                  FLEXIO_SPI_TransferSendTransaction(base, handle);
   \       0x42   0x4621             MOV      R1,R4
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x....'....        BL       FLEXIO_SPI_TransferSendTransaction
   1066              }
   1067          
   1068              /* All the transfer finished. */
   1069              if ((handle->txRemainingBytes == 0U) && (handle->rxRemainingBytes == 0U))
   \                     ??FLEXIO_SPI_MasterTransferHandleIRQ_3: (+1)
   \       0x4A   0x68E0             LDR      R0,[R4, #+12]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD110             BNE.N    ??FLEXIO_SPI_MasterTransferHandleIRQ_1
   \       0x50   0x6920             LDR      R0,[R4, #+16]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD10D             BNE.N    ??FLEXIO_SPI_MasterTransferHandleIRQ_1
   1070              {
   1071                  FLEXIO_SPI_MasterTransferAbort(base, handle);
   \       0x56   0x4621             MOV      R1,R4
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       FLEXIO_SPI_MasterTransferAbort
   1072                  if (handle->callback)
   \       0x5E   0x69E0             LDR      R0,[R4, #+28]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD006             BEQ.N    ??FLEXIO_SPI_MasterTransferHandleIRQ_1
   1073                  {
   1074                      (handle->callback)(base, handle, kStatus_FLEXIO_SPI_Idle, handle->userData);
   \       0x64   0x6A23             LDR      R3,[R4, #+32]
   \       0x66   0xF44F 0x72FB      MOV      R2,#+502
   \       0x6A   0x4621             MOV      R1,R4
   \       0x6C   0x4628             MOV      R0,R5
   \       0x6E   0x69E4             LDR      R4,[R4, #+28]
   \       0x70   0x47A0             BLX      R4
   1075                  }
   1076              }
   1077          }
   \                     ??FLEXIO_SPI_MasterTransferHandleIRQ_1: (+1)
   \       0x72   0xBD70             POP      {R4-R6,PC}       ;; return
   1078          
   1079          /*!
   1080           * brief Initializes the FlexIO SPI Slave handle, which is used in transactional functions.
   1081           *
   1082           * param base Pointer to the FLEXIO_SPI_Type structure.
   1083           * param handle Pointer to the flexio_spi_slave_handle_t structure to store the transfer state.
   1084           * param callback The callback function.
   1085           * param userData The parameter of the callback function.
   1086           * retval kStatus_Success Successfully create the handle.
   1087           * retval kStatus_OutOfRange The FlexIO type/handle/ISR table out of range.
   1088           */

   \                                 In section .text, align 2, keep-with-next
   1089          status_t FLEXIO_SPI_SlaveTransferCreateHandle(FLEXIO_SPI_Type *base,
   1090                                                        flexio_spi_slave_handle_t *handle,
   1091                                                        flexio_spi_slave_transfer_callback_t callback,
   1092                                                        void *userData)
   1093          {
   \                     FLEXIO_SPI_SlaveTransferCreateHandle: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
   1094              assert(handle);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD107             BNE.N    ??FLEXIO_SPI_SlaveTransferCreateHandle_0
   \        0xE   0xF240 0x4246      MOVW     R2,#+1094
   \       0x12   0x....             LDR.N    R1,??DataTable15_2
   \       0x14   0x....             LDR.N    R0,??DataTable15_12
   \       0x16   0x....'....        BL       __aeabi_assert
   \       0x1A   0x....'....        BL       __iar_EmptyStepPoint
   1095          
   1096              IRQn_Type flexio_irqs[] = FLEXIO_IRQS;
   \                     ??FLEXIO_SPI_SlaveTransferCreateHandle_0: (+1)
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x....             LDR.N    R1,??DataTable15_16
   \       0x22   0xE9D1 0x2300      LDRD     R2,R3,[R1, #+0]
   \       0x26   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   1097          
   1098              /* Zero the handle. */
   1099              memset(handle, 0, sizeof(*handle));
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x2124             MOVS     R1,#+36
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       __aeabi_memset4
   1100          
   1101              /* Register callback and userData. */
   1102              handle->callback = callback;
   \       0x34   0x61E6             STR      R6,[R4, #+28]
   1103              handle->userData = userData;
   \       0x36   0x6227             STR      R7,[R4, #+32]
   1104          
   1105              /* Enable interrupt in NVIC. */
   1106              EnableIRQ(flexio_irqs[FLEXIO_SPI_GetInstance(base)]);
   \       0x38   0x4628             MOV      R0,R5
   \       0x3A   0x....'....        BL       FLEXIO_SPI_GetInstance
   \       0x3E   0x4669             MOV      R1,SP
   \       0x40   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x44   0x....'....        BL       EnableIRQ
   1107          
   1108              /* Save the context in global variables to support the double weak mechanism. */
   1109              return FLEXIO_RegisterHandleIRQ(base, handle, FLEXIO_SPI_SlaveTransferHandleIRQ);
   \       0x48   0x....'....        ADR.W    R2,FLEXIO_SPI_SlaveTransferHandleIRQ
   \       0x4C   0x4621             MOV      R1,R4
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0x....'....        BL       FLEXIO_RegisterHandleIRQ
   \       0x54   0xBDFE             POP      {R1-R7,PC}       ;; return
   1110          }
   1111          
   1112          /*!
   1113           * brief Slave transfer data using IRQ.
   1114           *
   1115           * This function sends data using IRQ. This is a non-blocking function, which returns
   1116           * right away. When all data is sent out/received, the callback function is called.
   1117           * param handle Pointer to the flexio_spi_slave_handle_t structure to store the transfer state.
   1118           *
   1119           * param base Pointer to the FLEXIO_SPI_Type structure.
   1120           * param xfer FlexIO SPI transfer structure. See #flexio_spi_transfer_t.
   1121           * retval kStatus_Success Successfully start a transfer.
   1122           * retval kStatus_InvalidArgument Input argument is invalid.
   1123           * retval kStatus_FLEXIO_SPI_Busy SPI is not idle; it is running another transfer.
   1124           */

   \                                 In section .text, align 2, keep-with-next
   1125          status_t FLEXIO_SPI_SlaveTransferNonBlocking(FLEXIO_SPI_Type *base,
   1126                                                       flexio_spi_slave_handle_t *handle,
   1127                                                       flexio_spi_transfer_t *xfer)
   1128          {
   \                     FLEXIO_SPI_SlaveTransferNonBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
   1129              assert(handle);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD107             BNE.N    ??FLEXIO_SPI_SlaveTransferNonBlocking_0
   \        0xC   0xF240 0x4269      MOVW     R2,#+1129
   \       0x10   0x....             LDR.N    R1,??DataTable15_2
   \       0x12   0x....             LDR.N    R0,??DataTable15_12
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
   1130              assert(xfer);
   \                     ??FLEXIO_SPI_SlaveTransferNonBlocking_0: (+1)
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD107             BNE.N    ??FLEXIO_SPI_SlaveTransferNonBlocking_1
   \       0x20   0xF240 0x426A      MOVW     R2,#+1130
   \       0x24   0x....             LDR.N    R1,??DataTable15_2
   \       0x26   0x....             LDR.N    R0,??DataTable15_14
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1131          
   1132              uint32_t dataMode = 0;
   1133          
   1134              /* Check if SPI is busy. */
   1135              if (handle->state == kFLEXIO_SPI_Busy)
   \                     ??FLEXIO_SPI_SlaveTransferNonBlocking_1: (+1)
   \       0x30   0x6960             LDR      R0,[R4, #+20]
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD102             BNE.N    ??FLEXIO_SPI_SlaveTransferNonBlocking_2
   1136              {
   1137                  return kStatus_FLEXIO_SPI_Busy;
   \       0x36   0xF240 0x10F5      MOVW     R0,#+501
   \       0x3A   0xBD70             POP      {R4-R6,PC}
   1138              }
   1139          
   1140              /* Check if the argument is legal. */
   1141              if ((xfer->txData == NULL) && (xfer->rxData == NULL))
   \                     ??FLEXIO_SPI_SlaveTransferNonBlocking_2: (+1)
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD104             BNE.N    ??FLEXIO_SPI_SlaveTransferNonBlocking_3
   \       0x42   0x6868             LDR      R0,[R5, #+4]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD101             BNE.N    ??FLEXIO_SPI_SlaveTransferNonBlocking_3
   1142              {
   1143                  return kStatus_InvalidArgument;
   \       0x48   0x2004             MOVS     R0,#+4
   \       0x4A   0xBD70             POP      {R4-R6,PC}
   1144              }
   1145          
   1146              /* Configure the values in handle */
   1147              switch (xfer->flags)
   \                     ??FLEXIO_SPI_SlaveTransferNonBlocking_3: (+1)
   \       0x4C   0x7B28             LDRB     R0,[R5, #+12]
   \       0x4E   0x2802             CMP      R0,#+2
   \       0x50   0xD004             BEQ.N    ??FLEXIO_SPI_SlaveTransferNonBlocking_4
   \       0x52   0x2809             CMP      R0,#+9
   \       0x54   0xD007             BEQ.N    ??FLEXIO_SPI_SlaveTransferNonBlocking_5
   \       0x56   0x280A             CMP      R0,#+10
   \       0x58   0xD00B             BEQ.N    ??FLEXIO_SPI_SlaveTransferNonBlocking_6
   \       0x5A   0xE010             B.N      ??FLEXIO_SPI_SlaveTransferNonBlocking_7
   1148              {
   1149                  case kFLEXIO_SPI_8bitMsb:
   1150                      dataMode             = 8 * 2 - 1U;
   1151                      handle->bytePerFrame = 1U;
   1152                      handle->direction    = kFLEXIO_SPI_MsbFirst;
   1153                      break;
   1154                  case kFLEXIO_SPI_8bitLsb:
   1155                      dataMode             = 8 * 2 - 1U;
   \                     ??FLEXIO_SPI_SlaveTransferNonBlocking_4: (+1)
   \       0x5C   0x200F             MOVS     R0,#+15
   1156                      handle->bytePerFrame = 1U;
   \       0x5E   0x2101             MOVS     R1,#+1
   \       0x60   0x7621             STRB     R1,[R4, #+24]
   1157                      handle->direction    = kFLEXIO_SPI_LsbFirst;
   \       0x62   0x7661             STRB     R1,[R4, #+25]
   1158                      break;
   \       0x64   0xE010             B.N      ??FLEXIO_SPI_SlaveTransferNonBlocking_8
   1159                  case kFLEXIO_SPI_16bitMsb:
   1160                      dataMode             = 16 * 2 - 1U;
   \                     ??FLEXIO_SPI_SlaveTransferNonBlocking_5: (+1)
   \       0x66   0x201F             MOVS     R0,#+31
   1161                      handle->bytePerFrame = 2U;
   \       0x68   0x2102             MOVS     R1,#+2
   \       0x6A   0x7621             STRB     R1,[R4, #+24]
   1162                      handle->direction    = kFLEXIO_SPI_MsbFirst;
   \       0x6C   0x2100             MOVS     R1,#+0
   \       0x6E   0x7661             STRB     R1,[R4, #+25]
   1163                      break;
   \       0x70   0xE00A             B.N      ??FLEXIO_SPI_SlaveTransferNonBlocking_8
   1164                  case kFLEXIO_SPI_16bitLsb:
   1165                      dataMode             = 16 * 2 - 1U;
   \                     ??FLEXIO_SPI_SlaveTransferNonBlocking_6: (+1)
   \       0x72   0x201F             MOVS     R0,#+31
   1166                      handle->bytePerFrame = 2U;
   \       0x74   0x2102             MOVS     R1,#+2
   \       0x76   0x7621             STRB     R1,[R4, #+24]
   1167                      handle->direction    = kFLEXIO_SPI_LsbFirst;
   \       0x78   0x2101             MOVS     R1,#+1
   \       0x7A   0x7661             STRB     R1,[R4, #+25]
   1168                      break;
   \       0x7C   0xE004             B.N      ??FLEXIO_SPI_SlaveTransferNonBlocking_8
   1169                  default:
   1170                      dataMode             = 8 * 2 - 1U;
   \                     ??FLEXIO_SPI_SlaveTransferNonBlocking_7: (+1)
   \       0x7E   0x200F             MOVS     R0,#+15
   1171                      handle->bytePerFrame = 1U;
   \       0x80   0x2101             MOVS     R1,#+1
   \       0x82   0x7621             STRB     R1,[R4, #+24]
   1172                      handle->direction    = kFLEXIO_SPI_MsbFirst;
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0x7661             STRB     R1,[R4, #+25]
   1173                      assert(true);
   1174                      break;
   1175              }
   1176          
   1177              /* Configure transfer size. */
   1178              base->flexioBase->TIMCMP[base->timerIndex[0]] = dataMode;
   \                     ??FLEXIO_SPI_SlaveTransferNonBlocking_8: (+1)
   \       0x88   0x6831             LDR      R1,[R6, #+0]
   \       0x8A   0x7AB2             LDRB     R2,[R6, #+10]
   \       0x8C   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0x90   0xF8C1 0x0500      STR      R0,[R1, #+1280]
   1179          
   1180              handle->state            = kFLEXIO_SPI_Busy;
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0x6160             STR      R0,[R4, #+20]
   1181              handle->txData           = xfer->txData;
   \       0x98   0x6828             LDR      R0,[R5, #+0]
   \       0x9A   0x6020             STR      R0,[R4, #+0]
   1182              handle->rxData           = xfer->rxData;
   \       0x9C   0x6868             LDR      R0,[R5, #+4]
   \       0x9E   0x6060             STR      R0,[R4, #+4]
   1183              handle->txRemainingBytes = xfer->dataSize;
   \       0xA0   0x68A8             LDR      R0,[R5, #+8]
   \       0xA2   0x60E0             STR      R0,[R4, #+12]
   1184              handle->rxRemainingBytes = xfer->dataSize;
   \       0xA4   0x68A8             LDR      R0,[R5, #+8]
   \       0xA6   0x6120             STR      R0,[R4, #+16]
   1185          
   1186              /* Save total transfer size. */
   1187              handle->transferSize = xfer->dataSize;
   \       0xA8   0x68A8             LDR      R0,[R5, #+8]
   \       0xAA   0x60A0             STR      R0,[R4, #+8]
   1188          
   1189              /* Enable transmit and receive interrupt to handle tx and rx. */
   1190              FLEXIO_SPI_EnableInterrupts(base, kFLEXIO_SPI_TxEmptyInterruptEnable);
   \       0xAC   0x2101             MOVS     R1,#+1
   \       0xAE   0x4630             MOV      R0,R6
   \       0xB0   0x....'....        BL       FLEXIO_SPI_EnableInterrupts
   1191              FLEXIO_SPI_EnableInterrupts(base, kFLEXIO_SPI_RxFullInterruptEnable);
   \       0xB4   0x2102             MOVS     R1,#+2
   \       0xB6   0x4630             MOV      R0,R6
   \       0xB8   0x....'....        BL       FLEXIO_SPI_EnableInterrupts
   1192          
   1193              return kStatus_Success;
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xBD70             POP      {R4-R6,PC}       ;; return
   1194          }
   1195          
   1196          /*!
   1197           * brief FlexIO SPI slave IRQ handler function.
   1198           *
   1199           * param spiType Pointer to the FLEXIO_SPI_Type structure.
   1200           * param spiHandle Pointer to the flexio_spi_slave_handle_t structure to store the transfer state.
   1201           */

   \                                 In section .text, align 4, keep-with-next
   1202          void FLEXIO_SPI_SlaveTransferHandleIRQ(void *spiType, void *spiHandle)
   1203          {
   \                     FLEXIO_SPI_SlaveTransferHandleIRQ: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1204              assert(spiHandle);
   \        0x6   0xD107             BNE.N    ??FLEXIO_SPI_SlaveTransferHandleIRQ_0
   \        0x8   0xF240 0x42B4      MOVW     R2,#+1204
   \        0xC   0x....             LDR.N    R1,??DataTable15_2
   \        0xE   0x....             LDR.N    R0,??DataTable15_15
   \       0x10   0x....'....        BL       __aeabi_assert
   \       0x14   0x....'....        BL       __iar_EmptyStepPoint
   1205          
   1206              flexio_spi_master_handle_t *handle = (flexio_spi_master_handle_t *)spiHandle;
   1207              FLEXIO_SPI_Type *base;
   1208              uint32_t status;
   1209          
   1210              if (handle->state == kFLEXIO_SPI_Idle)
   \                     ??FLEXIO_SPI_SlaveTransferHandleIRQ_0: (+1)
   \       0x18   0x6960             LDR      R0,[R4, #+20]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD029             BEQ.N    ??FLEXIO_SPI_SlaveTransferHandleIRQ_1
   1211              {
   1212                  return;
   1213              }
   1214          
   1215              base   = (FLEXIO_SPI_Type *)spiType;
   1216              status = FLEXIO_SPI_GetStatusFlags(base);
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x....'....        BL       FLEXIO_SPI_GetStatusFlags
   \       0x24   0x4606             MOV      R6,R0
   1217          
   1218              /* Handle tx. */
   1219              if ((status & kFLEXIO_SPI_TxBufferEmptyFlag) && (handle->txRemainingBytes))
   \       0x26   0x07F0             LSLS     R0,R6,#+31
   \       0x28   0xD506             BPL.N    ??FLEXIO_SPI_SlaveTransferHandleIRQ_2
   \       0x2A   0x68E0             LDR      R0,[R4, #+12]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD003             BEQ.N    ??FLEXIO_SPI_SlaveTransferHandleIRQ_2
   1220              {
   1221                  FLEXIO_SPI_TransferSendTransaction(base, handle);
   \       0x30   0x4621             MOV      R1,R4
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0x....'....        BL       FLEXIO_SPI_TransferSendTransaction
   1222              }
   1223          
   1224              /* Handle rx. */
   1225              if ((status & kFLEXIO_SPI_RxBufferFullFlag) && (handle->rxRemainingBytes))
   \                     ??FLEXIO_SPI_SlaveTransferHandleIRQ_2: (+1)
   \       0x38   0x07B0             LSLS     R0,R6,#+30
   \       0x3A   0xD506             BPL.N    ??FLEXIO_SPI_SlaveTransferHandleIRQ_3
   \       0x3C   0x6920             LDR      R0,[R4, #+16]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD003             BEQ.N    ??FLEXIO_SPI_SlaveTransferHandleIRQ_3
   1226              {
   1227                  FLEXIO_SPI_TransferReceiveTransaction(base, handle);
   \       0x42   0x4621             MOV      R1,R4
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x....'....        BL       FLEXIO_SPI_TransferReceiveTransaction
   1228              }
   1229          
   1230              /* All the transfer finished. */
   1231              if ((handle->txRemainingBytes == 0U) && (handle->rxRemainingBytes == 0U))
   \                     ??FLEXIO_SPI_SlaveTransferHandleIRQ_3: (+1)
   \       0x4A   0x68E0             LDR      R0,[R4, #+12]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD110             BNE.N    ??FLEXIO_SPI_SlaveTransferHandleIRQ_1
   \       0x50   0x6920             LDR      R0,[R4, #+16]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD10D             BNE.N    ??FLEXIO_SPI_SlaveTransferHandleIRQ_1
   1232              {
   1233                  FLEXIO_SPI_SlaveTransferAbort(base, handle);
   \       0x56   0x4621             MOV      R1,R4
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       FLEXIO_SPI_SlaveTransferAbort
   1234                  if (handle->callback)
   \       0x5E   0x69E0             LDR      R0,[R4, #+28]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD006             BEQ.N    ??FLEXIO_SPI_SlaveTransferHandleIRQ_1
   1235                  {
   1236                      (handle->callback)(base, handle, kStatus_FLEXIO_SPI_Idle, handle->userData);
   \       0x64   0x6A23             LDR      R3,[R4, #+32]
   \       0x66   0xF44F 0x72FB      MOV      R2,#+502
   \       0x6A   0x4621             MOV      R1,R4
   \       0x6C   0x4628             MOV      R0,R5
   \       0x6E   0x69E4             LDR      R4,[R4, #+28]
   \       0x70   0x47A0             BLX      R4
   1237                  }
   1238              }
   1239          }
   \                     ??FLEXIO_SPI_SlaveTransferHandleIRQ_1: (+1)
   \       0x72   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x400F'C068        DC32     0x400fc068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0x....'....        DC32     s_flexioClocks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0x3FFF'FFFA        DC32     0x3ffffffa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \        0x0   0x0007'A120        DC32     0x7a120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x6E          DC8 "index <= 6"
   \              0x64 0x65    
   \              0x78 0x20    
   \              0x3C 0x3D    
   \              0x20 0x36    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 6EH, 78H, 70H, 5CH, 53H
   \              0x5C 0x6E    
   \              0x78 0x70    
   \              0x5C 0x53    
   \        0x8   0x44 0x4B          DC8 44H, 4BH, 5FH, 32H, 2EH, 36H, 2EH, 30H
   \              0x5F 0x32    
   \              0x2E 0x36    
   \              0x2E 0x30    
   \       0x10   0x5F 0x45          DC8 5FH, 45H, 56H, 4BH, 42H, 2DH, 49H, 4DH
   \              0x56 0x4B    
   \              0x42 0x2D    
   \              0x49 0x4D    
   \       0x18   0x58 0x52          DC8 58H, 52H, 54H, 31H, 30H, 35H, 30H, 5CH
   \              0x54 0x31    
   \              0x30 0x35    
   \              0x30 0x5C    
   \       0x20   0x64 0x65          DC8 64H, 65H, 76H, 69H, 63H, 65H, 73H, 5CH
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x73 0x5C    
   \       0x28   0x4D 0x49          DC8 4DH, 49H, 4DH, 58H, 52H, 54H, 31H, 30H
   \              0x4D 0x58    
   \              0x52 0x54    
   \              0x31 0x30    
   \       0x30   0x35 0x32          DC8 35H, 32H, 5CH, 64H, 72H, 69H, 76H, 65H
   \              0x5C 0x64    
   \              0x72 0x69    
   \              0x76 0x65    
   \       0x38   0x72 0x73          DC8 72H, 73H, 5CH, 66H, 73H, 6CH, 5FH, 63H
   \              0x5C 0x66    
   \              0x73 0x6C    
   \              0x5F 0x63    
   \       0x40   0x6C 0x6F          DC8 6CH, 6FH, 63H, 6BH, 2EH, 68H, 0
   \              0x63 0x6B    
   \              0x2E 0x68    
   \              0x00         
   \       0x47   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x62 0x61          DC8 "base"
   \              0x73 0x65    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 6EH, 78H, 70H, 5CH, 53H
   \              0x5C 0x6E    
   \              0x78 0x70    
   \              0x5C 0x53    
   \        0x8   0x44 0x4B          DC8 44H, 4BH, 5FH, 32H, 2EH, 36H, 2EH, 30H
   \              0x5F 0x32    
   \              0x2E 0x36    
   \              0x2E 0x30    
   \       0x10   0x5F 0x45          DC8 5FH, 45H, 56H, 4BH, 42H, 2DH, 49H, 4DH
   \              0x56 0x4B    
   \              0x42 0x2D    
   \              0x49 0x4D    
   \       0x18   0x58 0x52          DC8 58H, 52H, 54H, 31H, 30H, 35H, 30H, 5CH
   \              0x54 0x31    
   \              0x30 0x35    
   \              0x30 0x5C    
   \       0x20   0x64 0x65          DC8 64H, 65H, 76H, 69H, 63H, 65H, 73H, 5CH
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x73 0x5C    
   \       0x28   0x4D 0x49          DC8 4DH, 49H, 4DH, 58H, 52H, 54H, 31H, 30H
   \              0x4D 0x58    
   \              0x52 0x54    
   \              0x31 0x30    
   \       0x30   0x35 0x32          DC8 35H, 32H, 5CH, 64H, 72H, 69H, 76H, 65H
   \              0x5C 0x64    
   \              0x72 0x69    
   \              0x76 0x65    
   \       0x38   0x72 0x73          DC8 72H, 73H, 5CH, 66H, 73H, 6CH, 5FH, 66H
   \              0x5C 0x66    
   \              0x73 0x6C    
   \              0x5F 0x66    
   \       0x40   0x6C 0x65          DC8 6CH, 65H, 78H, 69H, 6FH, 5FH, 73H, 70H
   \              0x78 0x69    
   \              0x6F 0x5F    
   \              0x73 0x70    
   \       0x48   0x69 0x2E          DC8 69H, 2EH, 63H, 0
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x6D 0x61          DC8 "masterConfig"
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x62 0x61          DC8 "base && slaveConfig"
   \              0x73 0x65    
   \              0x20 0x26    
   \              0x26 0x20    
   \              0x73 0x6C    
   \              0x61 0x76    
   \              0x65 0x43    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x73 0x6C          DC8 "slaveConfig"
   \              0x61 0x76    
   \              0x65 0x43    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x00    

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x62 0x75          DC8 "buffer"
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x73 0x69          DC8 "size"
   \              0x7A 0x65    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x68 0x61          DC8 "handle"
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0xFF80 0x005A      DC16 -128, 90, 91
   \               0x005B      
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x78 0x66          DC8 "xfer"
   \              0x65 0x72    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x73 0x70          DC8 "spiHandle"
   \              0x69 0x48    
   \              0x61 0x6E    
   \              0x64 0x6C    
   \              0x65 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0xFF80 0x005A      DC16 -128, 90, 91
   \               0x005B      
   \        0x6   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CLOCK_ControlGate
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   CLOCK_EnableClock
         0   -> CLOCK_ControlGate
       8   EnableIRQ
         8   -> __NVIC_EnableIRQ
       0   FLEXIO_ClearShifterStatusFlags
       0   FLEXIO_DisableShifterStatusInterrupts
       0   FLEXIO_EnableShifterStatusDMA
       0   FLEXIO_EnableShifterStatusInterrupts
       0   FLEXIO_GetShifterStatusFlags
      16   FLEXIO_SPI_ClearStatusFlags
         0   -> FLEXIO_ClearShifterStatusFlags
        16   -> FLEXIO_ClearShifterStatusFlags
      16   FLEXIO_SPI_DisableInterrupts
         0   -> FLEXIO_DisableShifterStatusInterrupts
        16   -> FLEXIO_DisableShifterStatusInterrupts
      16   FLEXIO_SPI_EnableDMA
         0   -> FLEXIO_EnableShifterStatusDMA
        16   -> FLEXIO_EnableShifterStatusDMA
      16   FLEXIO_SPI_EnableInterrupts
         0   -> FLEXIO_EnableShifterStatusInterrupts
        16   -> FLEXIO_EnableShifterStatusInterrupts
       0   FLEXIO_SPI_GetInstance
         0   -> FLEXIO_GetInstance
       8   FLEXIO_SPI_GetStatusFlags
         8   -> FLEXIO_GetShifterStatusFlags
       0   FLEXIO_SPI_MasterDeinit
       8   FLEXIO_SPI_MasterGetDefaultConfig
         8   -> __aeabi_assert
         8   -> __aeabi_memset4
         8   -> __iar_EmptyStepPoint
      72   FLEXIO_SPI_MasterInit
        72   -> CLOCK_EnableClock
        72   -> FLEXIO_SPI_GetInstance
        72   -> FLEXIO_SetShifterConfig
        72   -> FLEXIO_SetTimerConfig
        72   -> __aeabi_assert
        72   -> __aeabi_memset4
        72   -> __iar_EmptyStepPoint
       4   FLEXIO_SPI_MasterSetBaudRate
      16   FLEXIO_SPI_MasterTransferAbort
        16   -> FLEXIO_SPI_DisableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   FLEXIO_SPI_MasterTransferBlocking
        24   -> FLEXIO_SPI_GetStatusFlags
        24   -> FLEXIO_SPI_ReadData
        24   -> FLEXIO_SPI_WriteData
      32   FLEXIO_SPI_MasterTransferCreateHandle
        32   -> EnableIRQ
        32   -> FLEXIO_RegisterHandleIRQ
        32   -> FLEXIO_SPI_GetInstance
        32   -> __aeabi_assert
        32   -> __aeabi_memset4
        32   -> __iar_EmptyStepPoint
      16   FLEXIO_SPI_MasterTransferGetCount
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   FLEXIO_SPI_MasterTransferHandleIRQ
        16   -- Indirect call
        16   -> FLEXIO_SPI_GetStatusFlags
        16   -> FLEXIO_SPI_MasterTransferAbort
        16   -> FLEXIO_SPI_TransferReceiveTransaction
        16   -> FLEXIO_SPI_TransferSendTransaction
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   FLEXIO_SPI_MasterTransferNonBlocking
        24   -> FLEXIO_SPI_EnableInterrupts
        24   -> FLEXIO_SPI_WriteData
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   FLEXIO_SPI_ReadBlocking
        24   -> FLEXIO_SPI_GetStatusFlags
        24   -> FLEXIO_SPI_ReadData
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       0   FLEXIO_SPI_ReadData
       0   FLEXIO_SPI_SlaveDeinit
         0   -> FLEXIO_SPI_MasterDeinit
       8   FLEXIO_SPI_SlaveGetDefaultConfig
         8   -> __aeabi_assert
         8   -> __aeabi_memset
         8   -> __iar_EmptyStepPoint
      64   FLEXIO_SPI_SlaveInit
        64   -> CLOCK_EnableClock
        64   -> FLEXIO_SPI_GetInstance
        64   -> FLEXIO_SetShifterConfig
        64   -> FLEXIO_SetTimerConfig
        64   -> __aeabi_assert
        64   -> __aeabi_memset4
        64   -> __iar_EmptyStepPoint
       0   FLEXIO_SPI_SlaveTransferAbort
         0   -> FLEXIO_SPI_MasterTransferAbort
      32   FLEXIO_SPI_SlaveTransferCreateHandle
        32   -> EnableIRQ
        32   -> FLEXIO_RegisterHandleIRQ
        32   -> FLEXIO_SPI_GetInstance
        32   -> __aeabi_assert
        32   -> __aeabi_memset4
        32   -> __iar_EmptyStepPoint
      16   FLEXIO_SPI_SlaveTransferHandleIRQ
        16   -- Indirect call
        16   -> FLEXIO_SPI_GetStatusFlags
        16   -> FLEXIO_SPI_SlaveTransferAbort
        16   -> FLEXIO_SPI_TransferReceiveTransaction
        16   -> FLEXIO_SPI_TransferSendTransaction
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   FLEXIO_SPI_SlaveTransferNonBlocking
        16   -> FLEXIO_SPI_EnableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   FLEXIO_SPI_TransferReceiveTransaction
         8   -> FLEXIO_SPI_ReadData
      16   FLEXIO_SPI_TransferSendTransaction
         0   -> FLEXIO_SPI_DisableInterrupts
        16   -> FLEXIO_SPI_WriteData
      24   FLEXIO_SPI_WriteBlocking
        24   -> FLEXIO_SPI_GetStatusFlags
        24   -> FLEXIO_SPI_WriteData
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       0   FLEXIO_SPI_WriteData
       0   __NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      12  ?_0
      72  ?_1
       8  ?_10
       8  ?_11
      12  ?_12
       8  ?_13
       8  ?_2
      76  ?_3
      16  ?_4
      20  ?_5
      12  ?_6
       8  ?_7
       8  ?_8
       8  ?_9
      64  CLOCK_ControlGate
       4  CLOCK_EnableClock
      24  EnableIRQ
       4  FLEXIO_ClearShifterStatusFlags
      10  FLEXIO_DisableShifterStatusInterrupts
      20  FLEXIO_EnableShifterStatusDMA
       8  FLEXIO_EnableShifterStatusInterrupts
       8  FLEXIO_GetShifterStatusFlags
      42  FLEXIO_SPI_ClearStatusFlags
      46  FLEXIO_SPI_DisableInterrupts
      46  FLEXIO_SPI_EnableDMA
      46  FLEXIO_SPI_EnableInterrupts
       6  FLEXIO_SPI_GetInstance
      40  FLEXIO_SPI_GetStatusFlags
     142  FLEXIO_SPI_MasterDeinit
      68  FLEXIO_SPI_MasterGetDefaultConfig
     482  FLEXIO_SPI_MasterInit
      46  FLEXIO_SPI_MasterSetBaudRate
      50  FLEXIO_SPI_MasterTransferAbort
     252  FLEXIO_SPI_MasterTransferBlocking
      92  FLEXIO_SPI_MasterTransferCreateHandle
      60  FLEXIO_SPI_MasterTransferGetCount
     116  FLEXIO_SPI_MasterTransferHandleIRQ
     294  FLEXIO_SPI_MasterTransferNonBlocking
      92  FLEXIO_SPI_ReadBlocking
      28  FLEXIO_SPI_ReadData
       2  FLEXIO_SPI_SlaveDeinit
      60  FLEXIO_SPI_SlaveGetDefaultConfig
     370  FLEXIO_SPI_SlaveInit
       4  FLEXIO_SPI_SlaveTransferAbort
      86  FLEXIO_SPI_SlaveTransferCreateHandle
     116  FLEXIO_SPI_SlaveTransferHandleIRQ
     192  FLEXIO_SPI_SlaveTransferNonBlocking
      80  FLEXIO_SPI_TransferReceiveTransaction
     104  FLEXIO_SPI_TransferSendTransaction
      92  FLEXIO_SPI_WriteBlocking
      24  FLEXIO_SPI_WriteData
      24  __NVIC_EnableIRQ

 
   276 bytes in section .rodata
 3 320 bytes in section .text
 
 3 320 bytes of CODE  memory
   276 bytes of CONST memory

Errors: none
Warnings: none
