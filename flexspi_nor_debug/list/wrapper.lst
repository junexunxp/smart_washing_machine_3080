###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  18:54:07
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\wrapper.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWCEE1.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\wrapper.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\wrapper.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\wrapper.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\wrapper.c
      1          /**
      2           * NOTE:
      3           *
      4           * HAL_TCP_xxx API reference implementation: wrappers/os/ubuntu/HAL_TCP_linux.c
      5           *
      6           */
      7          #include "infra_types.h"
      8          #include "infra_defs.h"
      9          #include "infra_compat.h"
     10          #include "wrappers_defs.h"
     11          #include "FreeRTOS.h"
     12          #include "timers.h"
     13          #include "queue.h"
     14          #include "semphr.h"
     15          #include "portmacro.h"
     16          #include "at_wrapper.h"
     17          #include "mimxrt1052.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     __NVIC_SetPriority: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   \        0x2   0xD404             BMI.N    ??__NVIC_SetPriority_0
   \        0x4   0x0109             LSLS     R1,R1,#+4
   \        0x6   0x....'....        LDR.W    R2,??DataTable16  ;; 0xe000e400
   \        0xA   0x5411             STRB     R1,[R2, R0]
   \        0xC   0x4770             BX       LR
   \                     ??__NVIC_SetPriority_0: (+1)
   \        0xE   0x0109             LSLS     R1,R1,#+4
   \       0x10   0x....'....        LDR.W    R2,??DataTable16_1  ;; 0xe000ed18
   \       0x14   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x18   0x4410             ADD      R0,R2,R0
   \       0x1A   0xF800 0x1C04      STRB     R1,[R0, #-4]
   \       0x1E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t SysTick_Config(uint32_t)
   \                     SysTick_Config: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x1E41             SUBS     R1,R0,#+1
   \        0x4   0xF1B1 0x7F80      CMP      R1,#+16777216
   \        0x8   0xD301             BCC.N    ??SysTick_Config_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xBD02             POP      {R1,PC}
   \                     ??SysTick_Config_0: (+1)
   \        0xE   0x1E40             SUBS     R0,R0,#+1
   \       0x10   0x....'....        LDR.W    R1,??DataTable16_2  ;; 0xe000e014
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \       0x16   0x210F             MOVS     R1,#+15
   \       0x18   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1C   0x....'....        BL       __NVIC_SetPriority
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x....'....        LDR.W    R1,??DataTable16_3  ;; 0xe000e018
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0x2007             MOVS     R0,#+7
   \       0x2A   0x....'....        LDR.W    R1,??DataTable16_4  ;; 0xe000e010
   \       0x2E   0x6008             STR      R0,[R1, #+0]
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD02             POP      {R1,PC}          ;; return
     18          #include "fsl_trng.h"
     19          #include "fsl_clock.h"
     20          #include "fsl_lpuart.h"
     21          
     22          

   \                                 In section .bss, align 1
     23          unsigned char srandom_inited = 0;
   \                     srandom_inited:
   \        0x0                      DS8 1
     24          #ifndef SECURITY_MATERIAL_APP
     25          #define PRODUCT_KEY_D      "a1I5Y6v8HwT"
     26          #define PRODUCT_SECRET_D   "S56FG57Rqjr24CHo"
     27          #define DEVICE_NAME_D      "smart_wm_test1"
     28          #define DEVICE_SECRET_D    "3qLxqnrCCxhEVJUJjq88jEYkPwi2CZCr"
     29          #define FIRMWARE_VER_D	 "1.0.0"
     30          #endif
     31          
     32          #ifndef EIO
     33          #define EIO 5
     34          #endif
     35          
     36          #define UART_TX_INT_THRESHOLD 1
     37          static volatile uint32_t sys_tick_cnt;
     38          static volatile uint8_t wrapped = 0;

   \                                 In section .rodata, align 4
     39          static const uint32_t s_uartBaseAddrs[8] = {(uint32_t)LPUART1_BASE, (uint32_t)LPUART2_BASE,
   \                     s_uartBaseAddrs:
   \        0x0   0x4018'4000        DC32 1075331072, 1075347456, 1075363840, 1075380224, 1075396608
   \              0x4018'8000  
   \              0x4018'C000  
   \              0x4019'0000  
   \              0x4019'4000  
   \       0x14   0x4019'8000        DC32 1075412992, 1075429376, 1075445760
   \              0x4019'C000  
   \              0x401A'0000  
     40          (uint32_t)LPUART3_BASE, (uint32_t)LPUART4_BASE, (uint32_t)LPUART5_BASE, (uint32_t)LPUART6_BASE, (uint32_t)LPUART7_BASE, 
     41          (uint32_t)LPUART8_BASE};
     42          static lpuart_handle_t s_handle[9];
     43          
     44          

   \                                 In section .bss, align 4
     45          volatile static uint32_t uart_status;
   \                     uart_status:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     46          volatile static uint32_t uart_rxstatus;
   \                     uart_rxstatus:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     47          TaskHandle_t isr_uart_handle;
   \                     isr_uart_handle:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     48          QueueHandle_t uart_txwait_sem,uart_rxwait_sem,check_st_sem;
   \                     uart_txwait_sem:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \                     uart_rxwait_sem:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \                     check_st_sem:
   \        0x0                      DS8 4
     49          

   \                                 In section .bss, align 1
     50          static uint8_t seam_wait_tx,seam_wait_rx;
   \                     seam_wait_tx:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
   \                     seam_wait_rx:
   \        0x0                      DS8 1
     51          /* Global Variable for VFS DEBUG Output */
     52          static void uart_callback(LPUART_Type *base, lpuart_handle_t *handle, status_t status, void *userData)
     53          {
     54              if (kStatus_LPUART_TxIdle == status)
     55              {
     56                  uart_status = kStatus_LPUART_TxIdle;
     57          
     58              }
     59          
     60              if (kStatus_LPUART_RxIdle == status)
     61              {
     62                  uart_rxstatus = kStatus_LPUART_RxIdle;
     63          
     64              }
     65          }
     66          
     67          

   \                                 In section .text, align 2, keep-with-next
     68          int32_t HAL_Uart_rxWait(uint32_t timeout){
   \                     HAL_Uart_rxWait: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     69          #if 1
     70            TickType_t xdelay = timeout/portTICK_PERIOD_MS;
     71            volatile uint32_t tick_prev = xTaskGetTickCount();
   \        0x4   0x....'....        BL       xTaskGetTickCount
   \        0x8   0x9000             STR      R0,[SP, #+0]
     72            while(uart_rxstatus == kStatus_LPUART_RxBusy){
   \                     ??HAL_Uart_rxWait_0: (+1)
   \        0xA   0x....'....        LDR.W    R0,??DataTable16_5
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0xF240 0x5115      MOVW     R1,#+1301
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD107             BNE.N    ??HAL_Uart_rxWait_1
     73            		if(xTaskGetTickCount() - tick_prev  > xdelay){
   \       0x18   0x....'....        BL       xTaskGetTickCount
   \       0x1C   0x9900             LDR      R1,[SP, #+0]
   \       0x1E   0x1A40             SUBS     R0,R0,R1
   \       0x20   0x4284             CMP      R4,R0
   \       0x22   0xD2F2             BCS.N    ??HAL_Uart_rxWait_0
     74          
     75          			return 1;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xBD16             POP      {R1,R2,R4,PC}
     76          
     77            		}
     78            }
     79          	return 0;
   \                     ??HAL_Uart_rxWait_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     80          #else
     81          	while(uart_rxstatus == kStatus_LPUART_RxBusy){
     82          		seam_wait_rx = 1;
     83          		xSemaphoreGive(check_st_sem);
     84          		HAL_SemaphoreWait(uart_rxwait_sem,timeout);
     85          		seam_wait_rx = 0;
     86          		if(uart_rxstatus == kStatus_LPUART_RxBusy)
     87          			return -1;
     88          	}
     89          	return 0;
     90          #endif
     91          }
     92          
     93          

   \                                 In section .text, align 2, keep-with-next
     94          int32_t HAL_Uart_txWait(uint32_t timeout){
   \                     HAL_Uart_txWait: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     95          #if 1
     96              TickType_t xdelay = timeout/portTICK_PERIOD_MS;
     97            volatile uint32_t tick_prev = xTaskGetTickCount();
   \        0x4   0x....'....        BL       xTaskGetTickCount
   \        0x8   0x9000             STR      R0,[SP, #+0]
     98            while(uart_status == kStatus_LPUART_TxBusy){
   \                     ??HAL_Uart_txWait_0: (+1)
   \        0xA   0x....             LDR.N    R0,??DataTable16_6
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0xF240 0x5114      MOVW     R1,#+1300
   \       0x12   0x4288             CMP      R0,R1
   \       0x14   0xD107             BNE.N    ??HAL_Uart_txWait_1
     99                if(xTaskGetTickCount() - tick_prev  > xdelay){
   \       0x16   0x....'....        BL       xTaskGetTickCount
   \       0x1A   0x9900             LDR      R1,[SP, #+0]
   \       0x1C   0x1A40             SUBS     R0,R0,R1
   \       0x1E   0x4284             CMP      R4,R0
   \       0x20   0xD2F3             BCS.N    ??HAL_Uart_txWait_0
    100          
    101          			return 1;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xBD16             POP      {R1,R2,R4,PC}
    102          
    103            		}
    104            }
    105          	return 0;
   \                     ??HAL_Uart_txWait_1: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    106          #else
    107          	if(uart_status == kStatus_LPUART_TxBusy){
    108          		seam_wait_tx = 1;
    109          		xSemaphoreGive(check_st_sem);
    110          		HAL_SemaphoreWait(uart_txwait_sem,timeout);
    111          		
    112          		seam_wait_tx = 0;
    113          		if(uart_status == kStatus_LPUART_TxBusy)
    114          			return -1;
    115          	}
    116          	return 0;
    117          #endif
    118          
    119          }
    120          
    121          /**
    122           * Deinitialises a UART interface
    123           *
    124           * @param[in]  uart  the interface which should be deinitialised
    125           *
    126           * @return  0 : on success, EIO : if an error occurred with any step
    127           */

   \                                 In section .text, align 2, keep-with-next
    128          int32_t HAL_AT_Uart_Deinit(uart_dev_t *uart)
    129          {
   \                     HAL_AT_Uart_Deinit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    130          	LPUART_Deinit((LPUART_Type *)s_uartBaseAddrs[uart->port]);
   \        0x2   0x....             LDR.N    R1,??DataTable16_7
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \        0xA   0x....'....        BL       LPUART_Deinit
    131          	HAL_SemaphoreDestroy(uart_rxwait_sem);
   \        0xE   0x....             LDR.N    R0,??DataTable16_8
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x....'....        BL       HAL_SemaphoreDestroy
    132          	HAL_SemaphoreDestroy(uart_txwait_sem);
   \       0x16   0x....             LDR.N    R0,??DataTable16_9
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x....'....        BL       HAL_SemaphoreDestroy
    133          	HAL_SemaphoreDestroy(check_st_sem);
   \       0x1E   0x....             LDR.N    R0,??DataTable16_10
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0x....'....        BL       HAL_SemaphoreDestroy
    134          	
    135          	return (int32_t)0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD02             POP      {R1,PC}          ;; return
    136          }
    137          

   \                                 In section .text, align 2, keep-with-next
    138          void uart2_interrupt_handle_task( void *pvParameters )
    139          {
   \                     uart2_interrupt_handle_task: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             LDR.N    R4,??DataTable16_11
   \        0x4   0xE005             B.N      ??uart2_interrupt_handle_task_0
    140              for( ;; )
    141              {
    142                  if( seam_wait_tx || seam_wait_rx )
    143                  {
    144                  	if((uart_status == kStatus_LPUART_TxIdle)&&seam_wait_tx){
    145          				seam_wait_tx = 0;
    146          				xSemaphoreGive(uart_txwait_sem);
    147          
    148                  	}
    149          			if((uart_rxstatus == kStatus_LPUART_RxIdle)&&seam_wait_rx){
    150          				seam_wait_rx = 0;
    151          				xSemaphoreGive(uart_rxwait_sem);
    152                  	}
    153          
    154                  }else{
    155          			HAL_SemaphoreWait(check_st_sem,5000);
   \                     ??uart2_interrupt_handle_task_1: (+1)
   \        0x6   0xF241 0x3188      MOVW     R1,#+5000
   \        0xA   0x....             LDR.N    R0,??DataTable16_10
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x....'....        BL       HAL_SemaphoreWait
    156                  }
   \                     ??uart2_interrupt_handle_task_0: (+1)
   \       0x12   0x....             LDR.N    R1,??DataTable16_12
   \       0x14   0x7808             LDRB     R0,[R1, #+0]
   \       0x16   0x7822             LDRB     R2,[R4, #+0]
   \       0x18   0x4310             ORRS     R0,R2,R0
   \       0x1A   0xD0F4             BEQ.N    ??uart2_interrupt_handle_task_1
   \       0x1C   0x....             LDR.N    R0,??DataTable16_6
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0xF240 0x5216      MOVW     R2,#+1302
   \       0x24   0x4290             CMP      R0,R2
   \       0x26   0xD10B             BNE.N    ??uart2_interrupt_handle_task_2
   \       0x28   0x7808             LDRB     R0,[R1, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD008             BEQ.N    ??uart2_interrupt_handle_task_2
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x7008             STRB     R0,[R1, #+0]
   \       0x32   0x4603             MOV      R3,R0
   \       0x34   0x4602             MOV      R2,R0
   \       0x36   0x4601             MOV      R1,R0
   \       0x38   0x....             LDR.N    R0,??DataTable16_9
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x....'....        BL       xQueueGenericSend
   \                     ??uart2_interrupt_handle_task_2: (+1)
   \       0x40   0x....             LDR.N    R0,??DataTable16_5
   \       0x42   0x6800             LDR      R0,[R0, #+0]
   \       0x44   0xF240 0x5117      MOVW     R1,#+1303
   \       0x48   0x4288             CMP      R0,R1
   \       0x4A   0xD1E2             BNE.N    ??uart2_interrupt_handle_task_0
   \       0x4C   0x7820             LDRB     R0,[R4, #+0]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD0DF             BEQ.N    ??uart2_interrupt_handle_task_0
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x7020             STRB     R0,[R4, #+0]
   \       0x56   0x4603             MOV      R3,R0
   \       0x58   0x4602             MOV      R2,R0
   \       0x5A   0x4601             MOV      R1,R0
   \       0x5C   0x....             LDR.N    R0,??DataTable16_8
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0x....'....        BL       xQueueGenericSend
   \       0x64   0xE7D5             B.N      ??uart2_interrupt_handle_task_0
    157              }
    158          }
    159          
    160          
    161          /**
    162           * Initialises a UART interface
    163           *
    164           *
    165           * @param[in]  uart  the interface which should be initialised
    166           *
    167           * @return  0 : on success, EIO : if an error occurred with any step
    168           */
    169          #define USE_LPUART_RTOS 1
    170          #if USE_LPUART_RTOS
    171          #include "fsl_lpuart_freertos.h"

   \                                 In section .bss, align 4
    172          lpuart_rtos_handle_t handle;
   \                     handle:
   \        0x0                      DS8 40

   \                                 In section .bss, align 4
    173          struct _lpuart_handle t_handle;
   \                     t_handle:
   \        0x0                      DS8 48

   \                                 In section .bss, align 4
    174          uint8_t background_buffer[512];
   \                     background_buffer:
   \        0x0                      DS8 512

   \                                 In section .data, align 4
    175          lpuart_rtos_config_t lpuart_config = {
   \                     lpuart_config:
   \        0x0   0x0000'0000        DC32 0H, 0, 115200
   \              0x0000'0000  
   \              0x0001'C200  
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x10   0x....'....        DC32 background_buffer, 512
   \              0x0000'0200  
    176              .baudrate    = 115200,
    177              .parity      = kLPUART_ParityDisabled,
    178              .stopbits    = kLPUART_OneStopBit,
    179              .buffer      = background_buffer,
    180              .buffer_size = sizeof(background_buffer),
    181          };
    182          #endif

   \                                 In section .text, align 2, keep-with-next
    183          int32_t HAL_AT_Uart_Init(uart_dev_t *uart)
    184          {
   \                     HAL_AT_Uart_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    185          #if USE_LPUART_RTOS
    186            lpuart_config.srcclk = BOARD_DebugConsoleSrcFreq();
                                          ^
Warning[Pe223]: function "BOARD_DebugConsoleSrcFreq" declared implicitly
   \        0x4   0x....             LDR.N    R5,??DataTable16_13
   \        0x6   0x....'....        BL       BOARD_DebugConsoleSrcFreq
   \        0xA   0x6068             STR      R0,[R5, #+4]
    187            lpuart_config.base   = (LPUART_Type *)s_uartBaseAddrs[uart->port];
   \        0xC   0x....             LDR.N    R0,??DataTable16_7
   \        0xE   0x7821             LDRB     R1,[R4, #+0]
   \       0x10   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0x14   0x6028             STR      R0,[R5, #+0]
    188            NVIC_SetPriority(LPUART3_IRQn, 5);
   \       0x16   0x2105             MOVS     R1,#+5
   \       0x18   0x2016             MOVS     R0,#+22
   \       0x1A   0x....'....        BL       __NVIC_SetPriority
    189            LPUART_RTOS_Init(&handle, &t_handle, &lpuart_config);
   \       0x1E   0x462A             MOV      R2,R5
   \       0x20   0x....             LDR.N    R1,??DataTable16_14
   \       0x22   0x....             LDR.N    R0,??DataTable16_15
   \       0x24   0x....'....        BL       LPUART_RTOS_Init
    190          #else
    191          	lpuart_config_t config = {0};
    192          	status_t status;
    193          	uint8_t *addr;
    194          	size_t size;
    195          	
    196          	LPUART_GetDefaultConfig(&config);
    197          	config.baudRate_Bps = uart->config.baud_rate;
    198          	config.enableTx = true;
    199          	config.enableRx = true;
    200          
    201          	switch (uart->config.parity)
    202          	{
    203          		case NO_PARITY:
    204          			config.parityMode = kLPUART_ParityDisabled;
    205          			break;
    206          		case ODD_PARITY:
    207          			config.parityMode = kLPUART_ParityOdd;
    208          			break;
    209          		case EVEN_PARITY:
    210          			config.parityMode = kLPUART_ParityEven;
    211          			break;
    212          		default:
    213          			return EIO;
    214          	}
    215          
    216          	switch (uart->config.data_width)
    217          	{
    218          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    219          		case DATA_WIDTH_7BIT:
    220          			config.dataBitsCount = kLPUART_SevenDataBits;
    221          			break;
    222          #endif
    223          		case DATA_WIDTH_8BIT:
    224          			config.dataBitsCount = kLPUART_EightDataBits;
    225          			break;
    226          		default:
    227          			return EIO;
    228          	}
    229          
    230          	switch (uart->config.stop_bits)
    231          	{
    232          		case STOP_BITS_1:
    233          			config.stopBitCount = kLPUART_OneStopBit;
    234          			break;
    235          		case STOP_BITS_2:
    236          			config.stopBitCount = kLPUART_TwoStopBit;
    237          			break;
    238          		default:
    239          			return EIO;
    240          	}
    241          	
    242          	/* TODO: Need to have array to save clock source for all uart instances */
    243          	uint32_t freq = 0;
    244          	freq = BOARD_DebugConsoleSrcFreq();
    245          	status = LPUART_Init((LPUART_Type *)s_uartBaseAddrs[uart->port], &config, freq);
    246          	
    247          	if (kStatus_Success != status)
    248          		return EIO;
    249          	
    250          
    251          	/* Create handle for LPUART */
    252          	LPUART_TransferCreateHandle((LPUART_Type *)s_uartBaseAddrs[uart->port], &s_handle[uart->port],
    253          								uart_callback, uart);
    254          
    255          	if (uart->port == 2){
    256          
    257          		size = 512;
    258          		addr = HAL_Malloc(size);
    259          		if (addr != NULL){
    260          		    LPUART_TransferStartRingBuffer((LPUART_Type *)s_uartBaseAddrs[uart->port], &s_handle[uart->port],
    261          		                                    addr, size);
    262          		}else{
    263          		    return -1;
    264          		}
    265          	}
    266                  
    267          #if 1
    268                  
    269          #else
    270          	xTaskCreate(
    271                            uart2_interrupt_handle_task,       /* Function that implements the task. */
    272                            "u2_isr_handle",          /* Text name for the task. */
    273                            256,      /* Stack size in words, not bytes. */
    274                            NULL,    /* Parameter passed into the task. */
    275                            (0),/* Priority at which the task is created. */
    276                            &isr_uart_handle);      /* Used to pass out the created task's handle. */
    277          	uart_rxwait_sem = HAL_SemaphoreCreate();
    278          	uart_txwait_sem = HAL_SemaphoreCreate();
    279          	check_st_sem = HAL_SemaphoreCreate();
    280                  
    281          #endif
    282          #endif
    283          	return 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    284          }
    285          
    286          
    287          /**
    288           * Receive data on a UART interface
    289           *
    290           * @param[in]   uart         the UART interface
    291           * @param[out]  data         pointer to the buffer which will store incoming data
    292           * @param[in]   expect_size  number of bytes to receive
    293           * @param[out]  recv_size    number of bytes received
    294           * @param[in]   timeout      timeout in milisecond, set this value to HAL_WAIT_FOREVER
    295           *                           if you want to wait forever
    296           *
    297           * @return  0 : on success, EIO : if an error occurred with any step
    298           */

   \                                 In section .text, align 2, keep-with-next
    299          int32_t HAL_AT_Uart_Recv(uart_dev_t *uart, void *data, uint32_t expect_size,
    300                                   uint32_t *recv_size, uint32_t timeout)
    301          {
   \                     HAL_AT_Uart_Recv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x9802             LDR      R0,[SP, #+8]
    302            #if USE_LPUART_RTOS
    303            int ret = LPUART_RTOS_Receive(&handle, data, expect_size, recv_size,timeout/portTICK_PERIOD_MS);
    304            return ret;
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x....             LDR.N    R0,??DataTable16_15
   \        0x8   0x....'....        BL       LPUART_RTOS_Receive
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
    305          #else
    306          	if(uart_rxstatus == kStatus_LPUART_RxBusy){
    307          			return EIO;
    308          		}
    309          
    310          	lpuart_transfer_t xfer;
    311              int32_t ret = 0;
    312              LPUART_Type *uartBase = (LPUART_Type *)s_uartBaseAddrs[uart->port];
    313              lpuart_handle_t *handle = &s_handle[uart->port];
    314          
    315              if (timeout == 0)
    316              {
    317                  timeout = 1000;
    318              }
    319          
    320              xfer.data = (uint8_t *)data;
    321              xfer.dataSize = expect_size;
    322          	uart_rxstatus = kStatus_LPUART_RxBusy;
    323              if (kStatus_Success != LPUART_TransferReceiveNonBlocking(uartBase, handle, &xfer, recv_size))
    324              {
    325          		uart_rxstatus = kStatus_LPUART_RxIdle;
    326                  return EIO;
    327              }
    328          	
    329          
    330          
    331          
    332              if (HAL_Uart_rxWait(timeout) != 0)
    333              {
    334                  LPUART_TransferAbortReceive(uartBase, handle);
    335          		uart_rxstatus = kStatus_LPUART_RxIdle;
    336          
    337                  *recv_size = 0;
    338          
    339                  ret = EIO;
    340              }
    341              else
    342              {
    343                  *recv_size = expect_size;
    344              }
    345            return ret;
    346          #endif
    347             
    348          }
    349          
    350          /**
    351           * Transmit data on a UART interface
    352           *
    353           * @param[in]  uart     the UART interface
    354           * @param[in]  data     pointer to the start of data
    355           * @param[in]  size     number of bytes to transmit
    356           * @param[in]  timeout  timeout in milisecond, set this value to HAL_WAIT_FOREVER
    357           *                      if you want to wait forever
    358           *
    359           * @return  0 : on success, EIO : if an error occurred with any step
    360           */

   \                                 In section .text, align 2, keep-with-next
    361          int32_t HAL_AT_Uart_Send(uart_dev_t *uart, const void *data, uint32_t size, uint32_t timeout)
    362          {
   \                     HAL_AT_Uart_Send: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    363            #if USE_LPUART_RTOS
    364            LPUART_RTOS_Send(&handle, (uint8_t *)data, size,timeout/portTICK_PERIOD_MS);
   \        0x2   0x....             LDR.N    R0,??DataTable16_15
   \        0x4   0x....'....        BL       LPUART_RTOS_Send
    365            return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD02             POP      {R1,PC}          ;; return
    366          #else
    367          	if(uart_status == kStatus_LPUART_TxBusy){
    368          		return EIO;
    369          	}
    370          	lpuart_transfer_t xfer;
    371              int32_t ret = 0;
    372              LPUART_Type *uartBase = (LPUART_Type *)s_uartBaseAddrs[uart->port];
    373              lpuart_handle_t *handle = &s_handle[uart->port];
    374          
    375              if (timeout == 0)
    376              {
    377                  timeout = 1000;
    378              }
    379          
    380          
    381          
    382              if (size < UART_TX_INT_THRESHOLD)
    383              {
    384                  LPUART_WriteBlocking(uartBase, (uint8_t *)data, size);
    385              }
    386              else
    387              {
    388                  xfer.data = (uint8_t *)data;
    389                  
    390                  xfer.dataSize = size;
    391          		uart_status = kStatus_LPUART_TxBusy;
    392                  LPUART_TransferSendNonBlocking(uartBase, handle, &xfer);
    393                  /* Wait for transfer finish */
    394                 
    395                  if (HAL_Uart_txWait(timeout) != 0)
    396                  {
    397                      LPUART_TransferAbortSend(uartBase, handle);
    398          			uart_status = kStatus_LPUART_TxIdle;
    399          
    400                      ret = EIO;
    401                  }
    402              }
    403          
    404          
    405              return ret;
    406          #endif
    407          }
    408          /**
    409           * @brief Deallocate memory block
    410           *
    411           * @param[in] ptr @n Pointer to a memory block previously allocated with platform_malloc.
    412           * @return None.
    413           * @see None.
    414           * @note None.
    415           */

   \                                 In section .text, align 2, keep-with-next
    416          void HAL_Free(void *ptr)
    417          {
    418          	vPortFree(ptr);
   \                     HAL_Free: (+1)
   \        0x0   0x....'....        B.W      vPortFree
    419          }
    420          
    421          
    422          /**
    423           * @brief Get device name from user's system persistent storage
    424           *
    425           * @param [ou] device_name: array to store device name, max length is IOTX_DEVICE_NAME_LEN
    426           * @return the actual length of device name
    427           */

   \                                 In section .text, align 2, keep-with-next
    428          int HAL_GetDeviceName(char device_name[IOTX_DEVICE_NAME_LEN + 1])
    429          {
   \                     HAL_GetDeviceName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    430          
    431          	if(strlen(DEVICE_NAME_D) <= IOTX_DEVICE_NAME_LEN){
    432                          memset(device_name, 0x0, IOTX_DEVICE_NAME_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2120             MOVS     R1,#+32
   \        0x8   0x....'....        BL       __aeabi_memset
    433          		strncpy(device_name, DEVICE_NAME_D, strlen(DEVICE_NAME_D));
   \        0xC   0x220E             MOVS     R2,#+14
   \        0xE   0x....             LDR.N    R1,??DataTable16_16
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    434          		return (int)strlen(device_name);
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1C   0x....'....        B.W      strlen
    435          	}else{
    436          
    437          		return -1;
    438          	}
    439          }
    440          
    441          
    442          /**
    443           * @brief Get device secret from user's system persistent storage
    444           *
    445           * @param [ou] device_secret: array to store device secret, max length is IOTX_DEVICE_SECRET_LEN
    446           * @return the actual length of device secret
    447           */

   \                                 In section .text, align 2, keep-with-next
    448          int HAL_GetDeviceSecret(char device_secret[IOTX_DEVICE_SECRET_LEN + 1])
    449          {
   \                     HAL_GetDeviceSecret: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    450          	if(strlen(DEVICE_SECRET_D) <= IOTX_DEVICE_SECRET_LEN){
    451                          memset(device_secret, 0x0, IOTX_DEVICE_SECRET_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2140             MOVS     R1,#+64
   \        0x8   0x....'....        BL       __aeabi_memset
    452          		strncpy(device_secret, DEVICE_SECRET_D, strlen(DEVICE_SECRET_D));
   \        0xC   0x2220             MOVS     R2,#+32
   \        0xE   0x....             LDR.N    R1,??DataTable16_17
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    453          		return (int)strlen(DEVICE_SECRET_D);
   \       0x16   0x2020             MOVS     R0,#+32
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    454          	}else{
    455          
    456          		return -1;
    457          	}
    458          }
    459          
    460          
    461          /**
    462           * @brief Get firmware version
    463           *
    464           * @param [ou] version: array to store firmware version, max length is IOTX_FIRMWARE_VER_LEN
    465           * @return the actual length of firmware version
    466           */

   \                                 In section .text, align 2, keep-with-next
    467          int HAL_GetFirmwareVersion(char *version)
    468          {
   \                     HAL_GetFirmwareVersion: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    469          	if(strlen(FIRMWARE_VER_D) <= IOTX_FIRMWARE_VER_LEN){
    470                          memset(version, 0x0, IOTX_FIRMWARE_VER_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2120             MOVS     R1,#+32
   \        0x8   0x....'....        BL       __aeabi_memset
    471          		strncpy(version, FIRMWARE_VER_D, strlen(FIRMWARE_VER_D));
   \        0xC   0x2205             MOVS     R2,#+5
   \        0xE   0x....             LDR.N    R1,??DataTable16_18
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    472          		version[strlen(FIRMWARE_VER_D)] = '\0';
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x7160             STRB     R0,[R4, #+5]
    473          		return (int)strlen(version);
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x20   0x....'....        B.W      strlen
    474          	}else{
    475          		return -1;
    476          	}
    477          }
    478          
    479          
    480          /**
    481           * @brief Get product key from user's system persistent storage
    482           *
    483           * @param [ou] product_key: array to store product key, max length is IOTX_PRODUCT_KEY_LEN
    484           * @return  the actual length of product key
    485           */

   \                                 In section .text, align 2, keep-with-next
    486          int HAL_GetProductKey(char product_key[IOTX_PRODUCT_KEY_LEN + 1])
    487          {
   \                     HAL_GetProductKey: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    488          	if(strlen(PRODUCT_KEY_D) <= IOTX_PRODUCT_KEY_LEN){
    489                          memset(product_key, 0x0, IOTX_PRODUCT_KEY_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2114             MOVS     R1,#+20
   \        0x8   0x....'....        BL       __aeabi_memset
    490          		strncpy(product_key, PRODUCT_KEY_D, strlen(PRODUCT_KEY_D));
   \        0xC   0x220B             MOVS     R2,#+11
   \        0xE   0x....             LDR.N    R1,??DataTable16_19
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    491          
    492          		return (int)strlen(PRODUCT_KEY_D);
   \       0x16   0x200B             MOVS     R0,#+11
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    493          	}else{
    494          		return -1;
    495          	}
    496          }
    497          
    498          

   \                                 In section .text, align 2, keep-with-next
    499          int HAL_GetProductSecret(char product_secret[IOTX_PRODUCT_SECRET_LEN + 1])
    500          {
   \                     HAL_GetProductSecret: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    501          	if(sizeof(PRODUCT_SECRET_D) <= IOTX_PRODUCT_SECRET_LEN){
    502                          memset(product_secret, 0x0, IOTX_PRODUCT_SECRET_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2140             MOVS     R1,#+64
   \        0x8   0x....'....        BL       __aeabi_memset
    503          		strncpy(product_secret, PRODUCT_SECRET_D, strlen(PRODUCT_SECRET_D));
   \        0xC   0x2210             MOVS     R2,#+16
   \        0xE   0x....             LDR.N    R1,??DataTable16_20
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    504          
    505          		return (int)strlen(PRODUCT_SECRET_D);
   \       0x16   0x2010             MOVS     R0,#+16
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    506          	}else{
    507          		return -1;
    508          	}
    509          }
    510          

   \                                 In section .text, align 2, keep-with-next
    511          int HAL_Kv_Get(const char *key, void *val, int *buffer_len)
    512          {
    513              return kv_item_get(key, val, buffer_len);
                            ^
Warning[Pe223]: function "kv_item_get" declared implicitly
   \                     HAL_Kv_Get: (+1)
   \        0x0   0x....'....        B.W      kv_item_get
    514          }
    515          

   \                                 In section .text, align 2, keep-with-next
    516          int HAL_Kv_Set(const char *key, const void *val, int len, int sync)
    517          {  
    518              return kv_item_set(key, val, len);
                            ^
Warning[Pe223]: function "kv_item_set" declared implicitly

  static void uart_callback(LPUART_Type *base, lpuart_handle_t *handle, status_t status, void *userData)
              ^
"C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\wrapper.c",52  Warning[Pe177]: 
          function "uart_callback" was declared but never referenced
   \                     HAL_Kv_Set: (+1)
   \        0x0   0x....'....        B.W      kv_item_set
    519          }
    520          /**
    521           * @brief Allocates a block of size bytes of memory, returning a pointer to the beginning of the block.
    522           *
    523           * @param [in] size @n specify block size in bytes.
    524           * @return A pointer to the beginning of the block.
    525           * @see None.
    526           * @note Block value is indeterminate.
    527           */

   \                                 In section .text, align 2, keep-with-next
    528          void *HAL_Malloc(uint32_t size)
    529          {
    530          	return ((void *)pvPortMalloc(size));
   \                     HAL_Malloc: (+1)
   \        0x0   0x....'....        B.W      pvPortMalloc
    531          }
    532          
    533          
    534          /**
    535           * @brief Create a mutex.
    536           *
    537           * @retval NULL : Initialize mutex failed.
    538           * @retval NOT_NULL : The mutex handle.
    539           * @see None.
    540           * @note None.
    541           */

   \                                 In section .text, align 2, keep-with-next
    542          void *HAL_MutexCreate(void)
    543          {
   \                     HAL_MutexCreate: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    544                QueueHandle_t sem;
    545          
    546              sem = (QueueHandle_t)xSemaphoreCreateMutex();
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x....'....        BL       xQueueCreateMutex
    547              if (0 == sem) {
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD100             BNE.N    ??HAL_MutexCreate_0
    548                return NULL;
   \        0xC   0x2000             MOVS     R0,#+0
    549              }
    550          
    551              return sem;
   \                     ??HAL_MutexCreate_0: (+1)
   \        0xE   0xBD02             POP      {R1,PC}          ;; return
    552          }
    553          
    554          
    555          /**
    556           * @brief Destroy the specified mutex object, it will release related resource.
    557           *
    558           * @param [in] mutex @n The specified mutex.
    559           * @return None.
    560           * @see None.
    561           * @note None.
    562           */

   \                                 In section .text, align 2, keep-with-next
    563          void HAL_MutexDestroy(void *mutex)
    564          {
    565          	QueueHandle_t sem;
    566              if (mutex == NULL) {
   \                     HAL_MutexDestroy: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??HAL_MutexDestroy_0
    567                  return;
    568              }
    569              sem = (QueueHandle_t)mutex;
    570              vSemaphoreDelete(sem);
   \        0x4   0x....'....        B.W      vQueueDelete
   \                     ??HAL_MutexDestroy_0: (+1)
   \        0x8   0x4770             BX       LR               ;; return
    571          }
    572          
    573          
    574          /**
    575           * @brief Waits until the specified mutex is in the signaled state.
    576           *
    577           * @param [in] mutex @n the specified mutex.
    578           * @return None.
    579           * @see None.
    580           * @note None.
    581           */

   \                                 In section .text, align 2, keep-with-next
    582          void HAL_MutexLock(void *mutex)
    583          {
   \                     HAL_MutexLock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    584          	BaseType_t ret;
    585              QueueHandle_t sem;
    586              if (mutex == NULL) {
   \        0x4   0xD00B             BEQ.N    ??HAL_MutexLock_0
    587                  return;
    588              }
    589          
    590              sem = (QueueHandle_t)mutex;
    591              ret = xSemaphoreTake(sem, 0xffffffff);
   \        0x6   0xF04F 0x31FF      MOV      R1,#-1
   \        0xA   0x....'....        BL       xQueueSemaphoreTake
   \        0xE   0xE004             B.N      ??HAL_MutexLock_1
    592              while (pdPASS != ret) {
    593                  ret = xSemaphoreTake(sem, 0xffffffff);
   \                     ??HAL_MutexLock_2: (+1)
   \       0x10   0xF04F 0x31FF      MOV      R1,#-1
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       xQueueSemaphoreTake
    594              }
   \                     ??HAL_MutexLock_1: (+1)
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD1F8             BNE.N    ??HAL_MutexLock_2
    595          }
   \                     ??HAL_MutexLock_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
    596          
    597          
    598          /**
    599           * @brief Releases ownership of the specified mutex object..
    600           *
    601           * @param [in] mutex @n the specified mutex.
    602           * @return None.
    603           * @see None.
    604           * @note None.
    605           */

   \                                 In section .text, align 2, keep-with-next
    606          void HAL_MutexUnlock(void *mutex)
    607          {
    608          	QueueHandle_t sem;
    609              if (mutex == NULL) {
   \                     HAL_MutexUnlock: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD004             BEQ.N    ??HAL_MutexUnlock_0
    610                  return;
    611              }
    612              sem = (QueueHandle_t)mutex;
    613              (void)xSemaphoreGive(sem);
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x461A             MOV      R2,R3
   \        0x8   0x4611             MOV      R1,R2
   \        0xA   0x....'....        B.W      xQueueGenericSend
   \                     ??HAL_MutexUnlock_0: (+1)
   \        0xE   0x4770             BX       LR               ;; return
    614          }
    615          
    616          
    617          /**
    618           * @brief Writes formatted data to stream.
    619           *
    620           * @param [in] fmt: @n String that contains the text to be written, it can optionally contain embedded format specifiers
    621               that specifies how subsequent arguments are converted for output.
    622           * @param [in] ...: @n the variable argument list, for formatted and inserted in the resulting string replacing their respective specifiers.
    623           * @return None.
    624           * @see None.
    625           * @note None.
    626           */
    627           #if 0
    628          void HAL_Printf(const char *fmt, ...)
    629          {
    630                  va_list args;
    631                  va_start(args, fmt);
    632                  format_printf(fmt,args);
    633                  va_end(args);
    634          	return;
    635          }
    636          #endif
    637          

   \                                 In section .text, align 2, keep-with-next
    638          uint32_t HAL_Random(uint32_t region)
    639          {
   \                     HAL_Random: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    640              uint32_t rand = 0xffffffff;
   \        0x4   0xF04F 0x30FF      MOV      R0,#-1
   \        0x8   0x9000             STR      R0,[SP, #+0]
    641              
    642              TRNG_GetRandomData(TRNG, (void *)&rand, 1);
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x4669             MOV      R1,SP
   \        0xE   0x....             LDR.N    R0,??DataTable16_21  ;; 0x400cc000
   \       0x10   0x....'....        BL       TRNG_GetRandomData
    643                  
    644          	return (rand%region);
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0x4601             MOV      R1,R0
   \       0x18   0xFBB1 0xF1F4      UDIV     R1,R1,R4
   \       0x1C   0xFB04 0x0411      MLS      R4,R4,R1,R0
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    645          }
    646          /**
    647           * @brief Sleep thread itself.
    648           *
    649           * @param [in] ms @n the time interval for which execution is to be suspended, in milliseconds.
    650           * @return None.
    651           * @see None.
    652           * @note None.
    653           */

   \                                 In section .text, align 2, keep-with-next
    654          void HAL_SleepMs(uint32_t ms)
    655          {
    656          	const TickType_t xdelay = ms/portTICK_PERIOD_MS;
    657          	vTaskDelay(xdelay);
   \                     HAL_SleepMs: (+1)
   \        0x0   0x....'....        B.W      vTaskDelay
    658              //uint32_t current_tick = xTaskGetTickCount();
    659          	//uint32_t anchor = current_tick + ms;
    660               //   uint32_t loopb = 0xffffffff;
    661                //  while(loopb--);
    662          	//while((anchor - current_tick>0) && (anchor - current_tick < 0xffffff)){
    663                   // current_tick = xTaskGetTickCount();
    664                  //}
    665          }
    666          
    667          
    668          /**
    669           * @brief Writes formatted data to string.
    670           *
    671           * @param [out] str: @n String that holds written text.
    672           * @param [in] len: @n Maximum length of character will be written
    673           * @param [in] fmt: @n Format that contains the text to be written, it can optionally contain embedded format specifiers
    674               that specifies how subsequent arguments are converted for output.
    675           * @param [in] ...: @n the variable argument list, for formatted and inserted in the resulting string replacing their respective specifiers.
    676           * @return bytes of character successfully written into string.
    677           * @see None.
    678           * @note None.
    679           */

   \                                 In section .text, align 2, keep-with-next
    680          int HAL_Snprintf(char *str, const int len, const char *fmt, ...)
    681          {
   \                     HAL_Snprintf: (+1)
   \        0x0   0xB408             PUSH     {R3}
   \        0x2   0xB500             PUSH     {LR}
    682          	va_list args;
    683          	int rc;
    684          
    685          	va_start(args, fmt);
   \        0x4   0xAB01             ADD      R3,SP,#+4
    686          	rc = vsnprintf(str, len, fmt, args);
    687          	va_end(args);
    688          	return rc;
   \        0x6   0x....'....        BL       vsnprintf
   \        0xA   0xF85D 0xFB08      LDR      PC,[SP], #+8     ;; return
    689          
    690          
    691          }
    692          
    693          

   \                                 In section .text, align 2, keep-with-next
    694          void HAL_Srandom(uint32_t seed)
    695          {
   \                     HAL_Srandom: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_22
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD000             BEQ.N    ??HAL_Srandom_0
   \        0x8   0x4770             BX       LR
   \                     ??HAL_Srandom_0: (+1)
   \        0xA   0xB500             PUSH     {LR}
   \        0xC   0xB095             SUB      SP,SP,#+84
    696          	if (!srandom_inited){
    697          	
    698          		trng_config_t trngConfig;
    699          		/* Initialize TRNG configuration structure to default.*/
    700          		/*
    701          		 * trngConfig.lock = TRNG_USER_CONFIG_DEFAULT_LOCK;
    702          		 * trngConfig.clockMode = kTRNG_ClockModeRingOscillator;
    703          		 * trngConfig.ringOscDiv = TRNG_USER_CONFIG_DEFAULT_OSC_DIV;
    704          		 * trngConfig.sampleMode = kTRNG_SampleModeRaw;
    705          		 * trngConfig.entropyDelay = TRNG_USER_CONFIG_DEFAULT_ENTROPY_DELAY;
    706          		 * trngConfig.sampleSize = TRNG_USER_CONFIG_DEFAULT_SAMPLE_SIZE;
    707          		 * trngConfig.sparseBitLimit = TRNG_USER_CONFIG_DEFAULT_SPARSE_BIT_LIMIT;
    708          		 * trngConfig.retryCount = TRNG_USER_CONFIG_DEFAULT_RETRY_COUNT;
    709          		 * trngConfig.longRunMaxLimit = TRNG_USER_CONFIG_DEFAULT_RUN_MAX_LIMIT;
    710          		 * trngConfig.monobitLimit.maximum = TRNG_USER_CONFIG_DEFAULT_MONOBIT_MAXIMUM;
    711          		 * trngConfig.monobitLimit.minimum = TRNG_USER_CONFIG_DEFAULT_MONOBIT_MINIMUM;
    712          		 * trngConfig.runBit1Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT1_MAXIMUM;
    713          		 * trngConfig.runBit1Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT1_MINIMUM;
    714          		 * trngConfig.runBit2Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT2_MAXIMUM;
    715          		 * trngConfig.runBit2Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT2_MINIMUM;
    716          		 * trngConfig.runBit3Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT3_MAXIMUM;
    717          		 * trngConfig.runBit3Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT3_MINIMUM;
    718          		 * trngConfig.runBit4Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT4_MAXIMUM;
    719          		 * trngConfig.runBit4Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT4_MINIMUM;
    720          		 * trngConfig.runBit5Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT5_MAXIMUM;
    721          		 * trngConfig.runBit5Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT5_MINIMUM;
    722          		 * trngConfig.runBit6PlusLimit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT6PLUS_MAXIMUM;
    723          		 * trngConfig.runBit6PlusLimit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT6PLUS_MINIMUM;
    724          		 * trngConfig.pokerLimit.maximum = TRNG_USER_CONFIG_DEFAULT_POKER_MAXIMUM;
    725          		 * trngConfig.pokerLimit.minimum = TRNG_USER_CONFIG_DEFAULT_POKER_MINIMUM;
    726          		 * trngConfig.frequencyCountLimit.maximum = TRNG_USER_CONFIG_DEFAULT_FREQUENCY_MAXIMUM;
    727          		 * trngConfig.frequencyCountLimit.minimum = TRNG_USER_CONFIG_DEFAULT_FREQUENCY_MINIMUM;
    728          		 */
    729          		TRNG_GetDefaultConfig(&trngConfig);
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x....'....        BL       TRNG_GetDefaultConfig
    730          		/* Set sample mode of the TRNG ring oscillator to Von Neumann, for better random data.*/
    731          		trngConfig.sampleMode = kTRNG_SampleModeVonNeumann;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF88D 0x0003      STRB     R0,[SP, #+3]
    732          		/* Initialize TRNG */
    733          		TRNG_Init(TRNG, &trngConfig);
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x....             LDR.N    R0,??DataTable16_21  ;; 0x400cc000
   \       0x1E   0x....'....        BL       TRNG_Init
    734          	}
    735          
    736          	return;
   \       0x22   0xB015             ADD      SP,SP,#+84
   \       0x24   0xBD00             POP      {PC}             ;; return
    737          }
    738          
    739          /**
    740           * @brief   create a semaphore
    741           *
    742           * @return semaphore handle.
    743           * @see None.
    744           * @note The recommended value of maximum count of the semaphore is 255.
    745           */

   \                                 In section .text, align 2, keep-with-next
    746          void *HAL_SemaphoreCreate(void)
    747          {
   \                     HAL_SemaphoreCreate: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    748          	QueueHandle_t sem = 0;
    749              sem = (QueueHandle_t)xSemaphoreCreateCounting(10, 0);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x200A             MOVS     R0,#+10
   \        0x6   0x....'....        BL       xQueueCreateCountingSemaphore
    750              if (0 == sem) {
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD100             BNE.N    ??HAL_SemaphoreCreate_0
    751                  return NULL;
   \        0xE   0x2000             MOVS     R0,#+0
    752              }
    753          
    754              return sem;
   \                     ??HAL_SemaphoreCreate_0: (+1)
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
    755          }
    756          
    757          
    758          /**
    759           * @brief   destory a semaphore
    760           *
    761           * @param[in] sem @n the specified sem.
    762           * @return None.
    763           * @see None.
    764           * @note None.
    765           */

   \                                 In section .text, align 2, keep-with-next
    766          void HAL_SemaphoreDestroy(void *sem)
    767          {
    768          	QueueHandle_t queue;
    769          
    770              if (sem == NULL) {
   \                     HAL_SemaphoreDestroy: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??HAL_SemaphoreDestroy_0
    771                  return;
    772              }
    773              queue = (QueueHandle_t)sem;
    774          
    775              vSemaphoreDelete(queue);
   \        0x4   0x....'....        B.W      vQueueDelete
   \                     ??HAL_SemaphoreDestroy_0: (+1)
   \        0x8   0x4770             BX       LR               ;; return
    776          }
    777          
    778          
    779          /**
    780           * @brief   signal thread wait on a semaphore
    781           *
    782           * @param[in] sem @n the specified semaphore.
    783           * @return None.
    784           * @see None.
    785           * @note None.
    786           */

   \                                 In section .text, align 2, keep-with-next
    787          void HAL_SemaphorePost(void *sem)
    788          {
    789          	QueueHandle_t queue;
    790              if (sem == NULL) {
   \                     HAL_SemaphorePost: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD004             BEQ.N    ??HAL_SemaphorePost_0
    791                  return;
    792              }
    793              queue = (QueueHandle_t)sem;
    794              (void)xSemaphoreGive(queue);
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x461A             MOV      R2,R3
   \        0x8   0x4611             MOV      R1,R2
   \        0xA   0x....'....        B.W      xQueueGenericSend
   \                     ??HAL_SemaphorePost_0: (+1)
   \        0xE   0x4770             BX       LR               ;; return
    795          }
    796          /**
    797           * @brief   wait on a semaphore
    798           *
    799           * @param[in] sem @n the specified semaphore.
    800           * @param[in] timeout_ms @n timeout interval in millisecond.
    801               If timeout_ms is PLATFORM_WAIT_INFINITE, the function will return only when the semaphore is signaled.
    802           * @return
    803             @verbatim
    804             =  0: The state of the specified object is signaled.
    805             =  -1: The time-out interval elapsed, and the object's state is nonsignaled.
    806             @endverbatim
    807           * @see None.
    808           * @note None.
    809           */

   \                                 In section .text, align 2, keep-with-next
    810          int HAL_SemaphoreWait(void *sem, uint32_t timeout_ms)
    811          {
   \                     HAL_SemaphoreWait: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    812          	BaseType_t ret = 0;
    813              QueueHandle_t queue;
    814              if (sem == NULL) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD102             BNE.N    ??HAL_SemaphoreWait_0
    815                  return -1;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD02             POP      {R1,PC}
    816              }
    817          
    818              queue = (QueueHandle_t)sem;
    819              ret = xSemaphoreTake(queue, timeout_ms/portTICK_PERIOD_MS);
    820              if (pdPASS != ret) {
   \                     ??HAL_SemaphoreWait_0: (+1)
   \        0xC   0x....'....        BL       xQueueSemaphoreTake
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD002             BEQ.N    ??HAL_SemaphoreWait_1
    821                  return -1;
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD02             POP      {R1,PC}
    822              }
    823              return 0;
   \                     ??HAL_SemaphoreWait_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD02             POP      {R1,PC}          ;; return
    824          }
    825          
    826          /**
    827           * @brief  create a thread
    828           *
    829           * @param[out] thread_handle @n The new thread handle, memory allocated before thread created and return it, free it after thread joined or exit.
    830           * @param[in] start_routine @n A pointer to the application-defined function to be executed by the thread.
    831                  This pointer represents the starting address of the thread.
    832           * @param[in] arg @n A pointer to a variable to be passed to the start_routine.
    833           * @param[in] hal_os_thread_param @n A pointer to stack params.
    834           * @param[out] stack_used @n if platform used stack buffer, set stack_used to 1, otherwise set it to 0.
    835           * @return
    836             @verbatim
    837               = 0: on success.
    838               = -1: error occur.
    839             @endverbatim
    840           * @see None.
    841           * @note None.
    842           */
    843           #ifndef DEFAULT_THREAD_NAME
    844           #define DEFAULT_THREAD_NAME "wrapper_"
    845           #define TASK_STACK_ALIGN_SIZE 4u
    846           #endif
    847           

   \                                 In section .text, align 2, keep-with-next
    848          int HAL_ThreadCreate(
    849                      void **thread_handle,
    850                      void *(*work_routine)(void *),
    851                      void *arg,
    852                      hal_os_thread_param_t *hal_os_thread_param,
    853                      int *stack_used)
    854          {
   \                     HAL_ThreadCreate: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    855            
    856          
    857          	char *name;
    858              size_t stacksize;
    859          
    860              if (thread_handle == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??HAL_ThreadCreate_0
    861                  return -1;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD76             POP      {R1,R2,R4-R6,PC}
    862              }
    863          
    864              if (work_routine == NULL) {
   \                     ??HAL_ThreadCreate_0: (+1)
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0xD102             BNE.N    ??HAL_ThreadCreate_1
    865                  return -1;
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD76             POP      {R1,R2,R4-R6,PC}
    866              }
    867          
    868              if (hal_os_thread_param == NULL) {
   \                     ??HAL_ThreadCreate_1: (+1)
   \       0x1A   0x2B00             CMP      R3,#+0
   \       0x1C   0xD102             BNE.N    ??HAL_ThreadCreate_2
    869                  return -1;
   \       0x1E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x22   0xBD76             POP      {R1,R2,R4-R6,PC}
    870              }
   \                     ??HAL_ThreadCreate_2: (+1)
   \       0x24   0x9806             LDR      R0,[SP, #+24]
    871              if (stack_used == NULL) {
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE.N    ??HAL_ThreadCreate_3
    872                  return -1;
   \       0x2A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x2E   0xBD76             POP      {R1,R2,R4-R6,PC}
    873              }
    874          
    875              if (stack_used != NULL) {
   \                     ??HAL_ThreadCreate_3: (+1)
   \       0x30   0xD001             BEQ.N    ??HAL_ThreadCreate_4
    876                  *stack_used = 0;
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x6001             STR      R1,[R0, #+0]
    877              }
    878          
    879              if (!hal_os_thread_param->name) {
   \                     ??HAL_ThreadCreate_4: (+1)
   \       0x36   0x6918             LDR      R0,[R3, #+16]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD101             BNE.N    ??HAL_ThreadCreate_5
    880                  name = DEFAULT_THREAD_NAME;
   \       0x3C   0x....             LDR.N    R1,??DataTable16_23
   \       0x3E   0xE000             B.N      ??HAL_ThreadCreate_6
    881              } else {
    882                  name = hal_os_thread_param->name;
   \                     ??HAL_ThreadCreate_5: (+1)
   \       0x40   0x4601             MOV      R1,R0
    883              }
    884          
    885              if (hal_os_thread_param->stack_size == 0) {
   \                     ??HAL_ThreadCreate_6: (+1)
   \       0x42   0x6898             LDR      R0,[R3, #+8]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD101             BNE.N    ??HAL_ThreadCreate_7
    886                  stacksize = configMINIMAL_STACK_SIZE;
   \       0x48   0xF44F 0x7080      MOV      R0,#+256
    887              } else {
    888                  stacksize = hal_os_thread_param->stack_size;
    889              }
    890          
    891           
    892              stacksize = (stacksize + TASK_STACK_ALIGN_SIZE - 1) / TASK_STACK_ALIGN_SIZE;
    893          	static TaskHandle_t xtask = NULL;
    894              BaseType_t ret = xTaskCreate((TaskFunction_t )(work_routine), name,stacksize,arg,hal_os_thread_param->priority,&xtask);
    895              if (NULL == ret) {
   \                     ??HAL_ThreadCreate_7: (+1)
   \       0x4C   0x....             LDR.N    R6,??DataTable16_24
   \       0x4E   0x9601             STR      R6,[SP, #+4]
   \       0x50   0xF9B3 0x3000      LDRSH    R3,[R3, #+0]
   \       0x54   0x9300             STR      R3,[SP, #+0]
   \       0x56   0x4613             MOV      R3,R2
   \       0x58   0x1CC0             ADDS     R0,R0,#+3
   \       0x5A   0x0880             LSRS     R0,R0,#+2
   \       0x5C   0x4602             MOV      R2,R0
   \       0x5E   0xB292             UXTH     R2,R2
   \       0x60   0x4628             MOV      R0,R5
   \       0x62   0x....'....        BL       xTaskCreate
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD102             BNE.N    ??HAL_ThreadCreate_8
    896                  return -1;
   \       0x6A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x6E   0xBD76             POP      {R1,R2,R4-R6,PC}
    897              }
    898              *thread_handle = (void *)xtask;
   \                     ??HAL_ThreadCreate_8: (+1)
   \       0x70   0x6830             LDR      R0,[R6, #+0]
   \       0x72   0x6020             STR      R0,[R4, #+0]
    899          
    900              return 0;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    901          }

   \                                 In section .bss, align 4
   \                     `HAL_ThreadCreate::xtask`:
   \        0x0                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    902          void HAL_ThreadDelete(void *thread_handle)
    903          {
    904          	vTaskDelete((TaskHandle_t )thread_handle);
   \                     HAL_ThreadDelete: (+1)
   \        0x0   0x....'....        B.W      vTaskDelete
    905          }
    906          
    907          

   \                                 In section .text, align 2, keep-with-next
    908          void *HAL_Timer_Create(const char *name, void (*func)(void *), void *user_data)
    909          {
   \                     HAL_Timer_Create: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4613             MOV      R3,R2
    910          	TimerHandle_t thandle = xTimerCreate(name, 1000, pdFALSE, user_data, (TimerCallbackFunction_t)func);
    911          	
    912          	return (void *)thandle;
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0xF44F 0x717A      MOV      R1,#+1000
   \        0xC   0x....'....        BL       xTimerCreate
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
    913          }
    914          
    915          

   \                                 In section .text, align 2, keep-with-next
    916          int HAL_Timer_Delete(void *timer)
    917          {
   \                     HAL_Timer_Delete: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    918          	return (int )xTimerDelete((TimerHandle_t ) timer, 0);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0x460B             MOV      R3,R1
   \        0x8   0x460A             MOV      R2,R1
   \        0xA   0x2105             MOVS     R1,#+5
   \        0xC   0x....'....        BL       xTimerGenericCommand
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
    919          }
    920          
    921          

   \                                 In section .text, align 2, keep-with-next
    922          int HAL_Timer_Start(void *timer, int ms)
    923          {
   \                     HAL_Timer_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    924          	BaseType_t ret = xTimerStart((TimerHandle_t ) timer,pdMS_TO_TICKS(ms));
    925          	return (int )ret;
   \        0x6   0x....'....        BL       xTaskGetTickCount
   \        0xA   0x4602             MOV      R2,R0
   \        0xC   0xF44F 0x707A      MOV      R0,#+1000
   \       0x10   0x4345             MULS     R5,R0,R5
   \       0x12   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \       0x18   0x2300             MOVS     R3,#+0
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       xTimerGenericCommand
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    926          }
    927          
    928          

   \                                 In section .text, align 2, keep-with-next
    929          int HAL_Timer_Stop(void *timer)
    930          {
   \                     HAL_Timer_Stop: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    931          	BaseType_t ret = xTimerStop((TimerHandle_t ) timer, 0);
    932          	return (int )ret;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0x460B             MOV      R3,R1
   \        0x8   0x460A             MOV      R2,R1
   \        0xA   0x2103             MOVS     R1,#+3
   \        0xC   0x....'....        BL       xTimerGenericCommand
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
    933          }
    934          
    935          
    936          
    937          /**
    938           * @brief Retrieves the number of milliseconds that have elapsed since the system was boot.
    939           *
    940           * @return the number of milliseconds.
    941           * @see None.
    942           * @note None.
    943           */

   \                                 In section .text, align 2, keep-with-next
    944          uint64_t HAL_UptimeMs(void)
    945          {
   \                     HAL_UptimeMs: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    946          	return (uint64_t)xTaskGetTickCount();
   \        0x2   0x....'....        BL       xTaskGetTickCount
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xBD04             POP      {R2,PC}          ;; return
    947          }
    948          /*
    949          void SysTick_Handler(void)
    950          {
    951              sys_tick_cnt++;
    952          	if(!sys_tick_cnt){
    953          		wrapped = 1;
    954          	}
    955          	if(sys_tick_cnt > 20){
    956          		wrapped = 0;
    957          
    958          	}
    959          }
    960          */
    961          

   \                                 In section .text, align 2, keep-with-next
    962          void HAL_timerInit(void ){
   \                     HAL_timerInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    963            SysTick_Config(CLOCK_GetFreq(kCLOCK_CoreSysClk) / 1000U);
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x....'....        BL       CLOCK_GetFreq
   \        0x8   0xF44F 0x717A      MOV      R1,#+1000
   \        0xC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x10   0xE8BD 0x4002      POP      {R1,LR}
   \       0x14   0x....             B.N      SysTick_Config
    964          }
    965          

   \                                 In section .text, align 2, keep-with-next
    966          int HAL_Vsnprintf(char *str, const int len, const char *format, va_list ap)
    967          {
    968          	return 1;
   \                     HAL_Vsnprintf: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
    969          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0xE000'E400        DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0xE000'ED18        DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0xE000'E014        DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0xE000'E018        DC32     0xe000e018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0xE000'E010        DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x....'....        DC32     uart_rxstatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x....'....        DC32     uart_status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x....'....        DC32     s_uartBaseAddrs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0x....'....        DC32     uart_rxwait_sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0x....'....        DC32     uart_txwait_sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x....'....        DC32     check_st_sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \        0x0   0x....'....        DC32     seam_wait_rx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \        0x0   0x....'....        DC32     seam_wait_tx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \        0x0   0x....'....        DC32     lpuart_config

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \        0x0   0x....'....        DC32     t_handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \        0x0   0x....'....        DC32     handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \        0x0   0x400C'C000        DC32     0x400cc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \        0x0   0x....'....        DC32     srandom_inited

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_23:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_24:
   \        0x0   0x....'....        DC32     `HAL_ThreadCreate::xtask`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x73 0x6D          DC8 "smart_wm_test1"
   \              0x61 0x72    
   \              0x74 0x5F    
   \              0x77 0x6D    
   \              0x5F 0x74    
   \              0x65 0x73    
   \              0x74 0x31    
   \              0x00         
   \        0xF   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x33 0x71          DC8 "3qLxqnrCCxhEVJUJjq88jEYkPwi2CZCr"
   \              0x4C 0x78    
   \              0x71 0x6E    
   \              0x72 0x43    
   \              0x43 0x78    
   \              0x68 0x45    
   \              0x56 0x4A    
   \              0x55 0x4A    
   \              0x6A 0x71    
   \              0x38 0x38    
   \              0x6A 0x45    
   \              0x59 0x6B    
   \              0x50 0x77    
   \              0x69 0x32    
   \              0x43 0x5A    
   \              0x43 0x72    
   \              0x00         
   \       0x21   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x31 0x2E          DC8 "1.0.0"
   \              0x30 0x2E    
   \              0x30 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x61 0x31          DC8 "a1I5Y6v8HwT"
   \              0x49 0x35    
   \              0x59 0x36    
   \              0x76 0x38    
   \              0x48 0x77    
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x53 0x35          DC8 "S56FG57Rqjr24CHo"
   \              0x36 0x46    
   \              0x47 0x35    
   \              0x37 0x52    
   \              0x71 0x6A    
   \              0x72 0x32    
   \              0x34 0x43    
   \              0x48 0x6F    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x77 0x72          DC8 "wrapper_"
   \              0x61 0x70    
   \              0x70 0x65    
   \              0x72 0x5F    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_AT_Uart_Deinit
         8   -> HAL_SemaphoreDestroy
         8   -> LPUART_Deinit
      16   HAL_AT_Uart_Init
        16   -> BOARD_DebugConsoleSrcFreq
        16   -> LPUART_RTOS_Init
        16   -> __NVIC_SetPriority
       8   HAL_AT_Uart_Recv
         8   -> LPUART_RTOS_Receive
       8   HAL_AT_Uart_Send
         8   -> LPUART_RTOS_Send
       0   HAL_Free
         0   -> vPortFree
       8   HAL_GetDeviceName
         8   -> __aeabi_memset
         0   -> strlen
         8   -> strncpy
       8   HAL_GetDeviceSecret
         8   -> __aeabi_memset
         8   -> strncpy
       8   HAL_GetFirmwareVersion
         8   -> __aeabi_memset
         0   -> strlen
         8   -> strncpy
       8   HAL_GetProductKey
         8   -> __aeabi_memset
         8   -> strncpy
       8   HAL_GetProductSecret
         8   -> __aeabi_memset
         8   -> strncpy
       0   HAL_Kv_Get
         0   -> kv_item_get
       0   HAL_Kv_Set
         0   -> kv_item_set
       0   HAL_Malloc
         0   -> pvPortMalloc
       8   HAL_MutexCreate
         8   -> xQueueCreateMutex
       0   HAL_MutexDestroy
         0   -> vQueueDelete
       8   HAL_MutexLock
         8   -> xQueueSemaphoreTake
       0   HAL_MutexUnlock
         0   -> xQueueGenericSend
      16   HAL_Random
        16   -> TRNG_GetRandomData
       8   HAL_SemaphoreCreate
         8   -> xQueueCreateCountingSemaphore
       0   HAL_SemaphoreDestroy
         0   -> vQueueDelete
       0   HAL_SemaphorePost
         0   -> xQueueGenericSend
       8   HAL_SemaphoreWait
         8   -> xQueueSemaphoreTake
       0   HAL_SleepMs
         0   -> vTaskDelay
       8   HAL_Snprintf
         8   -> vsnprintf
      88   HAL_Srandom
        88   -> TRNG_GetDefaultConfig
        88   -> TRNG_Init
      24   HAL_ThreadCreate
        24   -> xTaskCreate
       0   HAL_ThreadDelete
         0   -> vTaskDelete
       8   HAL_Timer_Create
         8   -> xTimerCreate
       8   HAL_Timer_Delete
         8   -> xTimerGenericCommand
      16   HAL_Timer_Start
        16   -> xTaskGetTickCount
        16   -> xTimerGenericCommand
       8   HAL_Timer_Stop
         8   -> xTimerGenericCommand
      16   HAL_Uart_rxWait
        16   -> xTaskGetTickCount
      16   HAL_Uart_txWait
        16   -> xTaskGetTickCount
       8   HAL_UptimeMs
         8   -> xTaskGetTickCount
       0   HAL_Vsnprintf
       8   HAL_timerInit
         8   -> CLOCK_GetFreq
         0   -> SysTick_Config
       8   SysTick_Config
         8   -> __NVIC_SetPriority
       0   __NVIC_SetPriority
       8   uart2_interrupt_handle_task
         8   -> HAL_SemaphoreWait
         8   -> xQueueGenericSend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      16  ?_0
      36  ?_1
       8  ?_2
      12  ?_3
      20  ?_4
      12  ?_5
      42  HAL_AT_Uart_Deinit
      44  HAL_AT_Uart_Init
      14  HAL_AT_Uart_Recv
      12  HAL_AT_Uart_Send
       4  HAL_Free
      32  HAL_GetDeviceName
      26  HAL_GetDeviceSecret
      36  HAL_GetFirmwareVersion
      26  HAL_GetProductKey
      26  HAL_GetProductSecret
       4  HAL_Kv_Get
       4  HAL_Kv_Set
       4  HAL_Malloc
      16  HAL_MutexCreate
      10  HAL_MutexDestroy
      32  HAL_MutexLock
      16  HAL_MutexUnlock
      36  HAL_Random
      18  HAL_SemaphoreCreate
      10  HAL_SemaphoreDestroy
      16  HAL_SemaphorePost
      30  HAL_SemaphoreWait
       4  HAL_SleepMs
      14  HAL_Snprintf
      38  HAL_Srandom
     120  HAL_ThreadCreate
       4  HAL_ThreadDelete
      18  HAL_Timer_Create
      18  HAL_Timer_Delete
      36  HAL_Timer_Start
      18  HAL_Timer_Stop
      44  HAL_Uart_rxWait
      42  HAL_Uart_txWait
      10  HAL_UptimeMs
       4  HAL_Vsnprintf
      22  HAL_timerInit
      52  SysTick_Config
      32  __NVIC_SetPriority
     512  background_buffer
       4  check_st_sem
      40  handle
       4  isr_uart_handle
      24  lpuart_config
      32  s_uartBaseAddrs
       1  seam_wait_rx
       1  seam_wait_tx
       1  srandom_inited
      48  t_handle
     102  uart2_interrupt_handle_task
       4  uart_rxstatus
       4  uart_rxwait_sem
       4  uart_status
       4  uart_txwait_sem
       4  xtask

 
   631 bytes in section .bss
    24 bytes in section .data
   136 bytes in section .rodata
 1 136 bytes in section .text
 
 1 136 bytes of CODE  memory
   136 bytes of CONST memory
   655 bytes of DATA  memory

Errors: none
Warnings: 4
