###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         06/Jun/2019  11:29:51
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\devices\MIMXRT1052\utilities\fsl_shell.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW294F.tmp
#        (C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\devices\MIMXRT1052\utilities\fsl_shell.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\list
#        -lA
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../boards\evkbimxrt1050\rtos_examples\csdk\app_preinclude.h
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../rtos/amazon-freertos/lib/FreeRTOS/portable/IAR/ARM_CM4F\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/..\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../..\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../CMSIS/Include\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../rtos/amazon-freertos/lib/include\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../rtos/amazon-freertos/lib/include/private\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/drivers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/utilities\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/utilities/str\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/utilities/debug_console\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/uart\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/serial_manager\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/kv\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/kv/include\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/drivers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../components/lists\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/drivers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/drivers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../../../devices/MIMXRT1052/xip\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar/../../../xip\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\atm\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_model\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_sign\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\infra\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\mqtt\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\wrappers\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\wrappers\external_libs\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\wifi\mk3060\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\coap_cloud\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\coap_server\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\coap_server\server\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_bind\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_bind\impl\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\csdk\eng\dev_bind\impl\awss_reset\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\mbedtls\include\mbedtls\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\mbedtls\include\
#        -I
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\..\..\..\..\..\middleware\mbedtls\port\ksdk\
#        -Om)
#    Locale       =  C
#    List file    =  
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\list\fsl_shell.lst
#    Object file  =  
#        C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\boards\evkbimxrt1050\rtos_examples\csdk\iar\flexspi_nor_debug\obj\fsl_shell.o
#
###############################################################################

C:\nxp\SDK_2.6.0_EVKB-IMXRT1050\devices\MIMXRT1052\utilities\fsl_shell.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2018 NXP
      4           * All rights reserved.
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           *
      8           * POSIX getopt for Windows
      9           * Code given out at the 1985 UNIFORUM conference in Dallas.
     10           *
     11           * From std-unix@ut-sally.UUCP (Moderator, John Quarterman) Sun Nov  3 14:34:15 1985
     12           * Relay-Version: version B 2.10.3 4.3bsd-beta 6/6/85; site gatech.CSNET
     13           * Posting-Version: version B 2.10.2 9/18/84; site ut-sally.UUCP
     14           * Path: gatech!akgua!mhuxv!mhuxt!mhuxr!ulysses!allegra!mit-eddie!genrad!panda!talcott!harvard!seismo!ut-sally!std-unix
     15           * From: std-unix@ut-sally.UUCP (Moderator, John Quarterman)
     16           * Newsgroups: mod.std.unix
     17           * Subject: public domain AT&T getopt source
     18           * Message-ID: <3352@ut-sally.UUCP>
     19           * Date: 3 Nov 85 19:34:15 GMT
     20           * Date-Received: 4 Nov 85 12:25:09 GMT
     21           * Organization: IEEE/P1003 Portable Operating System Environment Committee
     22           * Lines: 91
     23           * Approved: jsq@ut-sally.UUC
     24           * Here's something you've all been waiting for:  the AT&T public domain
     25           * source for getopt(3).  It is the code which was given out at the 1985
     26           * UNIFORUM conference in Dallas.  I obtained it by electronic mail
     27           * directly from AT&T.  The people there assure me that it is indeed
     28           * in the public domain
     29           * There is no manual page.  That is because the one they gave out at
     30           * UNIFORUM was slightly different from the current System V Release 2
     31           * manual page.  The difference apparently involved a note about the
     32           * famous rules 5 and 6, recommending using white space between an option
     33           * and its first argument, and not grouping options that have arguments.
     34           * Getopt itself is currently lenient about both of these things White
     35           * space is allowed, but not mandatory, and the last option in a group can
     36           * have an argument.  That particular version of the man page evidently
     37           * has no official existence, and my source at AT&T did not send a copy.
     38           * The current SVR2 man page reflects the actual behavor of this getopt.
     39           * However, I am not about to post a copy of anything licensed by AT&T.
     40           */
     41          
     42          #include <assert.h>
     43          #include <stdarg.h>
     44          #include <stdlib.h>
     45          #include "fsl_str.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t DisableGlobalIRQ(void)
   \                     DisableGlobalIRQ: (+1)
   \        0x0   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x4   0xB672             CPSID    I
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableGlobalIRQ(uint32_t)
   \                     EnableGlobalIRQ: (+1)
   \        0x0   0xF380 0x8810      MSR      PRIMASK,R0
   \        0x4   0x4770             BX       LR               ;; return
     46          
     47          #include "generic_list.h"
     48          #include "serial_manager.h"
     49          
     50          #include "fsl_shell.h"
     51          
     52          /*
     53           * The OSA_USED macro can only be defined when the OSA component is used.
     54           * If the source code of the OSA component does not exist, the OSA_USED cannot be defined.
     55           * OR, If OSA component is not added into project event the OSA source code exists, the OSA_USED
     56           * also cannot be defined.
     57           * The source code path of the OSA component is <MCUXpresso_SDK>/components/osa.
     58           *
     59           */
     60          #if defined(OSA_USED)
     61          
     62          #if (defined(SHELL_USE_COMMON_TASK) && (SHELL_USE_COMMON_TASK > 0U))
     63          #include "common_task.h"
     64          #else
     65          #include "fsl_os_abstraction.h"
     66          #endif
     67          
     68          #endif
     69          
     70          /*******************************************************************************
     71           * Definitions
     72           ******************************************************************************/
     73          #define KEY_ESC (0x1BU)
     74          #define KET_DEL (0x7FU)
     75          
     76          #define SHELL_EVENT_DATA_ARRIVED (1U << 0)
     77          #define SHELL_EVENT_DATA_SENT (1U << 1)
     78          
     79          #define SHELL_SPRINTF_BUFFER_SIZE (64U)
     80          
     81          /*! @brief A type for the handle special key. */
     82          typedef enum _fun_key_status
     83          {
     84              kSHELL_Normal   = 0U, /*!< Normal key */
     85              kSHELL_Special  = 1U, /*!< Special key */
     86              kSHELL_Function = 2U, /*!< Function key */
     87          } fun_key_status_t;
     88          
     89          /*! @brief Data structure for Shell environment. */
     90          typedef struct _shell_context_handle
     91          {
     92              list_t commandContextListHead; /*!< Command shellContextHandle list queue head */
     93              serial_handle_t serialHandle;  /*!< Serial manager handle */
     94              uint8_t
     95                  serialWriteHandleBuffer[SERIAL_MANAGER_WRITE_HANDLE_SIZE];   /*!< The buffer for serial manager write handle */
     96              serial_write_handle_t serialWriteHandle;                         /*!< The serial manager write handle */
     97              uint8_t serialReadHandleBuffer[SERIAL_MANAGER_READ_HANDLE_SIZE]; /*!< The buffer for serial manager read handle */
     98              serial_read_handle_t serialReadHandle;                           /*!< The serial manager read handle */
     99              char *prompt;                                                    /*!< Prompt string */
    100          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    101          
    102          #if defined(OSA_USED)
    103          
    104          #if (defined(SHELL_USE_COMMON_TASK) && (SHELL_USE_COMMON_TASK > 0U))
    105              common_task_message_t commontaskMsg; /*!< Message for common task */
    106          #else
    107              uint8_t event[OSA_EVENT_HANDLE_SIZE]; /*!< Event instance */
    108              uint8_t taskId[OSA_TASK_HANDLE_SIZE]; /*!< Task handle */
    109          #endif
    110          
    111          #endif
    112          
    113          #endif
    114              char line[SHELL_BUFFER_SIZE];                          /*!< Consult buffer */
    115              char hist_buf[SHELL_HISTORY_COUNT][SHELL_BUFFER_SIZE]; /*!< History buffer*/
    116              char printBuffer[SHELL_SPRINTF_BUFFER_SIZE];           /*!< Buffer for print */
    117              uint32_t printLength;                                  /*!< All length has been printed */
    118              uint16_t hist_current;                                 /*!< Current history command in hist buff*/
    119              uint16_t hist_count;                                   /*!< Total history command in hist buff*/
    120              enum _fun_key_status stat;                             /*!< Special key status */
    121              uint8_t cmd_num;                                       /*!< Number of user commands */
    122              uint8_t l_pos;                                         /*!< Total line position */
    123              uint8_t c_pos;                                         /*!< Current line position */
    124              volatile uint8_t notificationPost;                     /*!< The serial manager notification is post */
    125              uint8_t exit;                                          /*!< Exit Flag*/
    126              uint8_t printBusy;                                     /*!< Print is busy */
    127          } shell_context_handle_t;
    128          
    129          #define SHELL_STRUCT_OFFSET(type, field) ((size_t) & (((type *)0)->field))
    130          #define SHEEL_COMMAND_POINTER(node) ((shell_command_t *)(((uint32_t)node) - SHELL_STRUCT_OFFSET(shell_command_t, link)))
    131          /*******************************************************************************
    132           * Prototypes
    133           ******************************************************************************/
    134          static shell_status_t SHELL_HelpCommand(shell_handle_t shellHandle, int32_t argc, char **argv); /*!< help command */
    135          
    136          static shell_status_t SHELL_ExitCommand(shell_handle_t shellHandle, int32_t argc, char **argv); /*!< exit command */
    137          
    138          static int32_t SHELL_ParseLine(const char *cmd, uint32_t len, char *argv[]); /*!< parse line command */
    139          
    140          static int32_t SHELL_StringCompare(const char *str1, const char *str2, int32_t count); /*!< compare string command */
    141          
    142          static void SHELL_ProcessCommand(shell_context_handle_t *shellContextHandle, const char *cmd); /*!< process a command */
    143          
    144          static void SHELL_GetHistoryCommand(shell_context_handle_t *shellContextHandle,
    145                                              uint8_t hist_pos); /*!< get commands history */
    146          
    147          static void SHELL_AutoComplete(shell_context_handle_t *shellContextHandle); /*!< auto complete command */
    148          
    149          static shell_status_t SHELL_GetChar(shell_context_handle_t *shellContextHandle,
    150                                              uint8_t *ch); /*!< get a char from communication interface */
    151          
    152          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    153          static void SHELL_Task(void *param); /*!<  Shell task*/
    154          #endif
    155          
    156          /*******************************************************************************
    157           * Variables
    158           ******************************************************************************/
    159          

   \                                 In section .data, align 4
    160          static SHELL_COMMAND_DEFINE(help, "\r\n\"help\": List all the registered commands\r\n", SHELL_HelpCommand, 0);
   \                     g_shellCommandhelp:
   \        0x0   0x....'....        DC32 ?_0, ?_1, SHELL_HelpCommand
   \              0x....'....  
   \              0x....'....  
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x10   0x0000'0000        DC32 0H
   \       0x14   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
    161          static SHELL_COMMAND_DEFINE(exit, "\r\n\"exit\": Exit program\r\n", SHELL_ExitCommand, 0);
   \                     g_shellCommandexit:
   \        0x0   0x....'....        DC32 ?_2, ?_3, SHELL_ExitCommand
   \              0x....'....  
   \              0x....'....  
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x10   0x0000'0000        DC32 0H
   \       0x14   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    162          

   \                                 In section .bss, align 4
    163          static char s_paramBuffer[SHELL_BUFFER_SIZE];
   \                     s_paramBuffer:
   \        0x0                      DS8 64
    164          
    165          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    166          
    167          #if defined(OSA_USED)
    168          
    169          #if (defined(SHELL_USE_COMMON_TASK) && (SHELL_USE_COMMON_TASK > 0U))
    170          
    171          #else
    172          /*
    173           * \brief Defines the serial manager task's stack
    174           */
    175          OSA_TASK_DEFINE(SHELL_Task, SHELL_TASK_PRIORITY, 1, SHELL_TASK_STACK_SIZE, false);
    176          #endif
    177          
    178          #endif
    179          
    180          #endif
    181          /*******************************************************************************
    182           * Code
    183           ******************************************************************************/
    184          
    185          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    186          static void SHELL_SerialManagerRxCallback(void *callbackParam,
    187                                                    serial_manager_callback_message_t *message,
    188                                                    serial_manager_status_t status)
    189          {
    190              shell_context_handle_t *shellHandle;
    191          
    192              assert(callbackParam);
    193              assert(message);
    194          
    195              shellHandle = (shell_context_handle_t *)callbackParam;
    196          
    197              if (!shellHandle->notificationPost)
    198              {
    199                  shellHandle->notificationPost = 1U;
    200          #if defined(OSA_USED)
    201          
    202          #if (defined(SHELL_USE_COMMON_TASK) && (SHELL_USE_COMMON_TASK > 0U))
    203                  shellHandle->commontaskMsg.callback      = SHELL_Task;
    204                  shellHandle->commontaskMsg.callbackParam = shellHandle;
    205                  COMMON_TASK_post_message(&shellHandle->commontaskMsg);
    206          #else
    207                  (void)OSA_EventSet((osa_event_handle_t)shellHandle->event, SHELL_EVENT_DATA_ARRIVED);
    208          #endif
    209          
    210          #else
    211                  SHELL_Task(shellHandle);
    212          #endif
    213              }
    214          }
    215          #endif
    216          

   \                                 In section .text, align 2, keep-with-next
    217          static void SHELL_WriteBuffer(char *buffer, int32_t *indicator, char val, int len)
    218          {
   \                     SHELL_WriteBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    219              shell_context_handle_t *shellContextHandle;
    220              int i              = 0;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    221              shellContextHandle = (shell_context_handle_t *)buffer;
    222          
    223              for (i = 0; i < len; i++)
   \       0x10   0xE01A             B.N      ??SHELL_WriteBuffer_0
    224              {
    225                  if ((uint32_t)(*indicator + 1) >= SHELL_SPRINTF_BUFFER_SIZE)
   \                     ??SHELL_WriteBuffer_1: (+1)
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0x2840             CMP      R0,#+64
   \       0x18   0xD30D             BCC.N    ??SHELL_WriteBuffer_2
    226                  {
    227                      (void)SerialManager_WriteBlocking(shellContextHandle->serialWriteHandle,
    228                                                        (uint8_t *)shellContextHandle->printBuffer, (uint32_t)*indicator);
   \       0x1A   0x682A             LDR      R2,[R5, #+0]
   \       0x1C   0xF504 0x7192      ADD      R1,R4,#+292
   \       0x20   0x6960             LDR      R0,[R4, #+20]
   \       0x22   0x....'....        BL       SerialManager_WriteBlocking
    229                      shellContextHandle->printLength += (uint32_t)*indicator;
   \       0x26   0xF8D4 0x0164      LDR      R0,[R4, #+356]
   \       0x2A   0x6829             LDR      R1,[R5, #+0]
   \       0x2C   0x1808             ADDS     R0,R1,R0
   \       0x2E   0xF8C4 0x0164      STR      R0,[R4, #+356]
    230                      *indicator = 0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6028             STR      R0,[R5, #+0]
    231                  }
    232          
    233                  shellContextHandle->printBuffer[*indicator] = val;
   \                     ??SHELL_WriteBuffer_2: (+1)
   \       0x36   0x6828             LDR      R0,[R5, #+0]
   \       0x38   0x4420             ADD      R0,R4,R0
   \       0x3A   0xF880 0x6124      STRB     R6,[R0, #+292]
    234                  (*indicator)++;
   \       0x3E   0x6828             LDR      R0,[R5, #+0]
   \       0x40   0x1C40             ADDS     R0,R0,#+1
   \       0x42   0x6028             STR      R0,[R5, #+0]
    235              }
   \       0x44   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??SHELL_WriteBuffer_0: (+1)
   \       0x48   0x45B8             CMP      R8,R7
   \       0x4A   0xDBE2             BLT.N    ??SHELL_WriteBuffer_1
    236          }
   \       0x4C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    237          

   \                                 In section .text, align 2, keep-with-next
    238          static int SHELL_Sprintf(void *buffer, const char *formatString, va_list ap)
    239          {
   \                     SHELL_Sprintf: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0x4611             MOV      R1,R2
    240              shell_context_handle_t *shellContextHandle;
    241              uint32_t length;
    242              shellContextHandle = (shell_context_handle_t *)buffer;
    243          
    244              length = (uint32_t)StrFormatPrintf(formatString, ap, (char *)buffer, SHELL_WriteBuffer);
   \        0x8   0x....'....        LDR.W    R3,??DataTable12
   \        0xC   0x4622             MOV      R2,R4
   \        0xE   0x....'....        BL       StrFormatPrintf
    245              shellContextHandle->printLength += length;
   \       0x12   0xF8D4 0x1164      LDR      R1,[R4, #+356]
   \       0x16   0x1841             ADDS     R1,R0,R1
   \       0x18   0xF8C4 0x1164      STR      R1,[R4, #+356]
    246              return (int32_t)length;
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
    247          }
    248          
    249          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    250          static void SHELL_Task(void *param)
    251          #else

   \                                 In section .text, align 2, keep-with-next
    252          void SHELL_Task(shell_handle_t shellHandle)
    253          #endif
    254          {
   \                     SHELL_Task: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    255          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    256              shell_context_handle_t *shellContextHandle = (shell_context_handle_t *)param;
    257          #else
    258              shell_context_handle_t *shellContextHandle = (shell_context_handle_t *)shellHandle;
    259          #endif
    260              uint8_t ch;
    261          
    262              if (NULL != shellContextHandle)
   \        0x4   0xF000 0x81A6      BEQ.W    ??SHELL_Task_0
    263              {
    264          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    265          
    266          #if defined(OSA_USED)
    267          
    268          #if (defined(SHELL_USE_COMMON_TASK) && (SHELL_USE_COMMON_TASK > 0U))
    269          #else
    270                  osa_event_flags_t ev = 0;
    271          
    272                  do
    273                  {
    274                      if (KOSA_StatusSuccess == OSA_EventWait((osa_event_handle_t)shellContextHandle->event, osaEventFlagsAll_c,
    275                                                              false, osaWaitForever_c, &ev))
    276                      {
    277                          if (ev & SHELL_EVENT_DATA_ARRIVED)
    278          #endif
    279          
    280          #endif
    281          
    282          #endif
    283                  {
    284                      shellContextHandle->notificationPost = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xF884 0x0170      STRB     R0,[R4, #+368]
    285                      do
    286                      {
    287                          if ((bool)shellContextHandle->exit)
   \                     ??SHELL_Task_1: (+1)
   \        0xE   0xF894 0x0171      LDRB     R0,[R4, #+369]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD10E             BNE.N    ??SHELL_Task_2
    288                          {
    289                              if (shellContextHandle->serialReadHandle != NULL)
    290                              {
    291                                  (void)SerialManager_CloseReadHandle(shellContextHandle->serialReadHandle);
    292                                  shellContextHandle->serialReadHandle = NULL;
    293                              }
    294                              if (shellContextHandle->serialWriteHandle != NULL)
    295                              {
    296                                  (void)SerialManager_CloseWriteHandle(shellContextHandle->serialWriteHandle);
    297                                  shellContextHandle->serialWriteHandle = NULL;
    298                              }
    299                              break;
    300                          }
    301                          if (kStatus_SHELL_Success != (shell_status_t)SHELL_GetChar(shellContextHandle, &ch))
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x....'....        BL       SHELL_GetChar
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xF040 0x8198      BNE.W    ??SHELL_Task_0
    302                          {
    303                              /* If error occurred when getting a char, exit the task and waiting the new data arriving. */
    304                              break;
    305                          }
    306          
    307                          /* Special key */
    308                          if (ch == KEY_ESC)
   \       0x24   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x28   0x281B             CMP      R0,#+27
   \       0x2A   0xD113             BNE.N    ??SHELL_Task_3
    309                          {
    310                              shellContextHandle->stat = kSHELL_Special;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF884 0x016C      STRB     R0,[R4, #+364]
    311                              continue;
   \       0x32   0xE18A             B.N      ??SHELL_Task_4
    312                          }
   \                     ??SHELL_Task_2: (+1)
   \       0x34   0x69E0             LDR      R0,[R4, #+28]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD003             BEQ.N    ??SHELL_Task_5
   \       0x3A   0x....'....        BL       SerialManager_CloseReadHandle
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x61E0             STR      R0,[R4, #+28]
   \                     ??SHELL_Task_5: (+1)
   \       0x42   0x6960             LDR      R0,[R4, #+20]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xF000 0x8185      BEQ.W    ??SHELL_Task_0
   \       0x4A   0x....'....        BL       SerialManager_CloseWriteHandle
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x6160             STR      R0,[R4, #+20]
   \       0x52   0xBD73             POP      {R0,R1,R4-R6,PC}
    313                          else if (shellContextHandle->stat == kSHELL_Special)
   \                     ??SHELL_Task_3: (+1)
   \       0x54   0xF894 0x016C      LDRB     R0,[R4, #+364]
   \       0x58   0x2801             CMP      R0,#+1
   \       0x5A   0xD13A             BNE.N    ??SHELL_Task_6
    314                          {
    315                              /* Function key */
    316                              if ((char)ch == '[')
   \       0x5C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x60   0x285B             CMP      R0,#+91
   \       0x62   0xD103             BNE.N    ??SHELL_Task_7
    317                              {
    318                                  shellContextHandle->stat = kSHELL_Function;
   \       0x64   0x2002             MOVS     R0,#+2
   \       0x66   0xF884 0x016C      STRB     R0,[R4, #+364]
    319                                  continue;
   \       0x6A   0xE16E             B.N      ??SHELL_Task_4
    320                              }
    321                              shellContextHandle->stat = kSHELL_Normal;
   \                     ??SHELL_Task_7: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xF884 0x016C      STRB     R0,[R4, #+364]
    322                          }
    323                          else if (shellContextHandle->stat == kSHELL_Function)
    324                          {
    325                              shellContextHandle->stat = kSHELL_Normal;
    326          
    327                              switch ((uint8_t)ch)
    328                              {
    329                                  /* History operation here */
    330                                  case 'A': /* Up key */
    331                                      SHELL_GetHistoryCommand(shellContextHandle, (uint8_t)shellContextHandle->hist_current);
    332                                      if (shellContextHandle->hist_current < (shellContextHandle->hist_count - 1U))
    333                                      {
    334                                          shellContextHandle->hist_current++;
    335                                      }
    336                                      break;
    337                                  case 'B': /* Down key */
    338                                      SHELL_GetHistoryCommand(shellContextHandle, (uint8_t)shellContextHandle->hist_current);
    339                                      if (shellContextHandle->hist_current > 0U)
    340                                      {
    341                                          shellContextHandle->hist_current--;
    342                                      }
    343                                      break;
    344                                  case 'D': /* Left key */
    345                                      if ((bool)shellContextHandle->c_pos)
    346                                      {
    347                                          (void)SHELL_Write(shellContextHandle, "\b", 1);
    348                                          shellContextHandle->c_pos--;
    349                                      }
    350                                      break;
    351                                  case 'C': /* Right key */
    352                                      if (shellContextHandle->c_pos < shellContextHandle->l_pos)
    353                                      {
    354                                          (void)SHELL_Write(shellContextHandle,
    355                                                            &shellContextHandle->line[shellContextHandle->c_pos], 1);
    356                                          shellContextHandle->c_pos++;
    357                                      }
    358                                      break;
    359                                  default:
    360                                      break;
    361                              }
    362                              continue;
    363                          }
    364                          /* Handle tab key */
    365                          else if ((char)ch == '\t')
    366                          {
    367          #if SHELL_AUTO_COMPLETE
    368                              /* Move the cursor to the beginning of line */
    369                              int i;
    370                              for (i = 0; i < shellContextHandle->c_pos; i++)
    371                              {
    372                                  (void)SHELL_Write(shellContextHandle, "\b", 1);
    373                              }
    374                              /* Do auto complete */
    375                              SHELL_AutoComplete(shellContextHandle);
    376                              /* Move position to end */
    377                              shellContextHandle->c_pos = shellContextHandle->l_pos = (uint8_t)strlen(shellContextHandle->line);
    378          #endif
    379                              continue;
    380                          }
    381                          /* Handle backspace key */
    382                          else if ((ch == KET_DEL) || ((char)ch == '\b'))
    383                          {
    384                              /* There must be at last one char */
    385                              if (shellContextHandle->c_pos == 0U)
    386                              {
    387                                  continue;
    388                              }
    389          
    390                              shellContextHandle->l_pos--;
    391                              shellContextHandle->c_pos--;
    392          
    393                              if (shellContextHandle->l_pos > shellContextHandle->c_pos)
    394                              {
    395                                  (void)memmove(&shellContextHandle->line[shellContextHandle->c_pos],
    396                                                &shellContextHandle->line[shellContextHandle->c_pos + 1U],
    397                                                shellContextHandle->l_pos - shellContextHandle->c_pos);
    398                                  shellContextHandle->line[shellContextHandle->l_pos] = 0U;
    399                                  (void)SHELL_Write(shellContextHandle, "\b", 1);
    400                                  (void)SHELL_Write(shellContextHandle, &shellContextHandle->line[shellContextHandle->c_pos],
    401                                                    strlen(&shellContextHandle->line[shellContextHandle->c_pos]));
    402                                  (void)SHELL_Write(shellContextHandle, "  \b", 3);
    403          
    404                                  /* Reset position */
    405                                  int i;
    406                                  for (i = shellContextHandle->c_pos; i <= shellContextHandle->l_pos; i++)
    407                                  {
    408                                      (void)SHELL_Write(shellContextHandle, "\b", 1);
    409                                  }
    410                              }
    411                              else /* Normal backspace operation */
    412                              {
    413                                  (void)SHELL_Write(shellContextHandle, "\b \b", 3);
    414                                  shellContextHandle->line[shellContextHandle->l_pos] = 0U;
    415                              }
    416                              continue;
    417                          }
    418                          else
    419                          {
    420                          }
    421          
    422                          /* Input too long */
    423                          if (shellContextHandle->l_pos >= (SHELL_BUFFER_SIZE - 1U))
   \                     ??SHELL_Task_8: (+1)
   \       0x72   0xF894 0x016E      LDRB     R0,[R4, #+366]
   \       0x76   0x283F             CMP      R0,#+63
   \       0x78   0xD302             BCC.N    ??SHELL_Task_9
    424                          {
    425                              shellContextHandle->l_pos = 0;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xF884 0x016E      STRB     R0,[R4, #+366]
    426                          }
    427          
    428                          /* Handle end of line, break */
    429                          if (((char)ch == '\r') || ((char)ch == '\n'))
   \                     ??SHELL_Task_9: (+1)
   \       0x80   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x84   0x280D             CMP      R0,#+13
   \       0x86   0xD002             BEQ.N    ??SHELL_Task_10
   \       0x88   0x280A             CMP      R0,#+10
   \       0x8A   0xF040 0x810F      BNE.W    ??SHELL_Task_11
    430                          {
    431                              static char endoflinechar = 0U;
    432          
    433                              if (((uint8_t)endoflinechar != 0U) && ((uint8_t)endoflinechar != ch))
   \                     ??SHELL_Task_10: (+1)
   \       0x8E   0x....'....        LDR.W    R1,??DataTable12_1
   \       0x92   0x7808             LDRB     R0,[R1, #+0]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD004             BEQ.N    ??SHELL_Task_12
   \       0x98   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \       0x9C   0x4290             CMP      R0,R2
   \       0x9E   0xF040 0x8154      BNE.W    ??SHELL_Task_4
    434                              {
    435                                  continue;
    436                              }
    437                              else
    438                              {
    439                                  endoflinechar = (char)ch;
   \                     ??SHELL_Task_12: (+1)
   \       0xA2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xA6   0x7008             STRB     R0,[R1, #+0]
    440                                  (void)SHELL_Write(shellContextHandle, "\r\n", 2);
   \       0xA8   0x2202             MOVS     R2,#+2
   \       0xAA   0x....             ADR.N    R1,??DataTable3  ;; 0x0D, 0x0A, 0x00, 0x00
   \       0xAC   0x4620             MOV      R0,R4
   \       0xAE   0x....'....        BL       SHELL_Write
    441                                  /* If command line is NULL, will start a new transfer */
    442                                  if (0U == strlen(shellContextHandle->line))
   \       0xB2   0xF104 0x0024      ADD      R0,R4,#+36
   \       0xB6   0x....'....        BL       strlen
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xF040 0x80DB      BNE.W    ??SHELL_Task_13
    443                                  {
    444                                      (void)SHELL_Write(shellContextHandle, shellContextHandle->prompt,
    445                                                        strlen(shellContextHandle->prompt));
   \       0xC0   0x6A20             LDR      R0,[R4, #+32]
   \       0xC2   0x....'....        BL       strlen
   \       0xC6   0x4602             MOV      R2,R0
   \       0xC8   0x6A21             LDR      R1,[R4, #+32]
   \       0xCA   0x4620             MOV      R0,R4
   \       0xCC   0x....'....        BL       SHELL_Write
    446                                      continue;
   \       0xD0   0xE13B             B.N      ??SHELL_Task_4
    447                                  }
   \                     ??SHELL_Task_6: (+1)
   \       0xD2   0x2802             CMP      R0,#+2
   \       0xD4   0xD153             BNE.N    ??SHELL_Task_14
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xF884 0x016C      STRB     R0,[R4, #+364]
   \       0xDC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xE0   0x2841             CMP      R0,#+65
   \       0xE2   0xD007             BEQ.N    ??SHELL_Task_15
   \       0xE4   0xF0C0 0x8131      BCC.W    ??SHELL_Task_4
   \       0xE8   0x2843             CMP      R0,#+67
   \       0xEA   0xD034             BEQ.N    ??SHELL_Task_16
   \       0xEC   0xD314             BCC.N    ??SHELL_Task_17
   \       0xEE   0x2844             CMP      R0,#+68
   \       0xF0   0xD021             BEQ.N    ??SHELL_Task_18
   \       0xF2   0xE12A             B.N      ??SHELL_Task_4
   \                     ??SHELL_Task_15: (+1)
   \       0xF4   0xF8B4 0x1168      LDRH     R1,[R4, #+360]
   \       0xF8   0xB2C9             UXTB     R1,R1
   \       0xFA   0x4620             MOV      R0,R4
   \       0xFC   0x....'....        BL       SHELL_GetHistoryCommand
   \      0x100   0xF8B4 0x0168      LDRH     R0,[R4, #+360]
   \      0x104   0xF8B4 0x116A      LDRH     R1,[R4, #+362]
   \      0x108   0x1E49             SUBS     R1,R1,#+1
   \      0x10A   0x4288             CMP      R0,R1
   \      0x10C   0xF080 0x811D      BCS.W    ??SHELL_Task_4
   \      0x110   0x1C40             ADDS     R0,R0,#+1
   \      0x112   0xF8A4 0x0168      STRH     R0,[R4, #+360]
   \      0x116   0xE118             B.N      ??SHELL_Task_4
   \                     ??SHELL_Task_17: (+1)
   \      0x118   0xF8B4 0x1168      LDRH     R1,[R4, #+360]
   \      0x11C   0xB2C9             UXTB     R1,R1
   \      0x11E   0x4620             MOV      R0,R4
   \      0x120   0x....'....        BL       SHELL_GetHistoryCommand
   \      0x124   0xF8B4 0x0168      LDRH     R0,[R4, #+360]
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xF000 0x810E      BEQ.W    ??SHELL_Task_4
   \      0x12E   0x1E40             SUBS     R0,R0,#+1
   \      0x130   0xF8A4 0x0168      STRH     R0,[R4, #+360]
   \      0x134   0xE109             B.N      ??SHELL_Task_4
   \                     ??SHELL_Task_18: (+1)
   \      0x136   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x13A   0x2800             CMP      R0,#+0
   \      0x13C   0xF000 0x8105      BEQ.W    ??SHELL_Task_4
   \      0x140   0x2201             MOVS     R2,#+1
   \      0x142   0x....             ADR.N    R1,??DataTable3_1  ;; "\b"
   \      0x144   0x4620             MOV      R0,R4
   \      0x146   0x....'....        BL       SHELL_Write
   \      0x14A   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x14E   0x1E40             SUBS     R0,R0,#+1
   \      0x150   0xF884 0x016F      STRB     R0,[R4, #+367]
   \      0x154   0xE0F9             B.N      ??SHELL_Task_4
   \                     ??SHELL_Task_16: (+1)
   \      0x156   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x15A   0xF894 0x116E      LDRB     R1,[R4, #+366]
   \      0x15E   0x4288             CMP      R0,R1
   \      0x160   0xF080 0x80F3      BCS.W    ??SHELL_Task_4
   \      0x164   0x2201             MOVS     R2,#+1
   \      0x166   0x4420             ADD      R0,R4,R0
   \      0x168   0xF100 0x0124      ADD      R1,R0,#+36
   \      0x16C   0x4620             MOV      R0,R4
   \      0x16E   0x....'....        BL       SHELL_Write
   \      0x172   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x176   0x1C40             ADDS     R0,R0,#+1
   \      0x178   0xF884 0x016F      STRB     R0,[R4, #+367]
   \      0x17C   0xE0E5             B.N      ??SHELL_Task_4
   \                     ??SHELL_Task_14: (+1)
   \      0x17E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x182   0x2809             CMP      R0,#+9
   \      0x184   0xD119             BNE.N    ??SHELL_Task_19
   \      0x186   0x2500             MOVS     R5,#+0
   \      0x188   0xE005             B.N      ??SHELL_Task_20
   \                     ??SHELL_Task_21: (+1)
   \      0x18A   0x2201             MOVS     R2,#+1
   \      0x18C   0x....             ADR.N    R1,??DataTable3_1  ;; "\b"
   \      0x18E   0x4620             MOV      R0,R4
   \      0x190   0x....'....        BL       SHELL_Write
   \      0x194   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SHELL_Task_20: (+1)
   \      0x196   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x19A   0x4285             CMP      R5,R0
   \      0x19C   0xDBF5             BLT.N    ??SHELL_Task_21
   \      0x19E   0x4620             MOV      R0,R4
   \      0x1A0   0x....'....        BL       SHELL_AutoComplete
   \      0x1A4   0xF104 0x0024      ADD      R0,R4,#+36
   \      0x1A8   0x....'....        BL       strlen
   \      0x1AC   0xF884 0x016E      STRB     R0,[R4, #+366]
   \      0x1B0   0xF894 0x016E      LDRB     R0,[R4, #+366]
   \      0x1B4   0xF884 0x016F      STRB     R0,[R4, #+367]
   \      0x1B8   0xE0C7             B.N      ??SHELL_Task_4
   \                     ??SHELL_Task_19: (+1)
   \      0x1BA   0x287F             CMP      R0,#+127
   \      0x1BC   0xD002             BEQ.N    ??SHELL_Task_22
   \      0x1BE   0x2808             CMP      R0,#+8
   \      0x1C0   0xF47F 0xAF57      BNE.W    ??SHELL_Task_8
   \                     ??SHELL_Task_22: (+1)
   \      0x1C4   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x1C8   0x2800             CMP      R0,#+0
   \      0x1CA   0xF000 0x80BE      BEQ.W    ??SHELL_Task_4
   \      0x1CE   0xF894 0x016E      LDRB     R0,[R4, #+366]
   \      0x1D2   0x1E40             SUBS     R0,R0,#+1
   \      0x1D4   0xF884 0x016E      STRB     R0,[R4, #+366]
   \      0x1D8   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x1DC   0x1E40             SUBS     R0,R0,#+1
   \      0x1DE   0xF884 0x016F      STRB     R0,[R4, #+367]
   \      0x1E2   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x1E6   0xF894 0x116E      LDRB     R1,[R4, #+366]
   \      0x1EA   0x4288             CMP      R0,R1
   \      0x1EC   0xD237             BCS.N    ??SHELL_Task_23
   \      0x1EE   0x460A             MOV      R2,R1
   \      0x1F0   0x1A12             SUBS     R2,R2,R0
   \      0x1F2   0x4420             ADD      R0,R4,R0
   \      0x1F4   0xF100 0x0125      ADD      R1,R0,#+37
   \      0x1F8   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x1FC   0x4420             ADD      R0,R4,R0
   \      0x1FE   0x3024             ADDS     R0,R0,#+36
   \      0x200   0x....'....        BL       __aeabi_memmove
   \      0x204   0x2000             MOVS     R0,#+0
   \      0x206   0xF894 0x116E      LDRB     R1,[R4, #+366]
   \      0x20A   0x4421             ADD      R1,R4,R1
   \      0x20C   0xF881 0x0024      STRB     R0,[R1, #+36]
   \      0x210   0x....             ADR.N    R5,??DataTable3_1  ;; "\b"
   \      0x212   0x2201             MOVS     R2,#+1
   \      0x214   0x4629             MOV      R1,R5
   \      0x216   0x4620             MOV      R0,R4
   \      0x218   0x....'....        BL       SHELL_Write
   \      0x21C   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x220   0x4420             ADD      R0,R4,R0
   \      0x222   0x3024             ADDS     R0,R0,#+36
   \      0x224   0x....'....        BL       strlen
   \      0x228   0x4602             MOV      R2,R0
   \      0x22A   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x22E   0x4420             ADD      R0,R4,R0
   \      0x230   0xF100 0x0124      ADD      R1,R0,#+36
   \      0x234   0x4620             MOV      R0,R4
   \      0x236   0x....'....        BL       SHELL_Write
   \      0x23A   0x2203             MOVS     R2,#+3
   \      0x23C   0x....             ADR.N    R1,??DataTable4  ;; "  \b"
   \      0x23E   0x4620             MOV      R0,R4
   \      0x240   0x....'....        BL       SHELL_Write
   \      0x244   0xF894 0x616F      LDRB     R6,[R4, #+367]
   \                     ??SHELL_Task_24: (+1)
   \      0x248   0xF894 0x016E      LDRB     R0,[R4, #+366]
   \      0x24C   0x42B0             CMP      R0,R6
   \      0x24E   0xDB7C             BLT.N    ??SHELL_Task_4
   \      0x250   0x2201             MOVS     R2,#+1
   \      0x252   0x4629             MOV      R1,R5
   \      0x254   0x4620             MOV      R0,R4
   \      0x256   0x....'....        BL       SHELL_Write
   \      0x25A   0x1C76             ADDS     R6,R6,#+1
   \      0x25C   0xE7F4             B.N      ??SHELL_Task_24
   \                     ??SHELL_Task_23: (+1)
   \      0x25E   0x2203             MOVS     R2,#+3
   \      0x260   0x....             ADR.N    R1,??DataTable4_1  ;; "\b \b"
   \      0x262   0x4620             MOV      R0,R4
   \      0x264   0x....'....        BL       SHELL_Write
   \      0x268   0x2000             MOVS     R0,#+0
   \      0x26A   0xF894 0x116E      LDRB     R1,[R4, #+366]
   \      0x26E   0x4421             ADD      R1,R4,R1
   \      0x270   0xF881 0x0024      STRB     R0,[R1, #+36]
   \      0x274   0xE069             B.N      ??SHELL_Task_4
    448                                  SHELL_ProcessCommand(shellContextHandle, shellContextHandle->line);
   \                     ??SHELL_Task_13: (+1)
   \      0x276   0xF104 0x0124      ADD      R1,R4,#+36
   \      0x27A   0x4620             MOV      R0,R4
   \      0x27C   0x....'....        BL       SHELL_ProcessCommand
    449                                  /* Reset all params */
    450                                  shellContextHandle->c_pos = shellContextHandle->l_pos = 0;
   \      0x280   0x2000             MOVS     R0,#+0
   \      0x282   0xF884 0x016E      STRB     R0,[R4, #+366]
   \      0x286   0xF884 0x016F      STRB     R0,[R4, #+367]
    451                                  shellContextHandle->hist_current                      = 0;
   \      0x28A   0xF8A4 0x0168      STRH     R0,[R4, #+360]
    452                                  (void)SHELL_Write(shellContextHandle, shellContextHandle->prompt,
    453                                                    strlen(shellContextHandle->prompt));
   \      0x28E   0x6A20             LDR      R0,[R4, #+32]
   \      0x290   0x....'....        BL       strlen
   \      0x294   0x4602             MOV      R2,R0
   \      0x296   0x6A21             LDR      R1,[R4, #+32]
   \      0x298   0x4620             MOV      R0,R4
   \      0x29A   0x....'....        BL       SHELL_Write
    454                                  memset(shellContextHandle->line, 0, sizeof(shellContextHandle->line));
   \      0x29E   0x2200             MOVS     R2,#+0
   \      0x2A0   0x2140             MOVS     R1,#+64
   \      0x2A2   0xF104 0x0024      ADD      R0,R4,#+36
   \      0x2A6   0x....'....        BL       __aeabi_memset
    455                                  continue;
   \      0x2AA   0xE04E             B.N      ??SHELL_Task_4
    456                              }
    457                          }
    458          
    459                          /* Normal character */
    460                          if (shellContextHandle->c_pos < shellContextHandle->l_pos)
   \                     ??SHELL_Task_11: (+1)
   \      0x2AC   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x2B0   0xF894 0x116E      LDRB     R1,[R4, #+366]
   \      0x2B4   0x4288             CMP      R0,R1
   \      0x2B6   0xD22D             BCS.N    ??SHELL_Task_25
    461                          {
    462                              (void)memmove(&shellContextHandle->line[shellContextHandle->c_pos + 1U],
    463                                            &shellContextHandle->line[shellContextHandle->c_pos],
    464                                            shellContextHandle->l_pos - shellContextHandle->c_pos);
   \      0x2B8   0x460A             MOV      R2,R1
   \      0x2BA   0x1A12             SUBS     R2,R2,R0
   \      0x2BC   0x4420             ADD      R0,R4,R0
   \      0x2BE   0xF100 0x0124      ADD      R1,R0,#+36
   \      0x2C2   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x2C6   0x4420             ADD      R0,R4,R0
   \      0x2C8   0x3025             ADDS     R0,R0,#+37
   \      0x2CA   0x....'....        BL       __aeabi_memmove
    465                              shellContextHandle->line[shellContextHandle->c_pos] = (char)ch;
   \      0x2CE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x2D2   0xF894 0x116F      LDRB     R1,[R4, #+367]
   \      0x2D6   0x4421             ADD      R1,R4,R1
   \      0x2D8   0xF881 0x0024      STRB     R0,[R1, #+36]
    466                              (void)SHELL_Write(shellContextHandle, &shellContextHandle->line[shellContextHandle->c_pos],
    467                                                strlen(&shellContextHandle->line[shellContextHandle->c_pos]));
   \      0x2DC   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x2E0   0x4420             ADD      R0,R4,R0
   \      0x2E2   0x3024             ADDS     R0,R0,#+36
   \      0x2E4   0x....'....        BL       strlen
   \      0x2E8   0x4602             MOV      R2,R0
   \      0x2EA   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x2EE   0x4420             ADD      R0,R4,R0
   \      0x2F0   0xF100 0x0124      ADD      R1,R0,#+36
   \      0x2F4   0x4620             MOV      R0,R4
   \      0x2F6   0x....'....        BL       SHELL_Write
    468                              /* Move the cursor to new position */
    469                              int i;
    470                              for (i = shellContextHandle->c_pos; i < shellContextHandle->l_pos; i++)
   \      0x2FA   0xF894 0x516F      LDRB     R5,[R4, #+367]
   \                     ??SHELL_Task_26: (+1)
   \      0x2FE   0xF894 0x016E      LDRB     R0,[R4, #+366]
   \      0x302   0x4285             CMP      R5,R0
   \      0x304   0xDA14             BGE.N    ??SHELL_Task_27
    471                              {
    472                                  (void)SHELL_Write(shellContextHandle, "\b", 1);
   \      0x306   0x2201             MOVS     R2,#+1
   \      0x308   0x....             ADR.N    R1,??DataTable3_1  ;; "\b"
   \      0x30A   0x4620             MOV      R0,R4
   \      0x30C   0x....'....        BL       SHELL_Write
    473                              }
   \      0x310   0x1C6D             ADDS     R5,R5,#+1
   \      0x312   0xE7F4             B.N      ??SHELL_Task_26
    474                          }
    475                          else
    476                          {
    477                              shellContextHandle->line[shellContextHandle->l_pos] = (char)ch;
   \                     ??SHELL_Task_25: (+1)
   \      0x314   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x318   0x4421             ADD      R1,R4,R1
   \      0x31A   0xF881 0x0024      STRB     R0,[R1, #+36]
    478                              (void)SHELL_Write(shellContextHandle, &shellContextHandle->line[shellContextHandle->l_pos], 1);
   \      0x31E   0x2201             MOVS     R2,#+1
   \      0x320   0xF894 0x016E      LDRB     R0,[R4, #+366]
   \      0x324   0x4420             ADD      R0,R4,R0
   \      0x326   0xF100 0x0124      ADD      R1,R0,#+36
   \      0x32A   0x4620             MOV      R0,R4
   \      0x32C   0x....'....        BL       SHELL_Write
    479                          }
    480          
    481                          ch = 0;
   \                     ??SHELL_Task_27: (+1)
   \      0x330   0x2000             MOVS     R0,#+0
   \      0x332   0xF88D 0x0000      STRB     R0,[SP, #+0]
    482                          shellContextHandle->l_pos++;
   \      0x336   0xF894 0x016E      LDRB     R0,[R4, #+366]
   \      0x33A   0x1C40             ADDS     R0,R0,#+1
   \      0x33C   0xF884 0x016E      STRB     R0,[R4, #+366]
    483                          shellContextHandle->c_pos++;
   \      0x340   0xF894 0x016F      LDRB     R0,[R4, #+367]
   \      0x344   0x1C40             ADDS     R0,R0,#+1
   \      0x346   0xF884 0x016F      STRB     R0,[R4, #+367]
    484                      } while (!shellContextHandle->exit);
   \                     ??SHELL_Task_4: (+1)
   \      0x34A   0xF894 0x0171      LDRB     R0,[R4, #+369]
   \      0x34E   0x2800             CMP      R0,#+0
   \      0x350   0xF43F 0xAE5D      BEQ.W    ??SHELL_Task_1
    485                  }
    486          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    487          
    488          #if defined(OSA_USED)
    489          
    490          #if (defined(SHELL_USE_COMMON_TASK) && (SHELL_USE_COMMON_TASK > 0U))
    491          #else
    492                      }
    493                  } while (gUseRtos_c);
    494          #endif
    495          
    496          #endif
    497          
    498          #endif
    499              }
    500          }
   \                     ??SHELL_Task_0: (+1)
   \      0x354   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .bss, align 1
   \                     `SHELL_Task{2}{3}{4}{5}{6}{39}{40}::endoflinechar`:
   \        0x0                      DS8 1
    501          

   \                                 In section .text, align 2, keep-with-next
    502          static shell_status_t SHELL_HelpCommand(shell_handle_t shellHandle, int32_t argc, char **argv)
    503          {
   \                     SHELL_HelpCommand: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
    504              shell_context_handle_t *shellContextHandle = (shell_context_handle_t *)shellHandle;
    505              shell_command_t *shellCommandContextHandle;
    506              list_element_handle_t p = LIST_GetHead(&shellContextHandle->commandContextListHead);
   \        0x4   0x....'....        BL       LIST_GetHead
   \        0x8   0x0004             MOVS     R4,R0
   \        0xA   0xE014             B.N      ??SHELL_HelpCommand_0
    507          
    508              while (p != NULL)
    509              {
    510                  shellCommandContextHandle = SHEEL_COMMAND_POINTER(p);
   \                     ??SHELL_HelpCommand_1: (+1)
   \        0xC   0xF1A4 0x0610      SUB      R6,R4,#+16
    511                  if ((shellCommandContextHandle->pcHelpString != NULL) && (bool)strlen(shellCommandContextHandle->pcHelpString))
   \       0x10   0x6870             LDR      R0,[R6, #+4]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD00B             BEQ.N    ??SHELL_HelpCommand_2
   \       0x16   0x....'....        BL       strlen
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD007             BEQ.N    ??SHELL_HelpCommand_2
    512                  {
    513                      (void)SHELL_Write(shellContextHandle, shellCommandContextHandle->pcHelpString,
    514                                        strlen(shellCommandContextHandle->pcHelpString));
   \       0x1E   0x6870             LDR      R0,[R6, #+4]
   \       0x20   0x....'....        BL       strlen
   \       0x24   0x4602             MOV      R2,R0
   \       0x26   0x6871             LDR      R1,[R6, #+4]
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       SHELL_Write
    515                  }
    516          
    517                  p = LIST_GetNext(p);
   \                     ??SHELL_HelpCommand_2: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       LIST_GetNext
   \       0x34   0x0004             MOVS     R4,R0
    518              }
   \                     ??SHELL_HelpCommand_0: (+1)
   \       0x36   0xD1E9             BNE.N    ??SHELL_HelpCommand_1
    519              return kStatus_SHELL_Success;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return
    520          }
    521          

   \                                 In section .text, align 2, keep-with-next
    522          static shell_status_t SHELL_ExitCommand(shell_handle_t shellHandle, int32_t argc, char **argv)
    523          {
   \                     SHELL_ExitCommand: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    524              shell_context_handle_t *shellContextHandle = (shell_context_handle_t *)shellHandle;
    525              /* Skip warning */
    526              (void)SHELL_Write(shellContextHandle, "\r\nSHELL exited\r\n", strlen("\r\nSHELL exited\r\n"));
   \        0x4   0x2210             MOVS     R2,#+16
   \        0x6   0x....'....        LDR.W    R1,??DataTable12_2
   \        0xA   0x....'....        BL       SHELL_Write
    527              shellContextHandle->exit = (uint8_t) true;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF884 0x0171      STRB     R0,[R4, #+369]
    528              return kStatus_SHELL_Success;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD10             POP      {R4,PC}          ;; return
    529          }
    530          

   \                                 In section .text, align 2, keep-with-next
    531          static void SHELL_ProcessCommand(shell_context_handle_t *shellContextHandle, const char *cmd)
    532          {
   \                     SHELL_ProcessCommand: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB0C0             SUB      SP,SP,#+256
   \        0x6   0x4607             MOV      R7,R0
   \        0x8   0x460E             MOV      R6,R1
    533              shell_command_t *tmpCommand = NULL;
   \        0xA   0x2500             MOVS     R5,#+0
    534              const char *tmpCommandString;
    535              int32_t argc;
    536              char *argv[SHELL_BUFFER_SIZE];
    537              list_element_handle_t p;
    538              uint8_t flag = 1;
   \        0xC   0xF04F 0x0901      MOV      R9,#+1
    539              uint8_t tmpCommandLen;
    540              uint8_t tmpLen;
    541              uint8_t i = 0;
    542          
    543              tmpLen = (uint8_t)strlen(cmd);
   \       0x10   0x4630             MOV      R0,R6
   \       0x12   0x....'....        BL       strlen
    544              argc   = SHELL_ParseLine(cmd, tmpLen, argv);
   \       0x16   0x466A             MOV      R2,SP
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x4601             MOV      R1,R0
   \       0x1C   0x4630             MOV      R0,R6
   \       0x1E   0x....'....        BL       SHELL_ParseLine
   \       0x22   0x4680             MOV      R8,R0
    545          
    546              if ((argc > 0))
   \       0x24   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x28   0xDB38             BLT.N    ??SHELL_ProcessCommand_0
    547              {
    548                  p = LIST_GetHead(&shellContextHandle->commandContextListHead);
   \       0x2A   0x4638             MOV      R0,R7
   \       0x2C   0x....'....        BL       LIST_GetHead
   \       0x30   0x4604             MOV      R4,R0
   \       0x32   0xE003             B.N      ??SHELL_ProcessCommand_1
    549                  while (p != NULL)
    550                  {
    551                      tmpCommand       = SHEEL_COMMAND_POINTER(p);
    552                      tmpCommandString = tmpCommand->pcCommand;
    553                      tmpCommandLen    = (uint8_t)strlen(tmpCommandString);
    554                      /* Compare with space or end of string */
    555                      if ((cmd[tmpCommandLen] == ' ') || (cmd[tmpCommandLen] == (char)0x00))
    556                      {
    557                          if (SHELL_StringCompare(tmpCommandString, argv[0], (uint32_t)tmpCommandLen) == 0)
    558                          {
    559                              /* support commands with optional number of parameters */
    560                              if (tmpCommand->cExpectedNumberOfParameters == (uint8_t)SHELL_IGNORE_PARAMETER_COUNT)
    561                              {
    562                                  flag = 0;
    563                              }
    564                              else if ((tmpCommand->cExpectedNumberOfParameters == 0U) && (argc == 1))
    565                              {
    566                                  flag = 0;
    567                              }
    568                              else if (tmpCommand->cExpectedNumberOfParameters > 0U)
    569                              {
    570                                  if ((argc - 1U) == tmpCommand->cExpectedNumberOfParameters)
    571                                  {
    572                                      flag = 0;
    573                                  }
    574                              }
    575                              else
    576                              {
    577                                  flag = 1;
    578                              }
    579                              break;
    580                          }
    581                      }
    582                      p = LIST_GetNext(p);
   \                     ??SHELL_ProcessCommand_2: (+1)
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       LIST_GetNext
   \       0x3A   0x4604             MOV      R4,R0
   \                     ??SHELL_ProcessCommand_1: (+1)
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD02A             BEQ.N    ??SHELL_ProcessCommand_3
   \       0x40   0xF1A4 0x0510      SUB      R5,R4,#+16
   \       0x44   0xF8D5 0xA000      LDR      R10,[R5, #+0]
   \       0x48   0x4650             MOV      R0,R10
   \       0x4A   0x....'....        BL       strlen
   \       0x4E   0xB2C0             UXTB     R0,R0
   \       0x50   0x5C31             LDRB     R1,[R6, R0]
   \       0x52   0x2920             CMP      R1,#+32
   \       0x54   0xD001             BEQ.N    ??SHELL_ProcessCommand_4
   \       0x56   0x2900             CMP      R1,#+0
   \       0x58   0xD1EC             BNE.N    ??SHELL_ProcessCommand_2
   \                     ??SHELL_ProcessCommand_4: (+1)
   \       0x5A   0x4602             MOV      R2,R0
   \       0x5C   0x9900             LDR      R1,[SP, #+0]
   \       0x5E   0x4650             MOV      R0,R10
   \       0x60   0x....'....        BL       SHELL_StringCompare
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD1E5             BNE.N    ??SHELL_ProcessCommand_2
   \       0x68   0x7B28             LDRB     R0,[R5, #+12]
   \       0x6A   0x28FF             CMP      R0,#+255
   \       0x6C   0xD102             BNE.N    ??SHELL_ProcessCommand_5
   \       0x6E   0xF04F 0x0900      MOV      R9,#+0
   \       0x72   0xE010             B.N      ??SHELL_ProcessCommand_3
   \                     ??SHELL_ProcessCommand_5: (+1)
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD105             BNE.N    ??SHELL_ProcessCommand_6
   \       0x78   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x7C   0xD102             BNE.N    ??SHELL_ProcessCommand_6
   \       0x7E   0xF04F 0x0900      MOV      R9,#+0
   \       0x82   0xE008             B.N      ??SHELL_ProcessCommand_3
   \                     ??SHELL_ProcessCommand_6: (+1)
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD006             BEQ.N    ??SHELL_ProcessCommand_3
   \       0x88   0xF1A8 0x0001      SUB      R0,R8,#+1
   \       0x8C   0x7B29             LDRB     R1,[R5, #+12]
   \       0x8E   0x4288             CMP      R0,R1
   \       0x90   0xD101             BNE.N    ??SHELL_ProcessCommand_3
   \       0x92   0xF04F 0x0900      MOV      R9,#+0
    583                  }
    584                  if (NULL == p)
   \                     ??SHELL_ProcessCommand_3: (+1)
   \       0x96   0x2C00             CMP      R4,#+0
   \       0x98   0xD100             BNE.N    ??SHELL_ProcessCommand_0
    585                  {
    586                      tmpCommand = NULL;
   \       0x9A   0x2500             MOVS     R5,#+0
    587                  }
    588              }
    589          
    590              if ((tmpCommand != NULL) && (flag == 1U))
   \                     ??SHELL_ProcessCommand_0: (+1)
   \       0x9C   0x2D00             CMP      R5,#+0
   \       0x9E   0xD009             BEQ.N    ??SHELL_ProcessCommand_7
   \       0xA0   0xF1B9 0x0F01      CMP      R9,#+1
   \       0xA4   0xD106             BNE.N    ??SHELL_ProcessCommand_7
    591              {
    592                  (void)SHELL_Write(
    593                      shellContextHandle,
    594                      "\r\nIncorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n",
    595                      strlen(
    596                          "\r\nIncorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n"));
   \       0xA6   0x2259             MOVS     R2,#+89
   \       0xA8   0x....'....        LDR.W    R1,??DataTable12_3
   \       0xAC   0x4638             MOV      R0,R7
   \       0xAE   0x....'....        BL       SHELL_Write
    597                  tmpCommand = NULL;
   \       0xB2   0xE052             B.N      ??SHELL_ProcessCommand_8
    598              }
    599              else if (tmpCommand != NULL)
   \                     ??SHELL_ProcessCommand_7: (+1)
   \       0xB4   0x2D00             CMP      R5,#+0
   \       0xB6   0xD04A             BEQ.N    ??SHELL_ProcessCommand_9
    600              {
    601                  tmpLen = (uint8_t)strlen(cmd);
   \       0xB8   0x4630             MOV      R0,R6
   \       0xBA   0x....'....        BL       strlen
   \       0xBE   0x4604             MOV      R4,R0
    602                  /* Compare with last command. Push back to history buffer if different */
    603                  if (tmpLen != (uint8_t)SHELL_StringCompare(cmd, shellContextHandle->hist_buf[0], (int32_t)strlen(cmd)))
   \       0xC0   0x4630             MOV      R0,R6
   \       0xC2   0x....'....        BL       strlen
   \       0xC6   0x4602             MOV      R2,R0
   \       0xC8   0xF107 0x0164      ADD      R1,R7,#+100
   \       0xCC   0x4630             MOV      R0,R6
   \       0xCE   0x....'....        BL       SHELL_StringCompare
   \       0xD2   0xB2E4             UXTB     R4,R4
   \       0xD4   0xB2C0             UXTB     R0,R0
   \       0xD6   0x4284             CMP      R4,R0
   \       0xD8   0xD033             BEQ.N    ??SHELL_ProcessCommand_10
    604                  {
    605                      for (i = SHELL_HISTORY_COUNT - 1U; i > 0U; i--)
   \       0xDA   0x2402             MOVS     R4,#+2
   \       0xDC   0xE018             B.N      ??SHELL_ProcessCommand_11
    606                      {
    607                          (void)memset(shellContextHandle->hist_buf[i], '\0', SHELL_BUFFER_SIZE);
   \                     ??SHELL_ProcessCommand_12: (+1)
   \       0xDE   0x2200             MOVS     R2,#+0
   \       0xE0   0x2140             MOVS     R1,#+64
   \       0xE2   0xEB07 0x1084      ADD      R0,R7,R4, LSL #+6
   \       0xE6   0x3064             ADDS     R0,R0,#+100
   \       0xE8   0x....'....        BL       __aeabi_memset
    608                          tmpLen = (uint8_t)strlen(shellContextHandle->hist_buf[i - 1U]);
   \       0xEC   0xEB07 0x1084      ADD      R0,R7,R4, LSL #+6
   \       0xF0   0x3024             ADDS     R0,R0,#+36
   \       0xF2   0x....'....        BL       strlen
   \       0xF6   0x4602             MOV      R2,R0
    609                          (void)memcpy(shellContextHandle->hist_buf[i], shellContextHandle->hist_buf[i - 1U], tmpLen);
   \       0xF8   0xB2D2             UXTB     R2,R2
   \       0xFA   0xEB07 0x1084      ADD      R0,R7,R4, LSL #+6
   \       0xFE   0xF100 0x0124      ADD      R1,R0,#+36
   \      0x102   0xEB07 0x1084      ADD      R0,R7,R4, LSL #+6
   \      0x106   0x3064             ADDS     R0,R0,#+100
   \      0x108   0x....'....        BL       __aeabi_memcpy
    610                      }
   \      0x10C   0x1E64             SUBS     R4,R4,#+1
   \      0x10E   0xB2E4             UXTB     R4,R4
   \                     ??SHELL_ProcessCommand_11: (+1)
   \      0x110   0x2C00             CMP      R4,#+0
   \      0x112   0xD1E4             BNE.N    ??SHELL_ProcessCommand_12
    611                      (void)memset(shellContextHandle->hist_buf[0], '\0', SHELL_BUFFER_SIZE);
   \      0x114   0x2200             MOVS     R2,#+0
   \      0x116   0x2140             MOVS     R1,#+64
   \      0x118   0xF107 0x0064      ADD      R0,R7,#+100
   \      0x11C   0x....'....        BL       __aeabi_memset4
    612                      tmpLen = (uint8_t)strlen(cmd);
   \      0x120   0x4630             MOV      R0,R6
   \      0x122   0x....'....        BL       strlen
    613                      (void)memcpy(shellContextHandle->hist_buf[0], cmd, tmpLen);
   \      0x126   0xB2C0             UXTB     R0,R0
   \      0x128   0x4602             MOV      R2,R0
   \      0x12A   0x4631             MOV      R1,R6
   \      0x12C   0xF107 0x0064      ADD      R0,R7,#+100
   \      0x130   0x....'....        BL       __aeabi_memcpy
    614                      if (shellContextHandle->hist_count < SHELL_HISTORY_COUNT)
   \      0x134   0xF8B7 0x016A      LDRH     R0,[R7, #+362]
   \      0x138   0x2803             CMP      R0,#+3
   \      0x13A   0xD202             BCS.N    ??SHELL_ProcessCommand_10
    615                      {
    616                          shellContextHandle->hist_count++;
   \      0x13C   0x1C40             ADDS     R0,R0,#+1
   \      0x13E   0xF8A7 0x016A      STRH     R0,[R7, #+362]
    617                      }
    618                  }
    619                  tmpCommand->pFuncCallBack(shellContextHandle, argc, argv);
   \                     ??SHELL_ProcessCommand_10: (+1)
   \      0x142   0x466A             MOV      R2,SP
   \      0x144   0x4641             MOV      R1,R8
   \      0x146   0x4638             MOV      R0,R7
   \      0x148   0x68AB             LDR      R3,[R5, #+8]
   \      0x14A   0x4798             BLX      R3
    620                  tmpCommand = NULL;
   \      0x14C   0xE005             B.N      ??SHELL_ProcessCommand_8
    621              }
    622              else
    623              {
    624                  (void)SHELL_Write(
    625                      shellContextHandle,
    626                      "\r\nCommand not recognized.  Enter 'help' to view a list of available commands.\r\n\r\n",
    627                      strlen("\r\nCommand not recognized.  Enter 'help' to view a list of available commands.\r\n\r\n"));
   \                     ??SHELL_ProcessCommand_9: (+1)
   \      0x14E   0x2251             MOVS     R2,#+81
   \      0x150   0x....'....        LDR.W    R1,??DataTable12_4
   \      0x154   0x4638             MOV      R0,R7
   \      0x156   0x....'....        BL       SHELL_Write
    628                  tmpCommand = NULL;
    629              }
    630          }
   \                     ??SHELL_ProcessCommand_8: (+1)
   \      0x15A   0xB040             ADD      SP,SP,#+256
   \      0x15C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    631          

   \                                 In section .text, align 2, keep-with-next
    632          static void SHELL_GetHistoryCommand(shell_context_handle_t *shellContextHandle, uint8_t hist_pos)
    633          {
   \                     SHELL_GetHistoryCommand: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    634              uint8_t i;
    635              uint32_t tmp;
    636          
    637              if (shellContextHandle->hist_buf[0][0] == '\0')
   \        0x6   0xF895 0x0064      LDRB     R0,[R5, #+100]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD103             BNE.N    ??SHELL_GetHistoryCommand_0
    638              {
    639                  shellContextHandle->hist_current = 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xF8A5 0x0168      STRH     R0,[R5, #+360]
    640                  return;
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}
    641              }
    642          
    643          #if 0 /*hist_pos is passed from hist_current. And hist_current is only changed in case 'A'/'B',as hist_count is 3 \
    644                   most, it can't be more than 3  */
    645              if (hist_pos >= SHELL_HISTORY_COUNT)
    646              {
    647                  hist_pos = SHELL_HISTORY_COUNT - 1U;
    648              }
    649          #endif
    650          
    651              tmp = strlen(shellContextHandle->line);
   \                     ??SHELL_GetHistoryCommand_0: (+1)
   \       0x16   0xF105 0x0024      ADD      R0,R5,#+36
   \       0x1A   0x....'....        BL       strlen
   \       0x1E   0x0004             MOVS     R4,R0
    652              /* Clear current if have */
    653              if (tmp > 0U)
   \       0x20   0xD011             BEQ.N    ??SHELL_GetHistoryCommand_1
    654              {
    655                  (void)memset(shellContextHandle->line, '\0', tmp);
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x4621             MOV      R1,R4
   \       0x26   0xF105 0x0024      ADD      R0,R5,#+36
   \       0x2A   0x....'....        BL       __aeabi_memset4
    656                  for (i = 0; i < tmp; i++)
   \       0x2E   0x2700             MOVS     R7,#+0
   \       0x30   0xE005             B.N      ??SHELL_GetHistoryCommand_2
    657                  {
    658                      (void)SHELL_Write(shellContextHandle, "\b \b", 3);
   \                     ??SHELL_GetHistoryCommand_3: (+1)
   \       0x32   0x2203             MOVS     R2,#+3
   \       0x34   0x....             ADR.N    R1,??DataTable10  ;; "\b \b"
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x....'....        BL       SHELL_Write
    659                  }
   \       0x3C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??SHELL_GetHistoryCommand_2: (+1)
   \       0x3E   0x4638             MOV      R0,R7
   \       0x40   0xB2C0             UXTB     R0,R0
   \       0x42   0x42A0             CMP      R0,R4
   \       0x44   0xD3F5             BCC.N    ??SHELL_GetHistoryCommand_3
    660              }
    661          
    662              shellContextHandle->l_pos = (uint8_t)strlen(shellContextHandle->hist_buf[hist_pos]);
   \                     ??SHELL_GetHistoryCommand_1: (+1)
   \       0x46   0x4630             MOV      R0,R6
   \       0x48   0xEB05 0x1080      ADD      R0,R5,R0, LSL #+6
   \       0x4C   0x3064             ADDS     R0,R0,#+100
   \       0x4E   0x....'....        BL       strlen
   \       0x52   0xF885 0x016E      STRB     R0,[R5, #+366]
    663              shellContextHandle->c_pos = shellContextHandle->l_pos;
   \       0x56   0xF895 0x016E      LDRB     R0,[R5, #+366]
   \       0x5A   0xF885 0x016F      STRB     R0,[R5, #+367]
    664              (void)memcpy(shellContextHandle->line, shellContextHandle->hist_buf[hist_pos], shellContextHandle->l_pos);
   \       0x5E   0xF895 0x216E      LDRB     R2,[R5, #+366]
   \       0x62   0x4630             MOV      R0,R6
   \       0x64   0xEB05 0x1080      ADD      R0,R5,R0, LSL #+6
   \       0x68   0xF100 0x0164      ADD      R1,R0,#+100
   \       0x6C   0xF105 0x0024      ADD      R0,R5,#+36
   \       0x70   0x....'....        BL       __aeabi_memcpy
    665              (void)SHELL_Write(shellContextHandle, shellContextHandle->hist_buf[hist_pos],
    666                                strlen(shellContextHandle->hist_buf[hist_pos]));
   \       0x74   0x4630             MOV      R0,R6
   \       0x76   0xEB05 0x1080      ADD      R0,R5,R0, LSL #+6
   \       0x7A   0x3064             ADDS     R0,R0,#+100
   \       0x7C   0x....'....        BL       strlen
   \       0x80   0x4602             MOV      R2,R0
   \       0x82   0xEB15 0x1086      ADDS     R0,R5,R6, LSL #+6
   \       0x86   0xF100 0x0164      ADD      R1,R0,#+100
   \       0x8A   0x4628             MOV      R0,R5
   \       0x8C   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \       0x90   0x....             B.N      SHELL_Write
    667          }
    668          

   \                                 In section .text, align 2, keep-with-next
    669          static void SHELL_AutoComplete(shell_context_handle_t *shellContextHandle)
    670          {
   \                     SHELL_AutoComplete: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
    671              int32_t minLen;
    672              list_element_handle_t p;
    673              shell_command_t *tmpCommand = NULL;
    674              const char *namePtr;
    675              const char *cmdName;
    676          
    677              minLen  = SHELL_BUFFER_SIZE;
   \        0x6   0x2740             MOVS     R7,#+64
    678              namePtr = NULL;
   \        0x8   0x2500             MOVS     R5,#+0
    679          
    680              /* Empty tab, list all commands */
    681              if (shellContextHandle->line[0] == '\0')
   \        0xA   0xF896 0x0024      LDRB     R0,[R6, #+36]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD105             BNE.N    ??SHELL_AutoComplete_0
    682              {
    683                  (void)SHELL_HelpCommand(shellContextHandle, 0, NULL);
   \       0x12   0x462A             MOV      R2,R5
   \       0x14   0x4611             MOV      R1,R2
   \       0x16   0x4630             MOV      R0,R6
   \       0x18   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x1C   0x....             B.N      SHELL_HelpCommand
    684                  return;
    685              }
    686          
    687              SHELL_Write(shellContextHandle, "\r\n", 2);
   \                     ??SHELL_AutoComplete_0: (+1)
   \       0x1E   0x2202             MOVS     R2,#+2
   \       0x20   0x....             ADR.N    R1,??DataTable10_1  ;; 0x0D, 0x0A, 0x00, 0x00
   \       0x22   0x4630             MOV      R0,R6
   \       0x24   0x....'....        BL       SHELL_Write
    688          
    689              /* Do auto complete */
    690              p = LIST_GetHead(&shellContextHandle->commandContextListHead);
   \       0x28   0x4630             MOV      R0,R6
   \       0x2A   0x....'....        BL       LIST_GetHead
   \       0x2E   0x0004             MOVS     R4,R0
   \       0x30   0xE023             B.N      ??SHELL_AutoComplete_1
    691              while (p != NULL)
    692              {
    693                  tmpCommand = SHEEL_COMMAND_POINTER(p);
    694                  cmdName    = tmpCommand->pcCommand;
   \                     ??SHELL_AutoComplete_2: (+1)
   \       0x32   0xF1A4 0x0010      SUB      R0,R4,#+16
   \       0x36   0xF8D0 0x8000      LDR      R8,[R0, #+0]
    695                  if (SHELL_StringCompare(shellContextHandle->line, cmdName, (int32_t)strlen(shellContextHandle->line)) == 0)
   \       0x3A   0xF106 0x0024      ADD      R0,R6,#+36
   \       0x3E   0x....'....        BL       strlen
   \       0x42   0x4602             MOV      R2,R0
   \       0x44   0x4641             MOV      R1,R8
   \       0x46   0xF106 0x0024      ADD      R0,R6,#+36
   \       0x4A   0x....'....        BL       SHELL_StringCompare
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD10F             BNE.N    ??SHELL_AutoComplete_3
    696                  {
    697                      /* Show possible matches */
    698                      SHELL_Printf(shellContextHandle, "%s\r\n", (char *)cmdName);
   \       0x52   0x4642             MOV      R2,R8
   \       0x54   0x....'....        LDR.W    R1,??DataTable12_5
   \       0x58   0x4630             MOV      R0,R6
   \       0x5A   0x....'....        BL       SHELL_Printf
    699                      if (minLen > strlen(cmdName))
   \       0x5E   0x4640             MOV      R0,R8
   \       0x60   0x....'....        BL       strlen
   \       0x64   0x42B8             CMP      R0,R7
   \       0x66   0xD204             BCS.N    ??SHELL_AutoComplete_3
    700                      {
    701                          namePtr = cmdName;
   \       0x68   0x4645             MOV      R5,R8
    702                          minLen  = (int32_t)strlen(namePtr);
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x....'....        BL       strlen
   \       0x70   0x4607             MOV      R7,R0
    703                      }
    704                  }
    705                  p = LIST_GetNext(p);
   \                     ??SHELL_AutoComplete_3: (+1)
   \       0x72   0x4620             MOV      R0,R4
   \       0x74   0x....'....        BL       LIST_GetNext
   \       0x78   0x0004             MOVS     R4,R0
    706              }
   \                     ??SHELL_AutoComplete_1: (+1)
   \       0x7A   0xD1DA             BNE.N    ??SHELL_AutoComplete_2
    707              /* Auto complete string */
    708              if (namePtr != NULL)
   \       0x7C   0x2D00             CMP      R5,#+0
   \       0x7E   0xD005             BEQ.N    ??SHELL_AutoComplete_4
    709              {
    710                  (void)memcpy(shellContextHandle->line, namePtr, (uint32_t)minLen);
   \       0x80   0x463A             MOV      R2,R7
   \       0x82   0x4629             MOV      R1,R5
   \       0x84   0xF106 0x0024      ADD      R0,R6,#+36
   \       0x88   0x....'....        BL       __aeabi_memcpy
    711              }
    712              (void)SHELL_Write(shellContextHandle, shellContextHandle->prompt, strlen(shellContextHandle->prompt));
   \                     ??SHELL_AutoComplete_4: (+1)
   \       0x8C   0x6A30             LDR      R0,[R6, #+32]
   \       0x8E   0x....'....        BL       strlen
   \       0x92   0x4602             MOV      R2,R0
   \       0x94   0x6A31             LDR      R1,[R6, #+32]
   \       0x96   0x4630             MOV      R0,R6
   \       0x98   0x....'....        BL       SHELL_Write
    713              (void)SHELL_Write(shellContextHandle, shellContextHandle->line, strlen(shellContextHandle->line));
   \       0x9C   0xF106 0x0024      ADD      R0,R6,#+36
   \       0xA0   0x....'....        BL       strlen
   \       0xA4   0x4602             MOV      R2,R0
   \       0xA6   0xF106 0x0124      ADD      R1,R6,#+36
   \       0xAA   0x4630             MOV      R0,R6
   \       0xAC   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xB0   0x....             B.N      SHELL_Write
    714              return;
    715          }
    716          

   \                                 In section .text, align 2, keep-with-next
    717          static int32_t SHELL_StringCompare(const char *str1, const char *str2, int32_t count)
    718          {
   \                     SHELL_StringCompare: (+1)
   \        0x0   0xB410             PUSH     {R4}
    719              while ((bool)(count--))
   \                     ??SHELL_StringCompare_0: (+1)
   \        0x2   0x4613             MOV      R3,R2
   \        0x4   0x1E5A             SUBS     R2,R3,#+1
   \        0x6   0x2B00             CMP      R3,#+0
   \        0x8   0xD009             BEQ.N    ??SHELL_StringCompare_1
    720              {
    721                  if (*str1++ != *str2++)
   \        0xA   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \        0xE   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \       0x12   0x42A3             CMP      R3,R4
   \       0x14   0xD0F5             BEQ.N    ??SHELL_StringCompare_0
    722                  {
    723                      return (int32_t) * (unsigned char *)(str1 - 1) - *(unsigned char *)(str2 - 1);
   \       0x16   0x4618             MOV      R0,R3
   \       0x18   0x4621             MOV      R1,R4
   \       0x1A   0x1A40             SUBS     R0,R0,R1
   \       0x1C   0xE000             B.N      ??SHELL_StringCompare_2
    724                  }
    725              }
    726              return 0;
   \                     ??SHELL_StringCompare_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??SHELL_StringCompare_2: (+1)
   \       0x20   0xBC10             POP      {R4}
   \       0x22   0x4770             BX       LR               ;; return
    727          }
    728          

   \                                 In section .text, align 2, keep-with-next
    729          static int32_t SHELL_ParseLine(const char *cmd, uint32_t len, char *argv[])
    730          {
   \                     SHELL_ParseLine: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4614             MOV      R4,R2
    731              uint32_t argc;
    732              char *p;
    733              uint32_t position;
    734          
    735              /* Init params */
    736              (void)memset(s_paramBuffer, '\0', len + 1U);
   \        0x8   0x....             LDR.N    R6,??DataTable12_6
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x1C69             ADDS     R1,R5,#+1
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0x....'....        BL       __aeabi_memset4
    737              (void)memcpy(s_paramBuffer, cmd, len);
   \       0x14   0x462A             MOV      R2,R5
   \       0x16   0x4639             MOV      R1,R7
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0x....'....        BL       __aeabi_memcpy
    738          
    739              p        = s_paramBuffer;
    740              position = 0;
   \       0x1E   0x2100             MOVS     R1,#+0
    741              argc     = 0;
   \       0x20   0x4608             MOV      R0,R1
   \       0x22   0xE017             B.N      ??SHELL_ParseLine_0
    742          
    743              while (position < len)
    744              {
    745                  /* Skip all blanks */
    746                  while ((position < len) && ((char)(*p) == ' '))
    747                  {
    748                      *p = '\0';
    749                      p++;
    750                      position++;
    751                  }
    752          
    753                  if (position >= len)
    754                  {
    755                      break;
    756                  }
    757          
    758                  /* Process begin of a string */
    759                  if (*p == '"')
    760                  {
    761                      p++;
    762                      position++;
    763                      argv[argc] = p;
    764                      argc++;
    765                      /* Skip this string */
    766                      while ((*p != '"') && (position < len))
    767                      {
    768                          p++;
    769                          position++;
    770                      }
    771                      /* Skip '"' */
    772                      *p = '\0';
    773                      p++;
    774                      position++;
    775                  }
    776                  else /* Normal char */
    777                  {
    778                      argv[argc] = p;
    779                      argc++;
    780                      while (((char)*p != ' ') && (position < len))
    781                      {
    782                          p++;
    783                          position++;
    784                      }
    785                  }
    786              }
    787              return (int32_t)argc;
   \                     ??SHELL_ParseLine_1: (+1)
   \       0x24   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??SHELL_ParseLine_2: (+1)
   \       0x26   0x7832             LDRB     R2,[R6, #+0]
   \       0x28   0x2A20             CMP      R2,#+32
   \       0x2A   0xD117             BNE.N    ??SHELL_ParseLine_3
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0xF806 0x2B01      STRB     R2,[R6], #+1
   \       0x32   0x1C49             ADDS     R1,R1,#+1
   \       0x34   0xE010             B.N      ??SHELL_ParseLine_4
   \                     ??SHELL_ParseLine_5: (+1)
   \       0x36   0xF844 0x6020      STR      R6,[R4, R0, LSL #+2]
   \       0x3A   0x1C40             ADDS     R0,R0,#+1
   \                     ??SHELL_ParseLine_6: (+1)
   \       0x3C   0x7832             LDRB     R2,[R6, #+0]
   \       0x3E   0x2A20             CMP      R2,#+32
   \       0x40   0xD008             BEQ.N    ??SHELL_ParseLine_0
   \       0x42   0x42A9             CMP      R1,R5
   \       0x44   0xD206             BCS.N    ??SHELL_ParseLine_0
   \       0x46   0x1C76             ADDS     R6,R6,#+1
   \       0x48   0x1C49             ADDS     R1,R1,#+1
   \       0x4A   0xE7F7             B.N      ??SHELL_ParseLine_6
   \                     ??SHELL_ParseLine_7: (+1)
   \       0x4C   0x2200             MOVS     R2,#+0
   \       0x4E   0xF806 0x2B01      STRB     R2,[R6], #+1
   \       0x52   0x1C49             ADDS     R1,R1,#+1
   \                     ??SHELL_ParseLine_0: (+1)
   \       0x54   0x42A9             CMP      R1,R5
   \       0x56   0xD2E5             BCS.N    ??SHELL_ParseLine_1
   \                     ??SHELL_ParseLine_4: (+1)
   \       0x58   0x42A9             CMP      R1,R5
   \       0x5A   0xD3E4             BCC.N    ??SHELL_ParseLine_2
   \                     ??SHELL_ParseLine_3: (+1)
   \       0x5C   0x42A9             CMP      R1,R5
   \       0x5E   0xD2E1             BCS.N    ??SHELL_ParseLine_1
   \       0x60   0x7832             LDRB     R2,[R6, #+0]
   \       0x62   0x2A22             CMP      R2,#+34
   \       0x64   0xD1E7             BNE.N    ??SHELL_ParseLine_5
   \       0x66   0x1C76             ADDS     R6,R6,#+1
   \       0x68   0x1C49             ADDS     R1,R1,#+1
   \       0x6A   0xF844 0x6020      STR      R6,[R4, R0, LSL #+2]
   \       0x6E   0x1C40             ADDS     R0,R0,#+1
   \                     ??SHELL_ParseLine_8: (+1)
   \       0x70   0x7832             LDRB     R2,[R6, #+0]
   \       0x72   0x2A22             CMP      R2,#+34
   \       0x74   0xD0EA             BEQ.N    ??SHELL_ParseLine_7
   \       0x76   0x42A9             CMP      R1,R5
   \       0x78   0xD2E8             BCS.N    ??SHELL_ParseLine_7
   \       0x7A   0x1C76             ADDS     R6,R6,#+1
   \       0x7C   0x1C49             ADDS     R1,R1,#+1
   \       0x7E   0xE7F7             B.N      ??SHELL_ParseLine_8
    788          }
    789          

   \                                 In section .text, align 2, keep-with-next
    790          static shell_status_t SHELL_GetChar(shell_context_handle_t *shellContextHandle, uint8_t *ch)
    791          {
    792          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    793              uint32_t length = 0;
    794          
    795              SerialManager_TryRead(shellContextHandle->serialReadHandle, ch, 1, &length);
    796          
    797              if (length > 0)
    798              {
    799                  return kStatus_SHELL_Success;
    800              }
    801              else
    802              {
    803                  return kStatus_SHELL_Error;
    804              }
    805          #else
    806              return (shell_status_t)SerialManager_ReadBlocking(shellContextHandle->serialReadHandle, ch, 1);
   \                     SHELL_GetChar: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0x69C0             LDR      R0,[R0, #+28]
   \        0x4   0x....'....        B.W      SerialManager_ReadBlocking
    807          #endif
    808          }
    809          

   \                                 In section .text, align 2, keep-with-next
    810          shell_status_t SHELL_Init(shell_handle_t shellHandle, serial_handle_t serialHandle, char *prompt)
    811          {
   \                     SHELL_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4614             MOV      R4,R2
    812              shell_context_handle_t *shellContextHandle;
    813              serial_manager_status_t status = kStatus_SerialManager_Error;
    814              (void)status;
    815          
    816              assert(shellHandle);
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD107             BNE.N    ??SHELL_Init_0
   \        0xC   0xF44F 0x724C      MOV      R2,#+816
   \       0x10   0x....             LDR.N    R1,??DataTable12_7
   \       0x12   0x....             LDR.N    R0,??DataTable12_8
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
    817              assert(serialHandle);
   \                     ??SHELL_Init_0: (+1)
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD107             BNE.N    ??SHELL_Init_1
   \       0x20   0xF240 0x3231      MOVW     R2,#+817
   \       0x24   0x....             LDR.N    R1,??DataTable12_7
   \       0x26   0x....             LDR.N    R0,??DataTable12_9
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
    818              assert(prompt);
   \                     ??SHELL_Init_1: (+1)
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD107             BNE.N    ??SHELL_Init_2
   \       0x34   0xF240 0x3232      MOVW     R2,#+818
   \       0x38   0x....             LDR.N    R1,??DataTable12_7
   \       0x3A   0x....             LDR.N    R0,??DataTable12_10
   \       0x3C   0x....'....        BL       __aeabi_assert
   \       0x40   0x....'....        BL       __iar_EmptyStepPoint
    819          
    820              if (SHELL_HANDLE_SIZE < sizeof(shell_context_handle_t))
    821              {
    822                  return kStatus_SHELL_Error;
    823              }
    824          
    825              shellContextHandle = (shell_context_handle_t *)shellHandle;
    826          
    827              /* memory set for shellHandle */
    828              (void)memset(shellHandle, 0, SHELL_HANDLE_SIZE);
   \                     ??SHELL_Init_2: (+1)
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0xF44F 0x7102      MOV      R1,#+520
   \       0x4A   0x4630             MOV      R0,R6
   \       0x4C   0x....'....        BL       __aeabi_memset
    829          
    830          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    831          
    832          #if defined(OSA_USED)
    833          
    834          #if (defined(SHELL_USE_COMMON_TASK) && (SHELL_USE_COMMON_TASK > 0U))
    835              COMMON_TASK_init();
    836          #else
    837              if (KOSA_StatusSuccess != OSA_EventCreate((osa_event_handle_t)shellContextHandle->event, true))
    838              {
    839                  return kStatus_SHELL_Error;
    840              }
    841          
    842              if (KOSA_StatusSuccess !=
    843                  OSA_TaskCreate((osa_task_handle_t)shellContextHandle->taskId, OSA_TASK(SHELL_Task), shellContextHandle))
    844              {
    845                  return kStatus_SHELL_Error;
    846              }
    847          #endif
    848          
    849          #endif
    850          
    851          #endif
    852          
    853              shellContextHandle->prompt       = prompt;
   \       0x50   0x6234             STR      R4,[R6, #+32]
    854              shellContextHandle->serialHandle = serialHandle;
   \       0x52   0x60F5             STR      R5,[R6, #+12]
    855          
    856              shellContextHandle->serialWriteHandle = (serial_write_handle_t)&shellContextHandle->serialWriteHandleBuffer[0];
   \       0x54   0xF106 0x0010      ADD      R0,R6,#+16
   \       0x58   0x6170             STR      R0,[R6, #+20]
    857              status = SerialManager_OpenWriteHandle(shellContextHandle->serialHandle, shellContextHandle->serialWriteHandle);
    858              assert(kStatus_SerialManager_Success == status);
   \       0x5A   0x4601             MOV      R1,R0
   \       0x5C   0x68F0             LDR      R0,[R6, #+12]
   \       0x5E   0x....'....        BL       SerialManager_OpenWriteHandle
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD007             BEQ.N    ??SHELL_Init_3
   \       0x66   0xF240 0x325A      MOVW     R2,#+858
   \       0x6A   0x....             LDR.N    R1,??DataTable12_7
   \       0x6C   0x....             LDR.N    R0,??DataTable12_11
   \       0x6E   0x....'....        BL       __aeabi_assert
   \       0x72   0x....'....        BL       __iar_EmptyStepPoint
    859          
    860              shellContextHandle->serialReadHandle = (serial_read_handle_t)&shellContextHandle->serialReadHandleBuffer[0];
   \                     ??SHELL_Init_3: (+1)
   \       0x76   0xF106 0x0018      ADD      R0,R6,#+24
   \       0x7A   0x61F0             STR      R0,[R6, #+28]
    861              status = SerialManager_OpenReadHandle(shellContextHandle->serialHandle, shellContextHandle->serialReadHandle);
    862              assert(kStatus_SerialManager_Success == status);
   \       0x7C   0x4601             MOV      R1,R0
   \       0x7E   0x68F0             LDR      R0,[R6, #+12]
   \       0x80   0x....'....        BL       SerialManager_OpenReadHandle
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD007             BEQ.N    ??SHELL_Init_4
   \       0x88   0xF240 0x325E      MOVW     R2,#+862
   \       0x8C   0x....             LDR.N    R1,??DataTable12_7
   \       0x8E   0x....             LDR.N    R0,??DataTable12_11
   \       0x90   0x....'....        BL       __aeabi_assert
   \       0x94   0x....'....        BL       __iar_EmptyStepPoint
    863          
    864          #if (defined(SHELL_NON_BLOCKING_MODE) && (SHELL_NON_BLOCKING_MODE > 0U))
    865              SerialManager_InstallRxCallback(shellContextHandle->serialReadHandle, SHELL_SerialManagerRxCallback,
    866                                              shellContextHandle);
    867          #endif
    868          
    869              (void)SHELL_RegisterCommand(shellContextHandle, SHELL_COMMAND(help));
   \                     ??SHELL_Init_4: (+1)
   \       0x98   0x....             LDR.N    R1,??DataTable12_12
   \       0x9A   0x4630             MOV      R0,R6
   \       0x9C   0x....'....        BL       SHELL_RegisterCommand
    870              (void)SHELL_RegisterCommand(shellContextHandle, SHELL_COMMAND(exit));
   \       0xA0   0x....             LDR.N    R1,??DataTable12_13
   \       0xA2   0x4630             MOV      R0,R6
   \       0xA4   0x....'....        BL       SHELL_RegisterCommand
    871          
    872              (void)SHELL_Write(shellContextHandle, "\r\nSHELL build: ", strlen("\r\nSHELL build: "));
   \       0xA8   0x220F             MOVS     R2,#+15
   \       0xAA   0x....             LDR.N    R1,??DataTable12_14
   \       0xAC   0x4630             MOV      R0,R6
   \       0xAE   0x....'....        BL       SHELL_Write
    873              (void)SHELL_Write(shellContextHandle, __DATE__, strlen(__DATE__));
   \       0xB2   0x220B             MOVS     R2,#+11
   \       0xB4   0x....             LDR.N    R1,??DataTable12_15
   \       0xB6   0x4630             MOV      R0,R6
   \       0xB8   0x....'....        BL       SHELL_Write
    874              (void)SHELL_Write(shellContextHandle, "\r\nCopyright  2018  NXP\r\n",
    875                                strlen("\r\nCopyright  2018  NXP\r\n"));
   \       0xBC   0x2218             MOVS     R2,#+24
   \       0xBE   0x....             LDR.N    R1,??DataTable12_16
   \       0xC0   0x4630             MOV      R0,R6
   \       0xC2   0x....'....        BL       SHELL_Write
    876              (void)SHELL_Write(shellContextHandle, shellContextHandle->prompt, strlen(shellContextHandle->prompt));
   \       0xC6   0x6A30             LDR      R0,[R6, #+32]
   \       0xC8   0x....'....        BL       strlen
   \       0xCC   0x4602             MOV      R2,R0
   \       0xCE   0x6A31             LDR      R1,[R6, #+32]
   \       0xD0   0x4630             MOV      R0,R6
   \       0xD2   0x....'....        BL       SHELL_Write
    877          
    878              return kStatus_SHELL_Success;
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xBD70             POP      {R4-R6,PC}       ;; return
    879          }
    880          

   \                                 In section .text, align 2, keep-with-next
    881          shell_status_t SHELL_RegisterCommand(shell_handle_t shellHandle, shell_command_t *command)
    882          {
   \                     SHELL_RegisterCommand: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    883              shell_context_handle_t *shellContextHandle = (shell_context_handle_t *)shellHandle;
    884              assert(shellHandle);
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD107             BNE.N    ??SHELL_RegisterCommand_0
   \        0xA   0xF44F 0x725D      MOV      R2,#+884
   \        0xE   0x....             LDR.N    R1,??DataTable12_7
   \       0x10   0x....             LDR.N    R0,??DataTable12_8
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
    885              assert(command);
   \                     ??SHELL_RegisterCommand_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD107             BNE.N    ??SHELL_RegisterCommand_1
   \       0x1E   0xF240 0x3275      MOVW     R2,#+885
   \       0x22   0x....             LDR.N    R1,??DataTable12_7
   \       0x24   0x....             LDR.N    R0,??DataTable12_17
   \       0x26   0x....'....        BL       __aeabi_assert
   \       0x2A   0x....'....        BL       __iar_EmptyStepPoint
    886          
    887              /* memory set for shellHandle */
    888              (void)memset(&command->link, 0, sizeof(command->link));
   \                     ??SHELL_RegisterCommand_1: (+1)
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x210C             MOVS     R1,#+12
   \       0x32   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x36   0x....'....        BL       __aeabi_memset4
    889          
    890              (void)LIST_AddTail(&shellContextHandle->commandContextListHead, &command->link);
   \       0x3A   0xF104 0x0110      ADD      R1,R4,#+16
   \       0x3E   0x4628             MOV      R0,R5
   \       0x40   0x....'....        BL       LIST_AddTail
    891          
    892              return kStatus_SHELL_Success;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    893          }
    894          

   \                                 In section .text, align 2, keep-with-next
    895          shell_status_t SHELL_UnregisterCommand(shell_command_t *command)
    896          {
   \                     SHELL_UnregisterCommand: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    897              assert(command);
   \        0x4   0xD107             BNE.N    ??SHELL_UnregisterCommand_0
   \        0x6   0xF240 0x3281      MOVW     R2,#+897
   \        0xA   0x....             LDR.N    R1,??DataTable12_7
   \        0xC   0x....             LDR.N    R0,??DataTable12_17
   \        0xE   0x....'....        BL       __aeabi_assert
   \       0x12   0x....'....        BL       __iar_EmptyStepPoint
    898          
    899              (void)LIST_RemoveElement(&command->link);
   \                     ??SHELL_UnregisterCommand_0: (+1)
   \       0x16   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x1A   0x....'....        BL       LIST_RemoveElement
    900          
    901              /* memory set for shellHandle */
    902              (void)memset(&command->link, 0, sizeof(command->link));
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x210C             MOVS     R1,#+12
   \       0x22   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x26   0x....'....        BL       __aeabi_memset4
    903          
    904              return kStatus_SHELL_Success;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
    905          }
    906          

   \                                 In section .text, align 2, keep-with-next
    907          shell_status_t SHELL_Write(shell_handle_t shellHandle, char *buffer, uint32_t length)
    908          {
   \                     SHELL_Write: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4615             MOV      R5,R2
    909              shell_context_handle_t *shellContextHandle;
    910              uint32_t primask;
    911              shell_status_t status = kStatus_SHELL_Error;
    912          
    913              assert(shellHandle);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD107             BNE.N    ??SHELL_Write_0
   \        0xC   0xF240 0x3291      MOVW     R2,#+913
   \       0x10   0x....             LDR.N    R1,??DataTable12_7
   \       0x12   0x....             LDR.N    R0,??DataTable12_8
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
    914              assert(buffer);
   \                     ??SHELL_Write_0: (+1)
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD107             BNE.N    ??SHELL_Write_1
   \       0x20   0xF240 0x3292      MOVW     R2,#+914
   \       0x24   0x....             LDR.N    R1,??DataTable12_7
   \       0x26   0x....             LDR.N    R0,??DataTable12_18
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
    915          
    916              if (!(bool)length)
   \                     ??SHELL_Write_1: (+1)
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xD101             BNE.N    ??SHELL_Write_2
    917              {
    918                  return kStatus_SHELL_Success;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD70             POP      {R4-R6,PC}
    919              }
    920          
    921              shellContextHandle = (shell_context_handle_t *)shellHandle;
    922          
    923              primask = DisableGlobalIRQ();
   \                     ??SHELL_Write_2: (+1)
   \       0x38   0x....'....        BL       DisableGlobalIRQ
    924              if ((bool)shellContextHandle->printBusy)
   \       0x3C   0xF894 0x1172      LDRB     R1,[R4, #+370]
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD004             BEQ.N    ??SHELL_Write_3
    925              {
    926                  EnableGlobalIRQ(primask);
   \       0x44   0x....'....        BL       EnableGlobalIRQ
    927                  return kStatus_SHELL_Error;
   \       0x48   0xF243 0x60B1      MOVW     R0,#+14001
   \       0x4C   0xBD70             POP      {R4-R6,PC}
    928              }
    929              shellContextHandle->printBusy = 1U;
   \                     ??SHELL_Write_3: (+1)
   \       0x4E   0x2101             MOVS     R1,#+1
   \       0x50   0xF884 0x1172      STRB     R1,[R4, #+370]
    930              EnableGlobalIRQ(primask);
   \       0x54   0x....'....        BL       EnableGlobalIRQ
    931          
    932              status =
    933                  (shell_status_t)SerialManager_WriteBlocking(shellContextHandle->serialWriteHandle, (uint8_t *)buffer, length);
   \       0x58   0x462A             MOV      R2,R5
   \       0x5A   0x4631             MOV      R1,R6
   \       0x5C   0x6960             LDR      R0,[R4, #+20]
   \       0x5E   0x....'....        BL       SerialManager_WriteBlocking
    934          
    935              shellContextHandle->printBusy = 0U;
   \       0x62   0x2100             MOVS     R1,#+0
   \       0x64   0xF884 0x1172      STRB     R1,[R4, #+370]
    936          
    937              return status;
   \       0x68   0xBD70             POP      {R4-R6,PC}       ;; return
    938          }
    939          

   \                                 In section .text, align 2, keep-with-next
    940          int SHELL_Printf(shell_handle_t shellHandle, const char *formatString, ...)
    941          {
   \                     SHELL_Printf: (+1)
   \        0x0   0xB40C             PUSH     {R2,R3}
   \        0x2   0xB538             PUSH     {R3-R5,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460C             MOV      R4,R1
    942              shell_context_handle_t *shellContextHandle;
    943              uint32_t length;
    944              uint32_t primask;
    945              va_list ap;
    946          
    947              assert(shellHandle);
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD107             BNE.N    ??SHELL_Printf_0
   \        0xC   0xF240 0x32B3      MOVW     R2,#+947
   \       0x10   0x....             LDR.N    R1,??DataTable12_7
   \       0x12   0x....             LDR.N    R0,??DataTable12_8
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
    948              assert(formatString);
   \                     ??SHELL_Printf_0: (+1)
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD107             BNE.N    ??SHELL_Printf_1
   \       0x20   0xF44F 0x726D      MOV      R2,#+948
   \       0x24   0x....             LDR.N    R1,??DataTable12_7
   \       0x26   0x....             LDR.N    R0,??DataTable12_19
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
    949          
    950              shellContextHandle = (shell_context_handle_t *)shellHandle;
    951          
    952              primask = DisableGlobalIRQ();
   \                     ??SHELL_Printf_1: (+1)
   \       0x30   0x....'....        BL       DisableGlobalIRQ
    953              if ((bool)shellContextHandle->printBusy)
   \       0x34   0xF895 0x1172      LDRB     R1,[R5, #+370]
   \       0x38   0x2900             CMP      R1,#+0
   \       0x3A   0xD004             BEQ.N    ??SHELL_Printf_2
    954              {
    955                  EnableGlobalIRQ(primask);
   \       0x3C   0x....'....        BL       EnableGlobalIRQ
    956                  return -1;
   \       0x40   0xF04F 0x30FF      MOV      R0,#-1
   \       0x44   0xE017             B.N      ??SHELL_Printf_3
    957              }
    958              shellContextHandle->printBusy = 1U;
   \                     ??SHELL_Printf_2: (+1)
   \       0x46   0x2101             MOVS     R1,#+1
   \       0x48   0xF885 0x1172      STRB     R1,[R5, #+370]
    959              EnableGlobalIRQ(primask);
   \       0x4C   0x....'....        BL       EnableGlobalIRQ
    960          
    961              va_start(ap, formatString);
   \       0x50   0xAA04             ADD      R2,SP,#+16
    962          
    963              shellContextHandle->printLength = 0U;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF8C5 0x0164      STR      R0,[R5, #+356]
    964              length                          = (uint32_t)SHELL_Sprintf(shellHandle, formatString, ap);
   \       0x58   0x4621             MOV      R1,R4
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0x....'....        BL       SHELL_Sprintf
    965              (void)SerialManager_WriteBlocking(shellContextHandle->serialWriteHandle, (uint8_t *)shellContextHandle->printBuffer,
    966                                                length);
   \       0x60   0x4602             MOV      R2,R0
   \       0x62   0xF505 0x7192      ADD      R1,R5,#+292
   \       0x66   0x6968             LDR      R0,[R5, #+20]
   \       0x68   0x....'....        BL       SerialManager_WriteBlocking
    967              va_end(ap);
    968          
    969              shellContextHandle->printBusy = 0U;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xF885 0x0172      STRB     R0,[R5, #+370]
    970              return (int32_t)shellContextHandle->printLength;
   \       0x72   0xF8D5 0x0164      LDR      R0,[R5, #+356]
   \                     ??SHELL_Printf_3: (+1)
   \       0x76   0xBC32             POP      {R1,R4,R5}
   \       0x78   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    971          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x08 0x00          DC8      "\b",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x20 0x20          DC8      "  \b"
   \              0x08 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x08 0x20          DC8      "\b \b"
   \              0x08 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x08 0x20          DC8      "\b \b"
   \              0x08 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     SHELL_WriteBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x....'....        DC32     `SHELL_Task{2}{3}{4}{5}{6}{39}{40}::endoflinechar`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x....'....        DC32     s_paramBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \        0x0   0x....'....        DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \        0x0   0x....'....        DC32     g_shellCommandhelp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \        0x0   0x....'....        DC32     g_shellCommandexit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \        0x0   0x....'....        DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x68 0x65          DC8 "help"
   \              0x6C 0x70    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x0D 0x0A          DC8 "\015\012\"help\": List all the registered commands\015\012"
   \              0x22 0x68    
   \              0x65 0x6C    
   \              0x70 0x22    
   \              0x3A 0x20    
   \              0x4C 0x69    
   \              0x73 0x74    
   \              0x20 0x61    
   \              0x6C 0x6C    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x72    
   \              0x65 0x67    
   \              0x69 0x73    
   \              0x74 0x65    
   \              0x72 0x65    
   \              0x64 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \       0x2D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x65 0x78          DC8 "exit"
   \              0x69 0x74    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x0D 0x0A          DC8 "\015\012\"exit\": Exit program\015\012"
   \              0x22 0x65    
   \              0x78 0x69    
   \              0x74 0x22    
   \              0x3A 0x20    
   \              0x45 0x78    
   \              0x69 0x74    
   \              0x20 0x70    
   \              0x72 0x6F    
   \              0x67 0x72    
   \              0x61 0x6D    
   \              0x0D 0x0A    
   \              0x00         
   \       0x19   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \        0x0   0x08 0x00          DC8 "\010"

   \                                 In section .rodata, align 4
   \        0x0   0x20 0x20          DC8 "  \010"
   \              0x08 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x08 0x20          DC8 "\010 \010"
   \              0x08 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x0D 0x0A          DC8 "\015\012SHELL exited\015\012"
   \              0x53 0x48    
   \              0x45 0x4C    
   \              0x4C 0x20    
   \              0x65 0x78    
   \              0x69 0x74    
   \              0x65 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x0D 0x0A          DC8 0DH, 0AH, 49H, 6EH, 63H, 6FH, 72H, 72H
   \              0x49 0x6E    
   \              0x63 0x6F    
   \              0x72 0x72    
   \        0x8   0x65 0x63          DC8 65H, 63H, 74H, 20H, 63H, 6FH, 6DH, 6DH
   \              0x74 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \       0x10   0x61 0x6E          DC8 61H, 6EH, 64H, 20H, 70H, 61H, 72H, 61H
   \              0x64 0x20    
   \              0x70 0x61    
   \              0x72 0x61    
   \       0x18   0x6D 0x65          DC8 6DH, 65H, 74H, 65H, 72H, 28H, 73H, 29H
   \              0x74 0x65    
   \              0x72 0x28    
   \              0x73 0x29    
   \       0x20   0x2E 0x20          DC8 2EH, 20H, 20H, 45H, 6EH, 74H, 65H, 72H
   \              0x20 0x45    
   \              0x6E 0x74    
   \              0x65 0x72    
   \       0x28   0x20 0x22          DC8 20H, 22H, 68H, 65H, 6CH, 70H, 22H, 20H
   \              0x68 0x65    
   \              0x6C 0x70    
   \              0x22 0x20    
   \       0x30   0x74 0x6F          DC8 74H, 6FH, 20H, 76H, 69H, 65H, 77H, 20H
   \              0x20 0x76    
   \              0x69 0x65    
   \              0x77 0x20    
   \       0x38   0x61 0x20          DC8 61H, 20H, 6CH, 69H, 73H, 74H, 20H, 6FH
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x20 0x6F    
   \       0x40   0x66 0x20          DC8 66H, 20H, 61H, 76H, 61H, 69H, 6CH, 61H
   \              0x61 0x76    
   \              0x61 0x69    
   \              0x6C 0x61    
   \       0x48   0x62 0x6C          DC8 62H, 6CH, 65H, 20H, 63H, 6FH, 6DH, 6DH
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \       0x50   0x61 0x6E          DC8 61H, 6EH, 64H, 73H, 2EH, 0DH, 0AH, 0DH
   \              0x64 0x73    
   \              0x2E 0x0D    
   \              0x0A 0x0D    
   \       0x58   0x0A 0x00          DC8 0AH, 0
   \       0x5A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x0D 0x0A          DC8 0DH, 0AH, 43H, 6FH, 6DH, 6DH, 61H, 6EH
   \              0x43 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \        0x8   0x64 0x20          DC8 64H, 20H, 6EH, 6FH, 74H, 20H, 72H, 65H
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x72 0x65    
   \       0x10   0x63 0x6F          DC8 63H, 6FH, 67H, 6EH, 69H, 7AH, 65H, 64H
   \              0x67 0x6E    
   \              0x69 0x7A    
   \              0x65 0x64    
   \       0x18   0x2E 0x20          DC8 2EH, 20H, 20H, 45H, 6EH, 74H, 65H, 72H
   \              0x20 0x45    
   \              0x6E 0x74    
   \              0x65 0x72    
   \       0x20   0x20 0x27          DC8 20H, 27H, 68H, 65H, 6CH, 70H, 27H, 20H
   \              0x68 0x65    
   \              0x6C 0x70    
   \              0x27 0x20    
   \       0x28   0x74 0x6F          DC8 74H, 6FH, 20H, 76H, 69H, 65H, 77H, 20H
   \              0x20 0x76    
   \              0x69 0x65    
   \              0x77 0x20    
   \       0x30   0x61 0x20          DC8 61H, 20H, 6CH, 69H, 73H, 74H, 20H, 6FH
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x20 0x6F    
   \       0x38   0x66 0x20          DC8 66H, 20H, 61H, 76H, 61H, 69H, 6CH, 61H
   \              0x61 0x76    
   \              0x61 0x69    
   \              0x6C 0x61    
   \       0x40   0x62 0x6C          DC8 62H, 6CH, 65H, 20H, 63H, 6FH, 6DH, 6DH
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \       0x48   0x61 0x6E          DC8 61H, 6EH, 64H, 73H, 2EH, 0DH, 0AH, 0DH
   \              0x64 0x73    
   \              0x2E 0x0D    
   \              0x0A 0x0D    
   \       0x50   0x0A 0x00          DC8 0AH, 0
   \       0x52   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x25 0x73          DC8 "%s\015\012"
   \              0x0D 0x0A    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x73 0x68          DC8 "shellHandle"
   \              0x65 0x6C    
   \              0x6C 0x48    
   \              0x61 0x6E    
   \              0x64 0x6C    
   \              0x65 0x00    

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 6EH, 78H, 70H, 5CH, 53H
   \              0x5C 0x6E    
   \              0x78 0x70    
   \              0x5C 0x53    
   \        0x8   0x44 0x4B          DC8 44H, 4BH, 5FH, 32H, 2EH, 36H, 2EH, 30H
   \              0x5F 0x32    
   \              0x2E 0x36    
   \              0x2E 0x30    
   \       0x10   0x5F 0x45          DC8 5FH, 45H, 56H, 4BH, 42H, 2DH, 49H, 4DH
   \              0x56 0x4B    
   \              0x42 0x2D    
   \              0x49 0x4D    
   \       0x18   0x58 0x52          DC8 58H, 52H, 54H, 31H, 30H, 35H, 30H, 5CH
   \              0x54 0x31    
   \              0x30 0x35    
   \              0x30 0x5C    
   \       0x20   0x64 0x65          DC8 64H, 65H, 76H, 69H, 63H, 65H, 73H, 5CH
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x73 0x5C    
   \       0x28   0x4D 0x49          DC8 4DH, 49H, 4DH, 58H, 52H, 54H, 31H, 30H
   \              0x4D 0x58    
   \              0x52 0x54    
   \              0x31 0x30    
   \       0x30   0x35 0x32          DC8 35H, 32H, 5CH, 75H, 74H, 69H, 6CH, 69H
   \              0x5C 0x75    
   \              0x74 0x69    
   \              0x6C 0x69    
   \       0x38   0x74 0x69          DC8 74H, 69H, 65H, 73H, 5CH, 66H, 73H, 6CH
   \              0x65 0x73    
   \              0x5C 0x66    
   \              0x73 0x6C    
   \       0x40   0x5F 0x73          DC8 5FH, 73H, 68H, 65H, 6CH, 6CH, 2EH, 63H
   \              0x68 0x65    
   \              0x6C 0x6C    
   \              0x2E 0x63    
   \       0x48   0x00               DC8 0
   \       0x49   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x73 0x65          DC8 "serialHandle"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x48 0x61    
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x70 0x72          DC8 "prompt"
   \              0x6F 0x6D    
   \              0x70 0x74    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x6B 0x53          DC8 "kStatus_SerialManager_Success == status"
   \              0x74 0x61    
   \              0x74 0x75    
   \              0x73 0x5F    
   \              0x53 0x65    
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x4D 0x61    
   \              0x6E 0x61    
   \              0x67 0x65    
   \              0x72 0x5F    
   \              0x53 0x75    
   \              0x63 0x63    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x3D 0x3D    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x75    
   \              0x73 0x00    

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x0D 0x0A          DC8 "\015\012SHELL build: "
   \              0x53 0x48    
   \              0x45 0x4C    
   \              0x4C 0x20    
   \              0x62 0x75    
   \              0x69 0x6C    
   \              0x64 0x3A    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x4A 0x75          DC8 "Jun  6 2019"
   \              0x6E 0x20    
   \              0x20 0x36    
   \              0x20 0x32    
   \              0x30 0x31    
   \              0x39 0x00    

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x0D 0x0A          DC8 "\015\012Copyright  2018  NXP\015\012"
   \              0x43 0x6F    
   \              0x70 0x79    
   \              0x72 0x69    
   \              0x67 0x68    
   \              0x74 0x20    
   \              0x20 0x32    
   \              0x30 0x31    
   \              0x38 0x20    
   \              0x20 0x4E    
   \              0x58 0x50    
   \              0x0D 0x0A    
   \              0x00         
   \       0x19   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x63 0x6F          DC8 "command"
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x62 0x75          DC8 "buffer"
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x66 0x6F          DC8 "formatString"
   \              0x72 0x6D    
   \              0x61 0x74    
   \              0x53 0x74    
   \              0x72 0x69    
   \              0x6E 0x67    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DisableGlobalIRQ
       0   EnableGlobalIRQ
      24   SHELL_AutoComplete
        24   -> LIST_GetHead
        24   -> LIST_GetNext
         0   -> SHELL_HelpCommand
        24   -> SHELL_Printf
        24   -> SHELL_StringCompare
         0   -> SHELL_Write
        24   -> SHELL_Write
        24   -> __aeabi_memcpy
        24   -> strlen
       8   SHELL_ExitCommand
         8   -> SHELL_Write
       0   SHELL_GetChar
         0   -> SerialManager_ReadBlocking
      24   SHELL_GetHistoryCommand
         0   -> SHELL_Write
        24   -> SHELL_Write
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset4
        24   -> strlen
      16   SHELL_HelpCommand
        16   -> LIST_GetHead
        16   -> LIST_GetNext
        16   -> SHELL_Write
        16   -> strlen
      16   SHELL_Init
        16   -> SHELL_RegisterCommand
        16   -> SHELL_Write
        16   -> SerialManager_OpenReadHandle
        16   -> SerialManager_OpenWriteHandle
        16   -> __aeabi_assert
        16   -> __aeabi_memset
        16   -> __iar_EmptyStepPoint
        16   -> strlen
      24   SHELL_ParseLine
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset4
      24   SHELL_Printf
        24   -> DisableGlobalIRQ
        24   -> EnableGlobalIRQ
        24   -> SHELL_Sprintf
        24   -> SerialManager_WriteBlocking
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
     288   SHELL_ProcessCommand
       288   -- Indirect call
       288   -> LIST_GetHead
       288   -> LIST_GetNext
       288   -> SHELL_ParseLine
       288   -> SHELL_StringCompare
       288   -> SHELL_Write
       288   -> __aeabi_memcpy
       288   -> __aeabi_memset
       288   -> __aeabi_memset4
       288   -> strlen
      16   SHELL_RegisterCommand
        16   -> LIST_AddTail
        16   -> __aeabi_assert
        16   -> __aeabi_memset4
        16   -> __iar_EmptyStepPoint
       8   SHELL_Sprintf
         8   -> StrFormatPrintf
       4   SHELL_StringCompare
      24   SHELL_Task
        24   -> SHELL_AutoComplete
        24   -> SHELL_GetChar
        24   -> SHELL_GetHistoryCommand
        24   -> SHELL_ProcessCommand
        24   -> SHELL_Write
        24   -> SerialManager_CloseReadHandle
        24   -> SerialManager_CloseWriteHandle
        24   -> __aeabi_memmove
        24   -> __aeabi_memset
        24   -> strlen
       8   SHELL_UnregisterCommand
         8   -> LIST_RemoveElement
         8   -> __aeabi_assert
         8   -> __aeabi_memset4
         8   -> __iar_EmptyStepPoint
      16   SHELL_Write
        16   -> DisableGlobalIRQ
        16   -> EnableGlobalIRQ
        16   -> SerialManager_WriteBlocking
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   SHELL_WriteBuffer
        24   -> SerialManager_WriteBlocking


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable4
       4  ??DataTable4_1
       8  ?_0
      48  ?_1
      84  ?_10
       8  ?_11
      12  ?_12
      76  ?_13
      16  ?_14
       8  ?_15
      40  ?_16
      16  ?_17
      12  ?_18
      28  ?_19
       8  ?_2
       8  ?_20
       8  ?_21
      16  ?_22
      28  ?_3
       2  ?_4
       4  ?_5
       4  ?_6
       4  ?_7
      20  ?_8
      92  ?_9
       8  DisableGlobalIRQ
       6  EnableGlobalIRQ
     178  SHELL_AutoComplete
      24  SHELL_ExitCommand
       8  SHELL_GetChar
     146  SHELL_GetHistoryCommand
      60  SHELL_HelpCommand
     218  SHELL_Init
     128  SHELL_ParseLine
     124  SHELL_Printf
     352  SHELL_ProcessCommand
      72  SHELL_RegisterCommand
      30  SHELL_Sprintf
      36  SHELL_StringCompare
     854  SHELL_Task
      46  SHELL_UnregisterCommand
     106  SHELL_Write
      80  SHELL_WriteBuffer
       1  endoflinechar
      28  g_shellCommandexit
      28  g_shellCommandhelp
      64  s_paramBuffer

 
    65 bytes in section .bss
    56 bytes in section .data
   550 bytes in section .rodata
 2 580 bytes in section .text
 
 2 580 bytes of CODE  memory
   550 bytes of CONST memory
   121 bytes of DATA  memory

Errors: none
Warnings: none
