###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:18
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\mbedtls\library\entropy.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWD4DA.tmp
#        (C:\Development\smart_washing_machine_3080\mbedtls\library\entropy.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\entropy.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\entropy.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\mbedtls\library\entropy.c
      1          /*
      2           *  Entropy accumulator implementation
      3           *
      4           *  Copyright (C) 2006-2016, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_ENTROPY_C)
     29          
     30          #if defined(MBEDTLS_TEST_NULL_ENTROPY)
     31          #warning "**** WARNING!  MBEDTLS_TEST_NULL_ENTROPY defined! "
     32          #warning "**** THIS BUILD HAS NO DEFINED ENTROPY SOURCES "
     33          #warning "**** THIS BUILD IS *NOT* SUITABLE FOR PRODUCTION USE "
     34          #endif
     35          
     36          #include "mbedtls/entropy.h"
     37          #include "mbedtls/entropy_poll.h"
     38          #include "mbedtls/platform_util.h"
     39          
     40          #include <string.h>
     41          
     42          #if defined(MBEDTLS_FS_IO)
     43          #include <stdio.h>
     44          #endif
     45          
     46          #if defined(MBEDTLS_ENTROPY_NV_SEED)
     47          #include "mbedtls/platform.h"
     48          #endif
     49          
     50          #if defined(MBEDTLS_SELF_TEST)
     51          #if defined(MBEDTLS_PLATFORM_C)
     52          #include "mbedtls/platform.h"
     53          #else
     54          #include <stdio.h>
     55          #define mbedtls_printf     printf
     56          #endif /* MBEDTLS_PLATFORM_C */
     57          #endif /* MBEDTLS_SELF_TEST */
     58          
     59          #if defined(MBEDTLS_HAVEGE_C)
     60          #include "mbedtls/havege.h"
     61          #endif
     62          
     63          #define ENTROPY_MAX_LOOP    256     /**< Maximum amount to loop before error */
     64          

   \                                 In section .text, align 2, keep-with-next
     65          void mbedtls_entropy_init( mbedtls_entropy_context *ctx )
     66          {
   \                     mbedtls_entropy_init: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     67              ctx->source_count = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xF8C4 0x00E0      STR      R0,[R4, #+224]
     68              memset( ctx->source, 0, sizeof( ctx->source ) );
   \        0xA   0x4602             MOV      R2,R0
   \        0xC   0xF44F 0x71C8      MOV      R1,#+400
   \       0x10   0xF104 0x00E4      ADD      R0,R4,#+228
   \       0x14   0x....'....        BL       __aeabi_memset4
     69          
     70          #if defined(MBEDTLS_THREADING_C)
     71              mbedtls_mutex_init( &ctx->mutex );
     72          #endif
     73          
     74              ctx->accumulator_started = 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6020             STR      R0,[R4, #+0]
     75          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
     76              mbedtls_sha512_init( &ctx->accumulator );
   \       0x1C   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x20   0x....'....        BL       mbedtls_sha512_init
     77          #else
     78              mbedtls_sha256_init( &ctx->accumulator );
     79          #endif
     80          #if defined(MBEDTLS_HAVEGE_C)
     81              mbedtls_havege_init( &ctx->havege_data );
     82          #endif
     83          
     84              /* Reminder: Update ENTROPY_HAVE_STRONG in the test files
     85               *           when adding more strong entropy sources here. */
     86          
     87          #if defined(MBEDTLS_TEST_NULL_ENTROPY)
     88              mbedtls_entropy_add_source( ctx, mbedtls_null_entropy_poll, NULL,
     89                                          1, MBEDTLS_ENTROPY_SOURCE_STRONG );
     90          #endif
     91          
     92          #if !defined(MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES)
     93          #if !defined(MBEDTLS_NO_PLATFORM_ENTROPY)
     94              mbedtls_entropy_add_source( ctx, mbedtls_platform_entropy_poll, NULL,
     95                                          MBEDTLS_ENTROPY_MIN_PLATFORM,
     96                                          MBEDTLS_ENTROPY_SOURCE_STRONG );
     97          #endif
     98          #if defined(MBEDTLS_TIMING_C)
     99              mbedtls_entropy_add_source( ctx, mbedtls_hardclock_poll, NULL,
    100                                          MBEDTLS_ENTROPY_MIN_HARDCLOCK,
    101                                          MBEDTLS_ENTROPY_SOURCE_WEAK );
    102          #endif
    103          #if defined(MBEDTLS_HAVEGE_C)
    104              mbedtls_entropy_add_source( ctx, mbedtls_havege_poll, &ctx->havege_data,
    105                                          MBEDTLS_ENTROPY_MIN_HAVEGE,
    106                                          MBEDTLS_ENTROPY_SOURCE_STRONG );
    107          #endif
    108          #if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
    109              mbedtls_entropy_add_source( ctx, mbedtls_hardware_poll, NULL,
    110                                          MBEDTLS_ENTROPY_MIN_HARDWARE,
    111                                          MBEDTLS_ENTROPY_SOURCE_STRONG );
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0x2320             MOVS     R3,#+32
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x....'....        LDR.W    R1,??DataTable2_2
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       mbedtls_entropy_add_source
    112          #endif
    113          #if defined(MBEDTLS_ENTROPY_NV_SEED)
    114              mbedtls_entropy_add_source( ctx, mbedtls_nv_seed_poll, NULL,
    115                                          MBEDTLS_ENTROPY_BLOCK_SIZE,
    116                                          MBEDTLS_ENTROPY_SOURCE_STRONG );
    117              ctx->initial_entropy_run = 0;
    118          #endif
    119          #endif /* MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES */
    120          }
   \       0x36   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    121          

   \                                 In section .text, align 2, keep-with-next
    122          void mbedtls_entropy_free( mbedtls_entropy_context *ctx )
    123          {
   \                     mbedtls_entropy_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    124          #if defined(MBEDTLS_HAVEGE_C)
    125              mbedtls_havege_free( &ctx->havege_data );
    126          #endif
    127          #if defined(MBEDTLS_THREADING_C)
    128              mbedtls_mutex_free( &ctx->mutex );
    129          #endif
    130          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    131              mbedtls_sha512_free( &ctx->accumulator );
   \        0x4   0xF104 0x0008      ADD      R0,R4,#+8
   \        0x8   0x....'....        BL       mbedtls_sha512_free
    132          #else
    133              mbedtls_sha256_free( &ctx->accumulator );
    134          #endif
    135          #if defined(MBEDTLS_ENTROPY_NV_SEED)
    136              ctx->initial_entropy_run = 0;
    137          #endif
    138              ctx->source_count = 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xF8C4 0x00E0      STR      R0,[R4, #+224]
    139              mbedtls_platform_zeroize( ctx->source, sizeof( ctx->source ) );
   \       0x12   0xF44F 0x71C8      MOV      R1,#+400
   \       0x16   0xF104 0x00E4      ADD      R0,R4,#+228
   \       0x1A   0x....'....        BL       mbedtls_platform_zeroize
    140              ctx->accumulator_started = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6020             STR      R0,[R4, #+0]
    141          }
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
    142          

   \                                 In section .text, align 2, keep-with-next
    143          int mbedtls_entropy_add_source( mbedtls_entropy_context *ctx,
    144                                  mbedtls_entropy_f_source_ptr f_source, void *p_source,
    145                                  size_t threshold, int strong )
    146          {
   \                     mbedtls_entropy_add_source: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    147              int idx, ret = 0;
   \        0x2   0x2400             MOVS     R4,#+0
    148          
    149          #if defined(MBEDTLS_THREADING_C)
    150              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    151                  return( ret );
    152          #endif
    153          
    154              idx = ctx->source_count;
   \        0x4   0xF8D0 0x60E0      LDR      R6,[R0, #+224]
    155              if( idx >= MBEDTLS_ENTROPY_MAX_SOURCES )
   \        0x8   0x2E14             CMP      R6,#+20
   \        0xA   0xDB02             BLT.N    ??mbedtls_entropy_add_source_0
    156              {
    157                  ret = MBEDTLS_ERR_ENTROPY_MAX_SOURCES;
   \        0xC   0xF06F 0x043D      MVN      R4,#+61
    158                  goto exit;
   \       0x10   0xE017             B.N      ??mbedtls_entropy_add_source_1
    159              }
   \                     ??mbedtls_entropy_add_source_0: (+1)
   \       0x12   0x9D04             LDR      R5,[SP, #+16]
    160          
    161              ctx->source[idx].f_source  = f_source;
   \       0x14   0x2714             MOVS     R7,#+20
   \       0x16   0xFB07 0xFC06      MUL      R12,R7,R6
   \       0x1A   0x4484             ADD      R12,R0,R12
   \       0x1C   0xF8CC 0x10E4      STR      R1,[R12, #+228]
    162              ctx->source[idx].p_source  = p_source;
   \       0x20   0xFB07 0xF106      MUL      R1,R7,R6
   \       0x24   0x4401             ADD      R1,R0,R1
   \       0x26   0xF8C1 0x20E8      STR      R2,[R1, #+232]
    163              ctx->source[idx].threshold = threshold;
   \       0x2A   0xFB07 0xF106      MUL      R1,R7,R6
   \       0x2E   0x4401             ADD      R1,R0,R1
   \       0x30   0xF8C1 0x30F0      STR      R3,[R1, #+240]
    164              ctx->source[idx].strong    = strong;
   \       0x34   0xF8C1 0x50F4      STR      R5,[R1, #+244]
    165          
    166              ctx->source_count++;
   \       0x38   0xF8D0 0x10E0      LDR      R1,[R0, #+224]
   \       0x3C   0x1C49             ADDS     R1,R1,#+1
   \       0x3E   0xF8C0 0x10E0      STR      R1,[R0, #+224]
    167          
    168          exit:
    169          #if defined(MBEDTLS_THREADING_C)
    170              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    171                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    172          #endif
    173          
    174              return( ret );
   \                     ??mbedtls_entropy_add_source_1: (+1)
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0xBCF0             POP      {R4-R7}
   \       0x46   0x4770             BX       LR               ;; return
    175          }
    176          
    177          /*
    178           * Entropy accumulator update
    179           */

   \                                 In section .text, align 2, keep-with-next
    180          static int entropy_update( mbedtls_entropy_context *ctx, unsigned char source_id,
    181                                     const unsigned char *data, size_t len )
    182          {
   \                     entropy_update: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB091             SUB      SP,SP,#+68
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x461F             MOV      R7,R3
    183              unsigned char header[2];
    184              unsigned char tmp[MBEDTLS_ENTROPY_BLOCK_SIZE];
    185              size_t use_len = len;
    186              const unsigned char *p = data;
    187              int ret = 0;
    188          
    189              if( use_len > MBEDTLS_ENTROPY_BLOCK_SIZE )
   \        0xE   0x2F41             CMP      R7,#+65
   \       0x10   0xD309             BCC.N    ??entropy_update_0
    190              {
    191          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    192                  if( ( ret = mbedtls_sha512_ret( data, len, tmp, 0 ) ) != 0 )
   \       0x12   0x2300             MOVS     R3,#+0
   \       0x14   0xAA01             ADD      R2,SP,#+4
   \       0x16   0x4639             MOV      R1,R7
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0x....'....        BL       mbedtls_sha512_ret
   \       0x1E   0x0004             MOVS     R4,R0
   \       0x20   0xD121             BNE.N    ??entropy_update_1
    193                      goto cleanup;
    194          #else
    195                  if( ( ret = mbedtls_sha256_ret( data, len, tmp, 0 ) ) != 0 )
    196                      goto cleanup;
    197          #endif
    198                  p = tmp;
   \       0x22   0xAE01             ADD      R6,SP,#+4
    199                  use_len = MBEDTLS_ENTROPY_BLOCK_SIZE;
   \       0x24   0x2740             MOVS     R7,#+64
    200              }
    201          
    202              header[0] = source_id;
   \                     ??entropy_update_0: (+1)
   \       0x26   0xF88D 0x8000      STRB     R8,[SP, #+0]
    203              header[1] = use_len & 0xFF;
   \       0x2A   0x4638             MOV      R0,R7
   \       0x2C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    204          
    205              /*
    206               * Start the accumulator if this has not already happened. Note that
    207               * it is sufficient to start the accumulator here only because all calls to
    208               * gather entropy eventually execute this code.
    209               */
    210          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    211              if( ctx->accumulator_started == 0 &&
    212                  ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD106             BNE.N    ??entropy_update_2
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x3C   0x....'....        BL       mbedtls_sha512_starts_ret
   \       0x40   0x0004             MOVS     R4,R0
   \       0x42   0xD110             BNE.N    ??entropy_update_1
    213                  goto cleanup;
    214              else
    215                  ctx->accumulator_started = 1;
   \                     ??entropy_update_2: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x6028             STR      R0,[R5, #+0]
    216              if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, header, 2 ) ) != 0 )
   \       0x48   0x2202             MOVS     R2,#+2
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x50   0x....'....        BL       mbedtls_sha512_update_ret
   \       0x54   0x0004             MOVS     R4,R0
   \       0x56   0xD106             BNE.N    ??entropy_update_1
    217                  goto cleanup;
    218              ret = mbedtls_sha512_update_ret( &ctx->accumulator, p, use_len );
   \       0x58   0x463A             MOV      R2,R7
   \       0x5A   0x4631             MOV      R1,R6
   \       0x5C   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x60   0x....'....        BL       mbedtls_sha512_update_ret
   \       0x64   0x4604             MOV      R4,R0
    219          #else
    220              if( ctx->accumulator_started == 0 &&
    221                  ( ret = mbedtls_sha256_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
    222                  goto cleanup;
    223              else
    224                  ctx->accumulator_started = 1;
    225              if( ( ret = mbedtls_sha256_update_ret( &ctx->accumulator, header, 2 ) ) != 0 )
    226                  goto cleanup;
    227              ret = mbedtls_sha256_update_ret( &ctx->accumulator, p, use_len );
    228          #endif
    229          
    230          cleanup:
    231              mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
   \                     ??entropy_update_1: (+1)
   \       0x66   0x2140             MOVS     R1,#+64
   \       0x68   0xA801             ADD      R0,SP,#+4
   \       0x6A   0x....'....        BL       mbedtls_platform_zeroize
    232          
    233              return( ret );
   \       0x6E   0x4620             MOV      R0,R4
   \       0x70   0xB012             ADD      SP,SP,#+72
   \       0x72   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    234          }
    235          

   \                                 In section .text, align 2, keep-with-next
    236          int mbedtls_entropy_update_manual( mbedtls_entropy_context *ctx,
    237                                     const unsigned char *data, size_t len )
    238          {
   \                     mbedtls_entropy_update_manual: (+1)
   \        0x0   0x4613             MOV      R3,R2
    239              int ret;
    240          
    241          #if defined(MBEDTLS_THREADING_C)
    242              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    243                  return( ret );
    244          #endif
    245          
    246              ret = entropy_update( ctx, MBEDTLS_ENTROPY_SOURCE_MANUAL, data, len );
    247          
    248          #if defined(MBEDTLS_THREADING_C)
    249              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    250                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    251          #endif
    252          
    253              return( ret );
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x2114             MOVS     R1,#+20
   \        0x6   0x....             B.N      entropy_update
    254          }
    255          
    256          /*
    257           * Run through the different sources to add entropy to our accumulator
    258           */

   \                                 In section .text, align 2, keep-with-next
    259          static int entropy_gather_internal( mbedtls_entropy_context *ctx )
    260          {
   \                     entropy_gather_internal: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB0A1             SUB      SP,SP,#+132
   \        0x6   0x4607             MOV      R7,R0
    261              int ret, i, have_one_strong = 0;
   \        0x8   0x2500             MOVS     R5,#+0
    262              unsigned char buf[MBEDTLS_ENTROPY_MAX_GATHER];
    263              size_t olen;
    264          
    265              if( ctx->source_count == 0 )
   \        0xA   0xF8D7 0x00E0      LDR      R0,[R7, #+224]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD102             BNE.N    ??entropy_gather_internal_0
    266                  return( MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED );
   \       0x12   0xF06F 0x003F      MVN      R0,#+63
   \       0x16   0xE045             B.N      ??entropy_gather_internal_1
    267          
    268              /*
    269               * Run through our entropy sources
    270               */
    271              for( i = 0; i < ctx->source_count; i++ )
   \                     ??entropy_gather_internal_0: (+1)
   \       0x18   0x46A8             MOV      R8,R5
   \       0x1A   0xE00D             B.N      ??entropy_gather_internal_2
    272              {
    273                  if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
    274                      have_one_strong = 1;
    275          
    276                  olen = 0;
    277                  if( ( ret = ctx->source[i].f_source( ctx->source[i].p_source,
    278                                  buf, MBEDTLS_ENTROPY_MAX_GATHER, &olen ) ) != 0 )
    279                  {
    280                      goto cleanup;
    281                  }
    282          
    283                  /*
    284                   * Add if we actually gathered something
    285                   */
    286                  if( olen > 0 )
    287                  {
    288                      if( ( ret = entropy_update( ctx, (unsigned char) i,
    289                                                  buf, olen ) ) != 0 )
    290                          return( ret );
    291                      ctx->source[i].size += olen;
   \                     ??entropy_gather_internal_3: (+1)
   \       0x1C   0xFB06 0xF008      MUL      R0,R6,R8
   \       0x20   0x4438             ADD      R0,R7,R0
   \       0x22   0xF8D0 0x00EC      LDR      R0,[R0, #+236]
   \       0x26   0x9900             LDR      R1,[SP, #+0]
   \       0x28   0x1808             ADDS     R0,R1,R0
   \       0x2A   0xFB06 0xF608      MUL      R6,R6,R8
   \       0x2E   0x19B9             ADDS     R1,R7,R6
   \       0x30   0xF8C1 0x00EC      STR      R0,[R1, #+236]
   \                     ??entropy_gather_internal_4: (+1)
   \       0x34   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??entropy_gather_internal_2: (+1)
   \       0x38   0xF8D7 0x00E0      LDR      R0,[R7, #+224]
   \       0x3C   0x4580             CMP      R8,R0
   \       0x3E   0xDA28             BGE.N    ??entropy_gather_internal_5
   \       0x40   0x2614             MOVS     R6,#+20
   \       0x42   0xFB06 0xF008      MUL      R0,R6,R8
   \       0x46   0x4438             ADD      R0,R7,R0
   \       0x48   0xF8D0 0x00F4      LDR      R0,[R0, #+244]
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD100             BNE.N    ??entropy_gather_internal_6
   \       0x50   0x2501             MOVS     R5,#+1
   \                     ??entropy_gather_internal_6: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x9000             STR      R0,[SP, #+0]
   \       0x56   0x466B             MOV      R3,SP
   \       0x58   0x2280             MOVS     R2,#+128
   \       0x5A   0xA901             ADD      R1,SP,#+4
   \       0x5C   0xFB06 0xF008      MUL      R0,R6,R8
   \       0x60   0x4438             ADD      R0,R7,R0
   \       0x62   0xF8D0 0x00E8      LDR      R0,[R0, #+232]
   \       0x66   0xFB06 0xF408      MUL      R4,R6,R8
   \       0x6A   0x443C             ADD      R4,R7,R4
   \       0x6C   0xF8D4 0x40E4      LDR      R4,[R4, #+228]
   \       0x70   0x47A0             BLX      R4
   \       0x72   0x0004             MOVS     R4,R0
   \       0x74   0xD111             BNE.N    ??entropy_gather_internal_7
   \       0x76   0x9800             LDR      R0,[SP, #+0]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD0DB             BEQ.N    ??entropy_gather_internal_4
   \       0x7C   0x4603             MOV      R3,R0
   \       0x7E   0xAA01             ADD      R2,SP,#+4
   \       0x80   0x4640             MOV      R0,R8
   \       0x82   0x4601             MOV      R1,R0
   \       0x84   0xB2C9             UXTB     R1,R1
   \       0x86   0x4638             MOV      R0,R7
   \       0x88   0x....'....        BL       entropy_update
   \       0x8C   0x0004             MOVS     R4,R0
   \       0x8E   0xD0C5             BEQ.N    ??entropy_gather_internal_3
   \       0x90   0xE008             B.N      ??entropy_gather_internal_1
    292                  }
    293              }
    294          
    295              if( have_one_strong == 0 )
   \                     ??entropy_gather_internal_5: (+1)
   \       0x92   0x2D00             CMP      R5,#+0
   \       0x94   0xD101             BNE.N    ??entropy_gather_internal_7
    296                  ret = MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE;
   \       0x96   0xF06F 0x043C      MVN      R4,#+60
    297          
    298          cleanup:
    299              mbedtls_platform_zeroize( buf, sizeof( buf ) );
   \                     ??entropy_gather_internal_7: (+1)
   \       0x9A   0x2180             MOVS     R1,#+128
   \       0x9C   0xA801             ADD      R0,SP,#+4
   \       0x9E   0x....'....        BL       mbedtls_platform_zeroize
    300          
    301              return( ret );
   \       0xA2   0x4620             MOV      R0,R4
   \                     ??entropy_gather_internal_1: (+1)
   \       0xA4   0xB022             ADD      SP,SP,#+136
   \       0xA6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    302          }
    303          
    304          /*
    305           * Thread-safe wrapper for entropy_gather_internal()
    306           */

   \                                 In section .text, align 2, keep-with-next
    307          int mbedtls_entropy_gather( mbedtls_entropy_context *ctx )
    308          {
    309              int ret;
    310          
    311          #if defined(MBEDTLS_THREADING_C)
    312              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    313                  return( ret );
    314          #endif
    315          
    316              ret = entropy_gather_internal( ctx );
    317          
    318          #if defined(MBEDTLS_THREADING_C)
    319              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    320                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    321          #endif
    322          
    323              return( ret );
   \                     mbedtls_entropy_gather: (+1)
   \        0x0   0x....             B.N      entropy_gather_internal
    324          }
    325          

   \                                 In section .text, align 2, keep-with-next
    326          int mbedtls_entropy_func( void *data, unsigned char *output, size_t len )
    327          {
   \                     mbedtls_entropy_func: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB090             SUB      SP,SP,#+64
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4617             MOV      R7,R2
    328              int ret, count = 0, i, done;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    329              mbedtls_entropy_context *ctx = (mbedtls_entropy_context *) data;
    330              unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
    331          
    332              if( len > MBEDTLS_ENTROPY_BLOCK_SIZE )
   \       0x10   0x2F41             CMP      R7,#+65
   \       0x12   0xD302             BCC.N    ??mbedtls_entropy_func_0
    333                  return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );
   \       0x14   0xF06F 0x003B      MVN      R0,#+59
   \       0x18   0xE069             B.N      ??mbedtls_entropy_func_1
    334          
    335          #if defined(MBEDTLS_ENTROPY_NV_SEED)
    336              /* Update the NV entropy seed before generating any entropy for outside
    337               * use.
    338               */
    339              if( ctx->initial_entropy_run == 0 )
    340              {
    341                  ctx->initial_entropy_run = 1;
    342                  if( ( ret = mbedtls_entropy_update_nv_seed( ctx ) ) != 0 )
    343                      return( ret );
    344              }
    345          #endif
    346          
    347          #if defined(MBEDTLS_THREADING_C)
    348              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    349                  return( ret );
    350          #endif
    351          
    352              /*
    353               * Always gather extra entropy before a call
    354               */
    355              do
    356              {
    357                  if( count++ > ENTROPY_MAX_LOOP )
   \                     ??mbedtls_entropy_func_0: (+1)
   \       0x1A   0x4640             MOV      R0,R8
   \       0x1C   0xF100 0x0801      ADD      R8,R0,#+1
   \       0x20   0xF240 0x1101      MOVW     R1,#+257
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xDA07             BGE.N    ??mbedtls_entropy_func_2
    358                  {
    359                      ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
    360                      goto exit;
    361                  }
    362          
    363                  if( ( ret = entropy_gather_internal( ctx ) ) != 0 )
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       entropy_gather_internal
   \       0x2E   0x0004             MOVS     R4,R0
   \       0x30   0xD158             BNE.N    ??mbedtls_entropy_func_3
    364                      goto exit;
    365          
    366                  done = 1;
   \       0x32   0x2001             MOVS     R0,#+1
    367                  for( i = 0; i < ctx->source_count; i++ )
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0xE010             B.N      ??mbedtls_entropy_func_4
   \                     ??mbedtls_entropy_func_2: (+1)
   \       0x38   0xF06F 0x043B      MVN      R4,#+59
   \       0x3C   0xE052             B.N      ??mbedtls_entropy_func_3
    368                      if( ctx->source[i].size < ctx->source[i].threshold )
   \                     ??mbedtls_entropy_func_5: (+1)
   \       0x3E   0x2214             MOVS     R2,#+20
   \       0x40   0xFB02 0xF301      MUL      R3,R2,R1
   \       0x44   0x442B             ADD      R3,R5,R3
   \       0x46   0xF8D3 0x30EC      LDR      R3,[R3, #+236]
   \       0x4A   0x434A             MULS     R2,R2,R1
   \       0x4C   0x442A             ADD      R2,R5,R2
   \       0x4E   0xF8D2 0x20F0      LDR      R2,[R2, #+240]
   \       0x52   0x4293             CMP      R3,R2
   \       0x54   0xD200             BCS.N    ??mbedtls_entropy_func_6
    369                          done = 0;
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_entropy_func_6: (+1)
   \       0x58   0x1C49             ADDS     R1,R1,#+1
   \                     ??mbedtls_entropy_func_4: (+1)
   \       0x5A   0xF8D5 0x20E0      LDR      R2,[R5, #+224]
   \       0x5E   0x4291             CMP      R1,R2
   \       0x60   0xDBED             BLT.N    ??mbedtls_entropy_func_5
    370              }
    371              while( ! done );
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD0D9             BEQ.N    ??mbedtls_entropy_func_0
    372          
    373              memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0x2140             MOVS     R1,#+64
   \       0x6A   0x4668             MOV      R0,SP
   \       0x6C   0x....'....        BL       __aeabi_memset4
    374          
    375          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    376              /*
    377               * Note that at this stage it is assumed that the accumulator was started
    378               * in a previous call to entropy_update(). If this is not guaranteed, the
    379               * code below will fail.
    380               */
    381              if( ( ret = mbedtls_sha512_finish_ret( &ctx->accumulator, buf ) ) != 0 )
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x76   0x....'....        BL       mbedtls_sha512_finish_ret
   \       0x7A   0x0004             MOVS     R4,R0
   \       0x7C   0xD132             BNE.N    ??mbedtls_entropy_func_3
    382                  goto exit;
    383          
    384              /*
    385               * Reset accumulator and counters and recycle existing entropy
    386               */
    387              mbedtls_sha512_free( &ctx->accumulator );
   \       0x7E   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x82   0x....'....        BL       mbedtls_sha512_free
    388              mbedtls_sha512_init( &ctx->accumulator );
   \       0x86   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x8A   0x....'....        BL       mbedtls_sha512_init
    389              if( ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
   \       0x8E   0x2100             MOVS     R1,#+0
   \       0x90   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x94   0x....'....        BL       mbedtls_sha512_starts_ret
   \       0x98   0x0004             MOVS     R4,R0
   \       0x9A   0xD123             BNE.N    ??mbedtls_entropy_func_3
    390                  goto exit;
    391              if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, buf,
    392                                                     MBEDTLS_ENTROPY_BLOCK_SIZE ) ) != 0 )
   \       0x9C   0x2240             MOVS     R2,#+64
   \       0x9E   0x4669             MOV      R1,SP
   \       0xA0   0xF105 0x0008      ADD      R0,R5,#+8
   \       0xA4   0x....'....        BL       mbedtls_sha512_update_ret
   \       0xA8   0x0004             MOVS     R4,R0
   \       0xAA   0xD11B             BNE.N    ??mbedtls_entropy_func_3
    393                  goto exit;
    394          
    395              /*
    396               * Perform second SHA-512 on entropy
    397               */
    398              if( ( ret = mbedtls_sha512_ret( buf, MBEDTLS_ENTROPY_BLOCK_SIZE,
    399                                              buf, 0 ) ) != 0 )
   \       0xAC   0x2300             MOVS     R3,#+0
   \       0xAE   0x466A             MOV      R2,SP
   \       0xB0   0x2140             MOVS     R1,#+64
   \       0xB2   0x4668             MOV      R0,SP
   \       0xB4   0x....'....        BL       mbedtls_sha512_ret
   \       0xB8   0x0004             MOVS     R4,R0
   \       0xBA   0xD113             BNE.N    ??mbedtls_entropy_func_3
    400                  goto exit;
    401          #else /* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */
    402              if( ( ret = mbedtls_sha256_finish_ret( &ctx->accumulator, buf ) ) != 0 )
    403                  goto exit;
    404          
    405              /*
    406               * Reset accumulator and counters and recycle existing entropy
    407               */
    408              mbedtls_sha256_free( &ctx->accumulator );
    409              mbedtls_sha256_init( &ctx->accumulator );
    410              if( ( ret = mbedtls_sha256_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
    411                  goto exit;
    412              if( ( ret = mbedtls_sha256_update_ret( &ctx->accumulator, buf,
    413                                                     MBEDTLS_ENTROPY_BLOCK_SIZE ) ) != 0 )
    414                  goto exit;
    415          
    416              /*
    417               * Perform second SHA-256 on entropy
    418               */
    419              if( ( ret = mbedtls_sha256_ret( buf, MBEDTLS_ENTROPY_BLOCK_SIZE,
    420                                              buf, 0 ) ) != 0 )
    421                  goto exit;
    422          #endif /* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */
    423          
    424              for( i = 0; i < ctx->source_count; i++ )
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xE007             B.N      ??mbedtls_entropy_func_7
    425                  ctx->source[i].size = 0;
   \                     ??mbedtls_entropy_func_8: (+1)
   \       0xC0   0x2100             MOVS     R1,#+0
   \       0xC2   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \       0xC6   0xEB05 0x0282      ADD      R2,R5,R2, LSL #+2
   \       0xCA   0xF8C2 0x10EC      STR      R1,[R2, #+236]
   \       0xCE   0x1C40             ADDS     R0,R0,#+1
   \                     ??mbedtls_entropy_func_7: (+1)
   \       0xD0   0xF8D5 0x10E0      LDR      R1,[R5, #+224]
   \       0xD4   0x4288             CMP      R0,R1
   \       0xD6   0xDBF3             BLT.N    ??mbedtls_entropy_func_8
    426          
    427              memcpy( output, buf, len );
   \       0xD8   0x463A             MOV      R2,R7
   \       0xDA   0x4669             MOV      R1,SP
   \       0xDC   0x4630             MOV      R0,R6
   \       0xDE   0x....'....        BL       __aeabi_memcpy
    428          
    429              ret = 0;
   \       0xE2   0x2400             MOVS     R4,#+0
    430          
    431          exit:
    432              mbedtls_platform_zeroize( buf, sizeof( buf ) );
   \                     ??mbedtls_entropy_func_3: (+1)
   \       0xE4   0x2140             MOVS     R1,#+64
   \       0xE6   0x4668             MOV      R0,SP
   \       0xE8   0x....'....        BL       mbedtls_platform_zeroize
    433          
    434          #if defined(MBEDTLS_THREADING_C)
    435              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    436                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    437          #endif
    438          
    439              return( ret );
   \       0xEC   0x4620             MOV      R0,R4
   \                     ??mbedtls_entropy_func_1: (+1)
   \       0xEE   0xB010             ADD      SP,SP,#+64
   \       0xF0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    440          }
    441          
    442          #if defined(MBEDTLS_ENTROPY_NV_SEED)
    443          int mbedtls_entropy_update_nv_seed( mbedtls_entropy_context *ctx )
    444          {
    445              int ret = MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR;
    446              unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
    447          
    448              /* Read new seed  and write it to NV */
    449              if( ( ret = mbedtls_entropy_func( ctx, buf, MBEDTLS_ENTROPY_BLOCK_SIZE ) ) != 0 )
    450                  return( ret );
    451          
    452              if( mbedtls_nv_seed_write( buf, MBEDTLS_ENTROPY_BLOCK_SIZE ) < 0 )
    453                  return( MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR );
    454          
    455              /* Manually update the remaining stream with a separator value to diverge */
    456              memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );
    457              ret = mbedtls_entropy_update_manual( ctx, buf, MBEDTLS_ENTROPY_BLOCK_SIZE );
    458          
    459              return( ret );
    460          }
    461          #endif /* MBEDTLS_ENTROPY_NV_SEED */
    462          
    463          #if defined(MBEDTLS_FS_IO)
    464          int mbedtls_entropy_write_seed_file( mbedtls_entropy_context *ctx, const char *path )
    465          {
    466              int ret = MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR;
    467              FILE *f;
    468              unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
    469          
    470              if( ( f = fopen( path, "wb" ) ) == NULL )
    471                  return( MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR );
    472          
    473              if( ( ret = mbedtls_entropy_func( ctx, buf, MBEDTLS_ENTROPY_BLOCK_SIZE ) ) != 0 )
    474                  goto exit;
    475          
    476              if( fwrite( buf, 1, MBEDTLS_ENTROPY_BLOCK_SIZE, f ) != MBEDTLS_ENTROPY_BLOCK_SIZE )
    477              {
    478                  ret = MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR;
    479                  goto exit;
    480              }
    481          
    482              ret = 0;
    483          
    484          exit:
    485              mbedtls_platform_zeroize( buf, sizeof( buf ) );
    486          
    487              fclose( f );
    488              return( ret );
    489          }
    490          
    491          int mbedtls_entropy_update_seed_file( mbedtls_entropy_context *ctx, const char *path )
    492          {
    493              int ret = 0;
    494              FILE *f;
    495              size_t n;
    496              unsigned char buf[ MBEDTLS_ENTROPY_MAX_SEED_SIZE ];
    497          
    498              if( ( f = fopen( path, "rb" ) ) == NULL )
    499                  return( MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR );
    500          
    501              fseek( f, 0, SEEK_END );
    502              n = (size_t) ftell( f );
    503              fseek( f, 0, SEEK_SET );
    504          
    505              if( n > MBEDTLS_ENTROPY_MAX_SEED_SIZE )
    506                  n = MBEDTLS_ENTROPY_MAX_SEED_SIZE;
    507          
    508              if( fread( buf, 1, n, f ) != n )
    509                  ret = MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR;
    510              else
    511                  ret = mbedtls_entropy_update_manual( ctx, buf, n );
    512          
    513              fclose( f );
    514          
    515              mbedtls_platform_zeroize( buf, sizeof( buf ) );
    516          
    517              if( ret != 0 )
    518                  return( ret );
    519          
    520              return( mbedtls_entropy_write_seed_file( ctx, path ) );
    521          }
    522          #endif /* MBEDTLS_FS_IO */
    523          
    524          #if defined(MBEDTLS_SELF_TEST)
    525          #if !defined(MBEDTLS_TEST_NULL_ENTROPY)
    526          /*
    527           * Dummy source function
    528           */

   \                                 In section .text, align 2, keep-with-next
    529          static int entropy_dummy_source( void *data, unsigned char *output,
    530                                           size_t len, size_t *olen )
    531          {
   \                     entropy_dummy_source: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4608             MOV      R0,R1
   \        0x4   0x4614             MOV      R4,R2
   \        0x6   0x461D             MOV      R5,R3
    532              ((void) data);
    533          
    534              memset( output, 0x2a, len );
   \        0x8   0x222A             MOVS     R2,#+42
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0x....'....        BL       __aeabi_memset
    535              *olen = len;
   \       0x10   0x602C             STR      R4,[R5, #+0]
    536          
    537              return( 0 );
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    538          }
    539          #endif /* !MBEDTLS_TEST_NULL_ENTROPY */
    540          
    541          #if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
    542          

   \                                 In section .text, align 2, keep-with-next
    543          static int mbedtls_entropy_source_self_test_gather( unsigned char *buf, size_t buf_len )
    544          {
   \                     mbedtls_entropy_source_self_test_gather: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    545              int ret = 0;
   \        0x6   0x2000             MOVS     R0,#+0
    546              size_t entropy_len = 0;
   \        0x8   0x4607             MOV      R7,R0
    547              size_t olen = 0;
   \        0xA   0x4601             MOV      R1,R0
   \        0xC   0x9100             STR      R1,[SP, #+0]
    548              size_t attempts = buf_len;
   \        0xE   0x4634             MOV      R4,R6
    549          
    550              while( attempts > 0 && entropy_len < buf_len )
   \                     ??mbedtls_entropy_source_self_test_gather_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD00D             BEQ.N    ??mbedtls_entropy_source_self_test_gather_1
   \       0x14   0x42B7             CMP      R7,R6
   \       0x16   0xD20B             BCS.N    ??mbedtls_entropy_source_self_test_gather_1
    551              {
    552                  if( ( ret = mbedtls_hardware_poll( NULL, buf + entropy_len,
    553                      buf_len - entropy_len, &olen ) ) != 0 )
   \       0x18   0x466B             MOV      R3,SP
   \       0x1A   0x1BF2             SUBS     R2,R6,R7
   \       0x1C   0x19E9             ADDS     R1,R5,R7
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x....'....        BL       mbedtls_hardware_poll
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD106             BNE.N    ??mbedtls_entropy_source_self_test_gather_2
    554                      return( ret );
    555          
    556                  entropy_len += olen;
   \       0x28   0x9900             LDR      R1,[SP, #+0]
   \       0x2A   0x19CF             ADDS     R7,R1,R7
    557                  attempts--;
   \       0x2C   0x1E64             SUBS     R4,R4,#+1
   \       0x2E   0xE7EF             B.N      ??mbedtls_entropy_source_self_test_gather_0
    558              }
    559          
    560              if( entropy_len < buf_len )
   \                     ??mbedtls_entropy_source_self_test_gather_1: (+1)
   \       0x30   0x42B7             CMP      R7,R6
   \       0x32   0xD200             BCS.N    ??mbedtls_entropy_source_self_test_gather_2
    561              {
    562                  ret = 1;
   \       0x34   0x2001             MOVS     R0,#+1
    563              }
    564          
    565              return( ret );
   \                     ??mbedtls_entropy_source_self_test_gather_2: (+1)
   \       0x36   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    566          }
    567          
    568          

   \                                 In section .text, align 2, keep-with-next
    569          static int mbedtls_entropy_source_self_test_check_bits( const unsigned char *buf,
    570                                                                  size_t buf_len )
    571          {
   \                     mbedtls_entropy_source_self_test_check_bits: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    572              unsigned char set= 0xFF;
   \        0x2   0x22FF             MOVS     R2,#+255
    573              unsigned char unset = 0x00;
   \        0x4   0x2300             MOVS     R3,#+0
    574              size_t i;
    575          
    576              for( i = 0; i < buf_len; i++ )
   \        0x6   0x461C             MOV      R4,R3
   \        0x8   0xE003             B.N      ??mbedtls_entropy_source_self_test_check_bits_0
    577              {
    578                  set &= buf[i];
   \                     ??mbedtls_entropy_source_self_test_check_bits_1: (+1)
   \        0xA   0x5D05             LDRB     R5,[R0, R4]
   \        0xC   0x402A             ANDS     R2,R5,R2
    579                  unset |= buf[i];
   \        0xE   0x432B             ORRS     R3,R5,R3
    580              }
   \       0x10   0x1C64             ADDS     R4,R4,#+1
   \                     ??mbedtls_entropy_source_self_test_check_bits_0: (+1)
   \       0x12   0x428C             CMP      R4,R1
   \       0x14   0xD3F9             BCC.N    ??mbedtls_entropy_source_self_test_check_bits_1
    581          
    582              return( set == 0xFF || unset == 0x00 );
   \       0x16   0x2AFF             CMP      R2,#+255
   \       0x18   0xD005             BEQ.N    ??mbedtls_entropy_source_self_test_check_bits_2
   \       0x1A   0x4618             MOV      R0,R3
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x1E40             SUBS     R0,R0,#+1
   \       0x20   0x4180             SBCS     R0,R0,R0
   \       0x22   0x0FC0             LSRS     R0,R0,#+31
   \       0x24   0xE000             B.N      ??mbedtls_entropy_source_self_test_check_bits_3
   \                     ??mbedtls_entropy_source_self_test_check_bits_2: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \                     ??mbedtls_entropy_source_self_test_check_bits_3: (+1)
   \       0x28   0xBC30             POP      {R4,R5}
   \       0x2A   0x4770             BX       LR               ;; return
    583          }
    584          
    585          /*
    586           * A test to ensure hat the entropy sources are functioning correctly
    587           * and there is no obvious failure. The test performs the following checks:
    588           *  - The entropy source is not providing only 0s (all bits unset) or 1s (all
    589           *    bits set).
    590           *  - The entropy source is not providing values in a pattern. Because the
    591           *    hardware could be providing data in an arbitrary length, this check polls
    592           *    the hardware entropy source twice and compares the result to ensure they
    593           *    are not equal.
    594           *  - The error code returned by the entropy source is not an error.
    595           */

   \                                 In section .text, align 2, keep-with-next
    596          int mbedtls_entropy_source_self_test( int verbose )
    597          {
   \                     mbedtls_entropy_source_self_test: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x0005             MOVS     R5,R0
    598              int ret = 0;
    599              unsigned char buf0[2 * sizeof( unsigned long long int )];
    600              unsigned char buf1[2 * sizeof( unsigned long long int )];
    601          
    602              if( verbose != 0 )
   \        0x6   0xD002             BEQ.N    ??mbedtls_entropy_source_self_test_0
    603                  mbedtls_printf( "  ENTROPY_BIAS test: " );
   \        0x8   0x....             LDR.N    R0,??DataTable2_3
   \        0xA   0x....'....        BL       DbgConsole_Printf
    604          
    605              memset( buf0, 0x00, sizeof( buf0 ) );
   \                     ??mbedtls_entropy_source_self_test_0: (+1)
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x2110             MOVS     R1,#+16
   \       0x12   0xA804             ADD      R0,SP,#+16
   \       0x14   0x....'....        BL       __aeabi_memset4
    606              memset( buf1, 0x00, sizeof( buf1 ) );
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x2110             MOVS     R1,#+16
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x....'....        BL       __aeabi_memset4
    607          
    608              if( ( ret = mbedtls_entropy_source_self_test_gather( buf0, sizeof( buf0 ) ) ) != 0 )
   \       0x22   0x2110             MOVS     R1,#+16
   \       0x24   0xA804             ADD      R0,SP,#+16
   \       0x26   0x....'....        BL       mbedtls_entropy_source_self_test_gather
   \       0x2A   0x0004             MOVS     R4,R0
   \       0x2C   0xD119             BNE.N    ??mbedtls_entropy_source_self_test_1
    609                  goto cleanup;
    610              if( ( ret = mbedtls_entropy_source_self_test_gather( buf1, sizeof( buf1 ) ) ) != 0 )
   \       0x2E   0x2110             MOVS     R1,#+16
   \       0x30   0x4668             MOV      R0,SP
   \       0x32   0x....'....        BL       mbedtls_entropy_source_self_test_gather
   \       0x36   0x0004             MOVS     R4,R0
   \       0x38   0xD113             BNE.N    ??mbedtls_entropy_source_self_test_1
    611                  goto cleanup;
    612          
    613              /* Make sure that the returned values are not all 0 or 1 */
    614              if( ( ret = mbedtls_entropy_source_self_test_check_bits( buf0, sizeof( buf0 ) ) ) != 0 )
   \       0x3A   0x2110             MOVS     R1,#+16
   \       0x3C   0xA804             ADD      R0,SP,#+16
   \       0x3E   0x....'....        BL       mbedtls_entropy_source_self_test_check_bits
   \       0x42   0x0004             MOVS     R4,R0
   \       0x44   0xD10D             BNE.N    ??mbedtls_entropy_source_self_test_1
    615                  goto cleanup;
    616              if( ( ret = mbedtls_entropy_source_self_test_check_bits( buf1, sizeof( buf1 ) ) ) != 0 )
   \       0x46   0x2110             MOVS     R1,#+16
   \       0x48   0x4668             MOV      R0,SP
   \       0x4A   0x....'....        BL       mbedtls_entropy_source_self_test_check_bits
   \       0x4E   0x0004             MOVS     R4,R0
   \       0x50   0xD107             BNE.N    ??mbedtls_entropy_source_self_test_1
    617                  goto cleanup;
    618          
    619              /* Make sure that the entropy source is not returning values in a
    620               * pattern */
    621              ret = memcmp( buf0, buf1, sizeof( buf0 ) ) == 0;
   \       0x52   0x2210             MOVS     R2,#+16
   \       0x54   0x4669             MOV      R1,SP
   \       0x56   0xA804             ADD      R0,SP,#+16
   \       0x58   0x....'....        BL       memcmp
   \       0x5C   0x1E44             SUBS     R4,R0,#+1
   \       0x5E   0x41A4             SBCS     R4,R4,R4
   \       0x60   0x0FE4             LSRS     R4,R4,#+31
    622          
    623          cleanup:
    624              if( verbose != 0 )
   \                     ??mbedtls_entropy_source_self_test_1: (+1)
   \       0x62   0x2D00             CMP      R5,#+0
   \       0x64   0xD00B             BEQ.N    ??mbedtls_entropy_source_self_test_2
    625              {
    626                  if( ret != 0 )
   \       0x66   0x2C00             CMP      R4,#+0
   \       0x68   0xD003             BEQ.N    ??mbedtls_entropy_source_self_test_3
    627                      mbedtls_printf( "failed\n" );
   \       0x6A   0x....             LDR.N    R0,??DataTable2_4
   \       0x6C   0x....'....        BL       DbgConsole_Printf
   \       0x70   0xE002             B.N      ??mbedtls_entropy_source_self_test_4
    628                  else
    629                      mbedtls_printf( "passed\n" );
   \                     ??mbedtls_entropy_source_self_test_3: (+1)
   \       0x72   0x....             LDR.N    R0,??DataTable2_5
   \       0x74   0x....'....        BL       DbgConsole_Printf
    630          
    631                  mbedtls_printf( "\n" );
   \                     ??mbedtls_entropy_source_self_test_4: (+1)
   \       0x78   0x....             ADR.N    R0,??DataTable2  ;; "\n"
   \       0x7A   0x....'....        BL       DbgConsole_Printf
    632              }
    633          
    634              return( ret != 0 );
   \                     ??mbedtls_entropy_source_self_test_2: (+1)
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0x1E40             SUBS     R0,R0,#+1
   \       0x82   0x4180             SBCS     R0,R0,R0
   \       0x84   0x43C0             MVNS     R0,R0
   \       0x86   0x0FC0             LSRS     R0,R0,#+31
   \       0x88   0xB009             ADD      SP,SP,#+36
   \       0x8A   0xBD30             POP      {R4,R5,PC}       ;; return
    635          }
    636          
    637          #endif /* MBEDTLS_ENTROPY_HARDWARE_ALT */
    638          
    639          /*
    640           * The actual entropy quality is hard to test, but we can at least
    641           * test that the functions don't cause errors and write the correct
    642           * amount of data to buffers.
    643           */

   \                                 In section .text, align 2, keep-with-next
    644          int mbedtls_entropy_self_test( int verbose )
    645          {
   \                     mbedtls_entropy_self_test: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xF5AD 0x7D40      SUB      SP,SP,#+768
   \        0x6   0x4605             MOV      R5,R0
    646              int ret = 1;
    647          #if !defined(MBEDTLS_TEST_NULL_ENTROPY)
    648              mbedtls_entropy_context ctx;
    649              unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE] = { 0 };
   \        0x8   0xA811             ADD      R0,SP,#+68
   \        0xA   0x2140             MOVS     R1,#+64
   \        0xC   0x....'....        BL       __aeabi_memclr4
    650              unsigned char acc[MBEDTLS_ENTROPY_BLOCK_SIZE] = { 0 };
   \       0x10   0xA801             ADD      R0,SP,#+4
   \       0x12   0x2140             MOVS     R1,#+64
   \       0x14   0x....'....        BL       __aeabi_memclr4
    651              size_t i, j;
    652          #endif /* !MBEDTLS_TEST_NULL_ENTROPY */
    653          
    654              if( verbose != 0 )
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD002             BEQ.N    ??mbedtls_entropy_self_test_0
    655                  mbedtls_printf( "  ENTROPY test: " );
   \       0x1C   0x....             LDR.N    R0,??DataTable2_6
   \       0x1E   0x....'....        BL       DbgConsole_Printf
    656          
    657          #if !defined(MBEDTLS_TEST_NULL_ENTROPY)
    658              mbedtls_entropy_init( &ctx );
   \                     ??mbedtls_entropy_self_test_0: (+1)
   \       0x22   0xA822             ADD      R0,SP,#+136
   \       0x24   0x....'....        BL       mbedtls_entropy_init
    659          
    660              /* First do a gather to make sure we have default sources */
    661              if( ( ret = mbedtls_entropy_gather( &ctx ) ) != 0 )
   \       0x28   0xA822             ADD      R0,SP,#+136
   \       0x2A   0x....'....        BL       mbedtls_entropy_gather
   \       0x2E   0x0004             MOVS     R4,R0
   \       0x30   0xD144             BNE.N    ??mbedtls_entropy_self_test_1
    662                  goto cleanup;
    663          
    664              ret = mbedtls_entropy_add_source( &ctx, entropy_dummy_source, NULL, 16,
    665                                                MBEDTLS_ENTROPY_SOURCE_WEAK );
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x2310             MOVS     R3,#+16
   \       0x38   0x4602             MOV      R2,R0
   \       0x3A   0x....             LDR.N    R1,??DataTable2_7
   \       0x3C   0xA822             ADD      R0,SP,#+136
   \       0x3E   0x....'....        BL       mbedtls_entropy_add_source
   \       0x42   0x0004             MOVS     R4,R0
    666              if( ret != 0 )
   \       0x44   0xD13A             BNE.N    ??mbedtls_entropy_self_test_1
    667                  goto cleanup;
    668          
    669              if( ( ret = mbedtls_entropy_update_manual( &ctx, buf, sizeof buf ) ) != 0 )
   \       0x46   0x2240             MOVS     R2,#+64
   \       0x48   0xA911             ADD      R1,SP,#+68
   \       0x4A   0xA822             ADD      R0,SP,#+136
   \       0x4C   0x....'....        BL       mbedtls_entropy_update_manual
   \       0x50   0x0004             MOVS     R4,R0
   \       0x52   0xD133             BNE.N    ??mbedtls_entropy_self_test_1
    670                  goto cleanup;
    671          
    672              /*
    673               * To test that mbedtls_entropy_func writes correct number of bytes:
    674               * - use the whole buffer and rely on ASan to detect overruns
    675               * - collect entropy 8 times and OR the result in an accumulator:
    676               *   any byte should then be 0 with probably 2^(-64), so requiring
    677               *   each of the 32 or 64 bytes to be non-zero has a false failure rate
    678               *   of at most 2^(-58) which is acceptable.
    679               */
    680              for( i = 0; i < 8; i++ )
   \       0x54   0x2600             MOVS     R6,#+0
   \       0x56   0xE008             B.N      ??mbedtls_entropy_self_test_2
    681              {
    682                  if( ( ret = mbedtls_entropy_func( &ctx, buf, sizeof( buf ) ) ) != 0 )
    683                      goto cleanup;
    684          
    685                  for( j = 0; j < sizeof( buf ); j++ )
    686                      acc[j] |= buf[j];
   \                     ??mbedtls_entropy_self_test_3: (+1)
   \       0x58   0x5C0A             LDRB     R2,[R1, R0]
   \       0x5A   0xAB11             ADD      R3,SP,#+68
   \       0x5C   0x5C1B             LDRB     R3,[R3, R0]
   \       0x5E   0x431A             ORRS     R2,R3,R2
   \       0x60   0x540A             STRB     R2,[R1, R0]
   \       0x62   0x1C40             ADDS     R0,R0,#+1
   \                     ??mbedtls_entropy_self_test_4: (+1)
   \       0x64   0x2840             CMP      R0,#+64
   \       0x66   0xD3F7             BCC.N    ??mbedtls_entropy_self_test_3
   \       0x68   0x1C76             ADDS     R6,R6,#+1
   \                     ??mbedtls_entropy_self_test_2: (+1)
   \       0x6A   0x2E08             CMP      R6,#+8
   \       0x6C   0xD209             BCS.N    ??mbedtls_entropy_self_test_5
   \       0x6E   0x2240             MOVS     R2,#+64
   \       0x70   0xA911             ADD      R1,SP,#+68
   \       0x72   0xA822             ADD      R0,SP,#+136
   \       0x74   0x....'....        BL       mbedtls_entropy_func
   \       0x78   0x0004             MOVS     R4,R0
   \       0x7A   0xD11F             BNE.N    ??mbedtls_entropy_self_test_1
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xA901             ADD      R1,SP,#+4
   \       0x80   0xE7F0             B.N      ??mbedtls_entropy_self_test_4
    687              }
    688          
    689              for( j = 0; j < sizeof( buf ); j++ )
   \                     ??mbedtls_entropy_self_test_5: (+1)
   \       0x82   0x2100             MOVS     R1,#+0
   \       0x84   0xE000             B.N      ??mbedtls_entropy_self_test_6
   \                     ??mbedtls_entropy_self_test_7: (+1)
   \       0x86   0x1C49             ADDS     R1,R1,#+1
   \                     ??mbedtls_entropy_self_test_6: (+1)
   \       0x88   0x2940             CMP      R1,#+64
   \       0x8A   0xD213             BCS.N    ??mbedtls_entropy_self_test_8
    690              {
    691                  if( acc[j] == 0 )
   \       0x8C   0xA801             ADD      R0,SP,#+4
   \       0x8E   0x5C40             LDRB     R0,[R0, R1]
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD1F8             BNE.N    ??mbedtls_entropy_self_test_7
    692                  {
    693                      ret = 1;
   \       0x94   0x2401             MOVS     R4,#+1
    694                      goto cleanup;
   \       0x96   0xE011             B.N      ??mbedtls_entropy_self_test_1
    695                  }
    696              }
    697          
    698          #if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
    699              if( ( ret = mbedtls_entropy_source_self_test( 0 ) ) != 0 )
    700                  goto cleanup;
    701          #endif
    702          
    703          cleanup:
    704              mbedtls_entropy_free( &ctx );
    705          #endif /* !MBEDTLS_TEST_NULL_ENTROPY */
    706          
    707              if( verbose != 0 )
    708              {
    709                  if( ret != 0 )
    710                      mbedtls_printf( "failed\n\r" );
    711                  else
    712                      mbedtls_printf( "passed\n\r" );
   \                     ??mbedtls_entropy_self_test_9: (+1)
   \       0x98   0x....             LDR.N    R0,??DataTable2_8
   \       0x9A   0x....'....        BL       DbgConsole_Printf
    713          
    714                  mbedtls_printf( "\n\r" );
   \                     ??mbedtls_entropy_self_test_10: (+1)
   \       0x9E   0x....             ADR.N    R0,??DataTable2_1  ;; 0x0A, 0x0D, 0x00, 0x00
   \       0xA0   0x....'....        BL       DbgConsole_Printf
    715              }
    716          
    717              return( ret != 0 );
   \                     ??mbedtls_entropy_self_test_11: (+1)
   \       0xA4   0x4620             MOV      R0,R4
   \       0xA6   0x1E40             SUBS     R0,R0,#+1
   \       0xA8   0x4180             SBCS     R0,R0,R0
   \       0xAA   0x43C0             MVNS     R0,R0
   \       0xAC   0x0FC0             LSRS     R0,R0,#+31
   \       0xAE   0xF50D 0x7D40      ADD      SP,SP,#+768
   \       0xB2   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??mbedtls_entropy_self_test_8: (+1)
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x....'....        BL       mbedtls_entropy_source_self_test
   \       0xBA   0x4604             MOV      R4,R0
   \                     ??mbedtls_entropy_self_test_1: (+1)
   \       0xBC   0xA822             ADD      R0,SP,#+136
   \       0xBE   0x....'....        BL       mbedtls_entropy_free
   \       0xC2   0x2D00             CMP      R5,#+0
   \       0xC4   0xD0EE             BEQ.N    ??mbedtls_entropy_self_test_11
   \       0xC6   0x2C00             CMP      R4,#+0
   \       0xC8   0xD0E6             BEQ.N    ??mbedtls_entropy_self_test_9
   \       0xCA   0x....             LDR.N    R0,??DataTable2_9
   \       0xCC   0x....'....        BL       DbgConsole_Printf
   \       0xD0   0xE7E5             B.N      ??mbedtls_entropy_self_test_10
    718          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x0A 0x0D          DC8      0x0A, 0x0D, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     mbedtls_hardware_poll

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \        0x0   0x....'....        DC32     entropy_dummy_source

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x20 0x20          DC8 "  ENTROPY_BIAS test: "
   \              0x45 0x4E    
   \              0x54 0x52    
   \              0x4F 0x50    
   \              0x59 0x5F    
   \              0x42 0x49    
   \              0x41 0x53    
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x3A    
   \              0x20 0x00    
   \       0x16   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x66 0x61          DC8 "failed\012"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x70 0x61          DC8 "passed\012"
   \              0x73 0x73    
   \              0x65 0x64    
   \              0x0A 0x00    

   \                                 In section .rodata, align 2
   \        0x0   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x17   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x2E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x17   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x2E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x20 0x20          DC8 "  ENTROPY test: "
   \              0x45 0x4E    
   \              0x54 0x52    
   \              0x4F 0x50    
   \              0x59 0x20    
   \              0x74 0x65    
   \              0x73 0x74    
   \              0x3A 0x20    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x66 0x61          DC8 "failed\012\015"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x70 0x61          DC8 "passed\012\015"
   \              0x73 0x73    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \        0x0   0x0A 0x0D          DC8 "\012\015"
   \              0x00         
   \        0x3   0x00               DC8 0
    719          #endif /* MBEDTLS_SELF_TEST */
    720          
    721          #endif /* MBEDTLS_ENTROPY_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   entropy_dummy_source
        16   -> __aeabi_memset
     160   entropy_gather_internal
       160   -- Indirect call
       160   -> entropy_update
       160   -> mbedtls_platform_zeroize
      96   entropy_update
        96   -> mbedtls_platform_zeroize
        96   -> mbedtls_sha512_ret
        96   -> mbedtls_sha512_starts_ret
        96   -> mbedtls_sha512_update_ret
      16   mbedtls_entropy_add_source
       8   mbedtls_entropy_free
         8   -> mbedtls_platform_zeroize
         8   -> mbedtls_sha512_free
      88   mbedtls_entropy_func
        88   -> __aeabi_memcpy
        88   -> __aeabi_memset4
        88   -> entropy_gather_internal
        88   -> mbedtls_platform_zeroize
        88   -> mbedtls_sha512_finish_ret
        88   -> mbedtls_sha512_free
        88   -> mbedtls_sha512_init
        88   -> mbedtls_sha512_ret
        88   -> mbedtls_sha512_starts_ret
        88   -> mbedtls_sha512_update_ret
       0   mbedtls_entropy_gather
         0   -> entropy_gather_internal
      16   mbedtls_entropy_init
        16   -> __aeabi_memset4
        16   -> mbedtls_entropy_add_source
        16   -> mbedtls_sha512_init
     784   mbedtls_entropy_self_test
       784   -> DbgConsole_Printf
       784   -> __aeabi_memclr4
       784   -> mbedtls_entropy_add_source
       784   -> mbedtls_entropy_free
       784   -> mbedtls_entropy_func
       784   -> mbedtls_entropy_gather
       784   -> mbedtls_entropy_init
       784   -> mbedtls_entropy_source_self_test
       784   -> mbedtls_entropy_update_manual
      48   mbedtls_entropy_source_self_test
        48   -> DbgConsole_Printf
        48   -> __aeabi_memset4
        48   -> mbedtls_entropy_source_self_test_check_bits
        48   -> mbedtls_entropy_source_self_test_gather
        48   -> memcmp
       8   mbedtls_entropy_source_self_test_check_bits
      24   mbedtls_entropy_source_self_test_gather
        24   -> mbedtls_hardware_poll
       0   mbedtls_entropy_update_manual
         0   -> entropy_update


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      24  ?_0
       8  ?_1
       8  ?_2
       2  ?_3
      64  ?_4
      64  ?_5
      20  ?_6
      12  ?_7
      12  ?_8
       4  ?_9
      22  entropy_dummy_source
     170  entropy_gather_internal
     118  entropy_update
      72  mbedtls_entropy_add_source
      36  mbedtls_entropy_free
     244  mbedtls_entropy_func
       2  mbedtls_entropy_gather
      56  mbedtls_entropy_init
     210  mbedtls_entropy_self_test
     140  mbedtls_entropy_source_self_test
      44  mbedtls_entropy_source_self_test_check_bits
      56  mbedtls_entropy_source_self_test_gather
       8  mbedtls_entropy_update_manual

 
   218 bytes in section .rodata
 1 218 bytes in section .text
 
 1 218 bytes of CODE  memory
   218 bytes of CONST memory

Errors: none
Warnings: none
