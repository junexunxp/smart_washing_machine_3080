###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:31
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\component\kv\kv.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW92C.tmp
#        (C:\Development\smart_washing_machine_3080\component\kv\kv.c -D DEBUG
#        -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1 -D
#        CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\kv.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\kv.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\component\kv\kv.c
      1          /*
      2           * Copyright (C) 2015-2017 Alibaba Group Holding Limited
      3           */
      4          
      5          #include "kv_api.h"
      6          #include "kv_adapt.h"
      7          #include "kv_types.h"
      8          

   \                                 In section .bss, align 4
      9          static kv_mgr_t g_kv_mgr;
   \                     g_kv_mgr:
   \        0x0                      DS8 144
     10          
     11          static void kv_gc_task(void *arg);
     12          
     13          kv_item_t *kv_item_traverse(item_func func, uint8_t blk_idx, const char *key);
     14          
     15          extern void kv_register_cli_command(void);
     16          
     17          /******************************************************/
     18          /****************** Internal Interface ****************/
     19          /******************************************************/
     20          
     21          /**
     22           * @brief CRC-8: the poly is 0x31 (x^8 + x^5 + x^4 + 1)
     23           *
     24           * @param[in] buf       the buffer which is need calculate crc
     25           * @param[in] length    the length of the buffer
     26           *
     27           * @return the crc value
     28           */

   \                                 In section .text, align 2, keep-with-next
     29          static uint8_t calc_crc8(uint8_t *buf, uint16_t length)
     30          {
   \                     calc_crc8: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x4602             MOV      R2,R0
     31              uint8_t crc = 0x00;
   \        0x4   0x2000             MOVS     R0,#+0
     32              uint8_t i = 0;
     33          
     34              while (length--) {
   \                     ??calc_crc8_0: (+1)
   \        0x6   0x460B             MOV      R3,R1
   \        0x8   0x1E59             SUBS     R1,R3,#+1
   \        0xA   0xB29B             UXTH     R3,R3
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD010             BEQ.N    ??calc_crc8_1
     35                  crc ^= *buf++;
   \       0x10   0xF812 0x3B01      LDRB     R3,[R2], #+1
   \       0x14   0x4058             EORS     R0,R3,R0
     36                  for (i = 8; i > 0; i--) {
   \       0x16   0x2308             MOVS     R3,#+8
   \                     ??calc_crc8_2: (+1)
   \       0x18   0x461C             MOV      R4,R3
   \       0x1A   0xB2E4             UXTB     R4,R4
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD0F2             BEQ.N    ??calc_crc8_0
     37                      if (crc & 0x80) {
   \       0x20   0x0604             LSLS     R4,R0,#+24
   \       0x22   0xD401             BMI.N    ??calc_crc8_3
     38                          crc = (crc << 1) ^ 0x31;
     39                      } else {
     40                          crc <<= 1;
   \       0x24   0x0040             LSLS     R0,R0,#+1
   \       0x26   0xE002             B.N      ??calc_crc8_4
     41                      }
   \                     ??calc_crc8_3: (+1)
   \       0x28   0x0040             LSLS     R0,R0,#+1
   \       0x2A   0xF080 0x0031      EOR      R0,R0,#0x31
     42                  }
   \                     ??calc_crc8_4: (+1)
   \       0x2E   0x1E5B             SUBS     R3,R3,#+1
   \       0x30   0xE7F2             B.N      ??calc_crc8_2
     43              }
     44          
     45              return crc;
   \                     ??calc_crc8_1: (+1)
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0xBC10             POP      {R4}
   \       0x36   0x4770             BX       LR               ;; return
     46          }
     47          
     48          /**
     49           * @brief Trigger garbage collection process
     50           *
     51           * @return none
     52           */

   \                                 In section .text, align 2, keep-with-next
     53          static void kv_trigger_gc(void)
     54          {
     55              if (g_kv_mgr.gc_trigger != 0) {
   \                     kv_trigger_gc: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable20
   \        0x4   0x7848             LDRB     R0,[R1, #+1]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD10C             BNE.N    ??kv_trigger_gc_0
     56                  return;
     57              }
     58          
     59              g_kv_mgr.gc_waiter  = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x7088             STRB     R0,[R1, #+2]
     60              g_kv_mgr.gc_trigger = 1;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x7048             STRB     R0,[R1, #+1]
     61              kv_start_task("kv_gc", kv_gc_task, NULL, KV_TASK_STACK_SIZE);
   \       0x12   0xF44F 0x6380      MOV      R3,#+1024
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x....'....        ADR.W    R1,kv_gc_task
   \       0x1C   0x....'....        LDR.W    R0,??DataTable20_1
   \       0x20   0x....'....        B.W      kv_start_task
   \                     ??kv_trigger_gc_0: (+1)
   \       0x24   0x4770             BX       LR               ;; return
     62          }
     63          
     64          /**
     65           * @brief Free item resource
     66           *
     67           * @param[in] item pointer to item
     68           *
     69           * @return none
     70           */

   \                                 In section .text, align 2, keep-with-next
     71          static void kv_item_free(kv_item_t *item)
     72          {
   \                     kv_item_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     73              if (item) {
   \        0x4   0xD009             BEQ.N    ??kv_item_free_0
     74                  if (item->store) {
   \        0x6   0x68E0             LDR      R0,[R4, #+12]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD001             BEQ.N    ??kv_item_free_1
     75                      kv_free(item->store);
   \        0xC   0x....'....        BL       kv_free
     76                  }
     77                  kv_free(item);
   \                     ??kv_item_free_1: (+1)
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0xE8BD 0x4010      POP      {R4,LR}
   \       0x16   0x....'....        B.W      kv_free
     78              }
     79          }
   \                     ??kv_item_free_0: (+1)
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
     80          
     81          /**
     82           * @brief Set block state bit
     83           *
     84           * @param[in]  blk_idx   the position of the block index
     85           * @param[in]  state the state which want to set
     86           *
     87           * @return 0 on success, otherwise will be failed
     88           */

   \                                 In section .text, align 2, keep-with-next
     89          static int32_t kv_set_block_state(uint8_t blk_idx, uint8_t state)
     90          {
   \                     kv_set_block_state: (+1)
   \        0x0   0xB513             PUSH     {R0,R1,R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     91              int32_t ret;
     92          
     93              uint32_t pos = (blk_idx << KV_BLOCK_SIZE_BITS) + KV_STATE_OFFSET;
     94          
     95              ret = kv_flash_write(pos, &state, 1);
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xA901             ADD      R1,SP,#+4
   \        0x8   0x0480             LSLS     R0,R0,#+18
   \        0xA   0x1C40             ADDS     R0,R0,#+1
   \        0xC   0x....'....        BL       kv_flash_write
     96              if (ret != KV_OK) {
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD107             BNE.N    ??kv_set_block_state_0
     97                  return ret;
     98              }
     99          
    100              g_kv_mgr.block_info[blk_idx].state = state;
   \       0x14   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x18   0x....'....        LDR.W    R1,??DataTable20
   \       0x1C   0xEB01 0x01C4      ADD      R1,R1,R4, LSL #+3
   \       0x20   0x7508             STRB     R0,[R1, #+20]
    101          
    102              return KV_OK;
   \       0x22   0x2000             MOVS     R0,#+0
   \                     ??kv_set_block_state_0: (+1)
   \       0x24   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    103          }
    104          
    105          /**
    106           * @brief Set item state bit
    107           *
    108           * @param[in]  pos   the position of the item
    109           * @param[in]  state the state which want to set
    110           *
    111           * @return 0 on success, otherwise will be failed
    112           */

   \                                 In section .text, align 2, keep-with-next
    113          static int32_t kv_set_item_state(kv_size_t pos, uint8_t state)
    114          {
   \                     kv_set_item_state: (+1)
   \        0x0   0xB502             PUSH     {R1,LR}
    115              return kv_flash_write(pos + KV_STATE_OFFSET, &state, 1);
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   \        0x8   0x....'....        BL       kv_flash_write
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
    116          }
    117          
    118          /**
    119           * @brief Format block header
    120           *
    121           * @param[in]  blk_idx the index of the block
    122           *
    123           * @return 0 on success, otherwise will be failed
    124           */

   \                                 In section .text, align 2, keep-with-next
    125          static int32_t kv_block_format(uint8_t blk_idx)
    126          {
   \                     kv_block_format: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    127              block_hdr_t hdr;
    128          
    129              kv_size_t pos = (blk_idx << KV_BLOCK_SIZE_BITS);
   \        0x4   0x4625             MOV      R5,R4
   \        0x6   0x04AD             LSLS     R5,R5,#+18
    130          
    131              memset(&hdr, 0, sizeof(block_hdr_t));
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x2104             MOVS     R1,#+4
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x....'....        BL       __aeabi_memset4
    132              hdr.magic = KV_BLOCK_MAGIC_NUM;
   \       0x12   0x204B             MOVS     R0,#+75
   \       0x14   0xF88D 0x0000      STRB     R0,[SP, #+0]
    133          
    134              if (!kv_flash_erase(pos, KV_BLOCK_SIZE)) {
   \       0x18   0xF44F 0x2180      MOV      R1,#+262144
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x....'....        BL       kv_flash_erase
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD118             BNE.N    ??kv_block_format_0
    135                  hdr.state = KV_BLOCK_STATE_CLEAN;
   \       0x26   0x20EE             MOVS     R0,#+238
   \       0x28   0xF88D 0x0001      STRB     R0,[SP, #+1]
    136              } else {
    137                  return KV_ERR_FLASH_ERASE;
    138              }
    139          
    140              if (kv_flash_write(pos, &hdr, KV_BLOCK_HDR_SIZE) != KV_OK) {
   \       0x2C   0x2204             MOVS     R2,#+4
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x....'....        BL       kv_flash_write
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD111             BNE.N    ??kv_block_format_1
    141                  return KV_ERR_FLASH_WRITE;
    142              }
    143          
    144              g_kv_mgr.block_info[blk_idx].state = KV_BLOCK_STATE_CLEAN;
   \       0x3A   0x....'....        LDR.W    R0,??DataTable20
   \       0x3E   0x21EE             MOVS     R1,#+238
   \       0x40   0x4622             MOV      R2,R4
   \       0x42   0xEB00 0x02C2      ADD      R2,R0,R2, LSL #+3
   \       0x46   0x7511             STRB     R1,[R2, #+20]
    145              g_kv_mgr.block_info[blk_idx].space = KV_BLOCK_SIZE - KV_BLOCK_HDR_SIZE;
   \       0x48   0x....'....        LDR.W    R1,??DataTable20_2  ;; 0x3fffc
   \       0x4C   0x6111             STR      R1,[R2, #+16]
    146              g_kv_mgr.clean_blk_nums++;
   \       0x4E   0x78C1             LDRB     R1,[R0, #+3]
   \       0x50   0x1C49             ADDS     R1,R1,#+1
   \       0x52   0x70C1             STRB     R1,[R0, #+3]
    147          
    148              return KV_OK;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??kv_block_format_0: (+1)
   \       0x58   0x....'....        LDR.W    R0,??DataTable20_3  ;; 0xffffd8e9
   \       0x5C   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??kv_block_format_1: (+1)
   \       0x5E   0x....'....        LDR.W    R0,??DataTable20_4  ;; 0xffffd8ea
   \       0x62   0xBD32             POP      {R1,R4,R5,PC}
    149          }
    150          
    151          /**
    152           * @brief Calculcate the item wtite position
    153           *
    154           * @param[in]  len  the item length
    155           *
    156           * @return write position, 0 means there is no space to store
    157           */

   \                                 In section .text, align 2, keep-with-next
    158          static kv_size_t kv_calc_position(uint16_t len)
    159          {
   \                     kv_calc_position: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    160              uint8_t       blk_idx;
    161              block_info_t *blk_info;
    162          
    163          #if KV_BLOCK_NUMS > KV_RESERVED_BLOCKS + 1
    164              uint8_t  i;
    165              uint32_t blk_start;
    166          #endif
    167          
    168              blk_idx  = (g_kv_mgr.write_pos) >> KV_BLOCK_SIZE_BITS;
   \        0x2   0x....'....        LDR.W    R4,??DataTable20
   \        0x6   0x6861             LDR      R1,[R4, #+4]
   \        0x8   0x0C89             LSRS     R1,R1,#+18
   \        0xA   0xB2C9             UXTB     R1,R1
    169              blk_info = &(g_kv_mgr.block_info[blk_idx]);
   \        0xC   0xEB04 0x02C1      ADD      R2,R4,R1, LSL #+3
   \       0x10   0x3210             ADDS     R2,R2,#+16
    170          
    171              if (blk_info->space > len) {
   \       0x12   0x4603             MOV      R3,R0
   \       0x14   0x6815             LDR      R5,[R2, #+0]
   \       0x16   0x42AB             CMP      R3,R5
   \       0x18   0xD20B             BCS.N    ??kv_calc_position_0
    172                  if (((blk_info->space - len) < KV_ITEM_MAX_LEN) && \
    173                      (g_kv_mgr.clean_blk_nums <= KV_RESERVED_BLOCKS)) {
   \       0x1A   0x4629             MOV      R1,R5
   \       0x1C   0x1A08             SUBS     R0,R1,R0
   \       0x1E   0xF240 0x218A      MOVW     R1,#+650
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD231             BCS.N    ??kv_calc_position_1
   \       0x26   0x78E0             LDRB     R0,[R4, #+3]
   \       0x28   0x2802             CMP      R0,#+2
   \       0x2A   0xDA2E             BGE.N    ??kv_calc_position_1
    174                      kv_trigger_gc();
   \       0x2C   0x....'....        BL       kv_trigger_gc
   \       0x30   0xE02B             B.N      ??kv_calc_position_1
    175                  }
    176                  return g_kv_mgr.write_pos;
    177              }
    178          
    179          #if KV_BLOCK_NUMS > KV_RESERVED_BLOCKS + 1
    180              for (i = blk_idx + 1; i != blk_idx; i++) {
   \                     ??kv_calc_position_0: (+1)
   \       0x32   0x1C4A             ADDS     R2,R1,#+1
   \       0x34   0x4605             MOV      R5,R0
   \       0x36   0xE000             B.N      ??kv_calc_position_2
   \                     ??kv_calc_position_3: (+1)
   \       0x38   0x1C52             ADDS     R2,R2,#+1
   \                     ??kv_calc_position_2: (+1)
   \       0x3A   0x4613             MOV      R3,R2
   \       0x3C   0xB2DB             UXTB     R3,R3
   \       0x3E   0x428B             CMP      R3,R1
   \       0x40   0xD025             BEQ.N    ??kv_calc_position_4
    181                  if (i == KV_BLOCK_NUMS) {
   \       0x42   0x4613             MOV      R3,R2
   \       0x44   0xB2DB             UXTB     R3,R3
   \       0x46   0x2B10             CMP      R3,#+16
   \       0x48   0xD100             BNE.N    ??kv_calc_position_5
    182                      i = 0;
   \       0x4A   0x2200             MOVS     R2,#+0
    183                  }
    184          
    185                  blk_info = &(g_kv_mgr.block_info[i]);
   \                     ??kv_calc_position_5: (+1)
   \       0x4C   0x4613             MOV      R3,R2
   \       0x4E   0xB2DB             UXTB     R3,R3
   \       0x50   0xEB04 0x03C3      ADD      R3,R4,R3, LSL #+3
   \       0x54   0x3310             ADDS     R3,R3,#+16
    186                  if ((blk_info->space) > len) {
   \       0x56   0x681E             LDR      R6,[R3, #+0]
   \       0x58   0x42B5             CMP      R5,R6
   \       0x5A   0xD2ED             BCS.N    ??kv_calc_position_3
    187                      blk_start = (i << KV_BLOCK_SIZE_BITS);
    188                      g_kv_mgr.write_pos = blk_start + KV_BLOCK_SIZE - blk_info->space;
   \       0x5C   0x4611             MOV      R1,R2
   \       0x5E   0xB2C9             UXTB     R1,R1
   \       0x60   0x0489             LSLS     R1,R1,#+18
   \       0x62   0xF501 0x2180      ADD      R1,R1,#+262144
   \       0x66   0x4630             MOV      R0,R6
   \       0x68   0x1A09             SUBS     R1,R1,R0
   \       0x6A   0x6061             STR      R1,[R4, #+4]
    189          
    190                      if (blk_info->state == KV_BLOCK_STATE_CLEAN) {
   \       0x6C   0x7918             LDRB     R0,[R3, #+4]
   \       0x6E   0x28EE             CMP      R0,#+238
   \       0x70   0xD10B             BNE.N    ??kv_calc_position_1
    191                          if (kv_set_block_state(i, KV_BLOCK_STATE_USED) != KV_OK) {
   \       0x72   0x21CC             MOVS     R1,#+204
   \       0x74   0x4610             MOV      R0,R2
   \       0x76   0xB2C0             UXTB     R0,R0
   \       0x78   0x....'....        BL       kv_set_block_state
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD001             BEQ.N    ??kv_calc_position_6
    192                              return 0;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xBD70             POP      {R4-R6,PC}
    193                          }
    194                          g_kv_mgr.clean_blk_nums--;
   \                     ??kv_calc_position_6: (+1)
   \       0x84   0x78E0             LDRB     R0,[R4, #+3]
   \       0x86   0x1E40             SUBS     R0,R0,#+1
   \       0x88   0x70E0             STRB     R0,[R4, #+3]
    195                      }
    196                      return g_kv_mgr.write_pos;
   \                     ??kv_calc_position_1: (+1)
   \       0x8A   0x6860             LDR      R0,[R4, #+4]
   \       0x8C   0xBD70             POP      {R4-R6,PC}
    197                  }
    198              }
    199          #endif
    200          
    201              kv_trigger_gc();
   \                     ??kv_calc_position_4: (+1)
   \       0x8E   0x....'....        BL       kv_trigger_gc
    202          
    203              return 0;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xBD70             POP      {R4-R6,PC}       ;; return
    204          }
    205          
    206          /**
    207           * @brief Key-value pair item delete
    208           *
    209           * @param[in]  item pointer to the key-value pair need to deleted
    210           * @param[in]  flag the flag indicate item delete request is from del or update
    211           *
    212           * @return 0 on success, otherwise is failed
    213           */

   \                                 In section .text, align 2, keep-with-next
    214          static int32_t kv_item_del(kv_item_t *item, int flag)
    215          {
   \                     kv_item_del: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
    216              uint8_t    i;
    217              kv_size_t  off;
    218              item_hdr_t hdr;
    219          
    220              int   res = KV_OK;
    221              char *ori = NULL;
    222              char *new = NULL;
    223          
    224              if (flag == KV_DELETE_FLAG) {
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD116             BNE.N    ??kv_item_del_0
    225                  off = item->pos;
   \        0x8   0x697E             LDR      R6,[R7, #+20]
    226              } else if (flag == KV_UPDATE_FLAG) {
    227                  off = item->hdr.origin_off;
    228                  memset(&hdr, 0, KV_ITEM_HDR_SIZE);
    229                  if (kv_flash_read(off, &hdr, KV_ITEM_HDR_SIZE) != KV_OK) {
    230                      return KV_ERR_FLASH_READ;
    231                  }
    232          
    233                  if ((hdr.magic != KV_ITEM_MAGIC_NUM) || \
    234                      (hdr.state != KV_ITEM_STATE_NORMAL) || \
    235                      (hdr.key_len != item->hdr.key_len)) {
    236                      return KV_OK;
    237                  }
    238          
    239                  ori = (char *)kv_malloc(hdr.key_len);
    240                  if (!ori) {
    241                      return KV_ERR_MALLOC_FAILED;
    242                  }
    243          
    244                  new = (char *)kv_malloc(hdr.key_len);
    245                  if (!new) {
    246                      kv_free(ori);
    247                      return KV_ERR_MALLOC_FAILED;
    248                  }
    249          
    250                  kv_flash_read(off + KV_ITEM_HDR_SIZE, ori, hdr.key_len);
    251                  kv_flash_read(item->pos + KV_ITEM_HDR_SIZE, new, hdr.key_len);
    252                  if (memcmp(ori, new, hdr.key_len) != 0) {
    253                      kv_free(ori);
    254                      kv_free(new);
    255                      return KV_OK;
    256                  }
    257          
    258                  kv_free(ori);
    259                  kv_free(new);
    260              } else {
    261                  return KV_ERR_INVALID_PARAM;
    262              }
    263          
    264              if ((res = kv_set_item_state(off, KV_ITEM_STATE_DELETE)) != KV_OK) {
   \                     ??kv_item_del_1: (+1)
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x4630             MOV      R0,R6
   \        0xE   0x....'....        BL       kv_set_item_state
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD10E             BNE.N    ??kv_item_del_2
    265                  return res;
    266              }
    267          
    268              i = off >> KV_BLOCK_SIZE_BITS;
   \       0x16   0x0CB6             LSRS     R6,R6,#+18
    269              if (g_kv_mgr.block_info[i].state == KV_BLOCK_STATE_USED) {
   \       0x18   0x....'....        LDR.W    R1,??DataTable20
   \       0x1C   0x4632             MOV      R2,R6
   \       0x1E   0xB2D2             UXTB     R2,R2
   \       0x20   0xEB01 0x01C2      ADD      R1,R1,R2, LSL #+3
   \       0x24   0x7D09             LDRB     R1,[R1, #+20]
   \       0x26   0x29CC             CMP      R1,#+204
   \       0x28   0xD104             BNE.N    ??kv_item_del_2
    270                  res = kv_set_block_state(i, KV_BLOCK_STATE_DIRTY);
   \       0x2A   0x2144             MOVS     R1,#+68
   \       0x2C   0x4630             MOV      R0,R6
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x....'....        BL       kv_set_block_state
    271              }
    272          
    273              return res;
   \                     ??kv_item_del_2: (+1)
   \       0x34   0xBDFE             POP      {R1-R7,PC}       ;; return
   \                     ??kv_item_del_0: (+1)
   \       0x36   0x2901             CMP      R1,#+1
   \       0x38   0xD156             BNE.N    ??kv_item_del_3
   \       0x3A   0xF8D7 0x6006      LDR      R6,[R7, #+6]
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x210A             MOVS     R1,#+10
   \       0x42   0x4668             MOV      R0,SP
   \       0x44   0x....'....        BL       __aeabi_memset4
   \       0x48   0x220A             MOVS     R2,#+10
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x....'....        BL       kv_flash_read
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD002             BEQ.N    ??kv_item_del_4
   \       0x56   0x....'....        LDR.W    R0,??DataTable20_5  ;; 0xffffd8eb
   \       0x5A   0xBDFE             POP      {R1-R7,PC}
   \                     ??kv_item_del_4: (+1)
   \       0x5C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x60   0x2849             CMP      R0,#+73
   \       0x62   0xD108             BNE.N    ??kv_item_del_5
   \       0x64   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x68   0x28EE             CMP      R0,#+238
   \       0x6A   0xD104             BNE.N    ??kv_item_del_5
   \       0x6C   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \       0x70   0x78F9             LDRB     R1,[R7, #+3]
   \       0x72   0x4288             CMP      R0,R1
   \       0x74   0xD001             BEQ.N    ??kv_item_del_6
   \                     ??kv_item_del_5: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xBDFE             POP      {R1-R7,PC}
   \                     ??kv_item_del_6: (+1)
   \       0x7A   0x....'....        BL       kv_malloc
   \       0x7E   0x0005             MOVS     R5,R0
   \       0x80   0xD102             BNE.N    ??kv_item_del_7
   \       0x82   0x....'....        LDR.W    R0,??DataTable20_6  ;; 0xffffd8ed
   \       0x86   0xBDFE             POP      {R1-R7,PC}
   \                     ??kv_item_del_7: (+1)
   \       0x88   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \       0x8C   0x....'....        BL       kv_malloc
   \       0x90   0x0004             MOVS     R4,R0
   \       0x92   0xD105             BNE.N    ??kv_item_del_8
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0x....'....        BL       kv_free
   \       0x9A   0x....'....        LDR.W    R0,??DataTable20_6  ;; 0xffffd8ed
   \       0x9E   0xBDFE             POP      {R1-R7,PC}
   \                     ??kv_item_del_8: (+1)
   \       0xA0   0xF89D 0x2003      LDRB     R2,[SP, #+3]
   \       0xA4   0x4629             MOV      R1,R5
   \       0xA6   0xF106 0x000A      ADD      R0,R6,#+10
   \       0xAA   0x....'....        BL       kv_flash_read
   \       0xAE   0xF89D 0x2003      LDRB     R2,[SP, #+3]
   \       0xB2   0x4621             MOV      R1,R4
   \       0xB4   0x6978             LDR      R0,[R7, #+20]
   \       0xB6   0x300A             ADDS     R0,R0,#+10
   \       0xB8   0x....'....        BL       kv_flash_read
   \       0xBC   0xF89D 0x2003      LDRB     R2,[SP, #+3]
   \       0xC0   0x4621             MOV      R1,R4
   \       0xC2   0x4628             MOV      R0,R5
   \       0xC4   0x....'....        BL       memcmp
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0x4628             MOV      R0,R5
   \       0xCC   0xD006             BEQ.N    ??kv_item_del_9
   \       0xCE   0x....'....        BL       kv_free
   \       0xD2   0x4620             MOV      R0,R4
   \       0xD4   0x....'....        BL       kv_free
   \       0xD8   0x2000             MOVS     R0,#+0
   \       0xDA   0xBDFE             POP      {R1-R7,PC}
   \                     ??kv_item_del_9: (+1)
   \       0xDC   0x....'....        BL       kv_free
   \       0xE0   0x4620             MOV      R0,R4
   \       0xE2   0x....'....        BL       kv_free
   \       0xE6   0xE790             B.N      ??kv_item_del_1
   \                     ??kv_item_del_3: (+1)
   \       0xE8   0x....'....        LDR.W    R0,??DataTable20_7  ;; 0xffffd8ee
   \       0xEC   0xBDFE             POP      {R1-R7,PC}
    274          }
    275          
    276          /**
    277           * @brief recovery callback function when polling the block
    278           *
    279           * @param[in]  item pointer to the key-value pair item
    280           * @param[in]  key  pointer to the key
    281           *
    282           * @return KV_LOOP_CONTINUE: continue to polling, otherwise is failed
    283           */

   \                                 In section .text, align 2, keep-with-next
    284          static int32_t __item_recovery_cb(kv_item_t *item, const char *key)
    285          {
   \                     __item_recovery_cb: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
    286              int32_t res;
    287          
    288              char *p = (char *)kv_malloc(item->len);
   \        0x4   0x8A28             LDRH     R0,[R5, #+16]
   \        0x6   0x....'....        BL       kv_malloc
   \        0xA   0x0004             MOVS     R4,R0
    289              if (!p) {
   \        0xC   0xD102             BNE.N    ??__item_recovery_cb_0
    290                  return KV_ERR_MALLOC_FAILED;
   \        0xE   0x....'....        LDR.W    R0,??DataTable20_6  ;; 0xffffd8ed
   \       0x12   0xBD32             POP      {R1,R4,R5,PC}
    291              }
    292          
    293              res = kv_flash_read(item->pos + KV_ITEM_HDR_SIZE, p, item->len);
    294              if (res != KV_OK) {
   \                     ??__item_recovery_cb_0: (+1)
   \       0x14   0x8A2A             LDRH     R2,[R5, #+16]
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0x6968             LDR      R0,[R5, #+20]
   \       0x1A   0x300A             ADDS     R0,R0,#+10
   \       0x1C   0x....'....        BL       kv_flash_read
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD005             BEQ.N    ??__item_recovery_cb_1
    295                  kv_free(p);
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       kv_free
    296                  return KV_ERR_FLASH_READ;
   \       0x2A   0x....'....        LDR.W    R0,??DataTable20_5  ;; 0xffffd8eb
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
    297              }
    298          
    299              if (item->hdr.crc == calc_crc8((uint8_t *)p, item->len)) {
   \                     ??__item_recovery_cb_1: (+1)
   \       0x30   0x8A29             LDRH     R1,[R5, #+16]
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x....'....        BL       calc_crc8
   \       0x38   0x78A9             LDRB     R1,[R5, #+2]
   \       0x3A   0x4281             CMP      R1,R0
   \       0x3C   0xD10B             BNE.N    ??__item_recovery_cb_2
    300                  if ((item->hdr.origin_off != 0) && \
    301                      (item->pos != item->hdr.origin_off)) {
   \       0x3E   0xF8D5 0x0006      LDR      R0,[R5, #+6]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD00B             BEQ.N    ??__item_recovery_cb_3
   \       0x46   0x6969             LDR      R1,[R5, #+20]
   \       0x48   0x4281             CMP      R1,R0
   \       0x4A   0xD008             BEQ.N    ??__item_recovery_cb_3
    302                      kv_item_del(item, KV_UPDATE_FLAG);
   \       0x4C   0x2101             MOVS     R1,#+1
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0x....'....        BL       kv_item_del
   \       0x54   0xE003             B.N      ??__item_recovery_cb_3
    303                  }
    304              } else {
    305                  kv_item_del(item, KV_DELETE_FLAG);
   \                     ??__item_recovery_cb_2: (+1)
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       kv_item_del
    306              }
    307          
    308              kv_free(p);
   \                     ??__item_recovery_cb_3: (+1)
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x....'....        BL       kv_free
    309              return KV_LOOP_CONTINUE;
   \       0x64   0xF242 0x7010      MOVW     R0,#+10000
   \       0x68   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    310          }
    311          
    312          /**
    313           * @brief find callback function when polling the block
    314           *
    315           * @param[in]  item pointer to the key-value pair item
    316           * @param[in]  key  pointer to the key
    317           *
    318           * @return KV_OK: find the item;
    319           *         KV_LOOP_CONTINUE: continue to polling,
    320           *         otherwise is failed
    321           */

   \                                 In section .text, align 2, keep-with-next
    322          static int32_t __item_find_cb(kv_item_t *item, const char *key)
    323          {
   \                     __item_find_cb: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    324              int32_t res;
    325          
    326              if (item->hdr.key_len != strlen(key)) {
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x....'....        BL       strlen
   \        0xC   0x78E1             LDRB     R1,[R4, #+3]
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xD002             BEQ.N    ??__item_find_cb_0
    327                  return KV_LOOP_CONTINUE;
   \       0x12   0xF242 0x7010      MOVW     R0,#+10000
   \       0x16   0xBD32             POP      {R1,R4,R5,PC}
    328              }
    329          
    330              item->store = (char *)kv_malloc(item->hdr.key_len + item->hdr.val_len);
   \                     ??__item_find_cb_0: (+1)
   \       0x18   0x4608             MOV      R0,R1
   \       0x1A   0x88A1             LDRH     R1,[R4, #+4]
   \       0x1C   0x1808             ADDS     R0,R1,R0
   \       0x1E   0x....'....        BL       kv_malloc
   \       0x22   0x60E0             STR      R0,[R4, #+12]
    331              if (!item->store) {
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD102             BNE.N    ??__item_find_cb_1
    332                  return KV_ERR_MALLOC_FAILED;
   \       0x28   0x....'....        LDR.W    R0,??DataTable20_6  ;; 0xffffd8ed
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
    333              }
    334          
    335              res = kv_flash_read(item->pos + KV_ITEM_HDR_SIZE, item->store,
    336                                         item->len);
    337              if (res != KV_OK) {
   \                     ??__item_find_cb_1: (+1)
   \       0x2E   0x8A22             LDRH     R2,[R4, #+16]
   \       0x30   0x4601             MOV      R1,R0
   \       0x32   0x6960             LDR      R0,[R4, #+20]
   \       0x34   0x300A             ADDS     R0,R0,#+10
   \       0x36   0x....'....        BL       kv_flash_read
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD002             BEQ.N    ??__item_find_cb_2
    338                  return KV_ERR_FLASH_READ;
   \       0x3E   0x....'....        LDR.W    R0,??DataTable20_5  ;; 0xffffd8eb
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}
    339              }
    340          
    341              if (memcmp(item->store, key, strlen(key)) == 0) {
   \                     ??__item_find_cb_2: (+1)
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x....'....        BL       strlen
   \       0x4A   0x4602             MOV      R2,R0
   \       0x4C   0x4629             MOV      R1,R5
   \       0x4E   0x68E0             LDR      R0,[R4, #+12]
   \       0x50   0x....'....        BL       memcmp
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD101             BNE.N    ??__item_find_cb_3
    342                  return KV_OK;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xBD32             POP      {R1,R4,R5,PC}
    343              }
    344          
    345              return KV_LOOP_CONTINUE;
   \                     ??__item_find_cb_3: (+1)
   \       0x5C   0xF242 0x7010      MOVW     R0,#+10000
   \       0x60   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    346          }
    347          
    348          /**
    349           * @brief GC callback function when polling the block
    350           *
    351           * @param[in]  item pointer to the key-value pair item
    352           * @param[in]  key  pointer to the key
    353           *
    354           * @return KV_LOOP_CONTINUE: continue to polling, otherwise is failed
    355           */

   \                                 In section .text, align 2, keep-with-next
    356          static int32_t __item_gc_cb(kv_item_t *item, const char *key)
    357          {
   \                     __item_gc_cb: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
    358              char     *p;
    359              int32_t   res;
    360              uint8_t   idx;
    361              uint16_t  len;
    362          
    363              len = KV_ALIGN(KV_ITEM_HDR_SIZE + item->len);
   \        0x4   0x8A35             LDRH     R5,[R6, #+16]
   \        0x6   0x350D             ADDS     R5,R5,#+13
   \        0x8   0xF64F 0x70FC      MOVW     R0,#+65532
   \        0xC   0x4005             ANDS     R5,R0,R5
    364          
    365              p = (char *)kv_malloc(len);
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x....'....        BL       kv_malloc
   \       0x14   0x0004             MOVS     R4,R0
    366              if (!p) {
   \       0x16   0xD102             BNE.N    ??__item_gc_cb_0
    367                  return KV_ERR_MALLOC_FAILED;
   \       0x18   0x....'....        LDR.W    R0,??DataTable20_6  ;; 0xffffd8ed
   \       0x1C   0xBD70             POP      {R4-R6,PC}
    368              }
    369          
    370              if (kv_flash_read(item->pos, p, len) != KV_OK) {
   \                     ??__item_gc_cb_0: (+1)
   \       0x1E   0x462A             MOV      R2,R5
   \       0x20   0x4621             MOV      R1,R4
   \       0x22   0x6970             LDR      R0,[R6, #+20]
   \       0x24   0x....'....        BL       kv_flash_read
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??__item_gc_cb_1
    371                  res = KV_ERR_FLASH_READ;
   \       0x2C   0x....'....        LDR.W    R5,??DataTable20_5  ;; 0xffffd8eb
    372                  goto err;
   \       0x30   0xE019             B.N      ??__item_gc_cb_2
    373              }
    374          
    375              if (kv_flash_write(g_kv_mgr.write_pos, p, len) != KV_OK) {
   \                     ??__item_gc_cb_1: (+1)
   \       0x32   0x....'....        LDR.W    R6,??DataTable20
   \       0x36   0x462A             MOV      R2,R5
   \       0x38   0x4621             MOV      R1,R4
   \       0x3A   0x6870             LDR      R0,[R6, #+4]
   \       0x3C   0x....'....        BL       kv_flash_write
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD002             BEQ.N    ??__item_gc_cb_3
    376                  res = KV_ERR_FLASH_WRITE;
   \       0x44   0x....'....        LDR.W    R5,??DataTable20_4  ;; 0xffffd8ea
    377                  goto err;
   \       0x48   0xE00D             B.N      ??__item_gc_cb_2
    378              }
    379          
    380              g_kv_mgr.write_pos += len;
   \                     ??__item_gc_cb_3: (+1)
   \       0x4A   0x6870             LDR      R0,[R6, #+4]
   \       0x4C   0x1828             ADDS     R0,R5,R0
   \       0x4E   0x6070             STR      R0,[R6, #+4]
    381              idx = (g_kv_mgr.write_pos) >> KV_BLOCK_SIZE_BITS;
   \       0x50   0x0C80             LSRS     R0,R0,#+18
   \       0x52   0xB2C0             UXTB     R0,R0
    382              g_kv_mgr.block_info[idx].space -= len;
   \       0x54   0xEB06 0x01C0      ADD      R1,R6,R0, LSL #+3
   \       0x58   0x6909             LDR      R1,[R1, #+16]
   \       0x5A   0x1B4D             SUBS     R5,R1,R5
   \       0x5C   0xEB06 0x00C0      ADD      R0,R6,R0, LSL #+3
   \       0x60   0x6105             STR      R5,[R0, #+16]
    383              res = KV_LOOP_CONTINUE;
   \       0x62   0xF242 0x7510      MOVW     R5,#+10000
    384          
    385          err:
    386              kv_free(p);
   \                     ??__item_gc_cb_2: (+1)
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0x....'....        BL       kv_free
    387          
    388              return res;
   \       0x6C   0x4628             MOV      R0,R5
   \       0x6E   0xBD70             POP      {R4-R6,PC}       ;; return
    389          }
    390          
    391          /**
    392           * @brief Group delete callback function when polling the block
    393           *
    394           * @param[in]  item pointer to the key-value pair item
    395           * @param[in]  key  pointer to the key
    396           *
    397           * @return KV_LOOP_CONTINUE: continue to polling, otherwise is failed
    398           */

   \                                 In section .text, align 2, keep-with-next
    399          static int32_t __item_del_by_prefix_cb(kv_item_t *item, const char *prefix)
    400          {
   \                     __item_del_by_prefix_cb: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    401              char *key = NULL;
    402          
    403              if (item->hdr.key_len < strlen(prefix)) {
   \        0x6   0x4630             MOV      R0,R6
   \        0x8   0x....'....        BL       strlen
   \        0xC   0x78E9             LDRB     R1,[R5, #+3]
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xD202             BCS.N    ??__item_del_by_prefix_cb_0
    404                  return KV_LOOP_CONTINUE;
   \       0x12   0xF242 0x7010      MOVW     R0,#+10000
   \       0x16   0xBD70             POP      {R4-R6,PC}
    405              }
    406          
    407              key = (char *)kv_malloc(item->hdr.key_len + 1);
   \                     ??__item_del_by_prefix_cb_0: (+1)
   \       0x18   0x4608             MOV      R0,R1
   \       0x1A   0x1C40             ADDS     R0,R0,#+1
   \       0x1C   0x....'....        BL       kv_malloc
   \       0x20   0x0004             MOVS     R4,R0
    408              if (!key) {
   \       0x22   0xD102             BNE.N    ??__item_del_by_prefix_cb_1
    409                  return KV_ERR_MALLOC_FAILED;
   \       0x24   0x....'....        LDR.W    R0,??DataTable20_6  ;; 0xffffd8ed
   \       0x28   0xBD70             POP      {R4-R6,PC}
    410              }
    411          
    412              memset(key, 0, item->hdr.key_len + 1);
   \                     ??__item_del_by_prefix_cb_1: (+1)
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x78E9             LDRB     R1,[R5, #+3]
   \       0x2E   0x1C49             ADDS     R1,R1,#+1
   \       0x30   0x....'....        BL       __aeabi_memset
    413              kv_flash_read(item->pos + KV_ITEM_HDR_SIZE, key, item->hdr.key_len);
   \       0x34   0x78EA             LDRB     R2,[R5, #+3]
   \       0x36   0x4621             MOV      R1,R4
   \       0x38   0x6968             LDR      R0,[R5, #+20]
   \       0x3A   0x300A             ADDS     R0,R0,#+10
   \       0x3C   0x....'....        BL       kv_flash_read
    414          
    415              if (strncmp(key, prefix, strlen(prefix)) == 0) {
   \       0x40   0x4630             MOV      R0,R6
   \       0x42   0x....'....        BL       strlen
   \       0x46   0x4602             MOV      R2,R0
   \       0x48   0x4631             MOV      R1,R6
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x....'....        BL       strncmp
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD103             BNE.N    ??__item_del_by_prefix_cb_2
    416                  kv_item_del(item, KV_DELETE_FLAG);
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x4628             MOV      R0,R5
   \       0x58   0x....'....        BL       kv_item_del
    417              }
    418          
    419              kv_free(key);
   \                     ??__item_del_by_prefix_cb_2: (+1)
   \       0x5C   0x4620             MOV      R0,R4
   \       0x5E   0x....'....        BL       kv_free
    420          
    421              return KV_LOOP_CONTINUE;
   \       0x62   0xF242 0x7010      MOVW     R0,#+10000
   \       0x66   0xBD70             POP      {R4-R6,PC}       ;; return
    422          }
    423          
    424          /**
    425           * @brief Search key-value pair item
    426           *
    427           * @param[in]  key pointer to the item key
    428           *
    429           * @return key-value item or NULL
    430           */

   \                                 In section .text, align 2, keep-with-next
    431          static kv_item_t *kv_item_search(const char *key)
    432          {
   \                     kv_item_search: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    433              uint8_t i;
    434          
    435              kv_item_t *item = NULL;
    436          
    437              for (i = 0; i < KV_BLOCK_NUMS; i++) {
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0xE000             B.N      ??kv_item_search_0
   \                     ??kv_item_search_1: (+1)
   \        0x8   0x1C6D             ADDS     R5,R5,#+1
   \                     ??kv_item_search_0: (+1)
   \        0xA   0x4628             MOV      R0,R5
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2810             CMP      R0,#+16
   \       0x10   0xDA12             BGE.N    ??kv_item_search_2
    438                  if (g_kv_mgr.block_info[i].state != KV_BLOCK_STATE_CLEAN) {
   \       0x12   0x....'....        LDR.W    R0,??DataTable20
   \       0x16   0x4629             MOV      R1,R5
   \       0x18   0xB2C9             UXTB     R1,R1
   \       0x1A   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \       0x1E   0x7D00             LDRB     R0,[R0, #+20]
   \       0x20   0x28EE             CMP      R0,#+238
   \       0x22   0xD0F1             BEQ.N    ??kv_item_search_1
    439                      item = kv_item_traverse(__item_find_cb, i, key);
   \       0x24   0x4622             MOV      R2,R4
   \       0x26   0x4629             MOV      R1,R5
   \       0x28   0xB2C9             UXTB     R1,R1
   \       0x2A   0x....'....        LDR.W    R0,??DataTable20_8
   \       0x2E   0x....'....        BL       kv_item_traverse
    440                      if (item != NULL) {
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD0E8             BEQ.N    ??kv_item_search_1
    441                          return item;
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
    442                      }
    443                  }
    444              }
    445          
    446              return NULL;
   \                     ??kv_item_search_2: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    447          }
    448          
    449          /**
    450           * @brief Store key-value item
    451           *
    452           * @param[in]  key        pointer to the item key
    453           * @param[in]  val        pointer to the item value
    454           * @param[in]  len        the length of the value
    455           * @param[in]  origin_off the old item position offset
    456           *
    457           * @return 0 on success, otherwise is failed
    458           */

   \                                 In section .text, align 2, keep-with-next
    459          static int32_t kv_item_store(const char *key, const void *val, int len,
    460                                       kv_size_t origin_off)
    461          {
   \                     kv_item_store: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461F             MOV      R7,R3
    462              char       *p;
    463              uint8_t     idx;
    464              kv_size_t   pos;
    465              item_hdr_t  hdr;
    466              kv_store_t  store;
    467          
    468              hdr.magic      = KV_ITEM_MAGIC_NUM;
   \        0xC   0x2049             MOVS     R0,#+73
   \        0xE   0xF88D 0x0000      STRB     R0,[SP, #+0]
    469              hdr.state      = KV_ITEM_STATE_NORMAL;
   \       0x12   0x20EE             MOVS     R0,#+238
   \       0x14   0xF88D 0x0001      STRB     R0,[SP, #+1]
    470              hdr.key_len    = strlen(key);
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       strlen
   \       0x1E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    471              hdr.val_len    = len;
   \       0x22   0xF8AD 0x4004      STRH     R4,[SP, #+4]
    472              hdr.origin_off = origin_off;
   \       0x26   0xF10D 0x0006      ADD      R0,SP,#+6
   \       0x2A   0x6007             STR      R7,[R0, #+0]
    473          
    474              store.len = KV_ALIGN(KV_ITEM_HDR_SIZE + hdr.key_len + hdr.val_len);
   \       0x2C   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \       0x30   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \       0x34   0x180F             ADDS     R7,R1,R0
   \       0x36   0x370D             ADDS     R7,R7,#+13
   \       0x38   0xF64F 0x70FC      MOVW     R0,#+65532
   \       0x3C   0x4007             ANDS     R7,R0,R7
    475          
    476              store.p = (char *)kv_malloc(store.len);
   \       0x3E   0x4638             MOV      R0,R7
   \       0x40   0x....'....        BL       kv_malloc
   \       0x44   0x0004             MOVS     R4,R0
    477              if (!store.p) {
   \       0x46   0xD102             BNE.N    ??kv_item_store_0
    478                  return KV_ERR_MALLOC_FAILED;
   \       0x48   0x....'....        LDR.W    R0,??DataTable20_6  ;; 0xffffd8ed
   \       0x4C   0xE048             B.N      ??kv_item_store_1
    479              }
    480          
    481              memset(store.p, 0, store.len);
   \                     ??kv_item_store_0: (+1)
   \       0x4E   0x2200             MOVS     R2,#+0
   \       0x50   0x4639             MOV      R1,R7
   \       0x52   0x....'....        BL       __aeabi_memset
    482              p = store.p + KV_ITEM_HDR_SIZE;
   \       0x56   0xF104 0x080A      ADD      R8,R4,#+10
    483          
    484              memcpy(p, key, hdr.key_len);
   \       0x5A   0xF89D 0x2003      LDRB     R2,[SP, #+3]
   \       0x5E   0x4629             MOV      R1,R5
   \       0x60   0x4640             MOV      R0,R8
   \       0x62   0x....'....        BL       __aeabi_memcpy
    485              p += hdr.key_len;
   \       0x66   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \       0x6A   0xEB08 0x0500      ADD      R5,R8,R0
    486          
    487              memcpy(p, val, hdr.val_len);
   \       0x6E   0xF8BD 0x2004      LDRH     R2,[SP, #+4]
   \       0x72   0x4631             MOV      R1,R6
   \       0x74   0x4628             MOV      R0,R5
   \       0x76   0x....'....        BL       __aeabi_memcpy
    488              p -= hdr.key_len;
    489          
    490              hdr.crc = calc_crc8((uint8_t *)p, hdr.key_len + hdr.val_len);
   \       0x7A   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \       0x7E   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \       0x82   0x1809             ADDS     R1,R1,R0
   \       0x84   0xB289             UXTH     R1,R1
   \       0x86   0x4240             RSBS     R0,R0,#+0
   \       0x88   0x4428             ADD      R0,R5,R0
   \       0x8A   0x....'....        BL       calc_crc8
   \       0x8E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    491              memcpy(store.p, &hdr, KV_ITEM_HDR_SIZE);
   \       0x92   0x220A             MOVS     R2,#+10
   \       0x94   0x4669             MOV      R1,SP
   \       0x96   0x4620             MOV      R0,R4
   \       0x98   0x....'....        BL       __aeabi_memcpy
    492          
    493              pos = kv_calc_position(store.len);
   \       0x9C   0x4638             MOV      R0,R7
   \       0x9E   0x....'....        BL       kv_calc_position
   \       0xA2   0x0006             MOVS     R6,R0
    494              if (pos > 0) {
   \       0xA4   0xD014             BEQ.N    ??kv_item_store_2
    495                  store.res = kv_flash_write(pos, store.p, store.len);
   \       0xA6   0x463A             MOV      R2,R7
   \       0xA8   0x4621             MOV      R1,R4
   \       0xAA   0x....'....        BL       kv_flash_write
   \       0xAE   0x0005             MOVS     R5,R0
    496                  if (store.res == KV_OK) {
   \       0xB0   0xD110             BNE.N    ??kv_item_store_3
    497                      g_kv_mgr.write_pos = pos + store.len;
   \       0xB2   0x....'....        LDR.W    R0,??DataTable20
   \       0xB6   0x19BE             ADDS     R6,R7,R6
   \       0xB8   0x6046             STR      R6,[R0, #+4]
    498                      idx = (uint8_t)(g_kv_mgr.write_pos >> KV_BLOCK_SIZE_BITS);
   \       0xBA   0x4631             MOV      R1,R6
   \       0xBC   0x0C89             LSRS     R1,R1,#+18
   \       0xBE   0xB2C9             UXTB     R1,R1
    499                      g_kv_mgr.block_info[idx].space -= store.len;
   \       0xC0   0xEB00 0x02C1      ADD      R2,R0,R1, LSL #+3
   \       0xC4   0x6912             LDR      R2,[R2, #+16]
   \       0xC6   0x1BD7             SUBS     R7,R2,R7
   \       0xC8   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \       0xCC   0x6107             STR      R7,[R0, #+16]
   \       0xCE   0xE001             B.N      ??kv_item_store_3
    500                  }
    501              } else {
    502                  store.res = KV_ERR_NO_SPACE;
   \                     ??kv_item_store_2: (+1)
   \       0xD0   0x....'....        LDR.W    R5,??DataTable20_9  ;; 0xffffd8ef
    503              }
    504          
    505              if (store.p) {
   \                     ??kv_item_store_3: (+1)
   \       0xD4   0x2C00             CMP      R4,#+0
   \       0xD6   0xD002             BEQ.N    ??kv_item_store_4
    506                  kv_free(store.p);
   \       0xD8   0x4620             MOV      R0,R4
   \       0xDA   0x....'....        BL       kv_free
    507              }
    508          
    509              return store.res;
   \                     ??kv_item_store_4: (+1)
   \       0xDE   0x4628             MOV      R0,R5
   \                     ??kv_item_store_1: (+1)
   \       0xE0   0xB004             ADD      SP,SP,#+16
   \       0xE2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    510          }
    511          
    512          /**
    513           * @brief Update the item value
    514           *
    515           * @param[in]  item pointer to the key-value item
    516           * @param[in]  key  pointer to the item key
    517           * @param[in]  val  pointer to the item value
    518           * @param[in]  len  the length of the item value
    519           *
    520           * @return 0 on success, otherwise is failed
    521           */

   \                                 In section .text, align 2, keep-with-next
    522          static int32_t kv_item_update(kv_item_t *item, const char *key, const void *val,
    523                                        int32_t len)
    524          {
   \                     kv_item_update: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    525              int res;
    526          
    527              if (item->hdr.val_len == len) {
   \        0xA   0x88A0             LDRH     R0,[R4, #+4]
   \        0xC   0x42B8             CMP      R0,R7
   \        0xE   0xD10A             BNE.N    ??kv_item_update_0
    528                  if (!memcmp(item->store + item->hdr.key_len, val, len)) {
   \       0x10   0x463A             MOV      R2,R7
   \       0x12   0x4631             MOV      R1,R6
   \       0x14   0x68E0             LDR      R0,[R4, #+12]
   \       0x16   0x78E3             LDRB     R3,[R4, #+3]
   \       0x18   0x4418             ADD      R0,R0,R3
   \       0x1A   0x....'....        BL       memcmp
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??kv_item_update_0
    529                      return KV_OK;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBDF2             POP      {R1,R4-R7,PC}
    530                  }
    531              }
    532          
    533              res = kv_item_store(key, val, len, item->pos);
   \                     ??kv_item_update_0: (+1)
   \       0x26   0x6963             LDR      R3,[R4, #+20]
   \       0x28   0x463A             MOV      R2,R7
   \       0x2A   0x4631             MOV      R1,R6
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x....'....        BL       kv_item_store
    534              if (res != KV_OK) {
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD104             BNE.N    ??kv_item_update_1
    535                  return res;
    536              }
    537          
    538              res = kv_item_del(item, KV_DELETE_FLAG);
    539          
    540              return res;
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x3E   0x....             B.N      kv_item_del
   \                     ??kv_item_update_1: (+1)
   \       0x40   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    541          }
    542          
    543          /**
    544           * @brief Initialize the KV module
    545           *
    546           * @return  0 on success, otherwise is failed
    547           */

   \                                 In section .text, align 2, keep-with-next
    548          static int32_t kv_init_internal(void)
    549          {
   \                     kv_init_internal: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    550              uint8_t     i;
    551              uint8_t     next;
    552              block_hdr_t hdr;
    553          
    554              int32_t res  = KV_OK;
    555              int32_t nums = 0;
   \        0x4   0x2500             MOVS     R5,#+0
    556          
    557              uint8_t unclean[KV_BLOCK_NUMS] = {0};
   \        0x6   0xA801             ADD      R0,SP,#+4
   \        0x8   0x2110             MOVS     R1,#+16
   \        0xA   0x....'....        BL       __aeabi_memclr4
    558          
    559              for (i = 0; i < KV_BLOCK_NUMS; i++) {
   \        0xE   0x462E             MOV      R6,R5
   \       0x10   0x....'....        LDR.W    R4,??DataTable20
   \       0x14   0xE00B             B.N      ??kv_init_internal_0
    560                  memset(&hdr, 0, KV_BLOCK_HDR_SIZE);
    561                  kv_flash_read((i << KV_BLOCK_SIZE_BITS), &hdr, KV_BLOCK_HDR_SIZE);
    562                  if (hdr.magic == KV_BLOCK_MAGIC_NUM) {
    563                      if (INVALID_BLK_STATE(hdr.state)) {
    564                          if ((res = kv_block_format(i)) != KV_OK) {
    565                              return res;
    566                          } else {
    567                              continue;
    568                          }
    569                      }
    570          
    571                      g_kv_mgr.block_info[i].state = hdr.state;
    572                      kv_item_traverse(__item_recovery_cb, i, NULL);
    573                      if (hdr.state == KV_BLOCK_STATE_CLEAN) {
    574                          if (g_kv_mgr.block_info[i].space != (KV_BLOCK_SIZE - KV_BLOCK_HDR_SIZE)) {
    575                              unclean[nums] = i;
    576                              nums++;
    577                          } else {
    578                              g_kv_mgr.clean_blk_nums++;
    579                          }
    580                      }
    581                  } else {
    582                      if ((res = kv_block_format(i)) != KV_OK) {
   \                     ??kv_init_internal_1: (+1)
   \       0x16   0x4630             MOV      R0,R6
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x....'....        BL       kv_block_format
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xF040 0x808E      BNE.W    ??kv_init_internal_2
   \       0x24   0xE002             B.N      ??kv_init_internal_3
    583                          return res;
    584                      }
    585                  }
   \                     ??kv_init_internal_4: (+1)
   \       0x26   0x78E0             LDRB     R0,[R4, #+3]
   \       0x28   0x1C40             ADDS     R0,R0,#+1
   \       0x2A   0x70E0             STRB     R0,[R4, #+3]
   \                     ??kv_init_internal_3: (+1)
   \       0x2C   0x1C76             ADDS     R6,R6,#+1
   \                     ??kv_init_internal_0: (+1)
   \       0x2E   0x4630             MOV      R0,R6
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x2810             CMP      R0,#+16
   \       0x34   0xDA40             BGE.N    ??kv_init_internal_5
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0x2104             MOVS     R1,#+4
   \       0x3A   0x4668             MOV      R0,SP
   \       0x3C   0x....'....        BL       __aeabi_memset4
   \       0x40   0x2204             MOVS     R2,#+4
   \       0x42   0x4669             MOV      R1,SP
   \       0x44   0x4630             MOV      R0,R6
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0x0480             LSLS     R0,R0,#+18
   \       0x4A   0x....'....        BL       kv_flash_read
   \       0x4E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x52   0x284B             CMP      R0,#+75
   \       0x54   0xD1DF             BNE.N    ??kv_init_internal_1
   \       0x56   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x5A   0x28CC             CMP      R0,#+204
   \       0x5C   0xD00A             BEQ.N    ??kv_init_internal_6
   \       0x5E   0x28EE             CMP      R0,#+238
   \       0x60   0xD008             BEQ.N    ??kv_init_internal_6
   \       0x62   0x2844             CMP      R0,#+68
   \       0x64   0xD006             BEQ.N    ??kv_init_internal_6
   \       0x66   0x4630             MOV      R0,R6
   \       0x68   0xB2C0             UXTB     R0,R0
   \       0x6A   0x....'....        BL       kv_block_format
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD166             BNE.N    ??kv_init_internal_2
   \       0x72   0xE7DB             B.N      ??kv_init_internal_3
   \                     ??kv_init_internal_6: (+1)
   \       0x74   0x4631             MOV      R1,R6
   \       0x76   0xB2C9             UXTB     R1,R1
   \       0x78   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \       0x7C   0x7508             STRB     R0,[R1, #+20]
   \       0x7E   0x2200             MOVS     R2,#+0
   \       0x80   0x4631             MOV      R1,R6
   \       0x82   0xB2C9             UXTB     R1,R1
   \       0x84   0x....'....        LDR.W    R0,??DataTable20_10
   \       0x88   0x....'....        BL       kv_item_traverse
   \       0x8C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x90   0x28EE             CMP      R0,#+238
   \       0x92   0xD1CB             BNE.N    ??kv_init_internal_3
   \       0x94   0x4630             MOV      R0,R6
   \       0x96   0xB2C0             UXTB     R0,R0
   \       0x98   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \       0x9C   0x6900             LDR      R0,[R0, #+16]
   \       0x9E   0x....'....        LDR.W    R1,??DataTable20_2  ;; 0x3fffc
   \       0xA2   0x4288             CMP      R0,R1
   \       0xA4   0xD0BF             BEQ.N    ??kv_init_internal_4
   \       0xA6   0xA801             ADD      R0,SP,#+4
   \       0xA8   0x5546             STRB     R6,[R0, R5]
   \       0xAA   0x1C6D             ADDS     R5,R5,#+1
   \       0xAC   0xE7BE             B.N      ??kv_init_internal_3
    586              }
    587          
    588              while (nums > 0) {
    589                  i = unclean[nums - 1];
    590                  if (g_kv_mgr.clean_blk_nums >= KV_RESERVED_BLOCKS) {
    591                      res = kv_set_block_state(i, KV_BLOCK_STATE_DIRTY);
    592                      if (res != KV_OK) {
    593                          return res;
    594                      }
    595                  } else {
    596                      if ((res = kv_block_format(i)) != KV_OK) {
   \                     ??kv_init_internal_7: (+1)
   \       0xAE   0x....'....        BL       kv_block_format
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD144             BNE.N    ??kv_init_internal_2
   \       0xB6   0xE00E             B.N      ??kv_init_internal_8
    597                          return res;
    598                      }
    599                  }
   \                     ??kv_init_internal_5: (+1)
   \       0xB8   0x2D01             CMP      R5,#+1
   \       0xBA   0xDB43             BLT.N    ??kv_init_internal_9
   \       0xBC   0xA801             ADD      R0,SP,#+4
   \       0xBE   0x4428             ADD      R0,R0,R5
   \       0xC0   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \       0xC4   0x4621             MOV      R1,R4
   \       0xC6   0x78C9             LDRB     R1,[R1, #+3]
   \       0xC8   0x2900             CMP      R1,#+0
   \       0xCA   0xD0F0             BEQ.N    ??kv_init_internal_7
   \       0xCC   0x2144             MOVS     R1,#+68
   \       0xCE   0x....'....        BL       kv_set_block_state
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD134             BNE.N    ??kv_init_internal_2
    600                  nums--;
   \                     ??kv_init_internal_8: (+1)
   \       0xD6   0x1E6D             SUBS     R5,R5,#+1
   \       0xD8   0xE7EE             B.N      ??kv_init_internal_5
    601              }
    602          
    603              if (g_kv_mgr.clean_blk_nums == 0) {
    604                  if ((res = kv_block_format(0)) != KV_OK) {
    605                      return res;
    606                  }
    607              }
    608          
    609              if (g_kv_mgr.clean_blk_nums == KV_BLOCK_NUMS) {
    610                  g_kv_mgr.write_pos = KV_BLOCK_HDR_SIZE;
    611                  i = (uint8_t)(g_kv_mgr.write_pos & KV_BLOCK_OFF_MASK);
    612          
    613                  res = kv_set_block_state(i, KV_BLOCK_STATE_USED);
    614                  if (res != KV_OK) {
    615                      return res;
    616                  }
    617                  g_kv_mgr.clean_blk_nums--;
   \                     ??kv_init_internal_10: (+1)
   \       0xDA   0x78E0             LDRB     R0,[R4, #+3]
   \       0xDC   0x1E40             SUBS     R0,R0,#+1
   \       0xDE   0x70E0             STRB     R0,[R4, #+3]
   \       0xE0   0xE02D             B.N      ??kv_init_internal_11
    618              } else {
    619                  for (i = 0; i < KV_BLOCK_NUMS; i++) {
   \                     ??kv_init_internal_12: (+1)
   \       0xE2   0x2000             MOVS     R0,#+0
   \       0xE4   0xE000             B.N      ??kv_init_internal_13
   \                     ??kv_init_internal_14: (+1)
   \       0xE6   0x1C40             ADDS     R0,R0,#+1
   \                     ??kv_init_internal_13: (+1)
   \       0xE8   0x4601             MOV      R1,R0
   \       0xEA   0xB2C9             UXTB     R1,R1
   \       0xEC   0x2910             CMP      R1,#+16
   \       0xEE   0xDA26             BGE.N    ??kv_init_internal_11
    620                      if ((g_kv_mgr.block_info[i].state == KV_BLOCK_STATE_USED) || \
    621                          (g_kv_mgr.block_info[i].state == KV_BLOCK_STATE_DIRTY)) {
   \       0xF0   0x4601             MOV      R1,R0
   \       0xF2   0xB2C9             UXTB     R1,R1
   \       0xF4   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \       0xF8   0x7D09             LDRB     R1,[R1, #+20]
   \       0xFA   0x29CC             CMP      R1,#+204
   \       0xFC   0xD006             BEQ.N    ??kv_init_internal_15
   \       0xFE   0x4601             MOV      R1,R0
   \      0x100   0xB2C9             UXTB     R1,R1
   \      0x102   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \      0x106   0x7D09             LDRB     R1,[R1, #+20]
   \      0x108   0x2944             CMP      R1,#+68
   \      0x10A   0xD1EC             BNE.N    ??kv_init_internal_14
    622                          next = ((i + 1) == KV_BLOCK_NUMS) ? 0 : (i + 1);
   \                     ??kv_init_internal_15: (+1)
   \      0x10C   0x4601             MOV      R1,R0
   \      0x10E   0xB2C9             UXTB     R1,R1
   \      0x110   0x1C49             ADDS     R1,R1,#+1
   \      0x112   0x2910             CMP      R1,#+16
   \      0x114   0xD101             BNE.N    ??kv_init_internal_16
   \      0x116   0x2100             MOVS     R1,#+0
   \      0x118   0xE000             B.N      ??kv_init_internal_17
   \                     ??kv_init_internal_16: (+1)
   \      0x11A   0x1C41             ADDS     R1,R0,#+1
    623                          if (g_kv_mgr.block_info[next].state == KV_BLOCK_STATE_CLEAN) {
   \                     ??kv_init_internal_17: (+1)
   \      0x11C   0xB2C9             UXTB     R1,R1
   \      0x11E   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \      0x122   0x7D09             LDRB     R1,[R1, #+20]
   \      0x124   0x29EE             CMP      R1,#+238
   \      0x126   0xD1DE             BNE.N    ??kv_init_internal_14
    624                              g_kv_mgr.write_pos = (i << KV_BLOCK_SIZE_BITS) + \
    625                                                   KV_BLOCK_SIZE - \
    626                                                   g_kv_mgr.block_info[i].space;
   \      0x128   0x4601             MOV      R1,R0
   \      0x12A   0xB2C9             UXTB     R1,R1
   \      0x12C   0x0489             LSLS     R1,R1,#+18
   \      0x12E   0xF501 0x2180      ADD      R1,R1,#+262144
   \      0x132   0xB2C0             UXTB     R0,R0
   \      0x134   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \      0x138   0x6900             LDR      R0,[R0, #+16]
   \      0x13A   0x1A09             SUBS     R1,R1,R0
   \      0x13C   0x6061             STR      R1,[R4, #+4]
    627                              break;
    628                          }
    629                      }
    630                  }
    631              }
    632          
    633              return KV_OK;
   \                     ??kv_init_internal_11: (+1)
   \      0x13E   0x2000             MOVS     R0,#+0
   \                     ??kv_init_internal_2: (+1)
   \      0x140   0xB006             ADD      SP,SP,#+24
   \      0x142   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??kv_init_internal_9: (+1)
   \      0x144   0x78E0             LDRB     R0,[R4, #+3]
   \      0x146   0x2800             CMP      R0,#+0
   \      0x148   0xD104             BNE.N    ??kv_init_internal_18
   \      0x14A   0x2000             MOVS     R0,#+0
   \      0x14C   0x....'....        BL       kv_block_format
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD1F5             BNE.N    ??kv_init_internal_2
   \                     ??kv_init_internal_18: (+1)
   \      0x154   0x78E0             LDRB     R0,[R4, #+3]
   \      0x156   0x2810             CMP      R0,#+16
   \      0x158   0xD1C3             BNE.N    ??kv_init_internal_12
   \      0x15A   0x2004             MOVS     R0,#+4
   \      0x15C   0x6060             STR      R0,[R4, #+4]
   \      0x15E   0x21CC             MOVS     R1,#+204
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0x....'....        BL       kv_set_block_state
   \      0x166   0x2800             CMP      R0,#+0
   \      0x168   0xD0B7             BEQ.N    ??kv_init_internal_10
   \      0x16A   0xE7E9             B.N      ??kv_init_internal_2
    634          }
    635          
    636          /**
    637           * Garbage collection task
    638           *
    639           * @param[in] arg pointer to the argument
    640           *
    641           * @return none
    642           */

   \                                 In section .text, align 4, keep-with-next
    643          static void kv_gc_task(void *arg)
    644          {
   \                     kv_gc_task: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    645              int32_t   res;
                               ^
Warning[Pe550]: variable "res" was set but never used
    646              kv_size_t origin_pos;
    647              uint8_t   i;
    648              uint8_t   gc_idx;
    649          
    650              uint8_t gc_copy = 0;
   \        0x4   0x2500             MOVS     R5,#+0
    651          
    652              if ((res = kv_lock(g_kv_mgr.lock)) != KV_OK) {
   \        0x6   0x....'....        LDR.W    R4,??DataTable20
   \        0xA   0x68E0             LDR      R0,[R4, #+12]
   \        0xC   0x....'....        BL       kv_lock
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD14C             BNE.N    ??kv_gc_task_0
    653                  goto exit;
    654              }
    655          
    656              origin_pos = g_kv_mgr.write_pos;
   \       0x14   0x6866             LDR      R6,[R4, #+4]
    657              if (g_kv_mgr.clean_blk_nums == 0) {
   \       0x16   0x78E0             LDRB     R0,[R4, #+3]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD048             BEQ.N    ??kv_gc_task_0
    658                  goto exit;
    659              }
    660          
    661              for (gc_idx = 0; gc_idx < KV_BLOCK_NUMS; gc_idx++) {
   \       0x1C   0x462F             MOV      R7,R5
   \       0x1E   0xE000             B.N      ??kv_gc_task_1
   \                     ??kv_gc_task_2: (+1)
   \       0x20   0x1C7F             ADDS     R7,R7,#+1
   \                     ??kv_gc_task_1: (+1)
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2810             CMP      R0,#+16
   \       0x28   0xDA0B             BGE.N    ??kv_gc_task_3
    662                  if (g_kv_mgr.block_info[gc_idx].state == KV_BLOCK_STATE_CLEAN) {
   \       0x2A   0x4638             MOV      R0,R7
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \       0x32   0x7D00             LDRB     R0,[R0, #+20]
   \       0x34   0x28EE             CMP      R0,#+238
   \       0x36   0xD1F3             BNE.N    ??kv_gc_task_2
    663                      g_kv_mgr.write_pos = (gc_idx << KV_BLOCK_SIZE_BITS) + KV_BLOCK_HDR_SIZE;
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0x0480             LSLS     R0,R0,#+18
   \       0x3E   0x1D00             ADDS     R0,R0,#+4
   \       0x40   0x6060             STR      R0,[R4, #+4]
    664                      break;
    665                  }
    666              }
    667          
    668              if (gc_idx == KV_BLOCK_NUMS) {
   \                     ??kv_gc_task_3: (+1)
   \       0x42   0x4638             MOV      R0,R7
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0x2810             CMP      R0,#+16
   \       0x48   0xD031             BEQ.N    ??kv_gc_task_0
    669                  goto exit;
    670              }
    671          
    672              i = (origin_pos >> KV_BLOCK_SIZE_BITS) + 1;
   \       0x4A   0x46B0             MOV      R8,R6
   \       0x4C   0xEA4F 0x4898      LSR      R8,R8,#+18
   \       0x50   0xF108 0x0801      ADD      R8,R8,#+1
   \       0x54   0xE006             B.N      ??kv_gc_task_4
    673              while (1) {
    674                  if (i == KV_BLOCK_NUMS) {
    675                      i = 0;
    676                  }
    677          
    678                  if (g_kv_mgr.block_info[i].state == KV_BLOCK_STATE_DIRTY) {
    679                      kv_item_traverse(__item_gc_cb, i, NULL);
    680          
    681                      gc_copy = 1;
    682          
    683                      if (kv_block_format(i) != KV_OK) {
    684                          goto exit;
    685                      }
    686          
    687                      kv_set_block_state(gc_idx, KV_BLOCK_STATE_USED);
    688                      g_kv_mgr.clean_blk_nums--;
    689                      break;
    690                  }
    691          
    692                  if (i == (origin_pos >> KV_BLOCK_SIZE_BITS)) {
   \                     ??kv_gc_task_5: (+1)
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0xEBB0 0x4F96      CMP      R0,R6, LSR #+18
   \       0x5E   0xD023             BEQ.N    ??kv_gc_task_6
    693                      break;
    694                  }
    695                  i++;
   \       0x60   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??kv_gc_task_4: (+1)
   \       0x64   0x4640             MOV      R0,R8
   \       0x66   0xB2C0             UXTB     R0,R0
   \       0x68   0x2810             CMP      R0,#+16
   \       0x6A   0xD100             BNE.N    ??kv_gc_task_7
   \       0x6C   0x46A8             MOV      R8,R5
   \                     ??kv_gc_task_7: (+1)
   \       0x6E   0x4640             MOV      R0,R8
   \       0x70   0xB2C0             UXTB     R0,R0
   \       0x72   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \       0x76   0x7D00             LDRB     R0,[R0, #+20]
   \       0x78   0x2844             CMP      R0,#+68
   \       0x7A   0xD1EC             BNE.N    ??kv_gc_task_5
   \       0x7C   0x462A             MOV      R2,R5
   \       0x7E   0x4641             MOV      R1,R8
   \       0x80   0xB2C9             UXTB     R1,R1
   \       0x82   0x....'....        LDR.W    R0,??DataTable20_11
   \       0x86   0x....'....        BL       kv_item_traverse
   \       0x8A   0x2501             MOVS     R5,#+1
   \       0x8C   0x4640             MOV      R0,R8
   \       0x8E   0xB2C0             UXTB     R0,R0
   \       0x90   0x....'....        BL       kv_block_format
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD10A             BNE.N    ??kv_gc_task_0
   \       0x98   0x21CC             MOVS     R1,#+204
   \       0x9A   0x4638             MOV      R0,R7
   \       0x9C   0xB2C0             UXTB     R0,R0
   \       0x9E   0x....'....        BL       kv_set_block_state
   \       0xA2   0x78E0             LDRB     R0,[R4, #+3]
   \       0xA4   0x1E40             SUBS     R0,R0,#+1
   \       0xA6   0x70E0             STRB     R0,[R4, #+3]
    696              }
    697          
    698              if (gc_copy == 0) {
   \                     ??kv_gc_task_6: (+1)
   \       0xA8   0x2D00             CMP      R5,#+0
   \       0xAA   0xD100             BNE.N    ??kv_gc_task_0
    699                  g_kv_mgr.write_pos = origin_pos;
   \       0xAC   0x6066             STR      R6,[R4, #+4]
    700              }
    701          
    702          exit:
    703              g_kv_mgr.gc_trigger = 0;
   \                     ??kv_gc_task_0: (+1)
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0x7060             STRB     R0,[R4, #+1]
    704              kv_unlock(g_kv_mgr.lock);
   \       0xB2   0x68E0             LDR      R0,[R4, #+12]
   \       0xB4   0x....'....        BL       kv_unlock
    705              if (g_kv_mgr.gc_waiter > 0) {
   \       0xB8   0x78A0             LDRB     R0,[R4, #+2]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD002             BEQ.N    ??kv_gc_task_8
    706                  kv_sem_post_all(g_kv_mgr.gc_sem);
   \       0xBE   0x68A0             LDR      R0,[R4, #+8]
   \       0xC0   0x....'....        BL       kv_sem_post_all
    707              }
    708          
    709              kv_delete_task();
   \                     ??kv_gc_task_8: (+1)
   \       0xC4   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xC8   0x....'....        B.W      kv_delete_task
    710          }
    711          
    712          /**
    713           * @brief polling flash block
    714           *
    715           * @param[in]  func    pointer to callback function
    716           * @param[in]  blk_idx the block index
    717           * @param[in]  key     pointer to the key
    718           *
    719           * @return the key-value item or NULL.
    720           */

   \                                 In section .text, align 2, keep-with-next
    721          kv_item_t *kv_item_traverse(item_func func, uint8_t blk_idx, const char *key)
    722          {
   \                     kv_item_traverse: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4690             MOV      R8,R2
    723              int32_t     res;
    724              uint16_t    len;
    725              kv_size_t   pos;
    726              kv_size_t   end;
    727              kv_item_t  *item;
    728              item_hdr_t *hdr;
    729          
    730              pos = (blk_idx << KV_BLOCK_SIZE_BITS) + KV_BLOCK_HDR_SIZE;
   \        0xA   0x46B9             MOV      R9,R7
   \        0xC   0xEA4F 0x4989      LSL      R9,R9,#+18
   \       0x10   0xF109 0x0904      ADD      R9,R9,#+4
    731              end = (blk_idx << KV_BLOCK_SIZE_BITS) + KV_BLOCK_SIZE;
   \       0x14   0x463D             MOV      R5,R7
   \       0x16   0x04AD             LSLS     R5,R5,#+18
   \       0x18   0xF505 0x2580      ADD      R5,R5,#+262144
    732              len = 0;
    733          
    734              do {
    735                  item = (kv_item_t *)kv_malloc(sizeof(kv_item_t));
   \                     ??kv_item_traverse_0: (+1)
   \       0x1C   0x2018             MOVS     R0,#+24
   \       0x1E   0x....'....        BL       kv_malloc
   \       0x22   0x0004             MOVS     R4,R0
    736                  if (!item) {
   \       0x24   0xD07C             BEQ.N    ??kv_item_traverse_1
    737                      return NULL;
    738                  }
    739          
    740                  memset(item, 0, sizeof(kv_item_t));
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x2118             MOVS     R1,#+24
   \       0x2A   0x....'....        BL       __aeabi_memset4
    741                  hdr = &(item->hdr);
    742          
    743                  if (kv_flash_read(pos, hdr, KV_ITEM_HDR_SIZE) != KV_OK) {
   \       0x2E   0x220A             MOVS     R2,#+10
   \       0x30   0x4621             MOV      R1,R4
   \       0x32   0x4648             MOV      R0,R9
   \       0x34   0x....'....        BL       kv_flash_read
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD148             BNE.N    ??kv_item_traverse_2
    744                      kv_item_free(item);
    745                      return NULL;
    746                  }
    747          
    748                  if (hdr->magic != KV_ITEM_MAGIC_NUM) {
   \       0x3C   0x7820             LDRB     R0,[R4, #+0]
   \       0x3E   0x2849             CMP      R0,#+73
   \       0x40   0xD007             BEQ.N    ??kv_item_traverse_3
    749                      if ((hdr->magic == 0xFF) && (hdr->state == 0xFF)) {
   \       0x42   0x28FF             CMP      R0,#+255
   \       0x44   0xD102             BNE.N    ??kv_item_traverse_4
   \       0x46   0x7860             LDRB     R0,[R4, #+1]
   \       0x48   0x28FF             CMP      R0,#+255
   \       0x4A   0xD021             BEQ.N    ??kv_item_traverse_5
    750                          kv_item_free(item);
    751                          break;
    752                      }
    753                      hdr->val_len = 0xFFFF;
   \                     ??kv_item_traverse_4: (+1)
   \       0x4C   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x50   0x80A0             STRH     R0,[R4, #+4]
    754                  }
    755          
    756                  if ((hdr->val_len > KV_MAX_VAL_LEN) || \
    757                      (hdr->key_len > KV_MAX_KEY_LEN) || \
    758                      (hdr->val_len == 0) || (hdr->key_len == 0)) {
   \                     ??kv_item_traverse_3: (+1)
   \       0x52   0x88A0             LDRH     R0,[R4, #+4]
   \       0x54   0xF240 0x2101      MOVW     R1,#+513
   \       0x58   0x4288             CMP      R0,R1
   \       0x5A   0xDA08             BGE.N    ??kv_item_traverse_6
   \       0x5C   0x78E0             LDRB     R0,[R4, #+3]
   \       0x5E   0x2881             CMP      R0,#+129
   \       0x60   0xDA05             BGE.N    ??kv_item_traverse_6
   \       0x62   0x88A0             LDRH     R0,[R4, #+4]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD002             BEQ.N    ??kv_item_traverse_6
   \       0x68   0x78E0             LDRB     R0,[R4, #+3]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD114             BNE.N    ??kv_item_traverse_7
    759          
    760                      pos += KV_ITEM_HDR_SIZE;
   \                     ??kv_item_traverse_6: (+1)
   \       0x6E   0xF109 0x090A      ADD      R9,R9,#+10
    761                      kv_item_free(item);
   \       0x72   0x4620             MOV      R0,R4
   \       0x74   0x....'....        BL       kv_item_free
    762          
    763                      if (g_kv_mgr.block_info[blk_idx].state == KV_BLOCK_STATE_USED) {
   \       0x78   0x....             LDR.N    R0,??DataTable20
   \       0x7A   0x4639             MOV      R1,R7
   \       0x7C   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \       0x80   0x7D00             LDRB     R0,[R0, #+20]
   \       0x82   0x28CC             CMP      R0,#+204
   \       0x84   0xD139             BNE.N    ??kv_item_traverse_8
    764                          kv_set_block_state(blk_idx, KV_BLOCK_STATE_DIRTY);
   \       0x86   0x2144             MOVS     R1,#+68
   \       0x88   0x4638             MOV      R0,R7
   \       0x8A   0x....'....        BL       kv_set_block_state
   \       0x8E   0xE034             B.N      ??kv_item_traverse_8
    765                      }
    766                      continue;
    767                  }
   \                     ??kv_item_traverse_5: (+1)
   \       0x90   0x4620             MOV      R0,R4
   \       0x92   0x....'....        BL       kv_item_free
   \       0x96   0xE034             B.N      ??kv_item_traverse_9
    768          
    769                  len = KV_ALIGN(KV_ITEM_HDR_SIZE + hdr->key_len + hdr->val_len);
   \                     ??kv_item_traverse_7: (+1)
   \       0x98   0x88A1             LDRH     R1,[R4, #+4]
   \       0x9A   0xEB01 0x0A00      ADD      R10,R1,R0
   \       0x9E   0xF10A 0x0A0D      ADD      R10,R10,#+13
   \       0xA2   0xF64F 0x70FC      MOVW     R0,#+65532
   \       0xA6   0xEA00 0x0A0A      AND      R10,R0,R10
    770          
    771                  if (hdr->state == KV_ITEM_STATE_NORMAL) {
   \       0xAA   0x7860             LDRB     R0,[R4, #+1]
   \       0xAC   0x28EE             CMP      R0,#+238
   \       0xAE   0xD115             BNE.N    ??kv_item_traverse_10
    772                      item->pos = pos;
   \       0xB0   0xF8C4 0x9014      STR      R9,[R4, #+20]
    773                      item->len = hdr->key_len + hdr->val_len;
   \       0xB4   0x78E0             LDRB     R0,[R4, #+3]
   \       0xB6   0x88A1             LDRH     R1,[R4, #+4]
   \       0xB8   0x1808             ADDS     R0,R1,R0
   \       0xBA   0x8220             STRH     R0,[R4, #+16]
    774          
    775                      res = func(item, key);
   \       0xBC   0x4641             MOV      R1,R8
   \       0xBE   0x4620             MOV      R0,R4
   \       0xC0   0x47B0             BLX      R6
    776                      if (res == KV_OK) {
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD008             BEQ.N    ??kv_item_traverse_11
    777                          return item;
    778                      } else if (res != KV_LOOP_CONTINUE) {
   \       0xC6   0xF242 0x7110      MOVW     R1,#+10000
   \       0xCA   0x4288             CMP      R0,R1
   \       0xCC   0xD011             BEQ.N    ??kv_item_traverse_12
    779                          kv_item_free(item);
   \                     ??kv_item_traverse_2: (+1)
   \       0xCE   0x4620             MOV      R0,R4
   \       0xD0   0x....'....        BL       kv_item_free
    780                          return NULL;
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0xE024             B.N      ??kv_item_traverse_13
    781                      }
   \                     ??kv_item_traverse_11: (+1)
   \       0xD8   0x4620             MOV      R0,R4
   \       0xDA   0xE022             B.N      ??kv_item_traverse_13
    782                  } else {
    783                      if (g_kv_mgr.block_info[blk_idx].state == KV_BLOCK_STATE_USED) {
   \                     ??kv_item_traverse_10: (+1)
   \       0xDC   0x....             LDR.N    R0,??DataTable20
   \       0xDE   0x4639             MOV      R1,R7
   \       0xE0   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \       0xE4   0x7D00             LDRB     R0,[R0, #+20]
   \       0xE6   0x28CC             CMP      R0,#+204
   \       0xE8   0xD103             BNE.N    ??kv_item_traverse_12
    784                          kv_set_block_state(blk_idx, KV_BLOCK_STATE_DIRTY);
   \       0xEA   0x2144             MOVS     R1,#+68
   \       0xEC   0x4638             MOV      R0,R7
   \       0xEE   0x....'....        BL       kv_set_block_state
    785                      }
    786                  }
    787          
    788                  kv_item_free(item);
   \                     ??kv_item_traverse_12: (+1)
   \       0xF2   0x4620             MOV      R0,R4
   \       0xF4   0x....'....        BL       kv_item_free
    789                  pos += len;
   \       0xF8   0x44D1             ADD      R9,R9,R10
    790              } while (end > (pos + KV_ITEM_HDR_SIZE));
   \                     ??kv_item_traverse_8: (+1)
   \       0xFA   0xF109 0x000A      ADD      R0,R9,#+10
   \       0xFE   0x42A8             CMP      R0,R5
   \      0x100   0xD38C             BCC.N    ??kv_item_traverse_0
    791              
    792              if (end > pos) {
   \                     ??kv_item_traverse_9: (+1)
   \      0x102   0x45A9             CMP      R9,R5
   \      0x104   0xD207             BCS.N    ??kv_item_traverse_14
    793                  g_kv_mgr.block_info[blk_idx].space = end - pos;
   \      0x106   0xEBA5 0x0909      SUB      R9,R5,R9
   \      0x10A   0x....             LDR.N    R0,??DataTable20
   \      0x10C   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \      0x110   0xF8C0 0x9010      STR      R9,[R0, #+16]
   \      0x114   0xE004             B.N      ??kv_item_traverse_1
    794              } else {
    795                  g_kv_mgr.block_info[blk_idx].space = KV_ITEM_HDR_SIZE;
   \                     ??kv_item_traverse_14: (+1)
   \      0x116   0x200A             MOVS     R0,#+10
   \      0x118   0x....             LDR.N    R1,??DataTable20
   \      0x11A   0xEB01 0x01C7      ADD      R1,R1,R7, LSL #+3
   \      0x11E   0x6108             STR      R0,[R1, #+16]
    796              }
    797          
    798              return NULL;
   \                     ??kv_item_traverse_1: (+1)
   \      0x120   0x2000             MOVS     R0,#+0
   \                     ??kv_item_traverse_13: (+1)
   \      0x122   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    799          }
    800          
    801          /******************************************************/
    802          /****************** Public Interface ******************/
    803          /******************************************************/
    804          

   \                                 In section .text, align 2, keep-with-next
    805          int32_t kv_init(void)
    806          {
   \                     kv_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    807              int32_t res;
    808              uint8_t blk_idx;
    809          
    810              if (g_kv_mgr.inited) {
   \        0x2   0x....             LDR.N    R4,??DataTable20
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??kv_init_0
    811                  return KV_OK;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD10             POP      {R4,PC}
    812              }
    813          
    814              if (KV_BLOCK_NUMS <= KV_RESERVED_BLOCKS) {
    815                  return KV_ERR_INVALID_PARAM;
    816              }
    817          
    818              memset(&g_kv_mgr, 0, sizeof(kv_mgr_t));
   \                     ??kv_init_0: (+1)
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x2190             MOVS     R1,#+144
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x....'....        BL       __aeabi_memset4
    819          
    820              g_kv_mgr.lock = kv_lock_create();
   \       0x18   0x....'....        BL       kv_lock_create
   \       0x1C   0x60E0             STR      R0,[R4, #+12]
    821              if (g_kv_mgr.lock == NULL) {
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??kv_init_1
    822                  return KV_ERR_OS_LOCK;
   \       0x22   0x....             LDR.N    R0,??DataTable20_12  ;; 0xffffd8e8
   \       0x24   0xBD10             POP      {R4,PC}
    823              }
    824          
    825              g_kv_mgr.gc_sem = kv_sem_create();
   \                     ??kv_init_1: (+1)
   \       0x26   0x....'....        BL       kv_sem_create
   \       0x2A   0x60A0             STR      R0,[R4, #+8]
    826              if (g_kv_mgr.gc_sem == NULL) {
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD101             BNE.N    ??kv_init_2
    827                  return KV_ERR_OS_SEM;
   \       0x30   0x....             LDR.N    R0,??DataTable20_13  ;; 0xffffd8e7
   \       0x32   0xBD10             POP      {R4,PC}
    828              }
    829          
    830              if ((res = kv_init_internal()) != KV_OK) {
   \                     ??kv_init_2: (+1)
   \       0x34   0x....'....        BL       kv_init_internal
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD113             BNE.N    ??kv_init_3
    831                  return res;
    832              }
    833          
    834              g_kv_mgr.inited = 1;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x7020             STRB     R0,[R4, #+0]
    835          
    836              blk_idx = (g_kv_mgr.write_pos >> KV_BLOCK_SIZE_BITS);
    837              if (((g_kv_mgr.block_info[blk_idx].space) < KV_ITEM_MAX_LEN) && \
    838                   (g_kv_mgr.clean_blk_nums < KV_RESERVED_BLOCKS + 1)) {
   \       0x40   0x6860             LDR      R0,[R4, #+4]
   \       0x42   0x0C80             LSRS     R0,R0,#+18
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \       0x4A   0x6900             LDR      R0,[R0, #+16]
   \       0x4C   0xF240 0x218A      MOVW     R1,#+650
   \       0x50   0x4288             CMP      R0,R1
   \       0x52   0xD204             BCS.N    ??kv_init_4
   \       0x54   0x78E0             LDRB     R0,[R4, #+3]
   \       0x56   0x2802             CMP      R0,#+2
   \       0x58   0xDA01             BGE.N    ??kv_init_4
    839                  kv_trigger_gc();
   \       0x5A   0x....'....        BL       kv_trigger_gc
    840              }
    841          
    842              kv_register_cli_command();
   \                     ??kv_init_4: (+1)
   \       0x5E   0x....'....        BL       kv_register_cli_command
    843          
    844              return KV_OK;
   \       0x62   0x2000             MOVS     R0,#+0
   \                     ??kv_init_3: (+1)
   \       0x64   0xBD10             POP      {R4,PC}          ;; return
    845          }
    846          

   \                                 In section .text, align 2, keep-with-next
    847          void kv_deinit(void)
    848          {
   \                     kv_deinit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    849              g_kv_mgr.inited = 0;
   \        0x2   0x....             LDR.N    R4,??DataTable20
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x7020             STRB     R0,[R4, #+0]
    850          
    851              kv_sem_free(g_kv_mgr.gc_sem);
   \        0x8   0x68A0             LDR      R0,[R4, #+8]
   \        0xA   0x....'....        BL       kv_sem_free
    852          
    853              kv_lock_free(g_kv_mgr.lock);
   \        0xE   0x68E0             LDR      R0,[R4, #+12]
   \       0x10   0xE8BD 0x4010      POP      {R4,LR}
   \       0x14   0x....'....        B.W      kv_lock_free
    854          }
    855          

   \                                 In section .text, align 2, keep-with-next
    856          int32_t kv_item_set(const char *key, const void *val, int32_t len)
    857          {
   \                     kv_item_set: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4617             MOV      R7,R2
    858              int32_t res;
    859          
    860              kv_item_t *item = NULL;
    861          
    862          #if (KV_SECURE_SUPPORT) && (KV_SECURE_LEVEL > 1)
    863              return kv_item_secure_set(key, val, len);
    864          #endif
    865          
    866              if (!key || !val || (len <= 0) || (strlen(key) > KV_MAX_KEY_LEN) || \
    867                  (len > KV_MAX_VAL_LEN)) {
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD00B             BEQ.N    ??kv_item_set_0
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD009             BEQ.N    ??kv_item_set_0
   \       0x12   0x2F01             CMP      R7,#+1
   \       0x14   0xDB07             BLT.N    ??kv_item_set_0
   \       0x16   0x....'....        BL       strlen
   \       0x1A   0x2881             CMP      R0,#+129
   \       0x1C   0xD203             BCS.N    ??kv_item_set_0
   \       0x1E   0xF240 0x2001      MOVW     R0,#+513
   \       0x22   0x4287             CMP      R7,R0
   \       0x24   0xDB01             BLT.N    ??kv_item_set_1
    868                  return KV_ERR_INVALID_PARAM;
   \                     ??kv_item_set_0: (+1)
   \       0x26   0x....             LDR.N    R0,??DataTable20_7  ;; 0xffffd8ee
   \       0x28   0xE031             B.N      ??kv_item_set_2
    869              }
    870          
    871              if (g_kv_mgr.gc_trigger != 0) {
   \                     ??kv_item_set_1: (+1)
   \       0x2A   0x....'....        LDR.W    R8,??DataTable20
   \       0x2E   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD008             BEQ.N    ??kv_item_set_3
    872                  g_kv_mgr.gc_waiter++;
   \       0x36   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \       0x3A   0x1C40             ADDS     R0,R0,#+1
   \       0x3C   0xF888 0x0002      STRB     R0,[R8, #+2]
    873                  kv_sem_wait(g_kv_mgr.gc_sem);
   \       0x40   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x44   0x....'....        BL       kv_sem_wait
    874              }
    875          
    876              if ((res = kv_lock(g_kv_mgr.lock)) != KV_OK) {
   \                     ??kv_item_set_3: (+1)
   \       0x48   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x4C   0x....'....        BL       kv_lock
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD001             BEQ.N    ??kv_item_set_4
    877                  return KV_ERR_OS_LOCK;
   \       0x54   0x....             LDR.N    R0,??DataTable20_12  ;; 0xffffd8e8
   \       0x56   0xE01A             B.N      ??kv_item_set_2
    878              }
    879          
    880              item = kv_item_search(key);
   \                     ??kv_item_set_4: (+1)
   \       0x58   0x4630             MOV      R0,R6
   \       0x5A   0x....'....        BL       kv_item_search
   \       0x5E   0x0004             MOVS     R4,R0
    881              if (item != NULL) {
   \       0x60   0xD009             BEQ.N    ??kv_item_set_5
    882                  res = kv_item_update(item, key, val, len);
   \       0x62   0x463B             MOV      R3,R7
   \       0x64   0x462A             MOV      R2,R5
   \       0x66   0x4631             MOV      R1,R6
   \       0x68   0x....'....        BL       kv_item_update
   \       0x6C   0x4605             MOV      R5,R0
    883                  kv_item_free(item);
   \       0x6E   0x4620             MOV      R0,R4
   \       0x70   0x....'....        BL       kv_item_free
   \       0x74   0xE006             B.N      ??kv_item_set_6
    884              } else {
    885                  res = kv_item_store(key, val, len, 0);
   \                     ??kv_item_set_5: (+1)
   \       0x76   0x2300             MOVS     R3,#+0
   \       0x78   0x463A             MOV      R2,R7
   \       0x7A   0x4629             MOV      R1,R5
   \       0x7C   0x4630             MOV      R0,R6
   \       0x7E   0x....'....        BL       kv_item_store
   \       0x82   0x4605             MOV      R5,R0
    886              }
    887          
    888              kv_unlock(g_kv_mgr.lock);
   \                     ??kv_item_set_6: (+1)
   \       0x84   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x88   0x....'....        BL       kv_unlock
    889          
    890              return res;
   \       0x8C   0x4628             MOV      R0,R5
   \                     ??kv_item_set_2: (+1)
   \       0x8E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    891          }
    892          

   \                                 In section .text, align 2, keep-with-next
    893          int32_t kv_item_get(const char *key, void *buffer, int32_t *buffer_len)
    894          {
   \                     kv_item_get: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4614             MOV      R4,R2
    895              int32_t res;
                             ^
Warning[Pe550]: variable "res" was set but never used
    896          
    897              kv_item_t *item = NULL;
    898          
    899          #if (KV_SECURE_SUPPORT) && (KV_SECURE_LEVEL > 1)
    900              return kv_item_secure_get(key, buffer, buffer_len);
    901          #endif
    902          
    903              if (!key || !buffer || !buffer_len || (*buffer_len <= 0)) {
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD006             BEQ.N    ??kv_item_get_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD004             BEQ.N    ??kv_item_get_0
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD002             BEQ.N    ??kv_item_get_0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xDA01             BGE.N    ??kv_item_get_1
    904                  return KV_ERR_INVALID_PARAM;
   \                     ??kv_item_get_0: (+1)
   \       0x1A   0x....             LDR.N    R0,??DataTable20_7  ;; 0xffffd8ee
   \       0x1C   0xBDF2             POP      {R1,R4-R7,PC}
    905              }
    906          
    907              if ((res = kv_lock(g_kv_mgr.lock)) != KV_OK) {
   \                     ??kv_item_get_1: (+1)
   \       0x1E   0x....             LDR.N    R7,??DataTable20
   \       0x20   0x68F8             LDR      R0,[R7, #+12]
   \       0x22   0x....'....        BL       kv_lock
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ.N    ??kv_item_get_2
    908                  return KV_ERR_OS_LOCK;
   \       0x2A   0x....             LDR.N    R0,??DataTable20_12  ;; 0xffffd8e8
   \       0x2C   0xBDF2             POP      {R1,R4-R7,PC}
    909              }
    910          
    911              item = kv_item_search(key);
   \                     ??kv_item_get_2: (+1)
   \       0x2E   0x4630             MOV      R0,R6
   \       0x30   0x....'....        BL       kv_item_search
   \       0x34   0x4606             MOV      R6,R0
    912          
    913              kv_unlock(g_kv_mgr.lock);
   \       0x36   0x68F8             LDR      R0,[R7, #+12]
   \       0x38   0x....'....        BL       kv_unlock
    914          
    915              if (!item) {
   \       0x3C   0x2E00             CMP      R6,#+0
   \       0x3E   0xD101             BNE.N    ??kv_item_get_3
    916                  return KV_ERR_NOT_FOUND;
   \       0x40   0x....             LDR.N    R0,??DataTable20_14  ;; 0xffffd8ec
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}
    917              }
    918          
    919              if (*buffer_len < item->hdr.val_len) {
   \                     ??kv_item_get_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x88B1             LDRH     R1,[R6, #+4]
   \       0x48   0x4288             CMP      R0,R1
   \       0x4A   0xDA06             BGE.N    ??kv_item_get_4
    920                  *buffer_len = item->hdr.val_len;
   \       0x4C   0x4608             MOV      R0,R1
   \       0x4E   0x6020             STR      R0,[R4, #+0]
    921                  kv_item_free(item);
   \       0x50   0x4630             MOV      R0,R6
   \       0x52   0x....'....        BL       kv_item_free
    922                  return KV_ERR_NO_SPACE;
   \       0x56   0x....             LDR.N    R0,??DataTable20_9  ;; 0xffffd8ef
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}
    923              } else {
    924                  memcpy(buffer, (item->store + item->hdr.key_len), item->hdr.val_len);
   \                     ??kv_item_get_4: (+1)
   \       0x5A   0x460A             MOV      R2,R1
   \       0x5C   0x68F0             LDR      R0,[R6, #+12]
   \       0x5E   0x78F1             LDRB     R1,[R6, #+3]
   \       0x60   0x4401             ADD      R1,R0,R1
   \       0x62   0x4628             MOV      R0,R5
   \       0x64   0x....'....        BL       __aeabi_memcpy
    925                  *buffer_len = item->hdr.val_len;
   \       0x68   0x88B0             LDRH     R0,[R6, #+4]
   \       0x6A   0x6020             STR      R0,[R4, #+0]
    926              }
    927          
    928              kv_item_free(item);
   \       0x6C   0x4630             MOV      R0,R6
   \       0x6E   0x....'....        BL       kv_item_free
    929          
    930              return KV_OK;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    931          }
    932          

   \                                 In section .text, align 2, keep-with-next
    933          int32_t kv_item_delete(const char *key)
    934          {
   \                     kv_item_delete: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    935              int32_t res;
    936          
    937              kv_item_t *item = NULL;
    938          
    939              if ((res = kv_lock(g_kv_mgr.lock)) != KV_OK) {
   \        0x4   0x....             LDR.N    R5,??DataTable20
   \        0x6   0x68E8             LDR      R0,[R5, #+12]
   \        0x8   0x....'....        BL       kv_lock
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD001             BEQ.N    ??kv_item_delete_0
    940                  return KV_ERR_OS_LOCK;
   \       0x10   0x....             LDR.N    R0,??DataTable20_12  ;; 0xffffd8e8
   \       0x12   0xBD70             POP      {R4-R6,PC}
    941              }
    942          
    943              item = kv_item_search(key);
   \                     ??kv_item_delete_0: (+1)
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       kv_item_search
   \       0x1A   0x0004             MOVS     R4,R0
    944              if (!item) {
   \       0x1C   0xD104             BNE.N    ??kv_item_delete_1
    945                  kv_unlock(g_kv_mgr.lock);
   \       0x1E   0x68E8             LDR      R0,[R5, #+12]
   \       0x20   0x....'....        BL       kv_unlock
    946                  return KV_ERR_NOT_FOUND;
   \       0x24   0x....             LDR.N    R0,??DataTable20_14  ;; 0xffffd8ec
   \       0x26   0xBD70             POP      {R4-R6,PC}
    947              }
    948          
    949              res = kv_item_del(item, KV_DELETE_FLAG);
   \                     ??kv_item_delete_1: (+1)
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x....'....        BL       kv_item_del
   \       0x2E   0x4606             MOV      R6,R0
    950              kv_item_free(item);
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       kv_item_free
    951              kv_unlock(g_kv_mgr.lock);
   \       0x36   0x68E8             LDR      R0,[R5, #+12]
   \       0x38   0x....'....        BL       kv_unlock
    952          
    953              return res;
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return
    954          }
    955          

   \                                 In section .text, align 2, keep-with-next
    956          int32_t kv_item_delete_by_prefix(const char *prefix)
    957          {
   \                     kv_item_delete_by_prefix: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    958              int32_t i;
    959              int32_t res;
                             ^
Warning[Pe550]: variable "res" was set but never used
    960          
    961              if ((res = kv_lock(g_kv_mgr.lock)) != KV_OK) {
   \        0x4   0x....             LDR.N    R5,??DataTable20
   \        0x6   0x68E8             LDR      R0,[R5, #+12]
   \        0x8   0x....'....        BL       kv_lock
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD001             BEQ.N    ??kv_item_delete_by_prefix_0
    962                  return KV_ERR_OS_LOCK;
   \       0x10   0x....             LDR.N    R0,??DataTable20_12  ;; 0xffffd8e8
   \       0x12   0xBD70             POP      {R4-R6,PC}
    963              }
    964          
    965              for (i = 0; i < KV_BLOCK_NUMS; i++) {
   \                     ??kv_item_delete_by_prefix_0: (+1)
   \       0x14   0x2600             MOVS     R6,#+0
   \       0x16   0xE007             B.N      ??kv_item_delete_by_prefix_1
    966                  kv_item_traverse(__item_del_by_prefix_cb, i, prefix);
   \                     ??kv_item_delete_by_prefix_2: (+1)
   \       0x18   0x4622             MOV      R2,R4
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0x4601             MOV      R1,R0
   \       0x1E   0xB2C9             UXTB     R1,R1
   \       0x20   0x....             LDR.N    R0,??DataTable20_15
   \       0x22   0x....'....        BL       kv_item_traverse
    967              }
   \       0x26   0x1C76             ADDS     R6,R6,#+1
   \                     ??kv_item_delete_by_prefix_1: (+1)
   \       0x28   0x2E10             CMP      R6,#+16
   \       0x2A   0xDBF5             BLT.N    ??kv_item_delete_by_prefix_2
    968          
    969              kv_unlock(g_kv_mgr.lock);
   \       0x2C   0x68E8             LDR      R0,[R5, #+12]
   \       0x2E   0x....'....        BL       kv_unlock
    970          
    971              return KV_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD70             POP      {R4-R6,PC}       ;; return
    972          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x....'....        DC32     g_kv_mgr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x0003'FFFC        DC32     0x3fffc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \        0x0   0xFFFF'D8E9        DC32     0xffffd8e9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \        0x0   0xFFFF'D8EA        DC32     0xffffd8ea

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \        0x0   0xFFFF'D8EB        DC32     0xffffd8eb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \        0x0   0xFFFF'D8ED        DC32     0xffffd8ed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \        0x0   0xFFFF'D8EE        DC32     0xffffd8ee

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \        0x0   0x....'....        DC32     __item_find_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \        0x0   0xFFFF'D8EF        DC32     0xffffd8ef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \        0x0   0x....'....        DC32     __item_recovery_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \        0x0   0x....'....        DC32     __item_gc_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \        0x0   0xFFFF'D8E8        DC32     0xffffd8e8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \        0x0   0xFFFF'D8E7        DC32     0xffffd8e7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_14:
   \        0x0   0xFFFF'D8EC        DC32     0xffffd8ec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_15:
   \        0x0   0x....'....        DC32     __item_del_by_prefix_cb

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x6B 0x76          DC8 "kv_gc"
   \              0x5F 0x67    
   \              0x63 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    973          
    974          #if (KV_SECURE_SUPPORT)
    975          
    976          int32_t kv_item_secure_set(const char *key, const void *val, int32_t len)
    977          {
    978              int32_t res;
    979          
    980              uint8_t   *data = NULL;
    981              kv_item_t *item = NULL;
    982          
    983              if (!key || !val || (len <= 0) || (strlen(key) > KV_MAX_KEY_LEN) || \
    984                  (len > KV_MAX_VAL_LEN)) {
    985                  return KV_ERR_INVALID_PARAM;
    986              }
    987          
    988              if (g_kv_mgr.gc_trigger != 0) {
    989                  g_kv_mgr.gc_waiter++;
    990                  kv_sem_wait(g_kv_mgr.gc_sem);
    991              }
    992          
    993              if ((res = kv_lock(g_kv_mgr.lock)) != KV_OK) {
    994                  return KV_ERR_OS_LOCK;
    995              }
    996          
    997              data = (uint8_t *)kv_malloc(len);
    998              if (data == NULL) {
    999                  return KV_ERR_NO_SPACE;
   1000              }
   1001          
   1002              memset(data, 0, len);
   1003          
   1004              res = kv_secure_encrypt((uint8_t *)val, data, len);
   1005              if (res != KV_OK) {
   1006                  kv_free(data);
   1007                  data = NULL;
   1008          
   1009                  return KV_ERR_ENCRYPT;
   1010              }
   1011          
   1012              item = kv_item_search(key);
   1013              if (item != NULL) {
   1014                  res = kv_item_update(item, key, data, len);
   1015                  kv_item_free(item);
   1016          
   1017              } else {
   1018                  res = kv_item_store(key, data, len, 0);
   1019              }
   1020          
   1021              kv_unlock(g_kv_mgr.lock);
   1022          
   1023              kv_free(data);
   1024              data = NULL;
   1025          
   1026              return res;
   1027          }
   1028          
   1029          int32_t kv_item_secure_get(const char *key, void *buffer, int32_t *buffer_len)
   1030          {
   1031              int32_t res;
   1032          
   1033              uint8_t   *data = NULL;
   1034              kv_item_t *item = NULL;
   1035          
   1036              if (!key || !buffer || !buffer_len || (*buffer_len <= 0)) {
   1037                  return KV_ERR_INVALID_PARAM;
   1038              }
   1039          
   1040              if ((res = kv_lock(g_kv_mgr.lock)) != KV_OK) {
   1041                  return KV_ERR_OS_LOCK;
   1042              }
   1043          
   1044              item = kv_item_search(key);
   1045          
   1046              kv_unlock(g_kv_mgr.lock);
   1047          
   1048              if (!item) {
   1049                  return KV_ERR_NOT_FOUND;
   1050              }
   1051          
   1052              if (*buffer_len < item->hdr.val_len) {
   1053                  *buffer_len = item->hdr.val_len;
   1054                  kv_item_free(item);
   1055                  return KV_ERR_NO_SPACE;
   1056              } else {
   1057                  data = (uint8_t *)kv_malloc(item->hdr.val_len);
   1058                  if (data == NULL) {
   1059                      return KV_ERR_NO_SPACE;
   1060                  }
   1061          
   1062                  memset(data, 0, item->hdr.val_len);
   1063          
   1064                  res = kv_secure_decrypt((uint8_t *)(item->store + item->hdr.key_len), data, item->hdr.val_len);
   1065                  if (res != KV_OK) {
   1066                      kv_free(data);
   1067                      data = NULL;
   1068          
   1069                      return KV_ERR_DECRYPT;
   1070                  }
   1071          
   1072                  memcpy(buffer, data, item->hdr.val_len);
   1073                  *buffer_len = item->hdr.val_len;
   1074              }
   1075          
   1076              kv_item_free(item);
   1077          
   1078              kv_free(data);
   1079              data = NULL;
   1080          
   1081              return KV_OK;
   1082          }
   1083          
   1084          #endif
   1085          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   __item_del_by_prefix_cb
        16   -> __aeabi_memset
        16   -> kv_flash_read
        16   -> kv_free
        16   -> kv_item_del
        16   -> kv_malloc
        16   -> strlen
        16   -> strncmp
      16   __item_find_cb
        16   -> kv_flash_read
        16   -> kv_malloc
        16   -> memcmp
        16   -> strlen
      16   __item_gc_cb
        16   -> kv_flash_read
        16   -> kv_flash_write
        16   -> kv_free
        16   -> kv_malloc
      16   __item_recovery_cb
        16   -> calc_crc8
        16   -> kv_flash_read
        16   -> kv_free
        16   -> kv_item_del
        16   -> kv_malloc
       4   calc_crc8
      16   kv_block_format
        16   -> __aeabi_memset4
        16   -> kv_flash_erase
        16   -> kv_flash_write
      16   kv_calc_position
        16   -> kv_set_block_state
        16   -> kv_trigger_gc
       8   kv_deinit
         0   -> kv_lock_free
         8   -> kv_sem_free
      24   kv_gc_task
        24   -> kv_block_format
         0   -> kv_delete_task
        24   -> kv_item_traverse
        24   -> kv_lock
        24   -> kv_sem_post_all
        24   -> kv_set_block_state
        24   -> kv_unlock
       8   kv_init
         8   -> __aeabi_memset4
         8   -> kv_init_internal
         8   -> kv_lock_create
         8   -> kv_register_cli_command
         8   -> kv_sem_create
         8   -> kv_trigger_gc
      40   kv_init_internal
        40   -> __aeabi_memclr4
        40   -> __aeabi_memset4
        40   -> kv_block_format
        40   -> kv_flash_read
        40   -> kv_item_traverse
        40   -> kv_set_block_state
      32   kv_item_del
        32   -> __aeabi_memset4
        32   -> kv_flash_read
        32   -> kv_free
        32   -> kv_malloc
        32   -> kv_set_block_state
        32   -> kv_set_item_state
        32   -> memcmp
      16   kv_item_delete
        16   -> kv_item_del
        16   -> kv_item_free
        16   -> kv_item_search
        16   -> kv_lock
        16   -> kv_unlock
      16   kv_item_delete_by_prefix
        16   -> kv_item_traverse
        16   -> kv_lock
        16   -> kv_unlock
       8   kv_item_free
         0   -> kv_free
         8   -> kv_free
      24   kv_item_get
        24   -> __aeabi_memcpy
        24   -> kv_item_free
        24   -> kv_item_search
        24   -> kv_lock
        24   -> kv_unlock
      16   kv_item_search
        16   -> kv_item_traverse
      24   kv_item_set
        24   -> kv_item_free
        24   -> kv_item_search
        24   -> kv_item_store
        24   -> kv_item_update
        24   -> kv_lock
        24   -> kv_sem_wait
        24   -> kv_unlock
        24   -> strlen
      40   kv_item_store
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> calc_crc8
        40   -> kv_calc_position
        40   -> kv_flash_write
        40   -> kv_free
        40   -> kv_malloc
        40   -> strlen
      32   kv_item_traverse
        32   -- Indirect call
        32   -> __aeabi_memset4
        32   -> kv_flash_read
        32   -> kv_item_free
        32   -> kv_malloc
        32   -> kv_set_block_state
      24   kv_item_update
         0   -> kv_item_del
        24   -> kv_item_store
        24   -> memcmp
      16   kv_set_block_state
        16   -> kv_flash_write
       8   kv_set_item_state
         8   -> kv_flash_write
       0   kv_trigger_gc
         0   -> kv_start_task


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
       8  ?_0
      16  ?_1
     104  __item_del_by_prefix_cb
      98  __item_find_cb
     112  __item_gc_cb
     106  __item_recovery_cb
      56  calc_crc8
     144  g_kv_mgr
     100  kv_block_format
     150  kv_calc_position
      24  kv_deinit
     204  kv_gc_task
     102  kv_init
     364  kv_init_internal
     238  kv_item_del
      64  kv_item_delete
      54  kv_item_delete_by_prefix
      28  kv_item_free
     118  kv_item_get
      60  kv_item_search
     146  kv_item_set
     230  kv_item_store
     294  kv_item_traverse
      66  kv_item_update
      38  kv_set_block_state
      14  kv_set_item_state
      38  kv_trigger_gc

 
   144 bytes in section .bss
    24 bytes in section .rodata
 2 872 bytes in section .text
 
 2 872 bytes of CODE  memory
    24 bytes of CONST memory
   144 bytes of DATA  memory

Errors: none
Warnings: 3
