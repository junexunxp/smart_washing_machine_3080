###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:48
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\mbedtls\library\ssl_cache.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW4A52.tmp
#        (C:\Development\smart_washing_machine_3080\mbedtls\library\ssl_cache.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\ssl_cache.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\ssl_cache.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\mbedtls\library\ssl_cache.c
      1          /*
      2           *  SSL session cache implementation
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          /*
     22           * These session callbacks use a simple chained list
     23           * to store and retrieve the session information.
     24           */
     25          
     26          #if !defined(MBEDTLS_CONFIG_FILE)
     27          #include "mbedtls/config.h"
     28          #else
     29          #include MBEDTLS_CONFIG_FILE
     30          #endif
     31          
     32          #if defined(MBEDTLS_SSL_CACHE_C)
     33          
     34          #if defined(MBEDTLS_PLATFORM_C)
     35          #include "mbedtls/platform.h"
     36          #else
     37          #include <stdlib.h>
     38          #define mbedtls_calloc    calloc
     39          #define mbedtls_free      free
     40          #endif
     41          
     42          #include "mbedtls/ssl_cache.h"
     43          
     44          #include <string.h>
     45          

   \                                 In section .text, align 2, keep-with-next
     46          void mbedtls_ssl_cache_init( mbedtls_ssl_cache_context *cache )
     47          {
   \                     mbedtls_ssl_cache_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     48              memset( cache, 0, sizeof( mbedtls_ssl_cache_context ) );
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x210C             MOVS     R1,#+12
   \        0x8   0x....'....        BL       __aeabi_memset4
     49          
     50              cache->timeout = MBEDTLS_SSL_CACHE_DEFAULT_TIMEOUT;
   \        0xC   0x....             LDR.N    R0,??DataTable0  ;; 0x15180
   \        0xE   0x6060             STR      R0,[R4, #+4]
     51              cache->max_entries = MBEDTLS_SSL_CACHE_DEFAULT_MAX_ENTRIES;
   \       0x10   0x2032             MOVS     R0,#+50
   \       0x12   0x60A0             STR      R0,[R4, #+8]
     52          
     53          #if defined(MBEDTLS_THREADING_C)
     54              mbedtls_mutex_init( &cache->mutex );
     55          #endif
     56          }
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
     57          

   \                                 In section .text, align 2, keep-with-next
     58          int mbedtls_ssl_cache_get( void *data, mbedtls_ssl_session *session )
     59          {
   \                     mbedtls_ssl_cache_get: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460F             MOV      R7,R1
     60              int ret = 1;
   \        0x4   0x2601             MOVS     R6,#+1
     61          #if defined(MBEDTLS_HAVE_TIME)
     62              mbedtls_time_t t = mbedtls_time( NULL );
     63          #endif
     64              mbedtls_ssl_cache_context *cache = (mbedtls_ssl_cache_context *) data;
     65              mbedtls_ssl_cache_entry *cur, *entry;
     66          
     67          #if defined(MBEDTLS_THREADING_C)
     68              if( mbedtls_mutex_lock( &cache->mutex ) != 0 )
     69                  return( 1 );
     70          #endif
     71          
     72              cur = cache->chain;
   \        0x6   0x6805             LDR      R5,[R0, #+0]
     73              entry = NULL;
     74          
     75              while( cur != NULL )
   \                     ??mbedtls_ssl_cache_get_0: (+1)
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD03E             BEQ.N    ??mbedtls_ssl_cache_get_1
     76              {
     77                  entry = cur;
   \        0xC   0x462C             MOV      R4,R5
     78                  cur = cur->next;
   \        0xE   0xF8D5 0x5088      LDR      R5,[R5, #+136]
     79          
     80          #if defined(MBEDTLS_HAVE_TIME)
     81                  if( cache->timeout != 0 &&
     82                      (int) ( t - entry->timestamp ) > cache->timeout )
     83                      continue;
     84          #endif
     85          
     86                  if( session->ciphersuite != entry->session.ciphersuite ||
     87                      session->compression != entry->session.compression ||
     88                      session->id_len != entry->session.id_len )
   \       0x12   0x6838             LDR      R0,[R7, #+0]
   \       0x14   0x6821             LDR      R1,[R4, #+0]
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD1F6             BNE.N    ??mbedtls_ssl_cache_get_0
   \       0x1A   0x6878             LDR      R0,[R7, #+4]
   \       0x1C   0x6861             LDR      R1,[R4, #+4]
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD1F2             BNE.N    ??mbedtls_ssl_cache_get_0
   \       0x22   0x68B8             LDR      R0,[R7, #+8]
   \       0x24   0x68A1             LDR      R1,[R4, #+8]
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD1EE             BNE.N    ??mbedtls_ssl_cache_get_0
     89                      continue;
     90          
     91                  if( memcmp( session->id, entry->session.id,
     92                              entry->session.id_len ) != 0 )
   \       0x2A   0x460A             MOV      R2,R1
   \       0x2C   0xF104 0x010C      ADD      R1,R4,#+12
   \       0x30   0xF107 0x000C      ADD      R0,R7,#+12
   \       0x34   0x....'....        BL       memcmp
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD1E5             BNE.N    ??mbedtls_ssl_cache_get_0
     93                      continue;
     94          
     95                  memcpy( session->master, entry->session.master, 48 );
   \       0x3C   0x2230             MOVS     R2,#+48
   \       0x3E   0xF104 0x012C      ADD      R1,R4,#+44
   \       0x42   0xF107 0x002C      ADD      R0,R7,#+44
   \       0x46   0x....'....        BL       __aeabi_memcpy4
     96          
     97                  session->verify_result = entry->session.verify_result;
   \       0x4A   0x6E20             LDR      R0,[R4, #+96]
   \       0x4C   0x6638             STR      R0,[R7, #+96]
     98          
     99          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    100                  /*
    101                   * Restore peer certificate (without rest of the original chain)
    102                   */
    103                  if( entry->peer_cert.p != NULL )
   \       0x4E   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD018             BEQ.N    ??mbedtls_ssl_cache_get_2
    104                  {
    105                      if( ( session->peer_cert = mbedtls_calloc( 1,
    106                                           sizeof(mbedtls_x509_crt) ) ) == NULL )
   \       0x56   0xF44F 0x719A      MOV      R1,#+308
   \       0x5A   0x4630             MOV      R0,R6
   \       0x5C   0x....'....        BL       mbedtls_calloc
   \       0x60   0x65F8             STR      R0,[R7, #+92]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD011             BEQ.N    ??mbedtls_ssl_cache_get_1
    107                      {
    108                          ret = 1;
    109                          goto exit;
    110                      }
    111          
    112                      mbedtls_x509_crt_init( session->peer_cert );
   \       0x66   0x....'....        BL       mbedtls_x509_crt_init
    113                      if( mbedtls_x509_crt_parse( session->peer_cert, entry->peer_cert.p,
    114                                          entry->peer_cert.len ) != 0 )
   \       0x6A   0xF8D4 0x2080      LDR      R2,[R4, #+128]
   \       0x6E   0xF8D4 0x1084      LDR      R1,[R4, #+132]
   \       0x72   0x6DF8             LDR      R0,[R7, #+92]
   \       0x74   0x....'....        BL       mbedtls_x509_crt_parse
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD005             BEQ.N    ??mbedtls_ssl_cache_get_2
    115                      {
    116                          mbedtls_free( session->peer_cert );
   \       0x7C   0x6DF8             LDR      R0,[R7, #+92]
   \       0x7E   0x....'....        BL       mbedtls_free
    117                          session->peer_cert = NULL;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x65F8             STR      R0,[R7, #+92]
    118                          ret = 1;
    119                          goto exit;
   \       0x86   0xE000             B.N      ??mbedtls_ssl_cache_get_1
    120                      }
    121                  }
    122          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    123          
    124                  ret = 0;
   \                     ??mbedtls_ssl_cache_get_2: (+1)
   \       0x88   0x2600             MOVS     R6,#+0
    125                  goto exit;
    126              }
    127          
    128          exit:
    129          #if defined(MBEDTLS_THREADING_C)
    130              if( mbedtls_mutex_unlock( &cache->mutex ) != 0 )
    131                  ret = 1;
    132          #endif
    133          
    134              return( ret );
   \                     ??mbedtls_ssl_cache_get_1: (+1)
   \       0x8A   0x4630             MOV      R0,R6
   \       0x8C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    135          }
    136          

   \                                 In section .text, align 2, keep-with-next
    137          int mbedtls_ssl_cache_set( void *data, const mbedtls_ssl_session *session )
    138          {
   \                     mbedtls_ssl_cache_set: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460E             MOV      R6,R1
    139              int ret = 1;
   \        0x8   0x2701             MOVS     R7,#+1
    140          #if defined(MBEDTLS_HAVE_TIME)
    141              mbedtls_time_t t = mbedtls_time( NULL ), oldest = 0;
    142              mbedtls_ssl_cache_entry *old = NULL;
    143          #endif
    144              mbedtls_ssl_cache_context *cache = (mbedtls_ssl_cache_context *) data;
    145              mbedtls_ssl_cache_entry *cur, *prv;
    146              int count = 0;
   \        0xA   0xF04F 0x0900      MOV      R9,#+0
    147          
    148          #if defined(MBEDTLS_THREADING_C)
    149              if( ( ret = mbedtls_mutex_lock( &cache->mutex ) ) != 0 )
    150                  return( ret );
    151          #endif
    152          
    153              cur = cache->chain;
   \        0xE   0xF8D8 0x4000      LDR      R4,[R8, #+0]
    154              prv = NULL;
   \       0x12   0x464D             MOV      R5,R9
    155          
    156              while( cur != NULL )
   \                     ??mbedtls_ssl_cache_set_0: (+1)
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD048             BEQ.N    ??mbedtls_ssl_cache_set_1
    157              {
    158                  count++;
   \       0x18   0xF109 0x0901      ADD      R9,R9,#+1
    159          
    160          #if defined(MBEDTLS_HAVE_TIME)
    161                  if( cache->timeout != 0 &&
    162                      (int) ( t - cur->timestamp ) > cache->timeout )
    163                  {
    164                      cur->timestamp = t;
    165                      break; /* expired, reuse this slot, update timestamp */
    166                  }
    167          #endif
    168          
    169                  if( memcmp( session->id, cur->session.id, cur->session.id_len ) == 0 )
   \       0x1C   0x68A2             LDR      R2,[R4, #+8]
   \       0x1E   0xF104 0x010C      ADD      R1,R4,#+12
   \       0x22   0xF106 0x000C      ADD      R0,R6,#+12
   \       0x26   0x....'....        BL       memcmp
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD03D             BEQ.N    ??mbedtls_ssl_cache_set_1
    170                      break; /* client reconnected, keep timestamp for session id */
    171          
    172          #if defined(MBEDTLS_HAVE_TIME)
    173                  if( oldest == 0 || cur->timestamp < oldest )
    174                  {
    175                      oldest = cur->timestamp;
    176                      old = cur;
    177                  }
    178          #endif
    179          
    180                  prv = cur;
   \       0x2E   0x4625             MOV      R5,R4
    181                  cur = cur->next;
   \       0x30   0xF8D4 0x4088      LDR      R4,[R4, #+136]
   \       0x34   0xE7EE             B.N      ??mbedtls_ssl_cache_set_0
    182              }
    183          
    184              if( cur == NULL )
    185              {
    186          #if defined(MBEDTLS_HAVE_TIME)
    187                  /*
    188                   * Reuse oldest entry if max_entries reached
    189                   */
    190                  if( count >= cache->max_entries )
    191                  {
    192                      if( old == NULL )
    193                      {
    194                          ret = 1;
    195                          goto exit;
    196                      }
    197          
    198                      cur = old;
    199                  }
    200          #else /* MBEDTLS_HAVE_TIME */
    201                  /*
    202                   * Reuse first entry in chain if max_entries reached,
    203                   * but move to last place
    204                   */
    205                  if( count >= cache->max_entries )
    206                  {
    207                      if( cache->chain == NULL )
    208                      {
    209                          ret = 1;
    210                          goto exit;
    211                      }
    212          
    213                      cur = cache->chain;
    214                      cache->chain = cur->next;
    215                      cur->next = NULL;
    216                      prv->next = cur;
    217                  }
    218          #endif /* MBEDTLS_HAVE_TIME */
    219                  else
    220                  {
    221                      /*
    222                       * max_entries not reached, create new entry
    223                       */
    224                      cur = mbedtls_calloc( 1, sizeof(mbedtls_ssl_cache_entry) );
   \                     ??mbedtls_ssl_cache_set_2: (+1)
   \       0x36   0x218C             MOVS     R1,#+140
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0x....'....        BL       mbedtls_calloc
   \       0x3E   0x0004             MOVS     R4,R0
    225                      if( cur == NULL )
   \       0x40   0xD030             BEQ.N    ??mbedtls_ssl_cache_set_3
    226                      {
    227                          ret = 1;
    228                          goto exit;
    229                      }
    230          
    231                      if( prv == NULL )
   \       0x42   0x2D00             CMP      R5,#+0
   \       0x44   0xD102             BNE.N    ??mbedtls_ssl_cache_set_4
    232                          cache->chain = cur;
   \       0x46   0xF8C8 0x4000      STR      R4,[R8, #+0]
   \       0x4A   0xE001             B.N      ??mbedtls_ssl_cache_set_5
    233                      else
    234                          prv->next = cur;
   \                     ??mbedtls_ssl_cache_set_4: (+1)
   \       0x4C   0xF8C5 0x4088      STR      R4,[R5, #+136]
    235                  }
    236          
    237          #if defined(MBEDTLS_HAVE_TIME)
    238                  cur->timestamp = t;
    239          #endif
    240              }
    241          
    242              memcpy( &cur->session, session, sizeof( mbedtls_ssl_session ) );
   \                     ??mbedtls_ssl_cache_set_5: (+1)
   \       0x50   0x227C             MOVS     R2,#+124
   \       0x52   0x4631             MOV      R1,R6
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0x....'....        BL       __aeabi_memcpy4
    243          
    244          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    245              /*
    246               * If we're reusing an entry, free its certificate first
    247               */
    248              if( cur->peer_cert.p != NULL )
   \       0x5A   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD007             BEQ.N    ??mbedtls_ssl_cache_set_6
    249              {
    250                  mbedtls_free( cur->peer_cert.p );
   \       0x62   0x....'....        BL       mbedtls_free
    251                  memset( &cur->peer_cert, 0, sizeof(mbedtls_x509_buf) );
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0x210C             MOVS     R1,#+12
   \       0x6A   0xF104 0x007C      ADD      R0,R4,#+124
   \       0x6E   0x....'....        BL       __aeabi_memset4
    252              }
    253          
    254              /*
    255               * Store peer certificate
    256               */
    257              if( session->peer_cert != NULL )
   \                     ??mbedtls_ssl_cache_set_6: (+1)
   \       0x72   0x6DF0             LDR      R0,[R6, #+92]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD014             BEQ.N    ??mbedtls_ssl_cache_set_7
    258              {
    259                  cur->peer_cert.p = mbedtls_calloc( 1, session->peer_cert->raw.len );
   \       0x78   0x6841             LDR      R1,[R0, #+4]
   \       0x7A   0x4638             MOV      R0,R7
   \       0x7C   0x....'....        BL       mbedtls_calloc
   \       0x80   0xF8C4 0x0084      STR      R0,[R4, #+132]
    260                  if( cur->peer_cert.p == NULL )
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD00D             BEQ.N    ??mbedtls_ssl_cache_set_3
    261                  {
    262                      ret = 1;
    263                      goto exit;
    264                  }
    265          
    266                  memcpy( cur->peer_cert.p, session->peer_cert->raw.p,
    267                          session->peer_cert->raw.len );
   \       0x88   0x6DF0             LDR      R0,[R6, #+92]
   \       0x8A   0x6842             LDR      R2,[R0, #+4]
   \       0x8C   0x6881             LDR      R1,[R0, #+8]
   \       0x8E   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \       0x92   0x....'....        BL       __aeabi_memcpy
    268                  cur->peer_cert.len = session->peer_cert->raw.len;
   \       0x96   0x6DF0             LDR      R0,[R6, #+92]
   \       0x98   0x6840             LDR      R0,[R0, #+4]
   \       0x9A   0xF8C4 0x0080      STR      R0,[R4, #+128]
    269          
    270                  cur->session.peer_cert = NULL;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x65E0             STR      R0,[R4, #+92]
    271              }
    272          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    273          
    274              ret = 0;
   \                     ??mbedtls_ssl_cache_set_7: (+1)
   \       0xA2   0x2700             MOVS     R7,#+0
    275          
    276          exit:
    277          #if defined(MBEDTLS_THREADING_C)
    278              if( mbedtls_mutex_unlock( &cache->mutex ) != 0 )
    279                  ret = 1;
    280          #endif
    281          
    282              return( ret );
   \                     ??mbedtls_ssl_cache_set_3: (+1)
   \       0xA4   0x4638             MOV      R0,R7
   \       0xA6   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??mbedtls_ssl_cache_set_1: (+1)
   \       0xAA   0x2C00             CMP      R4,#+0
   \       0xAC   0xD1D0             BNE.N    ??mbedtls_ssl_cache_set_5
   \       0xAE   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0xB2   0x4581             CMP      R9,R0
   \       0xB4   0xDBBF             BLT.N    ??mbedtls_ssl_cache_set_2
   \       0xB6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD0F2             BEQ.N    ??mbedtls_ssl_cache_set_3
   \       0xBE   0x4604             MOV      R4,R0
   \       0xC0   0xF8D4 0x0088      LDR      R0,[R4, #+136]
   \       0xC4   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0xF8C4 0x0088      STR      R0,[R4, #+136]
   \       0xCE   0xF8C5 0x4088      STR      R4,[R5, #+136]
   \       0xD2   0xE7BD             B.N      ??mbedtls_ssl_cache_set_5
    283          }
    284          
    285          #if defined(MBEDTLS_HAVE_TIME)
    286          void mbedtls_ssl_cache_set_timeout( mbedtls_ssl_cache_context *cache, int timeout )
    287          {
    288              if( timeout < 0 ) timeout = 0;
    289          
    290              cache->timeout = timeout;
    291          }
    292          #endif /* MBEDTLS_HAVE_TIME */
    293          

   \                                 In section .text, align 2, keep-with-next
    294          void mbedtls_ssl_cache_set_max_entries( mbedtls_ssl_cache_context *cache, int max )
    295          {
    296              if( max < 0 ) max = 0;
   \                     mbedtls_ssl_cache_set_max_entries: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0xD500             BPL.N    ??mbedtls_ssl_cache_set_max_entries_0
   \        0x4   0x2100             MOVS     R1,#+0
    297          
    298              cache->max_entries = max;
   \                     ??mbedtls_ssl_cache_set_max_entries_0: (+1)
   \        0x6   0x6081             STR      R1,[R0, #+8]
    299          }
   \        0x8   0x4770             BX       LR               ;; return
    300          

   \                                 In section .text, align 2, keep-with-next
    301          void mbedtls_ssl_cache_free( mbedtls_ssl_cache_context *cache )
    302          {
   \                     mbedtls_ssl_cache_free: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
    303              mbedtls_ssl_cache_entry *cur, *prv;
    304          
    305              cur = cache->chain;
   \        0x4   0x682C             LDR      R4,[R5, #+0]
   \        0x6   0xE00C             B.N      ??mbedtls_ssl_cache_free_0
    306          
    307              while( cur != NULL )
    308              {
    309                  prv = cur;
   \                     ??mbedtls_ssl_cache_free_1: (+1)
   \        0x8   0x4626             MOV      R6,R4
    310                  cur = cur->next;
   \        0xA   0xF8D4 0x4088      LDR      R4,[R4, #+136]
    311          
    312                  mbedtls_ssl_session_free( &prv->session );
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0x....'....        BL       mbedtls_ssl_session_free
    313          
    314          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    315                  mbedtls_free( prv->peer_cert.p );
   \       0x14   0xF8D6 0x0084      LDR      R0,[R6, #+132]
   \       0x18   0x....'....        BL       mbedtls_free
    316          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    317          
    318                  mbedtls_free( prv );
   \       0x1C   0x4630             MOV      R0,R6
   \       0x1E   0x....'....        BL       mbedtls_free
    319              }
   \                     ??mbedtls_ssl_cache_free_0: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD1F0             BNE.N    ??mbedtls_ssl_cache_free_1
    320          
    321          #if defined(MBEDTLS_THREADING_C)
    322              mbedtls_mutex_free( &cache->mutex );
    323          #endif
    324              cache->chain = NULL;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6028             STR      R0,[R5, #+0]
    325          }
   \       0x2A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x0001'5180        DC32     0x15180
    326          
    327          #endif /* MBEDTLS_SSL_CACHE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   mbedtls_ssl_cache_free
        16   -> mbedtls_free
        16   -> mbedtls_ssl_session_free
      24   mbedtls_ssl_cache_get
        24   -> __aeabi_memcpy4
        24   -> mbedtls_calloc
        24   -> mbedtls_free
        24   -> mbedtls_x509_crt_init
        24   -> mbedtls_x509_crt_parse
        24   -> memcmp
       8   mbedtls_ssl_cache_init
         8   -> __aeabi_memset4
      32   mbedtls_ssl_cache_set
        32   -> __aeabi_memcpy
        32   -> __aeabi_memcpy4
        32   -> __aeabi_memset4
        32   -> mbedtls_calloc
        32   -> mbedtls_free
        32   -> memcmp
       0   mbedtls_ssl_cache_set_max_entries


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      44  mbedtls_ssl_cache_free
     142  mbedtls_ssl_cache_get
      22  mbedtls_ssl_cache_init
     212  mbedtls_ssl_cache_set
      10  mbedtls_ssl_cache_set_max_entries

 
 434 bytes in section .text
 
 434 bytes of CODE memory

Errors: none
Warnings: none
