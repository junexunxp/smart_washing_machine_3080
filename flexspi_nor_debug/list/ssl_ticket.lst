###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:51
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\mbedtls\library\ssl_ticket.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW55E0.tmp
#        (C:\Development\smart_washing_machine_3080\mbedtls\library\ssl_ticket.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\ssl_ticket.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\ssl_ticket.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\mbedtls\library\ssl_ticket.c
      1          /*
      2           *  TLS server tickets callbacks implementation
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_SSL_TICKET_C)
     29          
     30          #if defined(MBEDTLS_PLATFORM_C)
     31          #include "mbedtls/platform.h"
     32          #else
     33          #include <stdlib.h>
     34          #define mbedtls_calloc    calloc
     35          #define mbedtls_free      free
     36          #endif
     37          
     38          #include "mbedtls/ssl_ticket.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int mbedtls_cipher_get_key_bitlen(mbedtls_cipher_context_t const *)
   \                     mbedtls_cipher_get_key_bitlen: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD002             BEQ.N    ??mbedtls_cipher_get_key_bitlen_0
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??mbedtls_cipher_get_key_bitlen_1
   \                     ??mbedtls_cipher_get_key_bitlen_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
   \                     ??mbedtls_cipher_get_key_bitlen_1: (+1)
   \        0xE   0x4608             MOV      R0,R1
   \       0x10   0x6840             LDR      R0,[R0, #+4]
   \       0x12   0x4770             BX       LR               ;; return
     39          #include "mbedtls/platform_util.h"
     40          
     41          #include <string.h>
     42          
     43          /*
     44           * Initialze context
     45           */

   \                                 In section .text, align 2, keep-with-next
     46          void mbedtls_ssl_ticket_init( mbedtls_ssl_ticket_context *ctx )
     47          {
     48              memset( ctx, 0, sizeof( mbedtls_ssl_ticket_context ) );
   \                     mbedtls_ssl_ticket_init: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x21A0             MOVS     R1,#+160
   \        0x4   0x....'....        B.W      __aeabi_memset4
     49          
     50          #if defined(MBEDTLS_THREADING_C)
     51              mbedtls_mutex_init( &ctx->mutex );
     52          #endif
     53          }
     54          
     55          #define MAX_KEY_BYTES 32    /* 256 bits */
     56          
     57          /*
     58           * Generate/update a key
     59           */

   \                                 In section .text, align 2, keep-with-next
     60          static int ssl_ticket_gen_key( mbedtls_ssl_ticket_context *ctx,
     61                                         unsigned char index )
     62          {
   \                     ssl_ticket_gen_key: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x4604             MOV      R4,R0
     63              int ret;
     64              unsigned char buf[MAX_KEY_BYTES];
     65              mbedtls_ssl_ticket_key *key = ctx->keys + index;
   \        0x6   0xEB01 0x00C1      ADD      R0,R1,R1, LSL #+3
   \        0xA   0xEB14 0x05C0      ADDS     R5,R4,R0, LSL #+3
     66          
     67          #if defined(MBEDTLS_HAVE_TIME)
     68              key->generation_time = (uint32_t) mbedtls_time( NULL );
     69          #endif
     70          
     71              if( ( ret = ctx->f_rng( ctx->p_rng, key->name, sizeof( key->name ) ) ) != 0 )
   \        0xE   0x2204             MOVS     R2,#+4
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0xF8D4 0x009C      LDR      R0,[R4, #+156]
   \       0x16   0xF8D4 0x3098      LDR      R3,[R4, #+152]
   \       0x1A   0x4798             BLX      R3
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD119             BNE.N    ??ssl_ticket_gen_key_0
     72                  return( ret );
     73          
     74              if( ( ret = ctx->f_rng( ctx->p_rng, buf, sizeof( buf ) ) ) != 0 )
   \       0x20   0x2220             MOVS     R2,#+32
   \       0x22   0x4669             MOV      R1,SP
   \       0x24   0xF8D4 0x009C      LDR      R0,[R4, #+156]
   \       0x28   0xF8D4 0x3098      LDR      R3,[R4, #+152]
   \       0x2C   0x4798             BLX      R3
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD110             BNE.N    ??ssl_ticket_gen_key_0
     75                  return( ret );
     76          
     77              /* With GCM and CCM, same context can encrypt & decrypt */
     78              ret = mbedtls_cipher_setkey( &key->ctx, buf,
     79                                           mbedtls_cipher_get_key_bitlen( &key->ctx ),
     80                                           MBEDTLS_ENCRYPT );
   \       0x32   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x36   0x....'....        BL       mbedtls_cipher_get_key_bitlen
   \       0x3A   0x4602             MOV      R2,R0
   \       0x3C   0x2301             MOVS     R3,#+1
   \       0x3E   0x4669             MOV      R1,SP
   \       0x40   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x44   0x....'....        BL       mbedtls_cipher_setkey
   \       0x48   0x4604             MOV      R4,R0
     81          
     82              mbedtls_platform_zeroize( buf, sizeof( buf ) );
   \       0x4A   0x2120             MOVS     R1,#+32
   \       0x4C   0x4668             MOV      R0,SP
   \       0x4E   0x....'....        BL       mbedtls_platform_zeroize
     83          
     84              return( ret );
   \       0x52   0x4620             MOV      R0,R4
   \                     ??ssl_ticket_gen_key_0: (+1)
   \       0x54   0xB009             ADD      SP,SP,#+36
   \       0x56   0xBD30             POP      {R4,R5,PC}       ;; return
     85          }
     86          
     87          /*
     88           * Rotate/generate keys if necessary
     89           */

   \                                 In section .text, align 2, keep-with-next
     90          static int ssl_ticket_update_keys( mbedtls_ssl_ticket_context *ctx )
     91          {
     92          #if !defined(MBEDTLS_HAVE_TIME)
     93              ((void) ctx);
     94          #else
     95              if( ctx->ticket_lifetime != 0 )
     96              {
     97                  uint32_t current_time = (uint32_t) mbedtls_time( NULL );
     98                  uint32_t key_time = ctx->keys[ctx->active].generation_time;
     99          
    100                  if( current_time > key_time &&
    101                      current_time - key_time < ctx->ticket_lifetime )
    102                  {
    103                      return( 0 );
    104                  }
    105          
    106                  ctx->active = 1 - ctx->active;
    107          
    108                  return( ssl_ticket_gen_key( ctx, ctx->active ) );
    109              }
    110              else
    111          #endif /* MBEDTLS_HAVE_TIME */
    112                  return( 0 );
   \                     ssl_ticket_update_keys: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
    113          }
    114          
    115          /*
    116           * Setup context for actual use
    117           */

   \                                 In section .text, align 2, keep-with-next
    118          int mbedtls_ssl_ticket_setup( mbedtls_ssl_ticket_context *ctx,
    119              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
    120              mbedtls_cipher_type_t cipher,
    121              uint32_t lifetime )
    122          {
   \                     mbedtls_ssl_ticket_setup: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x9804             LDR      R0,[SP, #+16]
    123              int ret;
    124              const mbedtls_cipher_info_t *cipher_info;
    125          
    126              ctx->f_rng = f_rng;
   \        0x6   0xF8C5 0x1098      STR      R1,[R5, #+152]
    127              ctx->p_rng = p_rng;
   \        0xA   0xF8C5 0x209C      STR      R2,[R5, #+156]
    128          
    129              ctx->ticket_lifetime = lifetime;
   \        0xE   0xF8C5 0x0094      STR      R0,[R5, #+148]
    130          
    131              cipher_info = mbedtls_cipher_info_from_type( cipher);
   \       0x12   0x4618             MOV      R0,R3
   \       0x14   0x....'....        BL       mbedtls_cipher_info_from_type
   \       0x18   0x0004             MOVS     R4,R0
    132              if( cipher_info == NULL )
   \       0x1A   0xD009             BEQ.N    ??mbedtls_ssl_ticket_setup_0
    133                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
    134          
    135              if( cipher_info->mode != MBEDTLS_MODE_GCM &&
    136                  cipher_info->mode != MBEDTLS_MODE_CCM )
   \       0x1C   0x7860             LDRB     R0,[R4, #+1]
   \       0x1E   0x2806             CMP      R0,#+6
   \       0x20   0xD001             BEQ.N    ??mbedtls_ssl_ticket_setup_1
   \       0x22   0x2808             CMP      R0,#+8
   \       0x24   0xD104             BNE.N    ??mbedtls_ssl_ticket_setup_0
    137              {
    138                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
    139              }
    140          
    141              if( cipher_info->key_bitlen > 8 * MAX_KEY_BYTES )
   \                     ??mbedtls_ssl_ticket_setup_1: (+1)
   \       0x26   0x6860             LDR      R0,[R4, #+4]
   \       0x28   0xF240 0x1101      MOVW     R1,#+257
   \       0x2C   0x4288             CMP      R0,R1
   \       0x2E   0xD301             BCC.N    ??mbedtls_ssl_ticket_setup_2
    142                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   \                     ??mbedtls_ssl_ticket_setup_0: (+1)
   \       0x30   0x....             LDR.N    R0,??DataTable5  ;; 0xffff8f00
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}
    143          
    144              if( ( ret = mbedtls_cipher_setup( &ctx->keys[0].ctx, cipher_info ) ) != 0 ||
    145                  ( ret = mbedtls_cipher_setup( &ctx->keys[1].ctx, cipher_info ) ) != 0 )
   \                     ??mbedtls_ssl_ticket_setup_2: (+1)
   \       0x34   0x4621             MOV      R1,R4
   \       0x36   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x3A   0x....'....        BL       mbedtls_cipher_setup
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD113             BNE.N    ??mbedtls_ssl_ticket_setup_3
   \       0x42   0x4621             MOV      R1,R4
   \       0x44   0xF105 0x0050      ADD      R0,R5,#+80
   \       0x48   0x....'....        BL       mbedtls_cipher_setup
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD10C             BNE.N    ??mbedtls_ssl_ticket_setup_3
    146              {
    147                  return( ret );
    148              }
    149          
    150              if( ( ret = ssl_ticket_gen_key( ctx, 0 ) ) != 0 ||
    151                  ( ret = ssl_ticket_gen_key( ctx, 1 ) ) != 0 )
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x4628             MOV      R0,R5
   \       0x54   0x....'....        BL       ssl_ticket_gen_key
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD106             BNE.N    ??mbedtls_ssl_ticket_setup_3
   \       0x5C   0x2101             MOVS     R1,#+1
   \       0x5E   0x4628             MOV      R0,R5
   \       0x60   0x....'....        BL       ssl_ticket_gen_key
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD100             BNE.N    ??mbedtls_ssl_ticket_setup_3
    152              {
    153                  return( ret );
    154              }
    155          
    156              return( 0 );
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_ticket_setup_3: (+1)
   \       0x6A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    157          }
    158          
    159          /*
    160           * Serialize a session in the following format:
    161           *  0   .   n-1     session structure, n = sizeof(mbedtls_ssl_session)
    162           *  n   .   n+2     peer_cert length = m (0 if no certificate)
    163           *  n+3 .   n+2+m   peer cert ASN.1
    164           */

   \                                 In section .text, align 2, keep-with-next
    165          static int ssl_save_session( const mbedtls_ssl_session *session,
    166                                       unsigned char *buf, size_t buf_len,
    167                                       size_t *olen )
    168          {
   \                     ssl_save_session: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x461C             MOV      R4,R3
    169              unsigned char *p = buf;
    170              size_t left = buf_len;
    171          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    172              size_t cert_len;
    173          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    174          
    175              if( left < sizeof( mbedtls_ssl_session ) )
   \        0xC   0xF1B8 0x0F7C      CMP      R8,#+124
   \       0x10   0xD311             BCC.N    ??ssl_save_session_0
    176                  return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
    177          
    178              memcpy( p, session, sizeof( mbedtls_ssl_session ) );
   \       0x12   0x227C             MOVS     R2,#+124
   \       0x14   0x4629             MOV      R1,R5
   \       0x16   0x4630             MOV      R0,R6
   \       0x18   0x....'....        BL       __aeabi_memcpy
    179              p += sizeof( mbedtls_ssl_session );
   \       0x1C   0xF106 0x017C      ADD      R1,R6,#+124
    180              left -= sizeof( mbedtls_ssl_session );
   \       0x20   0xF1A8 0x087C      SUB      R8,R8,#+124
    181          
    182          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    183              if( session->peer_cert == NULL )
   \       0x24   0x6DE8             LDR      R0,[R5, #+92]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD101             BNE.N    ??ssl_save_session_1
    184                  cert_len = 0;
   \       0x2A   0x2700             MOVS     R7,#+0
   \       0x2C   0xE000             B.N      ??ssl_save_session_2
    185              else
    186                  cert_len = session->peer_cert->raw.len;
   \                     ??ssl_save_session_1: (+1)
   \       0x2E   0x6847             LDR      R7,[R0, #+4]
    187          
    188              if( left < 3 + cert_len )
   \                     ??ssl_save_session_2: (+1)
   \       0x30   0x1CF8             ADDS     R0,R7,#+3
   \       0x32   0x4580             CMP      R8,R0
   \       0x34   0xD201             BCS.N    ??ssl_save_session_3
    189                  return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
   \                     ??ssl_save_session_0: (+1)
   \       0x36   0x....             LDR.N    R0,??DataTable5_1  ;; 0xffff9600
   \       0x38   0xE015             B.N      ??ssl_save_session_4
    190          
    191              *p++ = (unsigned char)( cert_len >> 16 & 0xFF );
   \                     ??ssl_save_session_3: (+1)
   \       0x3A   0x4638             MOV      R0,R7
   \       0x3C   0x0C00             LSRS     R0,R0,#+16
   \       0x3E   0x7008             STRB     R0,[R1, #+0]
    192              *p++ = (unsigned char)( cert_len >>  8 & 0xFF );
   \       0x40   0x4638             MOV      R0,R7
   \       0x42   0x0A00             LSRS     R0,R0,#+8
   \       0x44   0x7048             STRB     R0,[R1, #+1]
    193              *p++ = (unsigned char)( cert_len       & 0xFF );
   \       0x46   0x708F             STRB     R7,[R1, #+2]
   \       0x48   0xF101 0x0803      ADD      R8,R1,#+3
    194          
    195              if( session->peer_cert != NULL )
   \       0x4C   0x6DE8             LDR      R0,[R5, #+92]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD004             BEQ.N    ??ssl_save_session_5
    196                  memcpy( p, session->peer_cert->raw.p, cert_len );
   \       0x52   0x463A             MOV      R2,R7
   \       0x54   0x6881             LDR      R1,[R0, #+8]
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0x....'....        BL       __aeabi_memcpy
    197          
    198              p += cert_len;
    199          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    200          
    201              *olen = p - buf;
   \                     ??ssl_save_session_5: (+1)
   \       0x5C   0xEB08 0x0007      ADD      R0,R8,R7
   \       0x60   0x1B86             SUBS     R6,R0,R6
   \       0x62   0x6026             STR      R6,[R4, #+0]
    202          
    203              return( 0 );
   \       0x64   0x2000             MOVS     R0,#+0
   \                     ??ssl_save_session_4: (+1)
   \       0x66   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    204          }
    205          
    206          /*
    207           * Unserialise session, see ssl_save_session()
    208           */

   \                                 In section .text, align 2, keep-with-next
    209          static int ssl_load_session( mbedtls_ssl_session *session,
    210                                       const unsigned char *buf, size_t len )
    211          {
   \                     ssl_load_session: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
    212              const unsigned char *p = buf;
    213              const unsigned char * const end = buf + len;
   \        0x8   0x18A7             ADDS     R7,R4,R2
    214          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    215              size_t cert_len;
    216          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    217          
    218              if( p + sizeof( mbedtls_ssl_session ) > end )
   \        0xA   0xF104 0x007C      ADD      R0,R4,#+124
   \        0xE   0x4287             CMP      R7,R0
   \       0x10   0xD201             BCS.N    ??ssl_load_session_0
    219                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   \       0x12   0x....             LDR.N    R0,??DataTable5  ;; 0xffff8f00
   \       0x14   0xE040             B.N      ??ssl_load_session_1
    220          
    221              memcpy( session, p, sizeof( mbedtls_ssl_session ) );
   \                     ??ssl_load_session_0: (+1)
   \       0x16   0x227C             MOVS     R2,#+124
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0x....'....        BL       __aeabi_memcpy
    222              p += sizeof( mbedtls_ssl_session );
   \       0x1E   0xF104 0x017C      ADD      R1,R4,#+124
    223          
    224          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    225              if( p + 3 > end )
   \       0x22   0x1CC8             ADDS     R0,R1,#+3
   \       0x24   0x4287             CMP      R7,R0
   \       0x26   0xD201             BCS.N    ??ssl_load_session_2
    226                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   \       0x28   0x....             LDR.N    R0,??DataTable5  ;; 0xffff8f00
   \       0x2A   0xE035             B.N      ??ssl_load_session_1
    227          
    228              cert_len = ( p[0] << 16 ) | ( p[1] << 8 ) | p[2];
   \                     ??ssl_load_session_2: (+1)
   \       0x2C   0x7808             LDRB     R0,[R1, #+0]
   \       0x2E   0x784D             LDRB     R5,[R1, #+1]
   \       0x30   0x022D             LSLS     R5,R5,#+8
   \       0x32   0xEA45 0x4500      ORR      R5,R5,R0, LSL #+16
   \       0x36   0x7888             LDRB     R0,[R1, #+2]
   \       0x38   0x4305             ORRS     R5,R0,R5
    229              p += 3;
   \       0x3A   0xF101 0x0803      ADD      R8,R1,#+3
    230          
    231              if( cert_len == 0 )
   \       0x3E   0xD102             BNE.N    ??ssl_load_session_3
    232              {
    233                  session->peer_cert = NULL;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x65F0             STR      R0,[R6, #+92]
   \       0x44   0xE023             B.N      ??ssl_load_session_4
    234              }
    235              else
    236              {
    237                  int ret;
    238          
    239                  if( p + cert_len > end )
   \                     ??ssl_load_session_3: (+1)
   \       0x46   0xEB08 0x0005      ADD      R0,R8,R5
   \       0x4A   0x4287             CMP      R7,R0
   \       0x4C   0xD201             BCS.N    ??ssl_load_session_5
    240                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   \       0x4E   0x....             LDR.N    R0,??DataTable5  ;; 0xffff8f00
   \       0x50   0xE022             B.N      ??ssl_load_session_1
    241          
    242                  session->peer_cert = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );
   \                     ??ssl_load_session_5: (+1)
   \       0x52   0xF44F 0x719A      MOV      R1,#+308
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x....'....        BL       mbedtls_calloc
   \       0x5C   0x65F0             STR      R0,[R6, #+92]
    243          
    244                  if( session->peer_cert == NULL )
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD101             BNE.N    ??ssl_load_session_6
    245                      return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   \       0x62   0x....             LDR.N    R0,??DataTable5_2  ;; 0xffff8100
   \       0x64   0xE018             B.N      ??ssl_load_session_1
    246          
    247                  mbedtls_x509_crt_init( session->peer_cert );
   \                     ??ssl_load_session_6: (+1)
   \       0x66   0x....'....        BL       mbedtls_x509_crt_init
    248          
    249                  if( ( ret = mbedtls_x509_crt_parse_der( session->peer_cert,
    250                                                  p, cert_len ) ) != 0 )
   \       0x6A   0x462A             MOV      R2,R5
   \       0x6C   0x4641             MOV      R1,R8
   \       0x6E   0x6DF0             LDR      R0,[R6, #+92]
   \       0x70   0x....'....        BL       mbedtls_x509_crt_parse_der
   \       0x74   0x0004             MOVS     R4,R0
   \       0x76   0xD009             BEQ.N    ??ssl_load_session_7
    251                  {
    252                      mbedtls_x509_crt_free( session->peer_cert );
   \       0x78   0x6DF0             LDR      R0,[R6, #+92]
   \       0x7A   0x....'....        BL       mbedtls_x509_crt_free
    253                      mbedtls_free( session->peer_cert );
   \       0x7E   0x6DF0             LDR      R0,[R6, #+92]
   \       0x80   0x....'....        BL       mbedtls_free
    254                      session->peer_cert = NULL;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x65F0             STR      R0,[R6, #+92]
    255                      return( ret );
   \       0x88   0x4620             MOV      R0,R4
   \       0x8A   0xE005             B.N      ??ssl_load_session_1
    256                  }
    257          
    258                  p += cert_len;
   \                     ??ssl_load_session_7: (+1)
   \       0x8C   0x44A8             ADD      R8,R8,R5
    259              }
    260          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    261          
    262              if( p != end )
   \                     ??ssl_load_session_4: (+1)
   \       0x8E   0x45B8             CMP      R8,R7
   \       0x90   0xD001             BEQ.N    ??ssl_load_session_8
    263                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   \       0x92   0x....             LDR.N    R0,??DataTable5  ;; 0xffff8f00
   \       0x94   0xE000             B.N      ??ssl_load_session_1
    264          
    265              return( 0 );
   \                     ??ssl_load_session_8: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \                     ??ssl_load_session_1: (+1)
   \       0x98   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    266          }
    267          
    268          /*
    269           * Create session ticket, with the following structure:
    270           *
    271           *    struct {
    272           *        opaque key_name[4];
    273           *        opaque iv[12];
    274           *        opaque encrypted_state<0..2^16-1>;
    275           *        opaque tag[16];
    276           *    } ticket;
    277           *
    278           * The key_name, iv, and length of encrypted_state are the additional
    279           * authenticated data.
    280           */

   \                                 In section .text, align 2, keep-with-next
    281          int mbedtls_ssl_ticket_write( void *p_ticket,
    282                                        const mbedtls_ssl_session *session,
    283                                        unsigned char *start,
    284                                        const unsigned char *end,
    285                                        size_t *tlen,
    286                                        uint32_t *ticket_lifetime )
    287          {
   \                     mbedtls_ssl_ticket_write: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0xF8DD 0x8050      LDR      R8,[SP, #+80]
    288              int ret;
    289              mbedtls_ssl_ticket_context *ctx = p_ticket;
    290              mbedtls_ssl_ticket_key *key;
    291              unsigned char *key_name = start;
    292              unsigned char *iv = start + 4;
   \       0x10   0x1D30             ADDS     R0,R6,#+4
   \       0x12   0x9009             STR      R0,[SP, #+36]
    293              unsigned char *state_len_bytes = iv + 12;
   \       0x14   0xF100 0x090C      ADD      R9,R0,#+12
    294              unsigned char *state = state_len_bytes + 2;
   \       0x18   0xF109 0x0A02      ADD      R10,R9,#+2
    295              unsigned char *tag;
    296              size_t clear_len, ciph_len;
    297          
    298              *tlen = 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    299          
    300              if( ctx == NULL || ctx->f_rng == NULL )
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD003             BEQ.N    ??mbedtls_ssl_ticket_write_0
   \       0x26   0xF8D4 0x0098      LDR      R0,[R4, #+152]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD101             BNE.N    ??mbedtls_ssl_ticket_write_1
    301                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   \                     ??mbedtls_ssl_ticket_write_0: (+1)
   \       0x2E   0x....             LDR.N    R0,??DataTable5  ;; 0xffff8f00
   \       0x30   0xE058             B.N      ??mbedtls_ssl_ticket_write_2
   \                     ??mbedtls_ssl_ticket_write_1: (+1)
   \       0x32   0x461F             MOV      R7,R3
    302          
    303              /* We need at least 4 bytes for key_name, 12 for IV, 2 for len 16 for tag,
    304               * in addition to session itself, that will be checked when writing it. */
    305              if( end - start < 4 + 12 + 2 + 16 )
   \       0x34   0x1BB8             SUBS     R0,R7,R6
   \       0x36   0x2822             CMP      R0,#+34
   \       0x38   0xDA01             BGE.N    ??mbedtls_ssl_ticket_write_3
    306                  return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
   \       0x3A   0x....             LDR.N    R0,??DataTable5_1  ;; 0xffff9600
   \       0x3C   0xE052             B.N      ??mbedtls_ssl_ticket_write_2
    307          
    308          #if defined(MBEDTLS_THREADING_C)
    309              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    310                  return( ret );
    311          #endif
    312          
    313              if( ( ret = ssl_ticket_update_keys( ctx ) ) != 0 )
   \                     ??mbedtls_ssl_ticket_write_3: (+1)
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0x....'....        BL       ssl_ticket_update_keys
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD14D             BNE.N    ??mbedtls_ssl_ticket_write_2
   \       0x48   0x9815             LDR      R0,[SP, #+84]
    314                  goto cleanup;
    315          
    316              key = &ctx->keys[ctx->active];
   \       0x4A   0xF894 0x1090      LDRB     R1,[R4, #+144]
   \       0x4E   0xEB01 0x02C1      ADD      R2,R1,R1, LSL #+3
   \       0x52   0xEB04 0x0BC2      ADD      R11,R4,R2, LSL #+3
    317          
    318              *ticket_lifetime = ctx->ticket_lifetime;
   \       0x56   0xF8D4 0x1094      LDR      R1,[R4, #+148]
   \       0x5A   0x6001             STR      R1,[R0, #+0]
    319          
    320              memcpy( key_name, key->name, 4 );
   \       0x5C   0x2204             MOVS     R2,#+4
   \       0x5E   0x4659             MOV      R1,R11
   \       0x60   0x4630             MOV      R0,R6
   \       0x62   0x....'....        BL       __aeabi_memcpy
    321          
    322              if( ( ret = ctx->f_rng( ctx->p_rng, iv, 12 ) ) != 0 )
   \       0x66   0x220C             MOVS     R2,#+12
   \       0x68   0x9909             LDR      R1,[SP, #+36]
   \       0x6A   0xF8D4 0x009C      LDR      R0,[R4, #+156]
   \       0x6E   0xF8D4 0x3098      LDR      R3,[R4, #+152]
   \       0x72   0x4798             BLX      R3
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD135             BNE.N    ??mbedtls_ssl_ticket_write_2
   \       0x78   0x4628             MOV      R0,R5
    323                  goto cleanup;
    324          
    325              /* Dump session state */
    326              if( ( ret = ssl_save_session( session,
    327                                            state, end - state, &clear_len ) ) != 0 ||
    328                  (unsigned long) clear_len > 65535 )
   \       0x7A   0xAB07             ADD      R3,SP,#+28
   \       0x7C   0xEBA7 0x070A      SUB      R7,R7,R10
   \       0x80   0x463A             MOV      R2,R7
   \       0x82   0x4651             MOV      R1,R10
   \       0x84   0x....'....        BL       ssl_save_session
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD12B             BNE.N    ??mbedtls_ssl_ticket_write_2
   \       0x8C   0x9907             LDR      R1,[SP, #+28]
   \       0x8E   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0x92   0xD227             BCS.N    ??mbedtls_ssl_ticket_write_2
    329              {
    330                   goto cleanup;
    331              }
    332              state_len_bytes[0] = ( clear_len >> 8 ) & 0xff;
   \       0x94   0x4608             MOV      R0,R1
   \       0x96   0x0A00             LSRS     R0,R0,#+8
   \       0x98   0xF889 0x0000      STRB     R0,[R9, #+0]
    333              state_len_bytes[1] = ( clear_len      ) & 0xff;
   \       0x9C   0x9807             LDR      R0,[SP, #+28]
   \       0x9E   0xF889 0x0001      STRB     R0,[R9, #+1]
    334          
    335              /* Encrypt and authenticate */
    336              tag = state + clear_len;
    337              if( ( ret = mbedtls_cipher_auth_encrypt( &key->ctx,
    338                              iv, 12, key_name, 4 + 12 + 2,
    339                              state, clear_len, state, &ciph_len, tag, 16 ) ) != 0 )
   \       0xA2   0x2010             MOVS     R0,#+16
   \       0xA4   0x9006             STR      R0,[SP, #+24]
   \       0xA6   0x9807             LDR      R0,[SP, #+28]
   \       0xA8   0x4450             ADD      R0,R10,R0
   \       0xAA   0x9005             STR      R0,[SP, #+20]
   \       0xAC   0xA808             ADD      R0,SP,#+32
   \       0xAE   0x9004             STR      R0,[SP, #+16]
   \       0xB0   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \       0xB4   0x9807             LDR      R0,[SP, #+28]
   \       0xB6   0x9002             STR      R0,[SP, #+8]
   \       0xB8   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0xBC   0x2012             MOVS     R0,#+18
   \       0xBE   0x9000             STR      R0,[SP, #+0]
   \       0xC0   0x4633             MOV      R3,R6
   \       0xC2   0x220C             MOVS     R2,#+12
   \       0xC4   0x9909             LDR      R1,[SP, #+36]
   \       0xC6   0xF10B 0x0008      ADD      R0,R11,#+8
   \       0xCA   0x....'....        BL       mbedtls_cipher_auth_encrypt
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD108             BNE.N    ??mbedtls_ssl_ticket_write_2
    340              {
    341                  goto cleanup;
    342              }
    343              if( ciph_len != clear_len )
   \       0xD2   0x9908             LDR      R1,[SP, #+32]
   \       0xD4   0x9A07             LDR      R2,[SP, #+28]
   \       0xD6   0x4291             CMP      R1,R2
   \       0xD8   0xD001             BEQ.N    ??mbedtls_ssl_ticket_write_4
    344              {
    345                  ret = MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0xDA   0x....             LDR.N    R0,??DataTable5_3  ;; 0xffff9400
    346                  goto cleanup;
   \       0xDC   0xE002             B.N      ??mbedtls_ssl_ticket_write_2
    347              }
    348          
    349              *tlen = 4 + 12 + 2 + 16 + ciph_len;
   \                     ??mbedtls_ssl_ticket_write_4: (+1)
   \       0xDE   0x3122             ADDS     R1,R1,#+34
   \       0xE0   0xF8C8 0x1000      STR      R1,[R8, #+0]
    350          
    351          cleanup:
    352          #if defined(MBEDTLS_THREADING_C)
    353              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    354                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    355          #endif
    356          
    357              return( ret );
   \                     ??mbedtls_ssl_ticket_write_2: (+1)
   \       0xE4   0xB00B             ADD      SP,SP,#+44
   \       0xE6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    358          }
    359          
    360          /*
    361           * Select key based on name
    362           */

   \                                 In section .text, align 2, keep-with-next
    363          static mbedtls_ssl_ticket_key *ssl_ticket_select_key(
    364                  mbedtls_ssl_ticket_context *ctx,
    365                  const unsigned char name[4] )
    366          {
   \                     ssl_ticket_select_key: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    367              unsigned char i;
    368          
    369              for( i = 0; i < sizeof( ctx->keys ) / sizeof( *ctx->keys ); i++ )
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0x2748             MOVS     R7,#+72
   \        0xA   0xE000             B.N      ??ssl_ticket_select_key_0
   \                     ??ssl_ticket_select_key_1: (+1)
   \        0xC   0x1C76             ADDS     R6,R6,#+1
   \                     ??ssl_ticket_select_key_0: (+1)
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x2802             CMP      R0,#+2
   \       0x14   0xD20F             BCS.N    ??ssl_ticket_select_key_2
    370                  if( memcmp( name, ctx->keys[i].name, 4 ) == 0 )
   \       0x16   0x2204             MOVS     R2,#+4
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0xFB17 0xF000      SMULBB   R0,R7,R0
   \       0x20   0x1821             ADDS     R1,R4,R0
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0x....'....        BL       memcmp
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD1EF             BNE.N    ??ssl_ticket_select_key_1
    371                      return( &ctx->keys[i] );
   \       0x2C   0xB2F6             UXTB     R6,R6
   \       0x2E   0xFB17 0xF606      SMULBB   R6,R7,R6
   \       0x32   0x19A0             ADDS     R0,R4,R6
   \       0x34   0xBDF2             POP      {R1,R4-R7,PC}
    372          
    373              return( NULL );
   \                     ??ssl_ticket_select_key_2: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    374          }
    375          
    376          /*
    377           * Load session ticket (see mbedtls_ssl_ticket_write for structure)
    378           */

   \                                 In section .text, align 2, keep-with-next
    379          int mbedtls_ssl_ticket_parse( void *p_ticket,
    380                                        mbedtls_ssl_session *session,
    381                                        unsigned char *buf,
    382                                        size_t len )
    383          {
   \                     mbedtls_ssl_ticket_parse: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
    384              int ret;
    385              mbedtls_ssl_ticket_context *ctx = p_ticket;
    386              mbedtls_ssl_ticket_key *key;
    387              unsigned char *key_name = buf;
    388              unsigned char *iv = buf + 4;
   \        0xC   0xF106 0x0804      ADD      R8,R6,#+4
    389              unsigned char *enc_len_p = iv + 12;
   \       0x10   0xF108 0x0A0C      ADD      R10,R8,#+12
    390              unsigned char *ticket = enc_len_p + 2;
   \       0x14   0xF10A 0x0902      ADD      R9,R10,#+2
    391              unsigned char *tag;
    392              size_t enc_len, clear_len;
    393          
    394              if( ctx == NULL || ctx->f_rng == NULL )
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD006             BEQ.N    ??mbedtls_ssl_ticket_parse_0
   \       0x1C   0xF8D4 0x0098      LDR      R0,[R4, #+152]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD002             BEQ.N    ??mbedtls_ssl_ticket_parse_0
   \       0x24   0x461F             MOV      R7,R3
    395                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
    396          
    397              /* See mbedtls_ssl_ticket_write() */
    398              if( len < 4 + 12 + 2 + 16 )
   \       0x26   0x2F22             CMP      R7,#+34
   \       0x28   0xD201             BCS.N    ??mbedtls_ssl_ticket_parse_1
    399                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   \                     ??mbedtls_ssl_ticket_parse_0: (+1)
   \       0x2A   0x....             LDR.N    R0,??DataTable5  ;; 0xffff8f00
   \       0x2C   0xE03F             B.N      ??mbedtls_ssl_ticket_parse_2
    400          
    401          #if defined(MBEDTLS_THREADING_C)
    402              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    403                  return( ret );
    404          #endif
    405          
    406              if( ( ret = ssl_ticket_update_keys( ctx ) ) != 0 )
   \                     ??mbedtls_ssl_ticket_parse_1: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       ssl_ticket_update_keys
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD13A             BNE.N    ??mbedtls_ssl_ticket_parse_2
    407                  goto cleanup;
    408          
    409              enc_len = ( enc_len_p[0] << 8 ) | enc_len_p[1];
   \       0x38   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \       0x3C   0xF89A 0xA001      LDRB     R10,[R10, #+1]
   \       0x40   0xEA4A 0x2A00      ORR      R10,R10,R0, LSL #+8
    410              tag = ticket + enc_len;
   \       0x44   0xEB09 0x0B0A      ADD      R11,R9,R10
    411          
    412              if( len != 4 + 12 + 2 + enc_len + 16 )
   \       0x48   0xF10A 0x0022      ADD      R0,R10,#+34
   \       0x4C   0x4287             CMP      R7,R0
   \       0x4E   0xD001             BEQ.N    ??mbedtls_ssl_ticket_parse_3
    413              {
    414                  ret = MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \       0x50   0x....             LDR.N    R0,??DataTable5  ;; 0xffff8f00
    415                  goto cleanup;
   \       0x52   0xE02C             B.N      ??mbedtls_ssl_ticket_parse_2
    416              }
    417          
    418              /* Select key */
    419              if( ( key = ssl_ticket_select_key( ctx, key_name ) ) == NULL )
   \                     ??mbedtls_ssl_ticket_parse_3: (+1)
   \       0x54   0x4631             MOV      R1,R6
   \       0x56   0x4620             MOV      R0,R4
   \       0x58   0x....'....        BL       ssl_ticket_select_key
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD101             BNE.N    ??mbedtls_ssl_ticket_parse_4
    420              {
    421                  /* We can't know for sure but this is a likely option unless we're
    422                   * under attack - this is only informative anyway */
    423                  ret = MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED;
   \       0x60   0x....             LDR.N    R0,??DataTable5_4  ;; 0xffff9280
    424                  goto cleanup;
   \       0x62   0xE024             B.N      ??mbedtls_ssl_ticket_parse_2
    425              }
    426          
    427              /* Decrypt and authenticate */
    428              if( ( ret = mbedtls_cipher_auth_decrypt( &key->ctx, iv, 12,
    429                              key_name, 4 + 12 + 2, ticket, enc_len,
    430                              ticket, &clear_len, tag, 16 ) ) != 0 )
   \                     ??mbedtls_ssl_ticket_parse_4: (+1)
   \       0x64   0x2110             MOVS     R1,#+16
   \       0x66   0x9106             STR      R1,[SP, #+24]
   \       0x68   0xF8CD 0xB014      STR      R11,[SP, #+20]
   \       0x6C   0xA907             ADD      R1,SP,#+28
   \       0x6E   0x9104             STR      R1,[SP, #+16]
   \       0x70   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x74   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \       0x78   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x7C   0x2112             MOVS     R1,#+18
   \       0x7E   0x9100             STR      R1,[SP, #+0]
   \       0x80   0x4633             MOV      R3,R6
   \       0x82   0x220C             MOVS     R2,#+12
   \       0x84   0x4641             MOV      R1,R8
   \       0x86   0x3008             ADDS     R0,R0,#+8
   \       0x88   0x....'....        BL       mbedtls_cipher_auth_decrypt
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD004             BEQ.N    ??mbedtls_ssl_ticket_parse_5
    431              {
    432                  if( ret == MBEDTLS_ERR_CIPHER_AUTH_FAILED )
   \       0x90   0xF510 0x4FC6      CMN      R0,#+25344
   \       0x94   0xD10B             BNE.N    ??mbedtls_ssl_ticket_parse_2
    433                      ret = MBEDTLS_ERR_SSL_INVALID_MAC;
   \       0x96   0x....             LDR.N    R0,??DataTable5_5  ;; 0xffff8e80
   \       0x98   0xE009             B.N      ??mbedtls_ssl_ticket_parse_2
    434          
    435                  goto cleanup;
    436              }
    437              if( clear_len != enc_len )
   \                     ??mbedtls_ssl_ticket_parse_5: (+1)
   \       0x9A   0x9807             LDR      R0,[SP, #+28]
   \       0x9C   0x4550             CMP      R0,R10
   \       0x9E   0xD001             BEQ.N    ??mbedtls_ssl_ticket_parse_6
    438              {
    439                  ret = MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0xA0   0x....             LDR.N    R0,??DataTable5_3  ;; 0xffff9400
    440                  goto cleanup;
   \       0xA2   0xE004             B.N      ??mbedtls_ssl_ticket_parse_2
    441              }
   \                     ??mbedtls_ssl_ticket_parse_6: (+1)
   \       0xA4   0x4628             MOV      R0,R5
    442          
    443              /* Actually load session */
    444              if( ( ret = ssl_load_session( session, ticket, clear_len ) ) != 0 )
   \       0xA6   0x9A07             LDR      R2,[SP, #+28]
   \       0xA8   0x4649             MOV      R1,R9
   \       0xAA   0x....'....        BL       ssl_load_session
    445                  goto cleanup;
    446          
    447          #if defined(MBEDTLS_HAVE_TIME)
    448              {
    449                  /* Check for expiration */
    450                  mbedtls_time_t current_time = mbedtls_time( NULL );
    451          
    452                  if( current_time < session->start ||
    453                      (uint32_t)( current_time - session->start ) > ctx->ticket_lifetime )
    454                  {
    455                      ret = MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED;
    456                      goto cleanup;
    457                  }
    458              }
    459          #endif
    460          
    461          cleanup:
    462          #if defined(MBEDTLS_THREADING_C)
    463              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    464                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    465          #endif
    466          
    467              return( ret );
   \                     ??mbedtls_ssl_ticket_parse_2: (+1)
   \       0xAE   0xB009             ADD      SP,SP,#+36
   \       0xB0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    468          }
    469          
    470          /*
    471           * Free context
    472           */

   \                                 In section .text, align 2, keep-with-next
    473          void mbedtls_ssl_ticket_free( mbedtls_ssl_ticket_context *ctx )
    474          {
   \                     mbedtls_ssl_ticket_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    475              mbedtls_cipher_free( &ctx->keys[0].ctx );
   \        0x4   0xF104 0x0008      ADD      R0,R4,#+8
   \        0x8   0x....'....        BL       mbedtls_cipher_free
    476              mbedtls_cipher_free( &ctx->keys[1].ctx );
   \        0xC   0xF104 0x0050      ADD      R0,R4,#+80
   \       0x10   0x....'....        BL       mbedtls_cipher_free
    477          
    478          #if defined(MBEDTLS_THREADING_C)
    479              mbedtls_mutex_free( &ctx->mutex );
    480          #endif
    481          
    482              mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ssl_ticket_context ) );
   \       0x14   0x21A0             MOVS     R1,#+160
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1C   0x....'....        B.W      mbedtls_platform_zeroize
    483          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0xFFFF'8F00        DC32     0xffff8f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0xFFFF'9600        DC32     0xffff9600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0xFFFF'8100        DC32     0xffff8100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0xFFFF'9400        DC32     0xffff9400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0xFFFF'9280        DC32     0xffff9280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \        0x0   0xFFFF'8E80        DC32     0xffff8e80
    484          
    485          #endif /* MBEDTLS_SSL_TICKET_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_cipher_get_key_bitlen
       8   mbedtls_ssl_ticket_free
         8   -> mbedtls_cipher_free
         0   -> mbedtls_platform_zeroize
       0   mbedtls_ssl_ticket_init
         0   -> __aeabi_memset4
      72   mbedtls_ssl_ticket_parse
        72   -> mbedtls_cipher_auth_decrypt
        72   -> ssl_load_session
        72   -> ssl_ticket_select_key
        72   -> ssl_ticket_update_keys
      16   mbedtls_ssl_ticket_setup
        16   -> mbedtls_cipher_info_from_type
        16   -> mbedtls_cipher_setup
        16   -> ssl_ticket_gen_key
      80   mbedtls_ssl_ticket_write
        80   -- Indirect call
        80   -> __aeabi_memcpy
        80   -> mbedtls_cipher_auth_encrypt
        80   -> ssl_save_session
        80   -> ssl_ticket_update_keys
      24   ssl_load_session
        24   -> __aeabi_memcpy
        24   -> mbedtls_calloc
        24   -> mbedtls_free
        24   -> mbedtls_x509_crt_free
        24   -> mbedtls_x509_crt_init
        24   -> mbedtls_x509_crt_parse_der
      24   ssl_save_session
        24   -> __aeabi_memcpy
      48   ssl_ticket_gen_key
        48   -- Indirect call
        48   -> mbedtls_cipher_get_key_bitlen
        48   -> mbedtls_cipher_setkey
        48   -> mbedtls_platform_zeroize
      24   ssl_ticket_select_key
        24   -> memcmp
       0   ssl_ticket_update_keys


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
      20  mbedtls_cipher_get_key_bitlen
      32  mbedtls_ssl_ticket_free
       8  mbedtls_ssl_ticket_init
     180  mbedtls_ssl_ticket_parse
     108  mbedtls_ssl_ticket_setup
     234  mbedtls_ssl_ticket_write
     156  ssl_load_session
     106  ssl_save_session
      88  ssl_ticket_gen_key
      58  ssl_ticket_select_key
       4  ssl_ticket_update_keys

 
 1 018 bytes in section .text
 
 1 018 bytes of CODE memory

Errors: none
Warnings: none
