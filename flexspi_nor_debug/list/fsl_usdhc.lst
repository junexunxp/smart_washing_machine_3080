###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:24
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\drivers\fsl_usdhc.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWECCB.tmp
#        (C:\Development\smart_washing_machine_3080\drivers\fsl_usdhc.c -D
#        DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1
#        -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE
#        -D "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\fsl_usdhc.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\fsl_usdhc.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\drivers\fsl_usdhc.c
      1          /*
      2           * Copyright (c) 2016, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           * All rights reserved.
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           */
      8          
      9          #include "fsl_usdhc.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xD408             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xF000 0x011F      AND      R1,R0,#0x1F
   \        0xA   0x408A             LSLS     R2,R2,R1
   \        0xC   0x....'....        LDR.W    R1,??DataTable15  ;; 0xe000e100
   \       0x10   0x0940             LSRS     R0,R0,#+5
   \       0x12   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_DisableIRQ(IRQn_Type)
   \                     __NVIC_DisableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xD40C             BMI.N    ??__NVIC_DisableIRQ_0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xF000 0x011F      AND      R1,R0,#0x1F
   \        0xA   0x408A             LSLS     R2,R2,R1
   \        0xC   0x....'....        LDR.W    R1,??DataTable15_1  ;; 0xe000e180
   \       0x10   0x0940             LSRS     R0,R0,#+5
   \       0x12   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \       0x16   0xF3BF 0x8F4F      DSB      SY
   \       0x1A   0xF3BF 0x8F6F      ISB      SY
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \       0x1E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_ControlGate(clock_ip_name_t, clock_gate_value_t)
   \                     CLOCK_ControlGate: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4626             MOV      R6,R4
   \        0x8   0x0A36             LSRS     R6,R6,#+8
   \        0xA   0xF004 0x041F      AND      R4,R4,#0x1F
   \        0xE   0x2E07             CMP      R6,#+7
   \       0x10   0xD309             BCC.N    ??CLOCK_ControlGate_0
   \       0x12   0xF240 0x32C1      MOVW     R2,#+961
   \       0x16   0x....'....        LDR.W    R1,??DataTable15_2
   \       0x1A   0x....'....        LDR.W    R0,??DataTable15_3
   \       0x1E   0x....'....        BL       __aeabi_assert
   \       0x22   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??CLOCK_ControlGate_0: (+1)
   \       0x26   0x....'....        LDR.W    R0,??DataTable16  ;; 0x400fc068
   \       0x2A   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0x2203             MOVS     R2,#+3
   \       0x32   0x40A2             LSLS     R2,R2,R4
   \       0x34   0x4391             BICS     R1,R1,R2
   \       0x36   0xFA05 0xF404      LSL      R4,R5,R4
   \       0x3A   0x430C             ORRS     R4,R4,R1
   \       0x3C   0x6004             STR      R4,[R0, #+0]
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \        0x0   0x2103             MOVS     R1,#+3
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             B.N      CLOCK_ControlGate

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int32_t EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0xF06F 0x027F      MVN      R2,#+127
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD101             BNE.N    ??EnableIRQ_0
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xBD02             POP      {R1,PC}
   \                     ??EnableIRQ_0: (+1)
   \       0x10   0x....'....        BL       __NVIC_EnableIRQ
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int32_t DisableIRQ(IRQn_Type)
   \                     DisableIRQ: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0xF06F 0x027F      MVN      R2,#+127
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD101             BNE.N    ??DisableIRQ_0
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xBD02             POP      {R1,PC}
   \                     ??DisableIRQ_0: (+1)
   \       0x10   0x....'....        BL       __NVIC_DisableIRQ
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USDHC_EnableInternalDMA(USDHC_Type *, bool)
   \                     USDHC_EnableInternalDMA: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0x6C81             LDR      R1,[R0, #+72]
   \        0x4   0xD003             BEQ.N    ??USDHC_EnableInternalDMA_0
   \        0x6   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0xA   0x6481             STR      R1,[R0, #+72]
   \        0xC   0x4770             BX       LR
   \                     ??USDHC_EnableInternalDMA_0: (+1)
   \        0xE   0x0849             LSRS     R1,R1,#+1
   \       0x10   0x0049             LSLS     R1,R1,#+1
   \       0x12   0x6481             STR      R1,[R0, #+72]
   \       0x14   0x6A81             LDR      R1,[R0, #+40]
   \       0x16   0xF421 0x7140      BIC      R1,R1,#0x300
   \       0x1A   0x6281             STR      R1,[R0, #+40]
   \       0x1C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USDHC_EnableInterruptStatus(USDHC_Type *, uint32_t)
   \                     USDHC_EnableInterruptStatus: (+1)
   \        0x0   0x6B42             LDR      R2,[R0, #+52]
   \        0x2   0x4311             ORRS     R1,R1,R2
   \        0x4   0x6341             STR      R1,[R0, #+52]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USDHC_DisableInterruptStatus(USDHC_Type *, uint32_t)
   \                     USDHC_DisableInterruptStatus: (+1)
   \        0x0   0x6B42             LDR      R2,[R0, #+52]
   \        0x2   0xEA22 0x0101      BIC      R1,R2,R1
   \        0x6   0x6341             STR      R1,[R0, #+52]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USDHC_EnableInterruptSignal(USDHC_Type *, uint32_t)
   \                     USDHC_EnableInterruptSignal: (+1)
   \        0x0   0x6B82             LDR      R2,[R0, #+56]
   \        0x2   0x4311             ORRS     R1,R1,R2
   \        0x4   0x6381             STR      R1,[R0, #+56]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USDHC_DisableInterruptSignal(USDHC_Type *, uint32_t)
   \                     USDHC_DisableInterruptSignal: (+1)
   \        0x0   0x6B82             LDR      R2,[R0, #+56]
   \        0x2   0xEA22 0x0101      BIC      R1,R2,R1
   \        0x6   0x6381             STR      R1,[R0, #+56]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t USDHC_GetEnabledInterruptStatusFlags(USDHC_Type *)
   \                     USDHC_GetEnabledInterruptStatusFlags: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x6B08             LDR      R0,[R1, #+48]
   \        0x4   0x6B89             LDR      R1,[R1, #+56]
   \        0x6   0x4008             ANDS     R0,R1,R0
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t USDHC_GetInterruptStatusFlags(USDHC_Type *)
   \                     USDHC_GetInterruptStatusFlags: (+1)
   \        0x0   0x6B00             LDR      R0,[R0, #+48]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USDHC_ClearInterruptStatusFlags(USDHC_Type *, uint32_t)
   \                     USDHC_ClearInterruptStatusFlags: (+1)
   \        0x0   0x6301             STR      R1,[R0, #+48]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USDHC_WriteData(USDHC_Type *, uint32_t)
   \                     USDHC_WriteData: (+1)
   \        0x0   0x6201             STR      R1,[R0, #+32]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t USDHC_ReadData(USDHC_Type *)
   \                     USDHC_ReadData: (+1)
   \        0x0   0x6A00             LDR      R0,[R0, #+32]
   \        0x2   0x4770             BX       LR               ;; return
     10          #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
     11          #include "fsl_cache.h"
     12          #endif /* FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL */
     13          
     14          /*******************************************************************************
     15           * Definitions
     16           ******************************************************************************/
     17          
     18          /* Component ID definition, used by tools. */
     19          #ifndef FSL_COMPONENT_ID
     20          #define FSL_COMPONENT_ID "platform.drivers.usdhc"
     21          #endif
     22          
     23          /*! @brief Clock setting */
     24          /* Max SD clock divisor from base clock */
     25          #define USDHC_MAX_DVS ((USDHC_SYS_CTRL_DVS_MASK >> USDHC_SYS_CTRL_DVS_SHIFT) + 1U)
     26          #define USDHC_MAX_CLKFS ((USDHC_SYS_CTRL_SDCLKFS_MASK >> USDHC_SYS_CTRL_SDCLKFS_SHIFT) + 1U)
     27          #define USDHC_PREV_DVS(x) ((x) -= 1U)
     28          #define USDHC_PREV_CLKFS(x, y) ((x) >>= (y))
     29          /*! @brief USDHC ADMA table address align size */
     30          #define USDHC_ADMA_TABLE_ADDRESS_ALIGN (4U)
     31          
     32          /* Typedef for interrupt handler. */
     33          typedef void (*usdhc_isr_t)(USDHC_Type *base, usdhc_handle_t *handle);
     34          /*! @brief Dummy data buffer for mmc boot mode  */

   \                                 In section NonCacheable, align 4
     35          AT_NONCACHEABLE_SECTION_ALIGN(uint32_t s_usdhcBootDummy, USDHC_ADMA2_ADDRESS_ALIGN);
   \                     s_usdhcBootDummy:
   \        0x0                      DS8 4
     36          /*******************************************************************************
     37           * Prototypes
     38           ******************************************************************************/
     39          /*!
     40           * @brief Get the instance.
     41           *
     42           * @param base USDHC peripheral base address.
     43           * @return Instance number.
     44           */
     45          static uint32_t USDHC_GetInstance(USDHC_Type *base);
     46          
     47          /*!
     48           * @brief Set transfer interrupt.
     49           *
     50           * @param base USDHC peripheral base address.
     51           * @param usingInterruptSignal True to use IRQ signal.
     52           */
     53          static void USDHC_SetTransferInterrupt(USDHC_Type *base, bool usingInterruptSignal);
     54          
     55          /*!
     56           * @brief Start transfer according to current transfer state
     57           *
     58           * @param base USDHC peripheral base address.
     59           * @param data Data to be transferred.
     60           * @param flag data present flag
     61           * @param enDMA DMA enable flag
     62           */
     63          static status_t USDHC_SetDataTransferConfig(USDHC_Type *base,
     64                                                      usdhc_data_t *data,
     65                                                      uint32_t *dataPresentFlag,
     66                                                      bool enDMA);
     67          
     68          /*!
     69           * @brief Receive command response
     70           *
     71           * @param base USDHC peripheral base address.
     72           * @param command Command to be sent.
     73           */
     74          static status_t USDHC_ReceiveCommandResponse(USDHC_Type *base, usdhc_command_t *command);
     75          
     76          /*!
     77           * @brief Read DATAPORT when buffer enable bit is set.
     78           *
     79           * @param base USDHC peripheral base address.
     80           * @param data Data to be read.
     81           * @param transferredWords The number of data words have been transferred last time transaction.
     82           * @return The number of total data words have been transferred after this time transaction.
     83           */
     84          static uint32_t USDHC_ReadDataPort(USDHC_Type *base, usdhc_data_t *data, uint32_t transferredWords);
     85          
     86          /*!
     87           * @brief Read data by using DATAPORT polling way.
     88           *
     89           * @param base USDHC peripheral base address.
     90           * @param data Data to be read.
     91           * @retval kStatus_Fail Read DATAPORT failed.
     92           * @retval kStatus_Success Operate successfully.
     93           */
     94          static status_t USDHC_ReadByDataPortBlocking(USDHC_Type *base, usdhc_data_t *data);
     95          
     96          /*!
     97           * @brief Write DATAPORT when buffer enable bit is set.
     98           *
     99           * @param base USDHC peripheral base address.
    100           * @param data Data to be read.
    101           * @param transferredWords The number of data words have been transferred last time.
    102           * @return The number of total data words have been transferred after this time transaction.
    103           */
    104          static uint32_t USDHC_WriteDataPort(USDHC_Type *base, usdhc_data_t *data, uint32_t transferredWords);
    105          
    106          /*!
    107           * @brief Write data by using DATAPORT polling way.
    108           *
    109           * @param base USDHC peripheral base address.
    110           * @param data Data to be transferred.
    111           * @retval kStatus_Fail Write DATAPORT failed.
    112           * @retval kStatus_Success Operate successfully.
    113           */
    114          static status_t USDHC_WriteByDataPortBlocking(USDHC_Type *base, usdhc_data_t *data);
    115          
    116          /*!
    117           * @brief Transfer data by polling way.
    118           *
    119           * @param base USDHC peripheral base address.
    120           * @param data Data to be transferred.
    121           * @param use DMA flag.
    122           * @retval kStatus_Fail Transfer data failed.
    123           * @retval kStatus_InvalidArgument Argument is invalid.
    124           * @retval kStatus_Success Operate successfully.
    125           */
    126          static status_t USDHC_TransferDataBlocking(USDHC_Type *base, usdhc_data_t *data, bool enDMA);
    127          
    128          /*!
    129           * @brief Handle card detect interrupt.
    130           *
    131           * @param base USDHC peripheral base address.
    132           * @param handle USDHC handle.
    133           * @param interruptFlags Card detect related interrupt flags.
    134           */
    135          static void USDHC_TransferHandleCardDetect(USDHC_Type *base, usdhc_handle_t *handle, uint32_t interruptFlags);
    136          
    137          /*!
    138           * @brief Handle command interrupt.
    139           *
    140           * @param base USDHC peripheral base address.
    141           * @param handle USDHC handle.
    142           * @param interruptFlags Command related interrupt flags.
    143           */
    144          static void USDHC_TransferHandleCommand(USDHC_Type *base, usdhc_handle_t *handle, uint32_t interruptFlags);
    145          
    146          /*!
    147           * @brief Handle data interrupt.
    148           *
    149           * @param base USDHC peripheral base address.
    150           * @param handle USDHC handle.
    151           * @param interruptFlags Data related interrupt flags.
    152           */
    153          static void USDHC_TransferHandleData(USDHC_Type *base, usdhc_handle_t *handle, uint32_t interruptFlags);
    154          
    155          /*!
    156           * @brief Handle SDIO card interrupt signal.
    157           *
    158           * @param base USDHC peripheral base address.
    159           * @param handle USDHC handle.
    160           */
    161          static void USDHC_TransferHandleSdioInterrupt(USDHC_Type *base, usdhc_handle_t *handle);
    162          
    163          /*!
    164           * @brief Handle SDIO block gap event.
    165           *
    166           * @param base USDHC peripheral base address.
    167           * @param handle USDHC handle.
    168           */
    169          static void USDHC_TransferHandleBlockGap(USDHC_Type *base, usdhc_handle_t *handle);
    170          
    171          /*!
    172           * @brief Handle retuning
    173           *
    174           * @param base USDHC peripheral base address.
    175           * @param handle USDHC handle.
    176           * @param interrupt flags
    177           */
    178          static void USDHC_TransferHandleReTuning(USDHC_Type *base, usdhc_handle_t *handle, uint32_t interruptFlags);
    179          
    180          /*!
    181           * @brief wait command done
    182           *
    183           * @param base USDHC peripheral base address.
    184           * @param command configuration
    185           * @param pollingCmdDone polling command done flag
    186           */
    187          static status_t USDHC_WaitCommandDone(USDHC_Type *base, usdhc_command_t *command, bool pollingCmdDone);
    188          
    189          /*******************************************************************************
    190           * Variables
    191           ******************************************************************************/
    192          /*! @brief USDHC base pointer array */

   \                                 In section .rodata, align 4
    193          static USDHC_Type *const s_usdhcBase[] = USDHC_BASE_PTRS;
   \                     s_usdhcBase:
   \        0x0   0x0000'0000        DC32 0H, 402C0000H, 402C4000H
   \              0x402C'0000  
   \              0x402C'4000  
    194          
    195          /*! @brief USDHC internal handle pointer array */

   \                                 In section .bss, align 4
    196          static usdhc_handle_t *s_usdhcHandle[ARRAY_SIZE(s_usdhcBase)] = {NULL};
   \                     s_usdhcHandle:
   \        0x0                      DS8 12
    197          
    198          /*! @brief USDHC IRQ name array */

   \                                 In section .rodata, align 4
    199          static const IRQn_Type s_usdhcIRQ[] = USDHC_IRQS;
   \                     s_usdhcIRQ:
   \        0x0   0xFF80 0x006E      DC16 -128, 110, 111
   \               0x006F      
   \        0x6   0x00 0x00          DC8 0, 0
    200          
    201          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    202          /*! @brief USDHC clock array name */

   \                                 In section .rodata, align 4
    203          static const clock_ip_name_t s_usdhcClock[] = USDHC_CLOCKS;
   \                     s_usdhcClock:
   \        0x0   0xFFFF 0x0602      DC16 -1, 1538, 1540
   \               0x0604      
   \        0x6   0x00 0x00          DC8 0, 0
    204          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    205          
    206          /* USDHC ISR for transactional APIs. */

   \                                 In section .bss, align 4
    207          static usdhc_isr_t s_usdhcIsr;
   \                     s_usdhcIsr:
   \        0x0                      DS8 4
    208          
    209          /*******************************************************************************
    210           * Code
    211           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    212          static uint32_t USDHC_GetInstance(USDHC_Type *base)
    213          {
   \                     USDHC_GetInstance: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    214              uint8_t instance = 0;
   \        0x2   0x2400             MOVS     R4,#+0
    215          
    216              while ((instance < ARRAY_SIZE(s_usdhcBase)) && (s_usdhcBase[instance] != base))
   \                     ??USDHC_GetInstance_0: (+1)
   \        0x4   0x2C03             CMP      R4,#+3
   \        0x6   0xD208             BCS.N    ??USDHC_GetInstance_1
   \        0x8   0x....'....        LDR.W    R1,??DataTable16_1
   \        0xC   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \       0x10   0x4281             CMP      R1,R0
   \       0x12   0xD002             BEQ.N    ??USDHC_GetInstance_1
    217              {
    218                  instance++;
   \       0x14   0x1C64             ADDS     R4,R4,#+1
   \       0x16   0xB2E4             UXTB     R4,R4
   \       0x18   0xE7F4             B.N      ??USDHC_GetInstance_0
    219              }
    220          
    221              assert(instance < ARRAY_SIZE(s_usdhcBase));
   \                     ??USDHC_GetInstance_1: (+1)
   \       0x1A   0x2C03             CMP      R4,#+3
   \       0x1C   0xD308             BCC.N    ??USDHC_GetInstance_2
   \       0x1E   0x22DD             MOVS     R2,#+221
   \       0x20   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x24   0x....'....        LDR.W    R0,??DataTable17
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
    222          
    223              return instance;
   \                     ??USDHC_GetInstance_2: (+1)
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0xBD10             POP      {R4,PC}          ;; return
    224          }
    225          

   \                                 In section .text, align 2, keep-with-next
    226          static void USDHC_SetTransferInterrupt(USDHC_Type *base, bool usingInterruptSignal)
    227          {
   \                     USDHC_SetTransferInterrupt: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    228              uint32_t interruptEnabled; /* The Interrupt status flags to be enabled */
    229          
    230              /* Disable all interrupts */
    231              USDHC_DisableInterruptStatus(base, (uint32_t)kUSDHC_AllInterruptFlags);
   \        0x6   0x....'....        LDR.W    R6,??DataTable16_3  ;; 0x157f513f
   \        0xA   0x4631             MOV      R1,R6
   \        0xC   0x....'....        BL       USDHC_DisableInterruptStatus
    232              USDHC_DisableInterruptSignal(base, (uint32_t)kUSDHC_AllInterruptFlags);
   \       0x10   0x4631             MOV      R1,R6
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x....'....        BL       USDHC_DisableInterruptSignal
    233              DisableIRQ(s_usdhcIRQ[USDHC_GetInstance(base)]);
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x....'....        BL       USDHC_GetInstance
   \       0x1E   0x....'....        LDR.W    R1,??DataTable16_4
   \       0x22   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x26   0x....'....        BL       DisableIRQ
    234          
    235              interruptEnabled = (kUSDHC_CommandFlag | kUSDHC_CardInsertionFlag | kUSDHC_DataFlag | kUSDHC_CardRemovalFlag |
    236                                  kUSDHC_SDR104TuningFlag | kUSDHC_BlockGapEventFlag);
    237          
    238              USDHC_EnableInterruptStatus(base, interruptEnabled);
   \       0x2A   0x....'....        LDR.W    R6,??DataTable17_1  ;; 0x157f50ff
   \       0x2E   0x4631             MOV      R1,R6
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       USDHC_EnableInterruptStatus
    239          
    240              if (usingInterruptSignal)
   \       0x36   0x2D00             CMP      R5,#+0
   \       0x38   0xD004             BEQ.N    ??USDHC_SetTransferInterrupt_0
    241              {
    242                  USDHC_EnableInterruptSignal(base, interruptEnabled);
   \       0x3A   0x4631             MOV      R1,R6
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x42   0x....             B.N      USDHC_EnableInterruptSignal
    243              }
    244          }
   \                     ??USDHC_SetTransferInterrupt_0: (+1)
   \       0x44   0xBD70             POP      {R4-R6,PC}       ;; return
    245          

   \                                 In section .text, align 2, keep-with-next
    246          static status_t USDHC_SetDataTransferConfig(USDHC_Type *base, usdhc_data_t *data, uint32_t *dataPresentFlag, bool enDMA)
    247          {
   \                     USDHC_SetDataTransferConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
    248              uint32_t mixCtrl = base->MIX_CTRL;
   \        0x2   0x6C85             LDR      R5,[R0, #+72]
    249          
    250              if (data != NULL)
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD071             BEQ.N    ??USDHC_SetDataTransferConfig_0
    251              {
    252                  /* if transfer boot continous, only need set the CREQ bit, leave others as it is */
    253                  if (data->dataType == kUSDHC_TransferDataBootcontinous)
   \        0x8   0x78CC             LDRB     R4,[R1, #+3]
   \        0xA   0x2C03             CMP      R4,#+3
   \        0xC   0xD109             BNE.N    ??USDHC_SetDataTransferConfig_1
    254                  {
    255                      /* clear stop at block gap request */
    256                      base->PROT_CTRL &= ~USDHC_PROT_CTRL_SABGREQ_MASK;
   \        0xE   0x6A81             LDR      R1,[R0, #+40]
   \       0x10   0xF421 0x3180      BIC      R1,R1,#0x10000
   \       0x14   0x6281             STR      R1,[R0, #+40]
    257                      /* continous transfer data */
    258                      base->PROT_CTRL |= USDHC_PROT_CTRL_CREQ_MASK;
   \       0x16   0x6A81             LDR      R1,[R0, #+40]
   \       0x18   0xF441 0x3100      ORR      R1,R1,#0x20000
   \       0x1C   0x6281             STR      R1,[R0, #+40]
    259                      return kStatus_Success;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xE05A             B.N      ??USDHC_SetDataTransferConfig_2
    260                  }
    261          
    262                  /* check data inhibit flag */
    263                  if (base->PRES_STATE & kUSDHC_DataInhibitFlag)
   \                     ??USDHC_SetDataTransferConfig_1: (+1)
   \       0x22   0x6A44             LDR      R4,[R0, #+36]
   \       0x24   0x07A4             LSLS     R4,R4,#+30
   \       0x26   0xD466             BMI.N    ??USDHC_SetDataTransferConfig_3
    264                  {
    265                      return kStatus_USDHC_BusyTransferring;
    266                  }
    267                  /* check transfer block count */
    268                  if ((data->blockCount > USDHC_MAX_BLOCK_COUNT) || ((data->txData == NULL) && (data->rxData == NULL)))
   \       0x28   0x688C             LDR      R4,[R1, #+8]
   \       0x2A   0xF5B4 0x3F80      CMP      R4,#+65536
   \       0x2E   0xD205             BCS.N    ??USDHC_SetDataTransferConfig_4
   \       0x30   0x690C             LDR      R4,[R1, #+16]
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD104             BNE.N    ??USDHC_SetDataTransferConfig_5
   \       0x36   0x68CC             LDR      R4,[R1, #+12]
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD101             BNE.N    ??USDHC_SetDataTransferConfig_5
    269                  {
    270                      return kStatus_InvalidArgument;
   \                     ??USDHC_SetDataTransferConfig_4: (+1)
   \       0x3C   0x2004             MOVS     R0,#+4
   \       0x3E   0xE04B             B.N      ??USDHC_SetDataTransferConfig_2
    271                  }
    272          
    273                  /* config mix parameter */
    274                  mixCtrl &= ~(USDHC_MIX_CTRL_MSBSEL_MASK | USDHC_MIX_CTRL_BCEN_MASK | USDHC_MIX_CTRL_DTDSEL_MASK |
    275                               USDHC_MIX_CTRL_AC12EN_MASK);
   \                     ??USDHC_SetDataTransferConfig_5: (+1)
   \       0x40   0xF025 0x0536      BIC      R5,R5,#0x36
    276          
    277                  if (data->rxData)
   \       0x44   0x68CC             LDR      R4,[R1, #+12]
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD001             BEQ.N    ??USDHC_SetDataTransferConfig_6
    278                  {
    279                      mixCtrl |= USDHC_MIX_CTRL_DTDSEL_MASK;
   \       0x4A   0xF045 0x0510      ORR      R5,R5,#0x10
    280                  }
    281                  if (data->blockCount > 1U)
   \                     ??USDHC_SetDataTransferConfig_6: (+1)
   \       0x4E   0x688C             LDR      R4,[R1, #+8]
   \       0x50   0x2C02             CMP      R4,#+2
   \       0x52   0xD306             BCC.N    ??USDHC_SetDataTransferConfig_7
    282                  {
    283                      mixCtrl |= USDHC_MIX_CTRL_MSBSEL_MASK | USDHC_MIX_CTRL_BCEN_MASK;
   \       0x54   0xF045 0x0522      ORR      R5,R5,#0x22
    284                      /* auto command 12 */
    285                      if (data->enableAutoCommand12)
   \       0x58   0x780C             LDRB     R4,[R1, #+0]
   \       0x5A   0x2C00             CMP      R4,#+0
   \       0x5C   0xD001             BEQ.N    ??USDHC_SetDataTransferConfig_7
    286                      {
    287                          mixCtrl |= USDHC_MIX_CTRL_AC12EN_MASK;
   \       0x5E   0xF045 0x0504      ORR      R5,R5,#0x4
    288                      }
    289                  }
    290          
    291                  /* auto command 23, auto send set block count cmd before multiple read/write */
    292                  if ((data->enableAutoCommand23))
   \                     ??USDHC_SetDataTransferConfig_7: (+1)
   \       0x62   0x784C             LDRB     R4,[R1, #+1]
   \       0x64   0x2C00             CMP      R4,#+0
   \       0x66   0xD00A             BEQ.N    ??USDHC_SetDataTransferConfig_8
    293                  {
    294                      mixCtrl |= USDHC_MIX_CTRL_AC23EN_MASK;
   \       0x68   0xF045 0x0580      ORR      R5,R5,#0x80
    295                      base->VEND_SPEC2 |= USDHC_VEND_SPEC2_ACMD23_ARGU2_EN_MASK;
   \       0x6C   0xF8D0 0x40C8      LDR      R4,[R0, #+200]
   \       0x70   0xF444 0x5480      ORR      R4,R4,#0x1000
   \       0x74   0xF8C0 0x40C8      STR      R4,[R0, #+200]
    296                      /* config the block count to DS_ADDR */
    297                      base->DS_ADDR = data->blockCount;
   \       0x78   0x688C             LDR      R4,[R1, #+8]
   \       0x7A   0x6004             STR      R4,[R0, #+0]
   \       0x7C   0xE007             B.N      ??USDHC_SetDataTransferConfig_9
    298                  }
    299                  else
    300                  {
    301                      mixCtrl &= ~USDHC_MIX_CTRL_AC23EN_MASK;
   \                     ??USDHC_SetDataTransferConfig_8: (+1)
   \       0x7E   0xF025 0x0580      BIC      R5,R5,#0x80
    302                      base->VEND_SPEC2 &= ~USDHC_VEND_SPEC2_ACMD23_ARGU2_EN_MASK;
   \       0x82   0xF8D0 0x40C8      LDR      R4,[R0, #+200]
   \       0x86   0xF424 0x5480      BIC      R4,R4,#0x1000
   \       0x8A   0xF8C0 0x40C8      STR      R4,[R0, #+200]
    303                  }
    304          
    305                  /* if transfer boot data, leave the block count to USDHC_SetMmcBootConfig function */
    306                  if (data->dataType != kUSDHC_TransferDataBoot)
   \                     ??USDHC_SetDataTransferConfig_9: (+1)
   \       0x8E   0x78CC             LDRB     R4,[R1, #+3]
   \       0x90   0x2C02             CMP      R4,#+2
   \       0x92   0xD00B             BEQ.N    ??USDHC_SetDataTransferConfig_10
    307                  {
    308                      /* config data block size/block count */
    309                      base->BLK_ATT = ((base->BLK_ATT & ~(USDHC_BLK_ATT_BLKSIZE_MASK | USDHC_BLK_ATT_BLKCNT_MASK)) |
    310                                       (USDHC_BLK_ATT_BLKSIZE(data->blockSize) | USDHC_BLK_ATT_BLKCNT(data->blockCount)));
   \       0x94   0x6844             LDR      R4,[R0, #+4]
   \       0x96   0xF404 0x4460      AND      R4,R4,#0xE000
   \       0x9A   0x684E             LDR      R6,[R1, #+4]
   \       0x9C   0xF3C6 0x060C      UBFX     R6,R6,#+0,#+13
   \       0xA0   0x4334             ORRS     R4,R6,R4
   \       0xA2   0x6889             LDR      R1,[R1, #+8]
   \       0xA4   0xEA44 0x4401      ORR      R4,R4,R1, LSL #+16
   \       0xA8   0x6044             STR      R4,[R0, #+4]
   \       0xAA   0xE005             B.N      ??USDHC_SetDataTransferConfig_11
    311                  }
    312                  else
    313                  {
    314                      mixCtrl |= USDHC_MIX_CTRL_MSBSEL_MASK | USDHC_MIX_CTRL_BCEN_MASK;
   \                     ??USDHC_SetDataTransferConfig_10: (+1)
   \       0xAC   0xF045 0x0522      ORR      R5,R5,#0x22
    315                      base->PROT_CTRL |= USDHC_PROT_CTRL_RD_DONE_NO_8CLK_MASK;
   \       0xB0   0x6A81             LDR      R1,[R0, #+40]
   \       0xB2   0xF441 0x1180      ORR      R1,R1,#0x100000
   \       0xB6   0x6281             STR      R1,[R0, #+40]
    316                  }
    317          
    318                  /* data present flag */
    319                  *dataPresentFlag |= kUSDHC_DataPresentFlag;
   \                     ??USDHC_SetDataTransferConfig_11: (+1)
   \       0xB8   0x6811             LDR      R1,[R2, #+0]
   \       0xBA   0xF441 0x1100      ORR      R1,R1,#0x200000
   \       0xBE   0x6011             STR      R1,[R2, #+0]
    320                  /* Disable useless interrupt */
    321                  if (enDMA)
   \       0xC0   0x2B00             CMP      R3,#+0
   \       0xC2   0x6B81             LDR      R1,[R0, #+56]
   \       0xC4   0xD00A             BEQ.N    ??USDHC_SetDataTransferConfig_12
    322                  {
    323                      base->INT_SIGNAL_EN &= ~(kUSDHC_BufferWriteReadyFlag | kUSDHC_BufferReadReadyFlag | kUSDHC_DmaCompleteFlag);
   \       0xC6   0xF021 0x0138      BIC      R1,R1,#0x38
   \       0xCA   0x6381             STR      R1,[R0, #+56]
    324                      base->INT_STATUS_EN &= ~(kUSDHC_BufferWriteReadyFlag | kUSDHC_BufferReadReadyFlag | kUSDHC_DmaCompleteFlag);
   \       0xCC   0x6B41             LDR      R1,[R0, #+52]
   \       0xCE   0xF021 0x0138      BIC      R1,R1,#0x38
   \       0xD2   0x6341             STR      R1,[R0, #+52]
    325                  }
    326                  else
    327                  {
    328                      base->INT_SIGNAL_EN |= kUSDHC_BufferWriteReadyFlag | kUSDHC_BufferReadReadyFlag;
    329                      base->INT_STATUS_EN |= kUSDHC_BufferWriteReadyFlag | kUSDHC_BufferReadReadyFlag;
    330                  }
    331              }
    332              else
    333              {
    334                  /* clear data flags */
    335                  mixCtrl &= ~(USDHC_MIX_CTRL_MSBSEL_MASK | USDHC_MIX_CTRL_BCEN_MASK | USDHC_MIX_CTRL_DTDSEL_MASK |
    336                               USDHC_MIX_CTRL_AC12EN_MASK | USDHC_MIX_CTRL_AC23EN_MASK);
    337          
    338                  if (base->PRES_STATE & kUSDHC_CommandInhibitFlag)
    339                  {
    340                      return kStatus_USDHC_BusyTransferring;
    341                  }
    342              }
    343          
    344              /* config the mix parameter */
    345              base->MIX_CTRL = mixCtrl;
   \                     ??USDHC_SetDataTransferConfig_13: (+1)
   \       0xD4   0x6485             STR      R5,[R0, #+72]
    346          
    347              return kStatus_Success;
   \       0xD6   0x2000             MOVS     R0,#+0
   \                     ??USDHC_SetDataTransferConfig_2: (+1)
   \       0xD8   0xBC70             POP      {R4-R6}
   \       0xDA   0x4770             BX       LR               ;; return
   \                     ??USDHC_SetDataTransferConfig_12: (+1)
   \       0xDC   0xF041 0x0130      ORR      R1,R1,#0x30
   \       0xE0   0x6381             STR      R1,[R0, #+56]
   \       0xE2   0x6B41             LDR      R1,[R0, #+52]
   \       0xE4   0xF041 0x0130      ORR      R1,R1,#0x30
   \       0xE8   0x6341             STR      R1,[R0, #+52]
   \       0xEA   0xE7F3             B.N      ??USDHC_SetDataTransferConfig_13
   \                     ??USDHC_SetDataTransferConfig_0: (+1)
   \       0xEC   0xF025 0x05B6      BIC      R5,R5,#0xB6
   \       0xF0   0x6A41             LDR      R1,[R0, #+36]
   \       0xF2   0x07C9             LSLS     R1,R1,#+31
   \       0xF4   0xD5EE             BPL.N    ??USDHC_SetDataTransferConfig_13
   \                     ??USDHC_SetDataTransferConfig_3: (+1)
   \       0xF6   0xF641 0x1064      MOVW     R0,#+6500
   \       0xFA   0xE7ED             B.N      ??USDHC_SetDataTransferConfig_2
    348          }
    349          

   \                                 In section .text, align 2, keep-with-next
    350          static status_t USDHC_ReceiveCommandResponse(USDHC_Type *base, usdhc_command_t *command)
    351          {
    352              uint32_t i;
    353          
    354              if (command->responseType != kCARD_ResponseTypeNone)
   \                     USDHC_ReceiveCommandResponse: (+1)
   \        0x0   0x7A4A             LDRB     R2,[R1, #+9]
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD021             BEQ.N    ??USDHC_ReceiveCommandResponse_0
    355              {
    356                  command->response[0U] = base->CMD_RSP0;
   \        0x6   0x6902             LDR      R2,[R0, #+16]
   \        0x8   0x60CA             STR      R2,[R1, #+12]
    357                  if (command->responseType == kCARD_ResponseTypeR2)
   \        0xA   0x7A4A             LDRB     R2,[R1, #+9]
   \        0xC   0x2A03             CMP      R2,#+3
   \        0xE   0xD11C             BNE.N    ??USDHC_ReceiveCommandResponse_0
    358                  {
    359                      command->response[1U] = base->CMD_RSP1;
   \       0x10   0x6942             LDR      R2,[R0, #+20]
   \       0x12   0x610A             STR      R2,[R1, #+16]
    360                      command->response[2U] = base->CMD_RSP2;
   \       0x14   0x6982             LDR      R2,[R0, #+24]
   \       0x16   0x614A             STR      R2,[R1, #+20]
    361                      command->response[3U] = base->CMD_RSP3;
   \       0x18   0x69C0             LDR      R0,[R0, #+28]
   \       0x1A   0x6188             STR      R0,[R1, #+24]
    362          
    363                      i = 4U;
   \       0x1C   0x2204             MOVS     R2,#+4
    364                      /* R3-R2-R1-R0(lowest 8 bit is invalid bit) has the same format as R2 format in SD specification document
    365                      after removed internal CRC7 and end bit. */
    366                      do
    367                      {
    368                          command->response[i - 1U] <<= 8U;
   \                     ??USDHC_ReceiveCommandResponse_1: (+1)
   \       0x1E   0xEB01 0x0082      ADD      R0,R1,R2, LSL #+2
   \       0x22   0x6880             LDR      R0,[R0, #+8]
   \       0x24   0x0200             LSLS     R0,R0,#+8
   \       0x26   0xEB01 0x0382      ADD      R3,R1,R2, LSL #+2
   \       0x2A   0x6098             STR      R0,[R3, #+8]
    369                          if (i > 1U)
   \       0x2C   0x2A02             CMP      R2,#+2
   \       0x2E   0xD308             BCC.N    ??USDHC_ReceiveCommandResponse_2
    370                          {
    371                              command->response[i - 1U] |= ((command->response[i - 2U] & 0xFF000000U) >> 24U);
   \       0x30   0xEB01 0x0082      ADD      R0,R1,R2, LSL #+2
   \       0x34   0x6880             LDR      R0,[R0, #+8]
   \       0x36   0x685B             LDR      R3,[R3, #+4]
   \       0x38   0xEA40 0x6013      ORR      R0,R0,R3, LSR #+24
   \       0x3C   0xEB01 0x0382      ADD      R3,R1,R2, LSL #+2
   \       0x40   0x6098             STR      R0,[R3, #+8]
    372                          }
    373                      } while (i--);
   \                     ??USDHC_ReceiveCommandResponse_2: (+1)
   \       0x42   0x4610             MOV      R0,R2
   \       0x44   0x1E42             SUBS     R2,R0,#+1
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD1E9             BNE.N    ??USDHC_ReceiveCommandResponse_1
    374                  }
    375              }
    376              /* check response error flag */
    377              if ((command->responseErrorFlags != 0U) &&
    378                  ((command->responseType == kCARD_ResponseTypeR1) || (command->responseType == kCARD_ResponseTypeR1b) ||
    379                   (command->responseType == kCARD_ResponseTypeR6) || (command->responseType == kCARD_ResponseTypeR5)))
   \                     ??USDHC_ReceiveCommandResponse_0: (+1)
   \       0x4A   0x69C8             LDR      R0,[R1, #+28]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD00F             BEQ.N    ??USDHC_ReceiveCommandResponse_3
   \       0x50   0x7A48             LDRB     R0,[R1, #+9]
   \       0x52   0x2801             CMP      R0,#+1
   \       0x54   0xD005             BEQ.N    ??USDHC_ReceiveCommandResponse_4
   \       0x56   0x2802             CMP      R0,#+2
   \       0x58   0xD003             BEQ.N    ??USDHC_ReceiveCommandResponse_4
   \       0x5A   0x2808             CMP      R0,#+8
   \       0x5C   0xD001             BEQ.N    ??USDHC_ReceiveCommandResponse_4
   \       0x5E   0x2806             CMP      R0,#+6
   \       0x60   0xD106             BNE.N    ??USDHC_ReceiveCommandResponse_3
    380              {
    381                  if (((command->responseErrorFlags) & (command->response[0U])) != 0U)
   \                     ??USDHC_ReceiveCommandResponse_4: (+1)
   \       0x62   0x69C8             LDR      R0,[R1, #+28]
   \       0x64   0x68C9             LDR      R1,[R1, #+12]
   \       0x66   0x4208             TST      R0,R1
   \       0x68   0xD002             BEQ.N    ??USDHC_ReceiveCommandResponse_3
    382                  {
    383                      return kStatus_USDHC_SendCommandFailed;
   \       0x6A   0xF641 0x1066      MOVW     R0,#+6502
   \       0x6E   0x4770             BX       LR
    384                  }
    385              }
    386          
    387              return kStatus_Success;
   \                     ??USDHC_ReceiveCommandResponse_3: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x4770             BX       LR               ;; return
    388          }
    389          

   \                                 In section .text, align 2, keep-with-next
    390          static uint32_t USDHC_ReadDataPort(USDHC_Type *base, usdhc_data_t *data, uint32_t transferredWords)
    391          {
   \                     USDHC_ReadDataPort: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    392              uint32_t i;
    393              uint32_t totalWords;
    394              uint32_t wordsCanBeRead; /* The words can be read at this time. */
    395              uint32_t readWatermark = ((base->WTMK_LVL & USDHC_WTMK_LVL_RD_WML_MASK) >> USDHC_WTMK_LVL_RD_WML_SHIFT);
   \        0xA   0x6C67             LDR      R7,[R4, #+68]
   \        0xC   0xF007 0x07FF      AND      R7,R7,#0xFF
    396          
    397              /* If DMA is enable, do not need to polling data port */
    398              if ((base->MIX_CTRL & USDHC_MIX_CTRL_DMAEN_MASK) == 0U)
   \       0x10   0x6CA0             LDR      R0,[R4, #+72]
   \       0x12   0x07C0             LSLS     R0,R0,#+31
   \       0x14   0xD428             BMI.N    ??USDHC_ReadDataPort_0
    399              {
    400                  /*
    401                   * Add non aligned access support ,user need make sure your buffer size is big
    402                   * enough to hold the data,in other words,user need make sure the buffer size
    403                   * is 4 byte aligned
    404                   */
    405                  if (data->blockSize % sizeof(uint32_t) != 0U)
   \       0x16   0x7928             LDRB     R0,[R5, #+4]
   \       0x18   0xF010 0x0F03      TST      R0,#0x3
   \       0x1C   0xD006             BEQ.N    ??USDHC_ReadDataPort_1
    406                  {
    407                      data->blockSize +=
    408                          sizeof(uint32_t) - (data->blockSize % sizeof(uint32_t)); /* make the block size as word-aligned */
   \       0x1E   0x6868             LDR      R0,[R5, #+4]
   \       0x20   0x1D00             ADDS     R0,R0,#+4
   \       0x22   0x7929             LDRB     R1,[R5, #+4]
   \       0x24   0xF001 0x0103      AND      R1,R1,#0x3
   \       0x28   0x1A40             SUBS     R0,R0,R1
   \       0x2A   0x6068             STR      R0,[R5, #+4]
    409                  }
    410          
    411                  totalWords = ((data->blockCount * data->blockSize) / sizeof(uint32_t));
   \                     ??USDHC_ReadDataPort_1: (+1)
   \       0x2C   0x68A9             LDR      R1,[R5, #+8]
   \       0x2E   0x6868             LDR      R0,[R5, #+4]
   \       0x30   0x4341             MULS     R1,R0,R1
   \       0x32   0x0889             LSRS     R1,R1,#+2
    412          
    413                  /* If watermark level is equal or bigger than totalWords, transfers totalWords data. */
    414                  if (readWatermark >= totalWords)
   \       0x34   0x428F             CMP      R7,R1
   \       0x36   0xD301             BCC.N    ??USDHC_ReadDataPort_2
    415                  {
    416                      wordsCanBeRead = totalWords;
   \       0x38   0x460F             MOV      R7,R1
   \       0x3A   0xE007             B.N      ??USDHC_ReadDataPort_3
    417                  }
    418                  /* If watermark level is less than totalWords and left words to be sent is equal or bigger than readWatermark,
    419                  transfers watermark level words. */
    420                  else if ((readWatermark < totalWords) && ((totalWords - transferredWords) >= readWatermark))
   \                     ??USDHC_ReadDataPort_2: (+1)
   \       0x3C   0xD204             BCS.N    ??USDHC_ReadDataPort_4
   \       0x3E   0x1B89             SUBS     R1,R1,R6
   \       0x40   0x428F             CMP      R7,R1
   \       0x42   0xD903             BLS.N    ??USDHC_ReadDataPort_3
   \       0x44   0x460F             MOV      R7,R1
   \       0x46   0xE001             B.N      ??USDHC_ReadDataPort_3
    421                  {
    422                      wordsCanBeRead = readWatermark;
    423                  }
    424                  /* If watermark level is less than totalWords and left words to be sent is less than readWatermark, transfers
    425                  left
    426                  words. */
    427                  else
    428                  {
    429                      wordsCanBeRead = (totalWords - transferredWords);
   \                     ??USDHC_ReadDataPort_4: (+1)
   \       0x48   0x460F             MOV      R7,R1
   \       0x4A   0x1BBF             SUBS     R7,R7,R6
    430                  }
    431          
    432                  i = 0U;
   \                     ??USDHC_ReadDataPort_3: (+1)
   \       0x4C   0xF04F 0x0800      MOV      R8,#+0
   \       0x50   0xE008             B.N      ??USDHC_ReadDataPort_5
    433                  while (i < wordsCanBeRead)
    434                  {
    435                      data->rxData[transferredWords++] = USDHC_ReadData(base);
   \                     ??USDHC_ReadDataPort_6: (+1)
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x....'....        BL       USDHC_ReadData
   \       0x58   0x68E9             LDR      R1,[R5, #+12]
   \       0x5A   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   \       0x5E   0x1C76             ADDS     R6,R6,#+1
    436                      i++;
   \       0x60   0xF108 0x0801      ADD      R8,R8,#+1
    437                  }
   \                     ??USDHC_ReadDataPort_5: (+1)
   \       0x64   0x45B8             CMP      R8,R7
   \       0x66   0xD3F4             BCC.N    ??USDHC_ReadDataPort_6
    438              }
    439          
    440              return transferredWords;
   \                     ??USDHC_ReadDataPort_0: (+1)
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    441          }
    442          

   \                                 In section .text, align 2, keep-with-next
    443          static status_t USDHC_ReadByDataPortBlocking(USDHC_Type *base, usdhc_data_t *data)
    444          {
   \                     USDHC_ReadByDataPortBlocking: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
    445              uint32_t totalWords;
    446              uint32_t transferredWords = 0U, interruptStatus = 0U;
   \        0x8   0x2700             MOVS     R7,#+0
   \        0xA   0x46B8             MOV      R8,R7
    447              status_t error = kStatus_Success;
   \        0xC   0x463C             MOV      R4,R7
    448          
    449              /*
    450               * Add non aligned access support ,user need make sure your buffer size is big
    451               * enough to hold the data,in other words,user need make sure the buffer size
    452               * is 4 byte aligned
    453               */
    454              if (data->blockSize % sizeof(uint32_t) != 0U)
   \        0xE   0x7930             LDRB     R0,[R6, #+4]
   \       0x10   0xF010 0x0F03      TST      R0,#0x3
   \       0x14   0xD006             BEQ.N    ??USDHC_ReadByDataPortBlocking_0
    455              {
    456                  data->blockSize +=
    457                      sizeof(uint32_t) - (data->blockSize % sizeof(uint32_t)); /* make the block size as word-aligned */
   \       0x16   0x6870             LDR      R0,[R6, #+4]
   \       0x18   0x1D00             ADDS     R0,R0,#+4
   \       0x1A   0x7931             LDRB     R1,[R6, #+4]
   \       0x1C   0xF001 0x0103      AND      R1,R1,#0x3
   \       0x20   0x1A40             SUBS     R0,R0,R1
   \       0x22   0x6070             STR      R0,[R6, #+4]
    458              }
    459          
    460              totalWords = ((data->blockCount * data->blockSize) / sizeof(uint32_t));
   \                     ??USDHC_ReadByDataPortBlocking_0: (+1)
   \       0x24   0xF8D6 0x9008      LDR      R9,[R6, #+8]
   \       0x28   0x6870             LDR      R0,[R6, #+4]
   \       0x2A   0xFB00 0xF909      MUL      R9,R0,R9
   \       0x2E   0xE019             B.N      ??USDHC_ReadByDataPortBlocking_1
    461          
    462              while ((error == kStatus_Success) && (transferredWords < totalWords))
    463              {
    464                  while (!(interruptStatus & (kUSDHC_BufferReadReadyFlag | kUSDHC_DataErrorFlag | kUSDHC_TuningErrorFlag)))
    465                  {
    466                      interruptStatus = USDHC_GetInterruptStatusFlags(base);
    467                  }
    468          
    469                  /* during std tuning process, software do not need to read data, but wait BRR is enough */
    470                  if ((data->dataType == kUSDHC_TransferDataTuning) && (interruptStatus & kUSDHC_BufferReadReadyFlag))
    471                  {
    472                      USDHC_ClearInterruptStatusFlags(base, kUSDHC_BufferReadReadyFlag | kUSDHC_TuningPassFlag);
    473          
    474                      return kStatus_Success;
    475                  }
    476                  else if ((interruptStatus & kUSDHC_TuningErrorFlag) != 0U)
    477                  {
    478                      USDHC_ClearInterruptStatusFlags(base, kUSDHC_TuningErrorFlag);
    479                      /* if tuning error occur ,return directly */
    480                      error = kStatus_USDHC_TuningError;
    481                  }
    482                  else if ((interruptStatus & kUSDHC_DataErrorFlag) != 0U)
   \                     ??USDHC_ReadByDataPortBlocking_2: (+1)
   \       0x30   0xF018 0x7FB8      TST      R8,#0x1700000
   \       0x34   0xD008             BEQ.N    ??USDHC_ReadByDataPortBlocking_3
    483                  {
    484                      if (!(data->enableIgnoreError))
   \       0x36   0x78B0             LDRB     R0,[R6, #+2]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD100             BNE.N    ??USDHC_ReadByDataPortBlocking_4
    485                      {
    486                          error = kStatus_Fail;
   \       0x3C   0x2401             MOVS     R4,#+1
    487                      }
    488                      /* clear data error flag */
    489                      USDHC_ClearInterruptStatusFlags(base, kUSDHC_DataErrorFlag);
   \                     ??USDHC_ReadByDataPortBlocking_4: (+1)
   \       0x3E   0xF04F 0x71B8      MOV      R1,#+24117248
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0x....'....        BL       USDHC_ClearInterruptStatusFlags
    490                  }
    491                  else
    492                  {
    493                  }
    494          
    495                  if (error == kStatus_Success)
   \                     ??USDHC_ReadByDataPortBlocking_3: (+1)
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD10B             BNE.N    ??USDHC_ReadByDataPortBlocking_1
    496                  {
    497                      transferredWords = USDHC_ReadDataPort(base, data, transferredWords);
   \       0x4C   0x463A             MOV      R2,R7
   \       0x4E   0x4631             MOV      R1,R6
   \       0x50   0x4628             MOV      R0,R5
   \       0x52   0x....'....        BL       USDHC_ReadDataPort
   \       0x56   0x4607             MOV      R7,R0
    498                      /* clear buffer read ready */
    499                      USDHC_ClearInterruptStatusFlags(base, kUSDHC_BufferReadReadyFlag);
   \       0x58   0x2120             MOVS     R1,#+32
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0x....'....        BL       USDHC_ClearInterruptStatusFlags
    500                      interruptStatus = 0U;
   \       0x60   0xF04F 0x0800      MOV      R8,#+0
    501                  }
   \                     ??USDHC_ReadByDataPortBlocking_1: (+1)
   \       0x64   0x2C00             CMP      R4,#+0
   \       0x66   0xD102             BNE.N    ??USDHC_ReadByDataPortBlocking_5
   \       0x68   0xEBB7 0x0F99      CMP      R7,R9, LSR #+2
   \       0x6C   0xD30A             BCC.N    ??USDHC_ReadByDataPortBlocking_6
    502              }
    503          
    504              /* Clear data complete flag after the last read operation. */
    505              USDHC_ClearInterruptStatusFlags(base, kUSDHC_DataCompleteFlag);
   \                     ??USDHC_ReadByDataPortBlocking_5: (+1)
   \       0x6E   0x2102             MOVS     R1,#+2
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x....'....        BL       USDHC_ClearInterruptStatusFlags
    506          
    507              return error;
   \       0x76   0x4620             MOV      R0,R4
   \                     ??USDHC_ReadByDataPortBlocking_7: (+1)
   \       0x78   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??USDHC_ReadByDataPortBlocking_8: (+1)
   \       0x7C   0x4628             MOV      R0,R5
   \       0x7E   0x....'....        BL       USDHC_GetInterruptStatusFlags
   \       0x82   0x4680             MOV      R8,R0
   \                     ??USDHC_ReadByDataPortBlocking_6: (+1)
   \       0x84   0x....'....        LDR.W    R0,??DataTable20  ;; 0x5700020
   \       0x88   0xEA18 0x0F00      TST      R8,R0
   \       0x8C   0xD0F6             BEQ.N    ??USDHC_ReadByDataPortBlocking_8
   \       0x8E   0x78F0             LDRB     R0,[R6, #+3]
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD109             BNE.N    ??USDHC_ReadByDataPortBlocking_9
   \       0x94   0xEA5F 0x6088      LSLS     R0,R8,#+26
   \       0x98   0xD506             BPL.N    ??USDHC_ReadByDataPortBlocking_9
   \       0x9A   0xF244 0x0120      MOVW     R1,#+16416
   \       0x9E   0x4628             MOV      R0,R5
   \       0xA0   0x....'....        BL       USDHC_ClearInterruptStatusFlags
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0xE7E7             B.N      ??USDHC_ReadByDataPortBlocking_7
   \                     ??USDHC_ReadByDataPortBlocking_9: (+1)
   \       0xA8   0xEA5F 0x1048      LSLS     R0,R8,#+5
   \       0xAC   0xD5C0             BPL.N    ??USDHC_ReadByDataPortBlocking_2
   \       0xAE   0xF04F 0x6180      MOV      R1,#+67108864
   \       0xB2   0x4628             MOV      R0,R5
   \       0xB4   0x....'....        BL       USDHC_ClearInterruptStatusFlags
   \       0xB8   0xF641 0x106A      MOVW     R0,#+6506
   \       0xBC   0x4604             MOV      R4,R0
   \       0xBE   0xE7C3             B.N      ??USDHC_ReadByDataPortBlocking_3
    508          }
    509          

   \                                 In section .text, align 2, keep-with-next
    510          static uint32_t USDHC_WriteDataPort(USDHC_Type *base, usdhc_data_t *data, uint32_t transferredWords)
    511          {
   \                     USDHC_WriteDataPort: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    512              uint32_t i;
    513              uint32_t totalWords;
    514              uint32_t wordsCanBeWrote; /* Words can be wrote at this time. */
    515              uint32_t writeWatermark = ((base->WTMK_LVL & USDHC_WTMK_LVL_WR_WML_MASK) >> USDHC_WTMK_LVL_WR_WML_SHIFT);
   \        0xA   0x6C60             LDR      R0,[R4, #+68]
   \        0xC   0xF3C0 0x4707      UBFX     R7,R0,#+16,#+8
    516          
    517              /* If DMA is enable, do not need to polling data port */
    518              if ((base->MIX_CTRL & USDHC_MIX_CTRL_DMAEN_MASK) == 0U)
   \       0x10   0x6CA0             LDR      R0,[R4, #+72]
   \       0x12   0x07C0             LSLS     R0,R0,#+31
   \       0x14   0xD428             BMI.N    ??USDHC_WriteDataPort_0
    519              {
    520                  /*
    521                   * Add non aligned access support ,user need make sure your buffer size is big
    522                   * enough to hold the data,in other words,user need make sure the buffer size
    523                   * is 4 byte aligned
    524                   */
    525                  if (data->blockSize % sizeof(uint32_t) != 0U)
   \       0x16   0x7928             LDRB     R0,[R5, #+4]
   \       0x18   0xF010 0x0F03      TST      R0,#0x3
   \       0x1C   0xD006             BEQ.N    ??USDHC_WriteDataPort_1
    526                  {
    527                      data->blockSize +=
    528                          sizeof(uint32_t) - (data->blockSize % sizeof(uint32_t)); /* make the block size as word-aligned */
   \       0x1E   0x6868             LDR      R0,[R5, #+4]
   \       0x20   0x1D00             ADDS     R0,R0,#+4
   \       0x22   0x7929             LDRB     R1,[R5, #+4]
   \       0x24   0xF001 0x0103      AND      R1,R1,#0x3
   \       0x28   0x1A40             SUBS     R0,R0,R1
   \       0x2A   0x6068             STR      R0,[R5, #+4]
    529                  }
    530          
    531                  totalWords = ((data->blockCount * data->blockSize) / sizeof(uint32_t));
   \                     ??USDHC_WriteDataPort_1: (+1)
   \       0x2C   0x68A9             LDR      R1,[R5, #+8]
   \       0x2E   0x6868             LDR      R0,[R5, #+4]
   \       0x30   0x4341             MULS     R1,R0,R1
   \       0x32   0x0889             LSRS     R1,R1,#+2
    532          
    533                  /* If watermark level is equal or bigger than totalWords, transfers totalWords data.*/
    534                  if (writeWatermark >= totalWords)
   \       0x34   0x428F             CMP      R7,R1
   \       0x36   0xD301             BCC.N    ??USDHC_WriteDataPort_2
    535                  {
    536                      wordsCanBeWrote = totalWords;
   \       0x38   0x460F             MOV      R7,R1
   \       0x3A   0xE007             B.N      ??USDHC_WriteDataPort_3
    537                  }
    538                  /* If watermark level is less than totalWords and left words to be sent is equal or bigger than watermark,
    539                  transfers watermark level words. */
    540                  else if ((writeWatermark < totalWords) && ((totalWords - transferredWords) >= writeWatermark))
   \                     ??USDHC_WriteDataPort_2: (+1)
   \       0x3C   0xD204             BCS.N    ??USDHC_WriteDataPort_4
   \       0x3E   0x1B89             SUBS     R1,R1,R6
   \       0x40   0x428F             CMP      R7,R1
   \       0x42   0xD903             BLS.N    ??USDHC_WriteDataPort_3
   \       0x44   0x460F             MOV      R7,R1
   \       0x46   0xE001             B.N      ??USDHC_WriteDataPort_3
    541                  {
    542                      wordsCanBeWrote = writeWatermark;
    543                  }
    544                  /* If watermark level is less than totalWords and left words to be sent is less than watermark, transfers left
    545                  words. */
    546                  else
    547                  {
    548                      wordsCanBeWrote = (totalWords - transferredWords);
   \                     ??USDHC_WriteDataPort_4: (+1)
   \       0x48   0x460F             MOV      R7,R1
   \       0x4A   0x1BBF             SUBS     R7,R7,R6
    549                  }
    550          
    551                  i = 0U;
   \                     ??USDHC_WriteDataPort_3: (+1)
   \       0x4C   0xF04F 0x0800      MOV      R8,#+0
   \       0x50   0xE008             B.N      ??USDHC_WriteDataPort_5
    552                  while (i < wordsCanBeWrote)
    553                  {
    554                      USDHC_WriteData(base, data->txData[transferredWords++]);
   \                     ??USDHC_WriteDataPort_6: (+1)
   \       0x52   0x6928             LDR      R0,[R5, #+16]
   \       0x54   0xF850 0x1026      LDR      R1,[R0, R6, LSL #+2]
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x....'....        BL       USDHC_WriteData
   \       0x5E   0x1C76             ADDS     R6,R6,#+1
    555                      i++;
   \       0x60   0xF108 0x0801      ADD      R8,R8,#+1
    556                  }
   \                     ??USDHC_WriteDataPort_5: (+1)
   \       0x64   0x45B8             CMP      R8,R7
   \       0x66   0xD3F4             BCC.N    ??USDHC_WriteDataPort_6
    557              }
    558          
    559              return transferredWords;
   \                     ??USDHC_WriteDataPort_0: (+1)
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    560          }
    561          

   \                                 In section .text, align 2, keep-with-next
    562          static status_t USDHC_WriteByDataPortBlocking(USDHC_Type *base, usdhc_data_t *data)
    563          {
   \                     USDHC_WriteByDataPortBlocking: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
    564              uint32_t totalWords;
    565          
    566              uint32_t transferredWords = 0U, interruptStatus = 0U;
   \        0x8   0xF04F 0x0800      MOV      R8,#+0
   \        0xC   0x4647             MOV      R7,R8
    567              status_t error = kStatus_Success;
   \        0xE   0x463C             MOV      R4,R7
    568          
    569              /*
    570               * Add non aligned access support ,user need make sure your buffer size is big
    571               * enough to hold the data,in other words,user need make sure the buffer size
    572               * is 4 byte aligned
    573               */
    574              if (data->blockSize % sizeof(uint32_t) != 0U)
   \       0x10   0x7930             LDRB     R0,[R6, #+4]
   \       0x12   0xF010 0x0F03      TST      R0,#0x3
   \       0x16   0xD006             BEQ.N    ??USDHC_WriteByDataPortBlocking_0
    575              {
    576                  data->blockSize +=
    577                      sizeof(uint32_t) - (data->blockSize % sizeof(uint32_t)); /* make the block size as word-aligned */
   \       0x18   0x6870             LDR      R0,[R6, #+4]
   \       0x1A   0x1D00             ADDS     R0,R0,#+4
   \       0x1C   0x7931             LDRB     R1,[R6, #+4]
   \       0x1E   0xF001 0x0103      AND      R1,R1,#0x3
   \       0x22   0x1A40             SUBS     R0,R0,R1
   \       0x24   0x6070             STR      R0,[R6, #+4]
    578              }
    579          
    580              totalWords = (data->blockCount * data->blockSize) / sizeof(uint32_t);
   \                     ??USDHC_WriteByDataPortBlocking_0: (+1)
   \       0x26   0xF8D6 0x9008      LDR      R9,[R6, #+8]
   \       0x2A   0x6870             LDR      R0,[R6, #+4]
   \       0x2C   0xFB00 0xF909      MUL      R9,R0,R9
   \       0x30   0xE018             B.N      ??USDHC_WriteByDataPortBlocking_1
    581          
    582              while ((error == kStatus_Success) && (transferredWords < totalWords))
    583              {
    584                  while (!(interruptStatus & (kUSDHC_BufferWriteReadyFlag | kUSDHC_DataErrorFlag | kUSDHC_TuningErrorFlag)))
    585                  {
    586                      interruptStatus = USDHC_GetInterruptStatusFlags(base);
    587                  }
    588          
    589                  if ((interruptStatus & kUSDHC_TuningErrorFlag) != 0U)
    590                  {
    591                      USDHC_ClearInterruptStatusFlags(base, kUSDHC_TuningErrorFlag);
    592                      /* if tuning error occur ,return directly */
    593                      return kStatus_USDHC_TuningError;
    594                  }
    595                  else if ((interruptStatus & kUSDHC_DataErrorFlag) != 0U)
   \                     ??USDHC_WriteByDataPortBlocking_2: (+1)
   \       0x32   0xF017 0x7FB8      TST      R7,#0x1700000
   \       0x36   0xD008             BEQ.N    ??USDHC_WriteByDataPortBlocking_3
    596                  {
    597                      if (!(data->enableIgnoreError))
   \       0x38   0x78B0             LDRB     R0,[R6, #+2]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD100             BNE.N    ??USDHC_WriteByDataPortBlocking_4
    598                      {
    599                          error = kStatus_Fail;
   \       0x3E   0x2401             MOVS     R4,#+1
    600                      }
    601                      /* clear data error flag */
    602                      USDHC_ClearInterruptStatusFlags(base, kUSDHC_DataErrorFlag);
   \                     ??USDHC_WriteByDataPortBlocking_4: (+1)
   \       0x40   0xF04F 0x71B8      MOV      R1,#+24117248
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x....'....        BL       USDHC_ClearInterruptStatusFlags
    603                  }
    604                  else
    605                  {
    606                  }
    607          
    608                  if (error == kStatus_Success)
   \                     ??USDHC_WriteByDataPortBlocking_3: (+1)
   \       0x4A   0x2C00             CMP      R4,#+0
   \       0x4C   0xD10A             BNE.N    ??USDHC_WriteByDataPortBlocking_1
    609                  {
    610                      transferredWords = USDHC_WriteDataPort(base, data, transferredWords);
   \       0x4E   0x4642             MOV      R2,R8
   \       0x50   0x4631             MOV      R1,R6
   \       0x52   0x4628             MOV      R0,R5
   \       0x54   0x....'....        BL       USDHC_WriteDataPort
   \       0x58   0x4680             MOV      R8,R0
    611                      /* clear buffer write ready */
    612                      USDHC_ClearInterruptStatusFlags(base, kUSDHC_BufferWriteReadyFlag);
   \       0x5A   0x2110             MOVS     R1,#+16
   \       0x5C   0x4628             MOV      R0,R5
   \       0x5E   0x....'....        BL       USDHC_ClearInterruptStatusFlags
    613                      interruptStatus = 0U;
   \       0x62   0x2700             MOVS     R7,#+0
    614                  }
   \                     ??USDHC_WriteByDataPortBlocking_1: (+1)
   \       0x64   0x2C00             CMP      R4,#+0
   \       0x66   0xD119             BNE.N    ??USDHC_WriteByDataPortBlocking_5
   \       0x68   0xEBB8 0x0F99      CMP      R8,R9, LSR #+2
   \       0x6C   0xD216             BCS.N    ??USDHC_WriteByDataPortBlocking_5
   \       0x6E   0xE003             B.N      ??USDHC_WriteByDataPortBlocking_6
   \                     ??USDHC_WriteByDataPortBlocking_7: (+1)
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x....'....        BL       USDHC_GetInterruptStatusFlags
   \       0x76   0x4607             MOV      R7,R0
   \                     ??USDHC_WriteByDataPortBlocking_6: (+1)
   \       0x78   0x....'....        LDR.W    R0,??DataTable21  ;; 0x5700010
   \       0x7C   0x4207             TST      R7,R0
   \       0x7E   0xD0F7             BEQ.N    ??USDHC_WriteByDataPortBlocking_7
   \       0x80   0x0178             LSLS     R0,R7,#+5
   \       0x82   0xD5D6             BPL.N    ??USDHC_WriteByDataPortBlocking_2
   \       0x84   0xF04F 0x6180      MOV      R1,#+67108864
   \       0x88   0x4628             MOV      R0,R5
   \       0x8A   0x....'....        BL       USDHC_ClearInterruptStatusFlags
   \       0x8E   0xF641 0x106A      MOVW     R0,#+6506
   \       0x92   0xE013             B.N      ??USDHC_WriteByDataPortBlocking_8
    615              }
    616          
    617              /* Wait write data complete or data transfer error after the last writing operation. */
    618              while (!(interruptStatus & (kUSDHC_DataCompleteFlag | kUSDHC_DataErrorFlag)))
    619              {
    620                  interruptStatus = USDHC_GetInterruptStatusFlags(base);
   \                     ??USDHC_WriteByDataPortBlocking_9: (+1)
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0x....'....        BL       USDHC_GetInterruptStatusFlags
   \       0x9A   0x4607             MOV      R7,R0
    621              }
   \                     ??USDHC_WriteByDataPortBlocking_5: (+1)
   \       0x9C   0x....'....        LDR.W    R1,??DataTable22  ;; 0x1700002
   \       0xA0   0x420F             TST      R7,R1
   \       0xA2   0xD0F7             BEQ.N    ??USDHC_WriteByDataPortBlocking_9
    622          
    623              if ((interruptStatus & kUSDHC_DataErrorFlag) != 0U)
   \       0xA4   0xF017 0x7FB8      TST      R7,#0x1700000
   \       0xA8   0xD004             BEQ.N    ??USDHC_WriteByDataPortBlocking_10
    624              {
    625                  if (!(data->enableIgnoreError))
   \       0xAA   0x78B0             LDRB     R0,[R6, #+2]
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD101             BNE.N    ??USDHC_WriteByDataPortBlocking_10
    626                  {
    627                      error = kStatus_Fail;
   \       0xB0   0x2001             MOVS     R0,#+1
   \       0xB2   0x4604             MOV      R4,R0
    628                  }
    629              }
    630              USDHC_ClearInterruptStatusFlags(base, (kUSDHC_DataCompleteFlag | kUSDHC_DataErrorFlag));
   \                     ??USDHC_WriteByDataPortBlocking_10: (+1)
   \       0xB4   0x4628             MOV      R0,R5
   \       0xB6   0x....'....        BL       USDHC_ClearInterruptStatusFlags
    631          
    632              return error;
   \       0xBA   0x4620             MOV      R0,R4
   \                     ??USDHC_WriteByDataPortBlocking_8: (+1)
   \       0xBC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    633          }
    634          
    635          /*!
    636           * brief send command function
    637           *
    638           * param base USDHC peripheral base address.
    639           * param command configuration
    640           */

   \                                 In section .text, align 4, keep-with-next
    641          void USDHC_SendCommand(USDHC_Type *base, usdhc_command_t *command)
    642          {
   \                     USDHC_SendCommand: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    643              assert(NULL != command);
   \        0x6   0xD109             BNE.N    ??USDHC_SendCommand_1
   \        0x8   0xF240 0x2283      MOVW     R2,#+643
   \        0xC   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x10   0x....'....        LDR.W    R0,??DataTable21_1
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
    644          
    645              uint32_t xferType = base->CMD_XFR_TYP, flags = command->flags;
   \                     ??USDHC_SendCommand_1: (+1)
   \       0x1C   0x68E9             LDR      R1,[R5, #+12]
   \       0x1E   0x6A22             LDR      R2,[R4, #+32]
    646          
    647              if (((base->PRES_STATE & kUSDHC_CommandInhibitFlag) == 0U) && (command->type != kCARD_CommandTypeEmpty))
   \       0x20   0x6A68             LDR      R0,[R5, #+36]
   \       0x22   0x07C0             LSLS     R0,R0,#+31
   \       0x24   0xD42B             BMI.N    ??USDHC_SendCommand_2
   \       0x26   0x7A20             LDRB     R0,[R4, #+8]
   \       0x28   0x2804             CMP      R0,#+4
   \       0x2A   0xD028             BEQ.N    ??USDHC_SendCommand_2
    648              {
    649                  /* Define the flag corresponding to each response type. */
    650                  switch (command->responseType)
   \       0x2C   0x7A60             LDRB     R0,[R4, #+9]
   \       0x2E   0x1E40             SUBS     R0,R0,#+1
   \       0x30   0x2808             CMP      R0,#+8
   \       0x32   0xD811             BHI.N    ??USDHC_SendCommand_3
   \       0x34   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USDHC_SendCommand_0:
   \       0x38   0x05 0x08          DC8      0x5,0x8,0xB,0xE
   \              0x0B 0x0E    
   \       0x3C   0x0E 0x05          DC8      0xE,0x5,0x8,0x5
   \              0x08 0x05    
   \       0x40   0x05 0x00          DC8      0x5,0x0
    651                  {
    652                      case kCARD_ResponseTypeNone:
    653                          break;
    654                      case kCARD_ResponseTypeR1: /* Response 1 */
    655                      case kCARD_ResponseTypeR5: /* Response 5 */
    656                      case kCARD_ResponseTypeR6: /* Response 6 */
    657                      case kCARD_ResponseTypeR7: /* Response 7 */
    658                          flags |= (kUSDHC_ResponseLength48Flag | kUSDHC_EnableCrcCheckFlag | kUSDHC_EnableIndexCheckFlag);
   \                     ??USDHC_SendCommand_4: (+1)
   \       0x42   0xF442 0x12D0      ORR      R2,R2,#0x1A0000
    659                          break;
   \       0x46   0xE007             B.N      ??USDHC_SendCommand_3
    660          
    661                      case kCARD_ResponseTypeR1b: /* Response 1 with busy */
    662                      case kCARD_ResponseTypeR5b: /* Response 5 with busy */
    663                          flags |= (kUSDHC_ResponseLength48BusyFlag | kUSDHC_EnableCrcCheckFlag | kUSDHC_EnableIndexCheckFlag);
   \                     ??USDHC_SendCommand_5: (+1)
   \       0x48   0xF442 0x12D8      ORR      R2,R2,#0x1B0000
    664                          break;
   \       0x4C   0xE004             B.N      ??USDHC_SendCommand_3
    665          
    666                      case kCARD_ResponseTypeR2: /* Response 2 */
    667                          flags |= (kUSDHC_ResponseLength136Flag | kUSDHC_EnableCrcCheckFlag);
   \                     ??USDHC_SendCommand_6: (+1)
   \       0x4E   0xF442 0x2210      ORR      R2,R2,#0x90000
    668                          break;
   \       0x52   0xE001             B.N      ??USDHC_SendCommand_3
    669          
    670                      case kCARD_ResponseTypeR3: /* Response 3 */
    671                      case kCARD_ResponseTypeR4: /* Response 4 */
    672                          flags |= (kUSDHC_ResponseLength48Flag);
   \                     ??USDHC_SendCommand_7: (+1)
   \       0x54   0xF442 0x3200      ORR      R2,R2,#0x20000
    673                          break;
    674          
    675                      default:
    676                          break;
    677                  }
    678          
    679                  if (command->type == kCARD_CommandTypeAbort)
   \                     ??USDHC_SendCommand_3: (+1)
   \       0x58   0x7A20             LDRB     R0,[R4, #+8]
   \       0x5A   0x2803             CMP      R0,#+3
   \       0x5C   0xD101             BNE.N    ??USDHC_SendCommand_8
    680                  {
    681                      flags |= kUSDHC_CommandTypeAbortFlag;
   \       0x5E   0xF442 0x0240      ORR      R2,R2,#0xC00000
    682                  }
    683          
    684                  /* config cmd index */
    685                  xferType &= ~(USDHC_CMD_XFR_TYP_CMDINX_MASK | USDHC_CMD_XFR_TYP_CMDTYP_MASK | USDHC_CMD_XFR_TYP_CICEN_MASK |
    686                                USDHC_CMD_XFR_TYP_CCCEN_MASK | USDHC_CMD_XFR_TYP_RSPTYP_MASK | USDHC_CMD_XFR_TYP_DPSEL_MASK);
    687          
    688                  xferType |=
    689                      (((command->index << USDHC_CMD_XFR_TYP_CMDINX_SHIFT) & USDHC_CMD_XFR_TYP_CMDINX_MASK) |
    690                       ((flags) & (USDHC_CMD_XFR_TYP_CMDTYP_MASK | USDHC_CMD_XFR_TYP_CICEN_MASK | USDHC_CMD_XFR_TYP_CCCEN_MASK |
    691                                   USDHC_CMD_XFR_TYP_RSPTYP_MASK | USDHC_CMD_XFR_TYP_DPSEL_MASK)));
   \                     ??USDHC_SendCommand_8: (+1)
   \       0x62   0x....'....        LDR.W    R0,??DataTable22_1  ;; 0xc004ffff
   \       0x66   0x4001             ANDS     R1,R0,R1
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x0600             LSLS     R0,R0,#+24
   \       0x6C   0xF000 0x507C      AND      R0,R0,#0x3F000000
   \       0x70   0x4301             ORRS     R1,R0,R1
   \       0x72   0xF402 0x027B      AND      R2,R2,#0xFB0000
   \       0x76   0x4311             ORRS     R1,R2,R1
    692          
    693                  /* config the command xfertype and argument */
    694                  base->CMD_ARG = command->argument;
   \       0x78   0x6860             LDR      R0,[R4, #+4]
   \       0x7A   0x60A8             STR      R0,[R5, #+8]
    695                  base->CMD_XFR_TYP = xferType;
   \       0x7C   0x60E9             STR      R1,[R5, #+12]
    696              }
    697          
    698              if (command->type == kCARD_CommandTypeEmpty)
   \                     ??USDHC_SendCommand_2: (+1)
   \       0x7E   0x7A20             LDRB     R0,[R4, #+8]
   \       0x80   0x2804             CMP      R0,#+4
   \       0x82   0xD103             BNE.N    ??USDHC_SendCommand_9
    699              {
    700                  /* disable CMD done interrupt for empty command */
    701                  base->INT_SIGNAL_EN &= ~USDHC_INT_SIGNAL_EN_CCIEN_MASK;
   \       0x84   0x6BA8             LDR      R0,[R5, #+56]
   \       0x86   0x0840             LSRS     R0,R0,#+1
   \       0x88   0x0040             LSLS     R0,R0,#+1
   \       0x8A   0x63A8             STR      R0,[R5, #+56]
    702              }
    703          }
   \                     ??USDHC_SendCommand_9: (+1)
   \       0x8C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    704          

   \                                 In section .text, align 2, keep-with-next
    705          static status_t USDHC_WaitCommandDone(USDHC_Type *base, usdhc_command_t *command, bool pollingCmdDone)
    706          {
   \                     USDHC_WaitCommandDone: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4617             MOV      R7,R2
    707              assert(NULL != command);
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD109             BNE.N    ??USDHC_WaitCommandDone_0
   \        0xC   0xF240 0x22C3      MOVW     R2,#+707
   \       0x10   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x14   0x....'....        LDR.W    R0,??DataTable21_1
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
    708          
    709              status_t error = kStatus_Success;
   \                     ??USDHC_WaitCommandDone_0: (+1)
   \       0x20   0x2400             MOVS     R4,#+0
    710              uint32_t interruptStatus = 0U;
   \       0x22   0x4620             MOV      R0,R4
    711              /* check if need polling command done or not */
    712              if (pollingCmdDone)
   \       0x24   0x2F00             CMP      R7,#+0
   \       0x26   0xD103             BNE.N    ??USDHC_WaitCommandDone_1
   \       0x28   0xE01B             B.N      ??USDHC_WaitCommandDone_2
    713              {
    714                  /* Wait command complete or USDHC encounters error. */
    715                  while (!(interruptStatus & (kUSDHC_CommandCompleteFlag | kUSDHC_CommandErrorFlag)))
    716                  {
    717                      interruptStatus = USDHC_GetInterruptStatusFlags(base);
   \                     ??USDHC_WaitCommandDone_3: (+1)
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x....'....        BL       USDHC_GetInterruptStatusFlags
    718                  }
   \                     ??USDHC_WaitCommandDone_1: (+1)
   \       0x30   0x....'....        LDR.W    R1,??DataTable22_2  ;; 0xf0001
   \       0x34   0x4208             TST      R0,R1
   \       0x36   0xD0F8             BEQ.N    ??USDHC_WaitCommandDone_3
    719          
    720                  if ((interruptStatus & kUSDHC_TuningErrorFlag) != 0U)
   \       0x38   0x0141             LSLS     R1,R0,#+5
   \       0x3A   0xD502             BPL.N    ??USDHC_WaitCommandDone_4
    721                  {
    722                      error = kStatus_USDHC_TuningError;
   \       0x3C   0xF641 0x146A      MOVW     R4,#+6506
   \       0x40   0xE003             B.N      ??USDHC_WaitCommandDone_5
    723                  }
    724                  else if ((interruptStatus & kUSDHC_CommandErrorFlag) != 0U)
   \                     ??USDHC_WaitCommandDone_4: (+1)
   \       0x42   0xF410 0x2F70      TST      R0,#0xF0000
   \       0x46   0xD000             BEQ.N    ??USDHC_WaitCommandDone_5
    725                  {
    726                      error = kStatus_Fail;
   \       0x48   0x2401             MOVS     R4,#+1
    727                  }
    728                  else
    729                  {
    730                  }
    731                  /* Receive response when command completes successfully. */
    732                  if (error == kStatus_Success)
   \                     ??USDHC_WaitCommandDone_5: (+1)
   \       0x4A   0x2C00             CMP      R4,#+0
   \       0x4C   0xD104             BNE.N    ??USDHC_WaitCommandDone_6
    733                  {
    734                      error = USDHC_ReceiveCommandResponse(base, command);
   \       0x4E   0x4629             MOV      R1,R5
   \       0x50   0x4630             MOV      R0,R6
   \       0x52   0x....'....        BL       USDHC_ReceiveCommandResponse
   \       0x56   0x4604             MOV      R4,R0
    735                  }
    736          
    737                  USDHC_ClearInterruptStatusFlags(
    738                      base, (kUSDHC_CommandCompleteFlag | kUSDHC_CommandErrorFlag | kUSDHC_TuningErrorFlag));
   \                     ??USDHC_WaitCommandDone_6: (+1)
   \       0x58   0x....'....        LDR.W    R1,??DataTable24  ;; 0x40f0001
   \       0x5C   0x4630             MOV      R0,R6
   \       0x5E   0x....'....        BL       USDHC_ClearInterruptStatusFlags
    739              }
    740          
    741              return error;
   \                     ??USDHC_WaitCommandDone_2: (+1)
   \       0x62   0x4620             MOV      R0,R4
   \       0x64   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    742          }
    743          

   \                                 In section .text, align 2, keep-with-next
    744          static status_t USDHC_TransferDataBlocking(USDHC_Type *base, usdhc_data_t *data, bool enDMA)
    745          {
   \                     USDHC_TransferDataBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
    746              status_t error = kStatus_Success;
   \        0x6   0x2400             MOVS     R4,#+0
    747              uint32_t interruptStatus = 0U;
   \        0x8   0x4620             MOV      R0,R4
    748          
    749              if (enDMA)
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD10A             BNE.N    ??USDHC_TransferDataBlocking_0
    750              {
    751                  /* Wait data complete or USDHC encounters error. */
    752                  while (!((interruptStatus &
    753                            (kUSDHC_DataCompleteFlag | kUSDHC_DataErrorFlag | kUSDHC_DmaErrorFlag | kUSDHC_TuningErrorFlag))))
    754                  {
    755                      interruptStatus = USDHC_GetInterruptStatusFlags(base);
    756                  }
    757          
    758                  if ((interruptStatus & kUSDHC_TuningErrorFlag) != 0U)
    759                  {
    760                      error = kStatus_USDHC_TuningError;
    761                  }
    762                  else if (((interruptStatus & (kUSDHC_DataErrorFlag | kUSDHC_DmaErrorFlag)) != 0U))
    763                  {
    764                      if ((!(data->enableIgnoreError)) || (interruptStatus & kUSDHC_DataTimeoutFlag))
    765                      {
    766                          error = kStatus_Fail;
    767                      }
    768                  }
    769                  else
    770                  {
    771                  }
    772                  /* load dummy data */
    773                  if ((data->dataType == kUSDHC_TransferDataBootcontinous) && (error == kStatus_Success))
    774                  {
    775                      *(data->rxData) = s_usdhcBootDummy;
    776                  }
    777          
    778                  USDHC_ClearInterruptStatusFlags(base, (kUSDHC_DataCompleteFlag | kUSDHC_DataErrorFlag | kUSDHC_DmaErrorFlag |
    779                                                         kUSDHC_TuningPassFlag | kUSDHC_TuningErrorFlag));
    780              }
    781              else
    782              {
    783                  if (data->rxData)
   \        0xE   0x68E8             LDR      R0,[R5, #+12]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0x4630             MOV      R0,R6
   \       0x14   0xD029             BEQ.N    ??USDHC_TransferDataBlocking_1
    784                  {
    785                      error = USDHC_ReadByDataPortBlocking(base, data);
   \       0x16   0x....'....        BL       USDHC_ReadByDataPortBlocking
   \       0x1A   0x4604             MOV      R4,R0
   \       0x1C   0xE028             B.N      ??USDHC_TransferDataBlocking_2
    786                  }
   \                     ??USDHC_TransferDataBlocking_3: (+1)
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x....'....        BL       USDHC_GetInterruptStatusFlags
   \                     ??USDHC_TransferDataBlocking_0: (+1)
   \       0x24   0x....'....        LDR.W    R1,??DataTable22_3  ;; 0x15700002
   \       0x28   0x4208             TST      R0,R1
   \       0x2A   0xD0F8             BEQ.N    ??USDHC_TransferDataBlocking_3
   \       0x2C   0x0141             LSLS     R1,R0,#+5
   \       0x2E   0xD502             BPL.N    ??USDHC_TransferDataBlocking_4
   \       0x30   0xF641 0x146A      MOVW     R4,#+6506
   \       0x34   0xE009             B.N      ??USDHC_TransferDataBlocking_5
   \                     ??USDHC_TransferDataBlocking_4: (+1)
   \       0x36   0x....'....        LDR.W    R1,??DataTable23  ;; 0x11700000
   \       0x3A   0x4208             TST      R0,R1
   \       0x3C   0xD005             BEQ.N    ??USDHC_TransferDataBlocking_5
   \       0x3E   0x78A9             LDRB     R1,[R5, #+2]
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD001             BEQ.N    ??USDHC_TransferDataBlocking_6
   \       0x44   0x02C0             LSLS     R0,R0,#+11
   \       0x46   0xD500             BPL.N    ??USDHC_TransferDataBlocking_5
   \                     ??USDHC_TransferDataBlocking_6: (+1)
   \       0x48   0x2401             MOVS     R4,#+1
   \                     ??USDHC_TransferDataBlocking_5: (+1)
   \       0x4A   0x78E8             LDRB     R0,[R5, #+3]
   \       0x4C   0x2803             CMP      R0,#+3
   \       0x4E   0xD106             BNE.N    ??USDHC_TransferDataBlocking_7
   \       0x50   0x2C00             CMP      R4,#+0
   \       0x52   0xD104             BNE.N    ??USDHC_TransferDataBlocking_7
   \       0x54   0x....'....        LDR.W    R0,??DataTable25
   \       0x58   0x6800             LDR      R0,[R0, #+0]
   \       0x5A   0x68E9             LDR      R1,[R5, #+12]
   \       0x5C   0x6008             STR      R0,[R1, #+0]
   \                     ??USDHC_TransferDataBlocking_7: (+1)
   \       0x5E   0x....'....        LDR.W    R1,??DataTable25_1  ;; 0x15704002
   \       0x62   0x4630             MOV      R0,R6
   \       0x64   0x....'....        BL       USDHC_ClearInterruptStatusFlags
   \       0x68   0xE002             B.N      ??USDHC_TransferDataBlocking_2
    787                  else
    788                  {
    789                      error = USDHC_WriteByDataPortBlocking(base, data);
   \                     ??USDHC_TransferDataBlocking_1: (+1)
   \       0x6A   0x....'....        BL       USDHC_WriteByDataPortBlocking
   \       0x6E   0x4604             MOV      R4,R0
    790                  }
    791              }
    792          
    793              return error;
   \                     ??USDHC_TransferDataBlocking_2: (+1)
   \       0x70   0x4620             MOV      R0,R4
   \       0x72   0xBD70             POP      {R4-R6,PC}       ;; return
    794          }
    795          
    796          /*!
    797           * brief USDHC module initialization function.
    798           *
    799           * Configures the USDHC according to the user configuration.
    800           *
    801           * Example:
    802             code
    803             usdhc_config_t config;
    804             config.cardDetectDat3 = false;
    805             config.endianMode = kUSDHC_EndianModeLittle;
    806             config.dmaMode = kUSDHC_DmaModeAdma2;
    807             config.readWatermarkLevel = 128U;
    808             config.writeWatermarkLevel = 128U;
    809             USDHC_Init(USDHC, &config);
    810             endcode
    811           *
    812           * param base USDHC peripheral base address.
    813           * param config USDHC configuration information.
    814           * retval kStatus_Success Operate successfully.
    815           */

   \                                 In section .text, align 2, keep-with-next
    816          void USDHC_Init(USDHC_Type *base, const usdhc_config_t *config)
    817          {
   \                     USDHC_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    818              assert(config);
   \        0x6   0xD109             BNE.N    ??USDHC_Init_0
   \        0x8   0xF240 0x3232      MOVW     R2,#+818
   \        0xC   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x10   0x....'....        LDR.W    R0,??DataTable24_1
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
    819              assert((config->writeWatermarkLevel >= 1U) && (config->writeWatermarkLevel <= 128U));
   \                     ??USDHC_Init_0: (+1)
   \       0x1C   0x79A0             LDRB     R0,[R4, #+6]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??USDHC_Init_1
   \       0x22   0x2881             CMP      R0,#+129
   \       0x24   0xD309             BCC.N    ??USDHC_Init_2
   \                     ??USDHC_Init_1: (+1)
   \       0x26   0xF240 0x3233      MOVW     R2,#+819
   \       0x2A   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x2E   0x....'....        LDR.W    R0,??DataTable24_2
   \       0x32   0x....'....        BL       __aeabi_assert
   \       0x36   0x....'....        BL       __iar_EmptyStepPoint
    820              assert((config->readWatermarkLevel >= 1U) && (config->readWatermarkLevel <= 128U));
   \                     ??USDHC_Init_2: (+1)
   \       0x3A   0x7960             LDRB     R0,[R4, #+5]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD001             BEQ.N    ??USDHC_Init_3
   \       0x40   0x2881             CMP      R0,#+129
   \       0x42   0xD309             BCC.N    ??USDHC_Init_4
   \                     ??USDHC_Init_3: (+1)
   \       0x44   0xF44F 0x724D      MOV      R2,#+820
   \       0x48   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x4C   0x....'....        LDR.W    R0,??DataTable24_3
   \       0x50   0x....'....        BL       __aeabi_assert
   \       0x54   0x....'....        BL       __iar_EmptyStepPoint
    821              assert(config->writeBurstLen <= 16U);
   \                     ??USDHC_Init_4: (+1)
   \       0x58   0x7A20             LDRB     R0,[R4, #+8]
   \       0x5A   0x2811             CMP      R0,#+17
   \       0x5C   0xD309             BCC.N    ??USDHC_Init_5
   \       0x5E   0xF240 0x3235      MOVW     R2,#+821
   \       0x62   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x66   0x....'....        LDR.W    R0,??DataTable24_4
   \       0x6A   0x....'....        BL       __aeabi_assert
   \       0x6E   0x....'....        BL       __iar_EmptyStepPoint
    822          
    823              uint32_t proctl, sysctl, wml;
    824          
    825          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    826              /* Enable USDHC clock. */
    827              CLOCK_EnableClock(s_usdhcClock[USDHC_GetInstance(base)]);
   \                     ??USDHC_Init_5: (+1)
   \       0x72   0x4628             MOV      R0,R5
   \       0x74   0x....'....        BL       USDHC_GetInstance
   \       0x78   0x....'....        LDR.W    R1,??DataTable26
   \       0x7C   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x80   0x....'....        BL       CLOCK_EnableClock
    828          #endif
    829          
    830              /* Reset USDHC. */
    831              USDHC_Reset(base, kUSDHC_ResetAll, 100U);
   \       0x84   0x2264             MOVS     R2,#+100
   \       0x86   0xF04F 0x7180      MOV      R1,#+16777216
   \       0x8A   0x4628             MOV      R0,R5
   \       0x8C   0x....'....        BL       USDHC_Reset
    832          
    833              proctl = base->PROT_CTRL;
   \       0x90   0x6AA9             LDR      R1,[R5, #+40]
    834              wml = base->WTMK_LVL;
   \       0x92   0x6C6A             LDR      R2,[R5, #+68]
    835              sysctl = base->SYS_CTRL;
   \       0x94   0x6AEB             LDR      R3,[R5, #+44]
    836          
    837              proctl &= ~(USDHC_PROT_CTRL_EMODE_MASK | USDHC_PROT_CTRL_DMASEL_MASK);
    838              /* Endian mode*/
    839              proctl |= USDHC_PROT_CTRL_EMODE(config->endianMode);
   \       0x96   0xF421 0x714C      BIC      R1,R1,#0x330
   \       0x9A   0x7920             LDRB     R0,[R4, #+4]
   \       0x9C   0x0100             LSLS     R0,R0,#+4
   \       0x9E   0xF000 0x0030      AND      R0,R0,#0x30
   \       0xA2   0x4301             ORRS     R1,R0,R1
    840          
    841              /* Watermark level */
    842              wml &= ~(USDHC_WTMK_LVL_RD_WML_MASK | USDHC_WTMK_LVL_WR_WML_MASK | USDHC_WTMK_LVL_RD_BRST_LEN_MASK |
    843                       USDHC_WTMK_LVL_WR_BRST_LEN_MASK);
    844              wml |= (USDHC_WTMK_LVL_RD_WML(config->readWatermarkLevel) | USDHC_WTMK_LVL_WR_WML(config->writeWatermarkLevel) |
    845                      USDHC_WTMK_LVL_RD_BRST_LEN(config->readBurstLen) | USDHC_WTMK_LVL_WR_BRST_LEN(config->writeBurstLen));
   \       0xA4   0xF002 0x22E0      AND      R2,R2,#0xE000E000
   \       0xA8   0x7960             LDRB     R0,[R4, #+5]
   \       0xAA   0x4302             ORRS     R2,R0,R2
   \       0xAC   0x79A0             LDRB     R0,[R4, #+6]
   \       0xAE   0xEA42 0x4200      ORR      R2,R2,R0, LSL #+16
   \       0xB2   0x79E0             LDRB     R0,[R4, #+7]
   \       0xB4   0x0200             LSLS     R0,R0,#+8
   \       0xB6   0xF400 0x50F8      AND      R0,R0,#0x1F00
   \       0xBA   0x4302             ORRS     R2,R0,R2
   \       0xBC   0x7A20             LDRB     R0,[R4, #+8]
   \       0xBE   0x0600             LSLS     R0,R0,#+24
   \       0xC0   0xF000 0x50F8      AND      R0,R0,#0x1F000000
   \       0xC4   0x4302             ORRS     R2,R0,R2
    846          
    847              /* config the data timeout value */
    848              sysctl &= ~USDHC_SYS_CTRL_DTOCV_MASK;
    849              sysctl |= USDHC_SYS_CTRL_DTOCV(config->dataTimeout);
    850          
    851              base->SYS_CTRL = sysctl;
   \       0xC6   0x6820             LDR      R0,[R4, #+0]
   \       0xC8   0xF360 0x4313      BFI      R3,R0,#+16,#+4
   \       0xCC   0x62EB             STR      R3,[R5, #+44]
    852              base->WTMK_LVL = wml;
   \       0xCE   0x646A             STR      R2,[R5, #+68]
    853              base->PROT_CTRL = proctl;
   \       0xD0   0x62A9             STR      R1,[R5, #+40]
    854          
    855          #if FSL_FEATURE_USDHC_HAS_EXT_DMA
    856              /* disable external DMA */
    857              base->VEND_SPEC &= ~USDHC_VEND_SPEC_EXT_DMA_EN_MASK;
    858          #endif
    859              /* disable internal DMA and DDR mode */
    860              base->MIX_CTRL &= ~(USDHC_MIX_CTRL_DMAEN_MASK | USDHC_MIX_CTRL_DDR_EN_MASK);
   \       0xD2   0x6CA8             LDR      R0,[R5, #+72]
   \       0xD4   0xF020 0x0009      BIC      R0,R0,#0x9
   \       0xD8   0x64A8             STR      R0,[R5, #+72]
    861              /* Enable interrupt status but doesn't enable interrupt signal. */
    862              USDHC_SetTransferInterrupt(base, false);
   \       0xDA   0x2100             MOVS     R1,#+0
   \       0xDC   0x4628             MOV      R0,R5
   \       0xDE   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0xE2   0x....             B.N      USDHC_SetTransferInterrupt
    863          }
    864          
    865          /*!
    866           * brief Deinitializes the USDHC.
    867           *
    868           * param base USDHC peripheral base address.
    869           */

   \                                 In section .text, align 2, keep-with-next
    870          void USDHC_Deinit(USDHC_Type *base)
    871          {
   \                     USDHC_Deinit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    872          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    873              /* Disable clock. */
    874              CLOCK_DisableClock(s_usdhcClock[USDHC_GetInstance(base)]);
   \        0x2   0x....'....        BL       USDHC_GetInstance
   \        0x6   0x....'....        LDR.W    R1,??DataTable26
   \        0xA   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \        0xE   0xE8BD 0x4002      POP      {R1,LR}
   \       0x12   0x....             B.N      CLOCK_DisableClock
    875          #endif
    876          }
    877          
    878          /*!
    879           * brief Resets the USDHC.
    880           *
    881           * param base USDHC peripheral base address.
    882           * param mask The reset type mask(_usdhc_reset).
    883           * param timeout Timeout for reset.
    884           * retval true Reset successfully.
    885           * retval false Reset failed.
    886           */

   \                                 In section .text, align 2, keep-with-next
    887          bool USDHC_Reset(USDHC_Type *base, uint32_t mask, uint32_t timeout)
    888          {
   \                     USDHC_Reset: (+1)
   \        0x0   0xB410             PUSH     {R4}
    889              base->SYS_CTRL |= (mask & (USDHC_SYS_CTRL_RSTA_MASK | USDHC_SYS_CTRL_RSTC_MASK | USDHC_SYS_CTRL_RSTD_MASK));
   \        0x2   0x6AC4             LDR      R4,[R0, #+44]
   \        0x4   0xF001 0x63E0      AND      R3,R1,#0x7000000
   \        0x8   0x431C             ORRS     R4,R3,R4
   \        0xA   0x62C4             STR      R4,[R0, #+44]
    890              /* Delay some time to wait reset success. */
    891              while ((base->SYS_CTRL & mask) != 0U)
   \                     ??USDHC_Reset_0: (+1)
   \        0xC   0x6AC3             LDR      R3,[R0, #+44]
   \        0xE   0x420B             TST      R3,R1
   \       0x10   0xD003             BEQ.N    ??USDHC_Reset_1
    892              {
    893                  if (timeout == 0U)
   \       0x12   0x2A00             CMP      R2,#+0
   \       0x14   0xD001             BEQ.N    ??USDHC_Reset_1
    894                  {
    895                      break;
    896                  }
    897                  timeout--;
   \       0x16   0x1E52             SUBS     R2,R2,#+1
   \       0x18   0xE7F8             B.N      ??USDHC_Reset_0
    898              }
    899          
    900              return ((!timeout) ? false : true);
   \                     ??USDHC_Reset_1: (+1)
   \       0x1A   0x4610             MOV      R0,R2
   \       0x1C   0x1E40             SUBS     R0,R0,#+1
   \       0x1E   0x4180             SBCS     R0,R0,R0
   \       0x20   0x43C0             MVNS     R0,R0
   \       0x22   0x0FC0             LSRS     R0,R0,#+31
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x4180             SBCS     R0,R0,R0
   \       0x28   0x43C0             MVNS     R0,R0
   \       0x2A   0x0FC0             LSRS     R0,R0,#+31
   \       0x2C   0xBC10             POP      {R4}
   \       0x2E   0x4770             BX       LR               ;; return
    901          }
    902          
    903          /*!
    904           * brief Gets the capability information.
    905           *
    906           * param base USDHC peripheral base address.
    907           * param capability Structure to save capability information.
    908           */

   \                                 In section .text, align 2, keep-with-next
    909          void USDHC_GetCapability(USDHC_Type *base, usdhc_capability_t *capability)
    910          {
   \                     USDHC_GetCapability: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    911              assert(capability);
   \        0x6   0xD109             BNE.N    ??USDHC_GetCapability_0
   \        0x8   0xF240 0x328F      MOVW     R2,#+911
   \        0xC   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x10   0x....'....        LDR.W    R0,??DataTable28
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
    912          
    913              uint32_t htCapability;
    914              uint32_t maxBlockLength;
    915          
    916              htCapability = base->HOST_CTRL_CAP;
   \                     ??USDHC_GetCapability_0: (+1)
   \       0x1C   0x6C29             LDR      R1,[R5, #+64]
    917          
    918              /* Get the capability of USDHC. */
    919              maxBlockLength = ((htCapability & USDHC_HOST_CTRL_CAP_MBL_MASK) >> USDHC_HOST_CTRL_CAP_MBL_SHIFT);
    920              capability->maxBlockLength = (512U << maxBlockLength);
   \       0x1E   0xF44F 0x7000      MOV      R0,#+512
   \       0x22   0x460A             MOV      R2,R1
   \       0x24   0x0C12             LSRS     R2,R2,#+16
   \       0x26   0xF002 0x0207      AND      R2,R2,#0x7
   \       0x2A   0x4090             LSLS     R0,R0,R2
   \       0x2C   0x60A0             STR      R0,[R4, #+8]
    921              /* Other attributes not in HTCAPBLT register. */
    922              capability->maxBlockCount = USDHC_MAX_BLOCK_COUNT;
   \       0x2E   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x32   0x60E0             STR      R0,[R4, #+12]
    923              capability->flags = (htCapability & (kUSDHC_SupportAdmaFlag | kUSDHC_SupportHighSpeedFlag | kUSDHC_SupportDmaFlag |
    924                                                   kUSDHC_SupportSuspendResumeFlag | kUSDHC_SupportV330Flag));
   \       0x34   0xF001 0x70F8      AND      R0,R1,#0x1F00000
   \       0x38   0x6120             STR      R0,[R4, #+16]
    925              capability->flags |= (htCapability & kUSDHC_SupportV300Flag);
   \       0x3A   0x4602             MOV      R2,R0
   \       0x3C   0xF001 0x7000      AND      R0,R1,#0x2000000
   \       0x40   0x4302             ORRS     R2,R0,R2
   \       0x42   0x6122             STR      R2,[R4, #+16]
    926              capability->flags |= (htCapability & kUSDHC_SupportV180Flag);
   \       0x44   0xF001 0x6080      AND      R0,R1,#0x4000000
   \       0x48   0x4302             ORRS     R2,R0,R2
   \       0x4A   0x6122             STR      R2,[R4, #+16]
    927              capability->flags |=
    928                  (htCapability & (kUSDHC_SupportDDR50Flag | kUSDHC_SupportSDR104Flag | kUSDHC_SupportSDR50Flag));
   \       0x4C   0x4610             MOV      R0,R2
   \       0x4E   0xF001 0x0107      AND      R1,R1,#0x7
   \       0x52   0x4301             ORRS     R1,R1,R0
   \       0x54   0x6121             STR      R1,[R4, #+16]
    929              /* USDHC support 4/8 bit data bus width. */
    930              capability->flags |= (kUSDHC_Support4BitFlag | kUSDHC_Support8BitFlag);
   \       0x56   0x4608             MOV      R0,R1
   \       0x58   0xF040 0x0030      ORR      R0,R0,#0x30
   \       0x5C   0x6120             STR      R0,[R4, #+16]
    931          }
   \       0x5E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    932          
    933          /*!
    934           * brief Sets the SD bus clock frequency.
    935           *
    936           * param base USDHC peripheral base address.
    937           * param srcClock_Hz USDHC source clock frequency united in Hz.
    938           * param busClock_Hz SD bus clock frequency united in Hz.
    939           *
    940           * return The nearest frequency of busClock_Hz configured to SD bus.
    941           */

   \                                 In section .text, align 2, keep-with-next
    942          uint32_t USDHC_SetSdClock(USDHC_Type *base, uint32_t srcClock_Hz, uint32_t busClock_Hz)
    943          {
   \                     USDHC_SetSdClock: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
    944              assert(srcClock_Hz != 0U);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD109             BNE.N    ??USDHC_SetSdClock_0
   \        0xC   0xF44F 0x726C      MOV      R2,#+944
   \       0x10   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x14   0x....'....        LDR.W    R0,??DataTable28_1
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
    945              assert((busClock_Hz != 0U) && (busClock_Hz <= srcClock_Hz));
   \                     ??USDHC_SetSdClock_0: (+1)
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD001             BEQ.N    ??USDHC_SetSdClock_1
   \       0x24   0x42AC             CMP      R4,R5
   \       0x26   0xD209             BCS.N    ??USDHC_SetSdClock_2
   \                     ??USDHC_SetSdClock_1: (+1)
   \       0x28   0xF240 0x32B1      MOVW     R2,#+945
   \       0x2C   0x....'....        LDR.W    R1,??DataTable16_2
   \       0x30   0x....'....        LDR.W    R0,??DataTable28_2
   \       0x34   0x....'....        BL       __aeabi_assert
   \       0x38   0x....'....        BL       __iar_EmptyStepPoint
    946          
    947              uint32_t totalDiv = 0U;
    948              uint32_t divisor = 0U;
   \                     ??USDHC_SetSdClock_2: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
    949              uint32_t prescaler = 0U;
   \       0x3E   0x4602             MOV      R2,R0
    950              uint32_t sysctl = 0U;
    951              uint32_t nearestFrequency = 0U;
    952          
    953              /* calucate total divisor first */
    954              if ((totalDiv = srcClock_Hz / busClock_Hz) > (USDHC_MAX_CLKFS * USDHC_MAX_DVS))
   \       0x40   0xFBB4 0xF1F5      UDIV     R1,R4,R5
   \       0x44   0xF241 0x0301      MOVW     R3,#+4097
   \       0x48   0x4299             CMP      R1,R3
   \       0x4A   0xD227             BCS.N    ??USDHC_SetSdClock_3
    955              {
    956                  return 0U;
    957              }
    958          
    959              if (totalDiv != 0U)
   \       0x4C   0x2900             CMP      R1,#+0
   \       0x4E   0xD039             BEQ.N    ??USDHC_SetSdClock_4
    960              {
    961                  /* calucate the divisor (srcClock_Hz / divisor) <= busClock_Hz */
    962                  if ((srcClock_Hz / totalDiv) > busClock_Hz)
   \       0x50   0xFBB4 0xF0F1      UDIV     R0,R4,R1
   \       0x54   0x4285             CMP      R5,R0
   \       0x56   0xD200             BCS.N    ??USDHC_SetSdClock_5
    963                  {
    964                      totalDiv++;
   \       0x58   0x1C49             ADDS     R1,R1,#+1
    965                  }
    966          
    967                  /* divide the total divisor to div and prescaler */
    968                  if (totalDiv > USDHC_MAX_DVS)
   \                     ??USDHC_SetSdClock_5: (+1)
   \       0x5A   0x2911             CMP      R1,#+17
   \       0x5C   0xD320             BCC.N    ??USDHC_SetSdClock_6
    969                  {
    970                      prescaler = totalDiv / USDHC_MAX_DVS;
   \       0x5E   0x460A             MOV      R2,R1
   \       0x60   0x0912             LSRS     R2,R2,#+4
   \       0x62   0xE000             B.N      ??USDHC_SetSdClock_7
    971                      /* prescaler must be a value which equal 2^n and smaller than SDHC_MAX_CLKFS */
    972                      while (((USDHC_MAX_CLKFS % prescaler) != 0U) || (prescaler == 1U))
    973                      {
    974                          prescaler++;
   \                     ??USDHC_SetSdClock_8: (+1)
   \       0x64   0x1C52             ADDS     R2,R2,#+1
    975                      }
   \                     ??USDHC_SetSdClock_7: (+1)
   \       0x66   0xF44F 0x7080      MOV      R0,#+256
   \       0x6A   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \       0x6E   0x4350             MULS     R0,R2,R0
   \       0x70   0xF5D0 0x7080      RSBS     R0,R0,#+256
   \       0x74   0xD1F6             BNE.N    ??USDHC_SetSdClock_8
   \       0x76   0x2A01             CMP      R2,#+1
   \       0x78   0xD0F4             BEQ.N    ??USDHC_SetSdClock_8
    976                      /* calucate the divisor */
    977                      divisor = totalDiv / prescaler;
   \       0x7A   0xFBB1 0xF0F2      UDIV     R0,R1,R2
   \       0x7E   0xE001             B.N      ??USDHC_SetSdClock_9
    978                      /* fine tuning the divisor until divisor * prescaler >= totalDiv */
    979                      while ((divisor * prescaler) < totalDiv)
    980                      {
    981                          divisor++;
    982                          if (divisor > USDHC_MAX_DVS)
    983                          {
    984                              if ((prescaler <<= 1U) > USDHC_MAX_CLKFS)
    985                              {
    986                                  return 0;
    987                              }
    988                              divisor = totalDiv / prescaler;
   \                     ??USDHC_SetSdClock_10: (+1)
   \       0x80   0xFBB1 0xF0F2      UDIV     R0,R1,R2
   \                     ??USDHC_SetSdClock_9: (+1)
   \       0x84   0xFB02 0xF300      MUL      R3,R2,R0
   \       0x88   0x428B             CMP      R3,R1
   \       0x8A   0xD212             BCS.N    ??USDHC_SetSdClock_11
   \       0x8C   0x1C40             ADDS     R0,R0,#+1
   \       0x8E   0x2811             CMP      R0,#+17
   \       0x90   0xD3F8             BCC.N    ??USDHC_SetSdClock_9
   \       0x92   0x0052             LSLS     R2,R2,#+1
   \       0x94   0xF240 0x1001      MOVW     R0,#+257
   \       0x98   0x4282             CMP      R2,R0
   \       0x9A   0xD3F1             BCC.N    ??USDHC_SetSdClock_10
   \                     ??USDHC_SetSdClock_3: (+1)
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0xBD70             POP      {R4-R6,PC}
    989                          }
    990                      }
    991                  }
    992                  else
    993                  {
    994                      /* in this situation , divsior and SDCLKFS can generate same clock
    995                      use SDCLKFS*/
    996                      if (((totalDiv % 2U) != 0U) & (totalDiv != 1U))
   \                     ??USDHC_SetSdClock_6: (+1)
   \       0xA0   0x07C8             LSLS     R0,R1,#+31
   \       0xA2   0xD504             BPL.N    ??USDHC_SetSdClock_12
   \       0xA4   0x2901             CMP      R1,#+1
   \       0xA6   0xD002             BEQ.N    ??USDHC_SetSdClock_12
    997                      {
    998                          divisor = totalDiv;
   \       0xA8   0x4608             MOV      R0,R1
    999                          prescaler = 1U;
   \       0xAA   0x2201             MOVS     R2,#+1
   \       0xAC   0xE001             B.N      ??USDHC_SetSdClock_11
   1000                      }
   1001                      else
   1002                      {
   1003                          divisor = 1U;
   \                     ??USDHC_SetSdClock_12: (+1)
   \       0xAE   0x2001             MOVS     R0,#+1
   1004                          prescaler = totalDiv;
   \       0xB0   0x460A             MOV      R2,R1
   1005                      }
   1006                  }
   1007                  nearestFrequency = srcClock_Hz / (divisor == 0U ? 1U : divisor) / prescaler;
   \                     ??USDHC_SetSdClock_11: (+1)
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD101             BNE.N    ??USDHC_SetSdClock_13
   \       0xB6   0x2101             MOVS     R1,#+1
   \       0xB8   0xE000             B.N      ??USDHC_SetSdClock_14
   \                     ??USDHC_SetSdClock_13: (+1)
   \       0xBA   0x4601             MOV      R1,R0
   \                     ??USDHC_SetSdClock_14: (+1)
   \       0xBC   0xFBB4 0xF1F1      UDIV     R1,R4,R1
   \       0xC0   0xFBB1 0xF4F2      UDIV     R4,R1,R2
   1008              }
   1009              /* in this condition , srcClock_Hz = busClock_Hz, */
   1010              else
   1011              {
   1012                  /* in DDR mode , set SDCLKFS to 0, divisor = 0, actually the
   1013                  totoal divider = 2U */
   1014                  divisor = 0U;
   1015                  prescaler = 0U;
   1016                  nearestFrequency = srcClock_Hz;
   1017              }
   1018          
   1019              /* calucate the value write to register */
   1020              if (divisor != 0U)
   \                     ??USDHC_SetSdClock_4: (+1)
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD000             BEQ.N    ??USDHC_SetSdClock_15
   1021              {
   1022                  USDHC_PREV_DVS(divisor);
   \       0xC8   0x1E40             SUBS     R0,R0,#+1
   1023              }
   1024              /* calucate the value write to register */
   1025              if (prescaler != 0U)
   \                     ??USDHC_SetSdClock_15: (+1)
   \       0xCA   0x2A00             CMP      R2,#+0
   \       0xCC   0xD000             BEQ.N    ??USDHC_SetSdClock_16
   1026              {
   1027                  USDHC_PREV_CLKFS(prescaler, 1U);
   \       0xCE   0x0852             LSRS     R2,R2,#+1
   1028              }
   1029          
   1030              /* Set the SD clock frequency divisor, SD clock frequency select, data timeout counter value. */
   1031              sysctl = base->SYS_CTRL;
   \                     ??USDHC_SetSdClock_16: (+1)
   \       0xD0   0x6AF1             LDR      R1,[R6, #+44]
   1032              sysctl &= ~(USDHC_SYS_CTRL_DVS_MASK | USDHC_SYS_CTRL_SDCLKFS_MASK);
   1033              sysctl |= (USDHC_SYS_CTRL_DVS(divisor) | USDHC_SYS_CTRL_SDCLKFS(prescaler));
   1034              base->SYS_CTRL = sysctl;
   \       0xD2   0xF36F 0x110F      BFC      R1,#+4,#+12
   \       0xD6   0x0100             LSLS     R0,R0,#+4
   \       0xD8   0xF000 0x00F0      AND      R0,R0,#0xF0
   \       0xDC   0x4308             ORRS     R0,R0,R1
   \       0xDE   0x0212             LSLS     R2,R2,#+8
   \       0xE0   0xF402 0x427F      AND      R2,R2,#0xFF00
   \       0xE4   0x4310             ORRS     R0,R2,R0
   \       0xE6   0x62F0             STR      R0,[R6, #+44]
   1035          
   1036              /* Wait until the SD clock is stable. */
   1037              while (!(base->PRES_STATE & USDHC_PRES_STATE_SDSTB_MASK))
   \                     ??USDHC_SetSdClock_17: (+1)
   \       0xE8   0x6A70             LDR      R0,[R6, #+36]
   \       0xEA   0x0700             LSLS     R0,R0,#+28
   \       0xEC   0xD5FC             BPL.N    ??USDHC_SetSdClock_17
   1038              {
   1039              }
   1040          
   1041              return nearestFrequency;
   \       0xEE   0x4620             MOV      R0,R4
   \       0xF0   0xBD70             POP      {R4-R6,PC}       ;; return
   1042          }
   1043          
   1044          /*!
   1045           * brief Sends 80 clocks to the card to set it to the active state.
   1046           *
   1047           * This function must be called each time the card is inserted to ensure that the card can receive the command
   1048           * correctly.
   1049           *
   1050           * param base USDHC peripheral base address.
   1051           * param timeout Timeout to initialize card.
   1052           * retval true Set card active successfully.
   1053           * retval false Set card active failed.
   1054           */

   \                                 In section .text, align 2, keep-with-next
   1055          bool USDHC_SetCardActive(USDHC_Type *base, uint32_t timeout)
   1056          {
   1057              base->SYS_CTRL |= USDHC_SYS_CTRL_INITA_MASK;
   \                     USDHC_SetCardActive: (+1)
   \        0x0   0x6AC2             LDR      R2,[R0, #+44]
   \        0x2   0xF042 0x6200      ORR      R2,R2,#0x8000000
   \        0x6   0x62C2             STR      R2,[R0, #+44]
   1058              /* Delay some time to wait card become active state. */
   1059              while ((base->SYS_CTRL & USDHC_SYS_CTRL_INITA_MASK) == USDHC_SYS_CTRL_INITA_MASK)
   \                     ??USDHC_SetCardActive_0: (+1)
   \        0x8   0x6AC2             LDR      R2,[R0, #+44]
   \        0xA   0x0112             LSLS     R2,R2,#+4
   \        0xC   0xD503             BPL.N    ??USDHC_SetCardActive_1
   1060              {
   1061                  if (!timeout)
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD001             BEQ.N    ??USDHC_SetCardActive_1
   1062                  {
   1063                      break;
   1064                  }
   1065                  timeout--;
   \       0x12   0x1E49             SUBS     R1,R1,#+1
   \       0x14   0xE7F8             B.N      ??USDHC_SetCardActive_0
   1066              }
   1067          
   1068              return ((!timeout) ? false : true);
   \                     ??USDHC_SetCardActive_1: (+1)
   \       0x16   0x4608             MOV      R0,R1
   \       0x18   0x1E40             SUBS     R0,R0,#+1
   \       0x1A   0x4180             SBCS     R0,R0,R0
   \       0x1C   0x43C0             MVNS     R0,R0
   \       0x1E   0x0FC0             LSRS     R0,R0,#+31
   \       0x20   0x1E40             SUBS     R0,R0,#+1
   \       0x22   0x4180             SBCS     R0,R0,R0
   \       0x24   0x43C0             MVNS     R0,R0
   \       0x26   0x0FC0             LSRS     R0,R0,#+31
   \       0x28   0x4770             BX       LR               ;; return
   1069          }
   1070          
   1071          /*!
   1072           * brief the enable/disable DDR mode
   1073           *
   1074           * param base USDHC peripheral base address.
   1075           * param enable/disable flag
   1076           * param nibble position
   1077           */

   \                                 In section .text, align 2, keep-with-next
   1078          void USDHC_EnableDDRMode(USDHC_Type *base, bool enable, uint32_t nibblePos)
   1079          {
   1080              uint32_t prescaler = (base->SYS_CTRL & USDHC_SYS_CTRL_SDCLKFS_MASK) >> USDHC_SYS_CTRL_SDCLKFS_SHIFT;
   \                     USDHC_EnableDDRMode: (+1)
   \        0x0   0x6AC3             LDR      R3,[R0, #+44]
   \        0x2   0xF3C3 0x2307      UBFX     R3,R3,#+8,#+8
   1081          
   1082              if (enable)
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0x6C81             LDR      R1,[R0, #+72]
   \        0xA   0xD00C             BEQ.N    ??USDHC_EnableDDRMode_0
   1083              {
   1084                  base->MIX_CTRL &= ~USDHC_MIX_CTRL_NIBBLE_POS_MASK;
   \        0xC   0xF021 0x0140      BIC      R1,R1,#0x40
   \       0x10   0x6481             STR      R1,[R0, #+72]
   1085                  base->MIX_CTRL |= (USDHC_MIX_CTRL_DDR_EN_MASK | USDHC_MIX_CTRL_NIBBLE_POS(nibblePos));
   \       0x12   0x6C81             LDR      R1,[R0, #+72]
   \       0x14   0x0192             LSLS     R2,R2,#+6
   \       0x16   0xF002 0x0240      AND      R2,R2,#0x40
   \       0x1A   0xF042 0x0208      ORR      R2,R2,#0x8
   \       0x1E   0x430A             ORRS     R2,R2,R1
   \       0x20   0x6482             STR      R2,[R0, #+72]
   1086                  prescaler >>= 1U;
   \       0x22   0x085B             LSRS     R3,R3,#+1
   \       0x24   0xE007             B.N      ??USDHC_EnableDDRMode_1
   1087              }
   1088              else
   1089              {
   1090                  base->MIX_CTRL &= ~USDHC_MIX_CTRL_DDR_EN_MASK;
   \                     ??USDHC_EnableDDRMode_0: (+1)
   \       0x26   0xF021 0x0108      BIC      R1,R1,#0x8
   \       0x2A   0x6481             STR      R1,[R0, #+72]
   1091          
   1092                  if (prescaler == 0U)
   \       0x2C   0x2B00             CMP      R3,#+0
   \       0x2E   0xD101             BNE.N    ??USDHC_EnableDDRMode_2
   1093                  {
   1094                      prescaler += 1U;
   \       0x30   0x2301             MOVS     R3,#+1
   \       0x32   0xE000             B.N      ??USDHC_EnableDDRMode_1
   1095                  }
   1096                  else
   1097                  {
   1098                      prescaler <<= 1U;
   \                     ??USDHC_EnableDDRMode_2: (+1)
   \       0x34   0x005B             LSLS     R3,R3,#+1
   1099                  }
   1100              }
   1101          
   1102              base->SYS_CTRL = (base->SYS_CTRL & (~USDHC_SYS_CTRL_SDCLKFS_MASK)) | USDHC_SYS_CTRL_SDCLKFS(prescaler);
   \                     ??USDHC_EnableDDRMode_1: (+1)
   \       0x36   0x6AC1             LDR      R1,[R0, #+44]
   \       0x38   0xF363 0x210F      BFI      R1,R3,#+8,#+8
   \       0x3C   0x62C1             STR      R1,[R0, #+44]
   1103          }
   \       0x3E   0x4770             BX       LR               ;; return
   1104          
   1105          /*!
   1106           * brief Configures the MMC boot feature.
   1107           *
   1108           * Example:
   1109             code
   1110             usdhc_boot_config_t config;
   1111             config.ackTimeoutCount = 4;
   1112             config.bootMode = kUSDHC_BootModeNormal;
   1113             config.blockCount = 5;
   1114             config.enableBootAck = true;
   1115             config.enableBoot = true;
   1116             config.enableAutoStopAtBlockGap = true;
   1117             USDHC_SetMmcBootConfig(USDHC, &config);
   1118             endcode
   1119           *
   1120           * param base USDHC peripheral base address.
   1121           * param config The MMC boot configuration information.
   1122           */

   \                                 In section .text, align 2, keep-with-next
   1123          void USDHC_SetMmcBootConfig(USDHC_Type *base, const usdhc_boot_config_t *config)
   1124          {
   \                     USDHC_SetMmcBootConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1125              assert(config);
   \        0x6   0xD108             BNE.N    ??USDHC_SetMmcBootConfig_0
   \        0x8   0xF240 0x4265      MOVW     R2,#+1125
   \        0xC   0x....             LDR.N    R1,??DataTable16_2
   \        0xE   0x....'....        LDR.W    R0,??DataTable24_1
   \       0x12   0x....'....        BL       __aeabi_assert
   \       0x16   0x....'....        BL       __iar_EmptyStepPoint
   1126              assert(config->ackTimeoutCount <= (USDHC_MMC_BOOT_DTOCV_ACK_MASK >> USDHC_MMC_BOOT_DTOCV_ACK_SHIFT));
   \                     ??USDHC_SetMmcBootConfig_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x2810             CMP      R0,#+16
   \       0x1E   0xD308             BCC.N    ??USDHC_SetMmcBootConfig_1
   \       0x20   0xF240 0x4266      MOVW     R2,#+1126
   \       0x24   0x....             LDR.N    R1,??DataTable16_2
   \       0x26   0x....'....        LDR.W    R0,??DataTable28_3
   \       0x2A   0x....'....        BL       __aeabi_assert
   \       0x2E   0x....'....        BL       __iar_EmptyStepPoint
   1127              assert(config->blockCount <= (USDHC_MMC_BOOT_BOOT_BLK_CNT_MASK >> USDHC_MMC_BOOT_BOOT_BLK_CNT_SHIFT));
   \                     ??USDHC_SetMmcBootConfig_1: (+1)
   \       0x32   0x68A0             LDR      R0,[R4, #+8]
   \       0x34   0xF5B0 0x3F80      CMP      R0,#+65536
   \       0x38   0xD308             BCC.N    ??USDHC_SetMmcBootConfig_2
   \       0x3A   0xF240 0x4267      MOVW     R2,#+1127
   \       0x3E   0x....             LDR.N    R1,??DataTable16_2
   \       0x40   0x....'....        LDR.W    R0,??DataTable28_4
   \       0x44   0x....'....        BL       __aeabi_assert
   \       0x48   0x....'....        BL       __iar_EmptyStepPoint
   1128          
   1129              uint32_t mmcboot = base->MMC_BOOT;
   \                     ??USDHC_SetMmcBootConfig_2: (+1)
   \       0x4C   0xF8D5 0x10C4      LDR      R1,[R5, #+196]
   1130          
   1131              mmcboot &= ~(USDHC_MMC_BOOT_DTOCV_ACK_MASK | USDHC_MMC_BOOT_BOOT_MODE_MASK | USDHC_MMC_BOOT_BOOT_BLK_CNT_MASK);
   1132              mmcboot |= USDHC_MMC_BOOT_DTOCV_ACK(config->ackTimeoutCount) | USDHC_MMC_BOOT_BOOT_MODE(config->bootMode);
   \       0x50   0xF64F 0x70D0      MOVW     R0,#+65488
   \       0x54   0x4001             ANDS     R1,R0,R1
   \       0x56   0x7820             LDRB     R0,[R4, #+0]
   \       0x58   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x5C   0x4301             ORRS     R1,R0,R1
   \       0x5E   0x7920             LDRB     R0,[R4, #+4]
   \       0x60   0x0140             LSLS     R0,R0,#+5
   \       0x62   0xF000 0x0020      AND      R0,R0,#0x20
   \       0x66   0x4301             ORRS     R1,R0,R1
   1133          
   1134              if (config->enableBootAck)
   \       0x68   0x7C20             LDRB     R0,[R4, #+16]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD001             BEQ.N    ??USDHC_SetMmcBootConfig_3
   1135              {
   1136                  mmcboot |= USDHC_MMC_BOOT_BOOT_ACK_MASK;
   \       0x6E   0xF041 0x0110      ORR      R1,R1,#0x10
   1137              }
   1138              if (config->enableAutoStopAtBlockGap)
   \                     ??USDHC_SetMmcBootConfig_3: (+1)
   \       0x72   0x7C60             LDRB     R0,[R4, #+17]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD014             BEQ.N    ??USDHC_SetMmcBootConfig_4
   1139              {
   1140                  mmcboot |=
   1141                      USDHC_MMC_BOOT_AUTO_SABG_EN_MASK | USDHC_MMC_BOOT_BOOT_BLK_CNT(USDHC_MAX_BLOCK_COUNT - config->blockCount);
   \       0x78   0xF64F 0x72FF      MOVW     R2,#+65535
   \       0x7C   0x68A0             LDR      R0,[R4, #+8]
   \       0x7E   0x1A12             SUBS     R2,R2,R0
   \       0x80   0x0412             LSLS     R2,R2,#+16
   \       0x82   0xF042 0x0280      ORR      R2,R2,#0x80
   \       0x86   0x4311             ORRS     R1,R2,R1
   1142                  /* always set the block count to USDHC_MAX_BLOCK_COUNT to use auto stop at block gap feature */
   1143                  base->BLK_ATT = ((base->BLK_ATT & ~(USDHC_BLK_ATT_BLKSIZE_MASK | USDHC_BLK_ATT_BLKCNT_MASK)) |
   1144                                   (USDHC_BLK_ATT_BLKSIZE(config->blockSize) | USDHC_BLK_ATT_BLKCNT(USDHC_MAX_BLOCK_COUNT)));
   \       0x88   0x6868             LDR      R0,[R5, #+4]
   \       0x8A   0xF400 0x4060      AND      R0,R0,#0xE000
   \       0x8E   0x68E2             LDR      R2,[R4, #+12]
   \       0x90   0xF3C2 0x020C      UBFX     R2,R2,#+0,#+13
   \       0x94   0x4310             ORRS     R0,R2,R0
   \       0x96   0xF040 0x407F      ORR      R0,R0,#0xFF000000
   \       0x9A   0xF440 0x007F      ORR      R0,R0,#0xFF0000
   \       0x9E   0x6068             STR      R0,[R5, #+4]
   \       0xA0   0xE00A             B.N      ??USDHC_SetMmcBootConfig_5
   1145              }
   1146              else
   1147              {
   1148                  base->BLK_ATT = ((base->BLK_ATT & ~(USDHC_BLK_ATT_BLKSIZE_MASK | USDHC_BLK_ATT_BLKCNT_MASK)) |
   1149                                   (USDHC_BLK_ATT_BLKSIZE(config->blockSize) | USDHC_BLK_ATT_BLKCNT(config->blockCount)));
   \                     ??USDHC_SetMmcBootConfig_4: (+1)
   \       0xA2   0x6868             LDR      R0,[R5, #+4]
   \       0xA4   0xF400 0x4060      AND      R0,R0,#0xE000
   \       0xA8   0x68E2             LDR      R2,[R4, #+12]
   \       0xAA   0xF3C2 0x020C      UBFX     R2,R2,#+0,#+13
   \       0xAE   0x4310             ORRS     R0,R2,R0
   \       0xB0   0x68A2             LDR      R2,[R4, #+8]
   \       0xB2   0xEA40 0x4002      ORR      R0,R0,R2, LSL #+16
   \       0xB6   0x6068             STR      R0,[R5, #+4]
   1150              }
   1151          
   1152              base->MMC_BOOT = mmcboot;
   \                     ??USDHC_SetMmcBootConfig_5: (+1)
   \       0xB8   0xF8C5 0x10C4      STR      R1,[R5, #+196]
   1153          }
   \       0xBC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1154          
   1155          /*!
   1156           * brief Sets the ADMA1 descriptor table configuration.
   1157           *
   1158           * param admaTable Adma table address.
   1159           * param admaTableWords Adma table length.
   1160           * param dataBufferAddr Data buffer address.
   1161           * param dataBytes Data length.
   1162           * param flags ADAM descriptor flag, used to indicate to create multiple or single descriptor, please
   1163           *  reference _usdhc_adma_flag.
   1164           * retval kStatus_OutOfRange ADMA descriptor table length isn't enough to describe data.
   1165           * retval kStatus_Success Operate successfully.
   1166           */

   \                                 In section .text, align 2, keep-with-next
   1167          status_t USDHC_SetADMA1Descriptor(
   1168              uint32_t *admaTable, uint32_t admaTableWords, const uint32_t *dataBufferAddr, uint32_t dataBytes, uint32_t flags)
   1169          {
   \                     USDHC_SetADMA1Descriptor: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461E             MOV      R6,R3
   1170              assert(NULL != admaTable);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD108             BNE.N    ??USDHC_SetADMA1Descriptor_0
   \        0xE   0xF240 0x4292      MOVW     R2,#+1170
   \       0x12   0x....             LDR.N    R1,??DataTable16_2
   \       0x14   0x....'....        LDR.W    R0,??DataTable28_5
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
   1171              assert(NULL != dataBufferAddr);
   \                     ??USDHC_SetADMA1Descriptor_0: (+1)
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD108             BNE.N    ??USDHC_SetADMA1Descriptor_1
   \       0x24   0xF240 0x4293      MOVW     R2,#+1171
   \       0x28   0x....             LDR.N    R1,??DataTable16_2
   \       0x2A   0x....'....        LDR.W    R0,??DataTable28_6
   \       0x2E   0x....'....        BL       __aeabi_assert
   \       0x32   0x....'....        BL       __iar_EmptyStepPoint
   1172          
   1173              uint32_t miniEntries, startEntries = 0U,
   1174                                    maxEntries = (admaTableWords * sizeof(uint32_t)) / sizeof(usdhc_adma1_descriptor_t);
   \                     ??USDHC_SetADMA1Descriptor_1: (+1)
   \       0x36   0xF027 0x4740      BIC      R7,R7,#0xC0000000
   1175              usdhc_adma1_descriptor_t *adma1EntryAddress = (usdhc_adma1_descriptor_t *)(admaTable);
   1176              uint32_t i, dmaBufferLen = 0U;
   1177              const uint32_t *data = dataBufferAddr;
   1178          
   1179              if (((uint32_t)data % USDHC_ADMA1_ADDRESS_ALIGN) != 0U)
   \       0x3A   0x0528             LSLS     R0,R5,#+20
   \       0x3C   0xD002             BEQ.N    ??USDHC_SetADMA1Descriptor_2
   1180              {
   1181                  return kStatus_USDHC_DMADataAddrNotAlign;
   \       0x3E   0xF641 0x1068      MOVW     R0,#+6504
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}
   1182              }
   \                     ??USDHC_SetADMA1Descriptor_2: (+1)
   \       0x44   0x9806             LDR      R0,[SP, #+24]
   1183          
   1184              if (flags == kUSDHC_AdmaDescriptorMultipleFlag)
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD102             BNE.N    ??USDHC_SetADMA1Descriptor_3
   1185              {
   1186                  return kStatus_USDHC_NotSupport;
   \       0x4A   0xF641 0x106B      MOVW     R0,#+6507
   \       0x4E   0xBDF2             POP      {R1,R4-R7,PC}
   1187              }
   1188              /*
   1189               * Add non aligned access support ,user need make sure your buffer size is big
   1190               * enough to hold the data,in other words,user need make sure the buffer size
   1191               * is 4 byte aligned
   1192               */
   1193              if (dataBytes % sizeof(uint32_t) != 0U)
   \                     ??USDHC_SetADMA1Descriptor_3: (+1)
   \       0x50   0xF016 0x0F03      TST      R6,#0x3
   \       0x54   0xD003             BEQ.N    ??USDHC_SetADMA1Descriptor_4
   1194              {
   1195                  /* make the data length as word-aligned */
   1196                  dataBytes += sizeof(uint32_t) - (dataBytes % sizeof(uint32_t));
   \       0x56   0x1D30             ADDS     R0,R6,#+4
   \       0x58   0xF006 0x0603      AND      R6,R6,#0x3
   \       0x5C   0x1B86             SUBS     R6,R0,R6
   1197              }
   1198          
   1199              /* Check if ADMA descriptor's number is enough. */
   1200              if ((dataBytes % USDHC_ADMA1_DESCRIPTOR_MAX_LENGTH_PER_ENTRY) == 0U)
   \                     ??USDHC_SetADMA1Descriptor_4: (+1)
   \       0x5E   0xF44F 0x4170      MOV      R1,#+61440
   \       0x62   0x4608             MOV      R0,R1
   \       0x64   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \       0x68   0xFB01 0x6010      MLS      R0,R1,R0,R6
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0x4608             MOV      R0,R1
   \       0x70   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \       0x74   0xD000             BEQ.N    ??USDHC_SetADMA1Descriptor_5
   1201              {
   1202                  miniEntries = dataBytes / USDHC_ADMA1_DESCRIPTOR_MAX_LENGTH_PER_ENTRY;
   1203              }
   1204              else
   1205              {
   1206                  miniEntries = ((dataBytes / USDHC_ADMA1_DESCRIPTOR_MAX_LENGTH_PER_ENTRY) + 1U);
   \       0x76   0x1C40             ADDS     R0,R0,#+1
   1207              }
   1208          
   1209              /* ADMA1 needs two descriptors to finish a transfer */
   1210              miniEntries <<= 1U;
   1211          
   1212              if (miniEntries + startEntries > maxEntries)
   \                     ??USDHC_SetADMA1Descriptor_5: (+1)
   \       0x78   0xEBB7 0x0F40      CMP      R7,R0, LSL #+1
   \       0x7C   0xD201             BCS.N    ??USDHC_SetADMA1Descriptor_6
   1213              {
   1214                  return kStatus_OutOfRange;
   \       0x7E   0x2003             MOVS     R0,#+3
   \       0x80   0xBDF2             POP      {R1,R4-R7,PC}
   1215              }
   1216          
   1217              for (i = startEntries; i < (miniEntries + startEntries); i += 2U)
   \                     ??USDHC_SetADMA1Descriptor_6: (+1)
   \       0x82   0x2200             MOVS     R2,#+0
   \                     ??USDHC_SetADMA1Descriptor_7: (+1)
   \       0x84   0xEBB2 0x0F40      CMP      R2,R0, LSL #+1
   \       0x88   0xD220             BCS.N    ??USDHC_SetADMA1Descriptor_8
   1218              {
   1219                  if (dataBytes > USDHC_ADMA1_DESCRIPTOR_MAX_LENGTH_PER_ENTRY)
   \       0x8A   0xF24F 0x0301      MOVW     R3,#+61441
   \       0x8E   0x429E             CMP      R6,R3
   \       0x90   0xD201             BCS.N    ??USDHC_SetADMA1Descriptor_9
   1220                  {
   1221                      dmaBufferLen = USDHC_ADMA1_DESCRIPTOR_MAX_LENGTH_PER_ENTRY;
   1222                  }
   1223                  else
   1224                  {
   1225                      dmaBufferLen = dataBytes;
   \       0x92   0x4633             MOV      R3,R6
   \       0x94   0xE000             B.N      ??USDHC_SetADMA1Descriptor_10
   1226                  }
   \                     ??USDHC_SetADMA1Descriptor_9: (+1)
   \       0x96   0x460B             MOV      R3,R1
   1227          
   1228                  adma1EntryAddress[i] = (dmaBufferLen << USDHC_ADMA1_DESCRIPTOR_LENGTH_SHIFT);
   \                     ??USDHC_SetADMA1Descriptor_10: (+1)
   \       0x98   0x031F             LSLS     R7,R3,#+12
   \       0x9A   0xF844 0x7022      STR      R7,[R4, R2, LSL #+2]
   1229                  adma1EntryAddress[i] |= kUSDHC_Adma1DescriptorTypeSetLength;
   \       0x9E   0xF854 0x7022      LDR      R7,[R4, R2, LSL #+2]
   \       0xA2   0xF047 0x0711      ORR      R7,R7,#0x11
   \       0xA6   0xF844 0x7022      STR      R7,[R4, R2, LSL #+2]
   1230                  adma1EntryAddress[i + 1U] = (uint32_t)(data);
   \       0xAA   0xEB04 0x0782      ADD      R7,R4,R2, LSL #+2
   \       0xAE   0x607D             STR      R5,[R7, #+4]
   1231                  adma1EntryAddress[i + 1U] |= kUSDHC_Adma1DescriptorTypeTransfer;
   \       0xB0   0x462F             MOV      R7,R5
   \       0xB2   0xF047 0x0721      ORR      R7,R7,#0x21
   \       0xB6   0xEB04 0x0C82      ADD      R12,R4,R2, LSL #+2
   \       0xBA   0xF8CC 0x7004      STR      R7,[R12, #+4]
   1232                  data += dmaBufferLen / sizeof(uint32_t);
   \       0xBE   0x461F             MOV      R7,R3
   \       0xC0   0x08BF             LSRS     R7,R7,#+2
   \       0xC2   0xEB05 0x0587      ADD      R5,R5,R7, LSL #+2
   1233                  dataBytes -= dmaBufferLen;
   \       0xC6   0x1AF6             SUBS     R6,R6,R3
   1234              }
   \       0xC8   0x1C92             ADDS     R2,R2,#+2
   \       0xCA   0xE7DB             B.N      ??USDHC_SetADMA1Descriptor_7
   1235              /* the end of the descriptor */
   1236              adma1EntryAddress[i - 1U] |= kUSDHC_Adma1DescriptorEndFlag;
   \                     ??USDHC_SetADMA1Descriptor_8: (+1)
   \       0xCC   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \       0xD0   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0xD4   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0xD8   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \       0xDC   0xF841 0x0C04      STR      R0,[R1, #-4]
   1237          
   1238              return kStatus_Success;
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1239          }
   1240          
   1241          /*!
   1242           * brief Sets the ADMA2 descriptor table configuration.
   1243           *
   1244           * param admaTable Adma table address.
   1245           * param admaTableWords Adma table length.
   1246           * param dataBufferAddr Data buffer address.
   1247           * param dataBytes Data Data length.
   1248           * param flags ADAM descriptor flag, used to indicate to create multiple or single descriptor, please
   1249           *  reference _usdhc_adma_flag.
   1250           * retval kStatus_OutOfRange ADMA descriptor table length isn't enough to describe data.
   1251           * retval kStatus_Success Operate successfully.
   1252           */

   \                                 In section .text, align 2, keep-with-next
   1253          status_t USDHC_SetADMA2Descriptor(
   1254              uint32_t *admaTable, uint32_t admaTableWords, const uint32_t *dataBufferAddr, uint32_t dataBytes, uint32_t flags)
   1255          {
   \                     USDHC_SetADMA2Descriptor: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461E             MOV      R6,R3
   1256              assert(NULL != admaTable);
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD108             BNE.N    ??USDHC_SetADMA2Descriptor_0
   \       0x10   0xF44F 0x629D      MOV      R2,#+1256
   \       0x14   0x....             LDR.N    R1,??DataTable16_2
   \       0x16   0x....'....        LDR.W    R0,??DataTable28_5
   \       0x1A   0x....'....        BL       __aeabi_assert
   \       0x1E   0x....'....        BL       __iar_EmptyStepPoint
   1257              assert(NULL != dataBufferAddr);
   \                     ??USDHC_SetADMA2Descriptor_0: (+1)
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD108             BNE.N    ??USDHC_SetADMA2Descriptor_1
   \       0x26   0xF240 0x42E9      MOVW     R2,#+1257
   \       0x2A   0x....             LDR.N    R1,??DataTable16_2
   \       0x2C   0x....'....        LDR.W    R0,??DataTable28_6
   \       0x30   0x....'....        BL       __aeabi_assert
   \       0x34   0x....'....        BL       __iar_EmptyStepPoint
   1258          
   1259              uint32_t miniEntries, startEntries = 0U,
   \                     ??USDHC_SetADMA2Descriptor_1: (+1)
   \       0x38   0x2200             MOVS     R2,#+0
   1260                                    maxEntries = (admaTableWords * sizeof(uint32_t)) / sizeof(usdhc_adma2_descriptor_t);
   \       0x3A   0x00BF             LSLS     R7,R7,#+2
   \       0x3C   0x08FF             LSRS     R7,R7,#+3
   1261              usdhc_adma2_descriptor_t *adma2EntryAddress = (usdhc_adma2_descriptor_t *)(admaTable);
   1262              uint32_t i, dmaBufferLen = 0U;
   1263              const uint32_t *data = dataBufferAddr;
   1264          
   1265              if (((uint32_t)data % USDHC_ADMA2_ADDRESS_ALIGN) != 0U)
   \       0x3E   0xF015 0x0003      ANDS     R0,R5,#0x3
   \       0x42   0xD002             BEQ.N    ??USDHC_SetADMA2Descriptor_2
   1266              {
   1267                  return kStatus_USDHC_DMADataAddrNotAlign;
   \       0x44   0xF641 0x1068      MOVW     R0,#+6504
   \       0x48   0xE05E             B.N      ??USDHC_SetADMA2Descriptor_3
   1268              }
   \                     ??USDHC_SetADMA2Descriptor_2: (+1)
   \       0x4A   0x4631             MOV      R1,R6
   1269              /*
   1270               * Add non aligned access support ,user need make sure your buffer size is big
   1271               * enough to hold the data,in other words,user need make sure the buffer size
   1272               * is 4 byte aligned
   1273               */
   1274              if (dataBytes % sizeof(uint32_t) != 0U)
   \       0x4C   0xF011 0x0F03      TST      R1,#0x3
   \       0x50   0xD003             BEQ.N    ??USDHC_SetADMA2Descriptor_4
   1275              {
   1276                  /* make the data length as word-aligned */
   1277                  dataBytes += sizeof(uint32_t) - (dataBytes % sizeof(uint32_t));
   \       0x52   0x1D08             ADDS     R0,R1,#+4
   \       0x54   0xF001 0x0103      AND      R1,R1,#0x3
   \       0x58   0x1A41             SUBS     R1,R0,R1
   1278              }
   1279          
   1280              /* Check if ADMA descriptor's number is enough. */
   1281              if ((dataBytes % USDHC_ADMA2_DESCRIPTOR_MAX_LENGTH_PER_ENTRY) == 0U)
   \                     ??USDHC_SetADMA2Descriptor_4: (+1)
   \       0x5A   0xF64F 0x73FC      MOVW     R3,#+65532
   \       0x5E   0x4618             MOV      R0,R3
   \       0x60   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \       0x64   0xFB03 0x1010      MLS      R0,R3,R0,R1
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0x4618             MOV      R0,R3
   \       0x6C   0xFBB1 0xFCF0      UDIV     R12,R1,R0
   \       0x70   0xD001             BEQ.N    ??USDHC_SetADMA2Descriptor_5
   1282              {
   1283                  miniEntries = dataBytes / USDHC_ADMA2_DESCRIPTOR_MAX_LENGTH_PER_ENTRY;
   1284              }
   1285              else
   1286              {
   1287                  miniEntries = ((dataBytes / USDHC_ADMA2_DESCRIPTOR_MAX_LENGTH_PER_ENTRY) + 1U);
   \       0x72   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??USDHC_SetADMA2Descriptor_5: (+1)
   \       0x76   0x9E06             LDR      R6,[SP, #+24]
   1288              }
   1289              /* calucate the start entry for multiple descriptor mode, ADMA engine is not stop, so update the descriptor
   1290              data adress and data size is enough */
   1291              if (flags == kUSDHC_AdmaDescriptorMultipleFlag)
   \       0x78   0x2E01             CMP      R6,#+1
   \       0x7A   0xD149             BNE.N    ??USDHC_SetADMA2Descriptor_6
   1292              {
   1293                  for (i = 0U; i < maxEntries; i++)
   \                     ??USDHC_SetADMA2Descriptor_7: (+1)
   \       0x7C   0x42BA             CMP      R2,R7
   \       0x7E   0xD245             BCS.N    ??USDHC_SetADMA2Descriptor_8
   1294                  {
   1295                      if ((adma2EntryAddress[i].attribute & kUSDHC_Adma2DescriptorValidFlag) == 0U)
   \       0x80   0xF814 0x0032      LDRB     R0,[R4, R2, LSL #+3]
   \       0x84   0x07C0             LSLS     R0,R0,#+31
   \       0x86   0xD541             BPL.N    ??USDHC_SetADMA2Descriptor_8
   1296                      {
   1297                          break;
   1298                      }
   1299                  }
   \       0x88   0x1C52             ADDS     R2,R2,#+1
   \       0x8A   0xE7F7             B.N      ??USDHC_SetADMA2Descriptor_7
   1300                  startEntries = i;
   1301                  /* add one entry for dummy entry */
   1302                  miniEntries += 1U;
   1303              }
   1304          
   1305              if ((miniEntries + startEntries) > maxEntries)
   1306              {
   1307                  return kStatus_OutOfRange;
   1308              }
   1309          
   1310              for (i = startEntries; i < (miniEntries + startEntries); i++)
   \                     ??USDHC_SetADMA2Descriptor_9: (+1)
   \       0x8C   0x4617             MOV      R7,R2
   \       0x8E   0xE01C             B.N      ??USDHC_SetADMA2Descriptor_10
   1311              {
   1312                  if (dataBytes > USDHC_ADMA2_DESCRIPTOR_MAX_LENGTH_PER_ENTRY)
   1313                  {
   1314                      dmaBufferLen = USDHC_ADMA2_DESCRIPTOR_MAX_LENGTH_PER_ENTRY;
   1315                  }
   1316                  else
   1317                  {
   1318                      dmaBufferLen = (dataBytes == 0U ? sizeof(uint32_t) :
   1319                                                        dataBytes); /* adma don't support 0 data length transfer descriptor */
   1320                  }
   1321          
   1322                  /* Each descriptor for ADMA2 is 64-bit in length */
   1323                  adma2EntryAddress[i].address = (dataBytes == 0U) ? &s_usdhcBootDummy : data;
   1324                  adma2EntryAddress[i].attribute = (dmaBufferLen << USDHC_ADMA2_DESCRIPTOR_LENGTH_SHIFT);
   1325                  adma2EntryAddress[i].attribute |=
   1326                      (dataBytes == 0U) ? 0U : (kUSDHC_Adma2DescriptorTypeTransfer | kUSDHC_Adma2DescriptorInterruptFlag);
   \                     ??USDHC_SetADMA2Descriptor_11: (+1)
   \       0x90   0xF04F 0x0E25      MOV      LR,#+37
   \       0x94   0xE00B             B.N      ??USDHC_SetADMA2Descriptor_12
   \                     ??USDHC_SetADMA2Descriptor_13: (+1)
   \       0x96   0x46AE             MOV      LR,R5
   \                     ??USDHC_SetADMA2Descriptor_14: (+1)
   \       0x98   0xEB04 0x08C7      ADD      R8,R4,R7, LSL #+3
   \       0x9C   0xF8C8 0xE004      STR      LR,[R8, #+4]
   \       0xA0   0xEA4F 0x4E00      LSL      LR,R0,#+16
   \       0xA4   0xF844 0xE037      STR      LR,[R4, R7, LSL #+3]
   \       0xA8   0xD1F2             BNE.N    ??USDHC_SetADMA2Descriptor_11
   \       0xAA   0xF04F 0x0E00      MOV      LR,#+0
   \                     ??USDHC_SetADMA2Descriptor_12: (+1)
   \       0xAE   0xF854 0x8037      LDR      R8,[R4, R7, LSL #+3]
   \       0xB2   0xEA4E 0x0E08      ORR      LR,LR,R8
   \       0xB6   0xF844 0xE037      STR      LR,[R4, R7, LSL #+3]
   1327                  data += (dmaBufferLen / sizeof(uint32_t));
   \       0xBA   0x4686             MOV      LR,R0
   \       0xBC   0xEA4F 0x0E9E      LSR      LR,LR,#+2
   \       0xC0   0xEB05 0x058E      ADD      R5,R5,LR, LSL #+2
   1328          
   1329                  if (dataBytes != 0U)
   \       0xC4   0xD000             BEQ.N    ??USDHC_SetADMA2Descriptor_15
   1330                  {
   1331                      dataBytes -= dmaBufferLen;
   \       0xC6   0x1A09             SUBS     R1,R1,R0
   1332                  }
   \                     ??USDHC_SetADMA2Descriptor_15: (+1)
   \       0xC8   0x1C7F             ADDS     R7,R7,#+1
   \                     ??USDHC_SetADMA2Descriptor_10: (+1)
   \       0xCA   0xEB02 0x000C      ADD      R0,R2,R12
   \       0xCE   0x4287             CMP      R7,R0
   \       0xD0   0xD224             BCS.N    ??USDHC_SetADMA2Descriptor_16
   \       0xD2   0xF64F 0x70FD      MOVW     R0,#+65533
   \       0xD6   0x4281             CMP      R1,R0
   \       0xD8   0xD301             BCC.N    ??USDHC_SetADMA2Descriptor_17
   \       0xDA   0x4618             MOV      R0,R3
   \       0xDC   0xE004             B.N      ??USDHC_SetADMA2Descriptor_18
   \                     ??USDHC_SetADMA2Descriptor_17: (+1)
   \       0xDE   0x2900             CMP      R1,#+0
   \       0xE0   0xD101             BNE.N    ??USDHC_SetADMA2Descriptor_19
   \       0xE2   0x2004             MOVS     R0,#+4
   \       0xE4   0xE000             B.N      ??USDHC_SetADMA2Descriptor_18
   \                     ??USDHC_SetADMA2Descriptor_19: (+1)
   \       0xE6   0x4608             MOV      R0,R1
   \                     ??USDHC_SetADMA2Descriptor_18: (+1)
   \       0xE8   0x2900             CMP      R1,#+0
   \       0xEA   0xD1D4             BNE.N    ??USDHC_SetADMA2Descriptor_13
   \       0xEC   0x....'....        LDR.W    LR,??DataTable25
   \       0xF0   0xE7D2             B.N      ??USDHC_SetADMA2Descriptor_14
   1333              }
   1334          
   1335              /* add a dummy valid ADMA descriptor for multiple descriptor mode, this is useful when transfer boot data, the ADMA
   1336              engine
   1337              will not stop at block gap */
   1338              if (flags == kUSDHC_AdmaDescriptorMultipleFlag)
   1339              {
   1340                  adma2EntryAddress[startEntries + 1U].attribute |= kUSDHC_Adma2DescriptorTypeTransfer;
   1341              }
   1342              else
   1343              {
   1344                  /* set the end bit */
   1345                  adma2EntryAddress[i - 1U].attribute |= kUSDHC_Adma2DescriptorEndFlag;
   \                     ??USDHC_SetADMA2Descriptor_20: (+1)
   \       0xF2   0xEB04 0x00C7      ADD      R0,R4,R7, LSL #+3
   \       0xF6   0xF850 0x0C08      LDR      R0,[R0, #-8]
   \       0xFA   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0xFE   0xEB04 0x01C7      ADD      R1,R4,R7, LSL #+3
   \      0x102   0xF841 0x0C08      STR      R0,[R1, #-8]
   1346              }
   1347          
   1348              return kStatus_Success;
   \                     ??USDHC_SetADMA2Descriptor_21: (+1)
   \      0x106   0x2000             MOVS     R0,#+0
   \                     ??USDHC_SetADMA2Descriptor_3: (+1)
   \      0x108   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??USDHC_SetADMA2Descriptor_8: (+1)
   \      0x10C   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??USDHC_SetADMA2Descriptor_6: (+1)
   \      0x110   0xEB02 0x000C      ADD      R0,R2,R12
   \      0x114   0x4287             CMP      R7,R0
   \      0x116   0xD2B9             BCS.N    ??USDHC_SetADMA2Descriptor_9
   \      0x118   0x2003             MOVS     R0,#+3
   \      0x11A   0xE7F5             B.N      ??USDHC_SetADMA2Descriptor_3
   \                     ??USDHC_SetADMA2Descriptor_16: (+1)
   \      0x11C   0x2E01             CMP      R6,#+1
   \      0x11E   0xD1E8             BNE.N    ??USDHC_SetADMA2Descriptor_20
   \      0x120   0xEB04 0x00C2      ADD      R0,R4,R2, LSL #+3
   \      0x124   0x6880             LDR      R0,[R0, #+8]
   \      0x126   0xF040 0x0021      ORR      R0,R0,#0x21
   \      0x12A   0xEB04 0x02C2      ADD      R2,R4,R2, LSL #+3
   \      0x12E   0x6090             STR      R0,[R2, #+8]
   \      0x130   0xE7E9             B.N      ??USDHC_SetADMA2Descriptor_21
   1349          }
   1350          
   1351          /*!
   1352           * brief Internal DMA configuration.
   1353           * This function is used to config the USDHC DMA related registers.
   1354           * param base USDHC peripheral base address.
   1355           * param adma configuration
   1356           * param dataAddr transfer data address, a simple DMA parameter, if ADMA is used, leave it to NULL.
   1357           * param enAutoCmd23 flag to indicate Auto CMD23 is enable or not, a simple DMA parameter,if ADMA is used, leave it to
   1358           * false.
   1359           * retval kStatus_OutOfRange ADMA descriptor table length isn't enough to describe data.
   1360           * retval kStatus_Success Operate successfully.
   1361           */

   \                                 In section .text, align 2, keep-with-next
   1362          status_t USDHC_SetInternalDmaConfig(USDHC_Type *base,
   1363                                              usdhc_adma_config_t *dmaConfig,
   1364                                              const uint32_t *dataAddr,
   1365                                              bool enAutoCmd23)
   1366          {
   \                     USDHC_SetInternalDmaConfig: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461F             MOV      R7,R3
   1367              assert(dmaConfig);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD109             BNE.N    ??USDHC_SetInternalDmaConfig_0
   \        0xE   0xF240 0x5257      MOVW     R2,#+1367
   \       0x12   0x....'....        LDR.W    R1,??DataTable28_7
   \       0x16   0x....'....        LDR.W    R0,??DataTable28_8
   \       0x1A   0x....'....        BL       __aeabi_assert
   \       0x1E   0x....'....        BL       __iar_EmptyStepPoint
   1368              assert(dataAddr);
   \                     ??USDHC_SetInternalDmaConfig_0: (+1)
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD109             BNE.N    ??USDHC_SetInternalDmaConfig_1
   \       0x26   0xF44F 0x62AB      MOV      R2,#+1368
   \       0x2A   0x....'....        LDR.W    R1,??DataTable28_7
   \       0x2E   0x....'....        LDR.W    R0,??DataTable28_9
   \       0x32   0x....'....        BL       __aeabi_assert
   \       0x36   0x....'....        BL       __iar_EmptyStepPoint
   1369              assert((NULL != dmaConfig->admaTable) &&
   1370                     (((USDHC_ADMA_TABLE_ADDRESS_ALIGN - 1U) & (uint32_t)dmaConfig->admaTable) == 0U));
   \                     ??USDHC_SetInternalDmaConfig_1: (+1)
   \       0x3A   0x6860             LDR      R0,[R4, #+4]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD003             BEQ.N    ??USDHC_SetInternalDmaConfig_2
   \       0x40   0x7920             LDRB     R0,[R4, #+4]
   \       0x42   0xF010 0x0F03      TST      R0,#0x3
   \       0x46   0xD009             BEQ.N    ??USDHC_SetInternalDmaConfig_3
   \                     ??USDHC_SetInternalDmaConfig_2: (+1)
   \       0x48   0xF240 0x525A      MOVW     R2,#+1370
   \       0x4C   0x....'....        LDR.W    R1,??DataTable28_7
   \       0x50   0x....'....        LDR.W    R0,??DataTable28_10
   \       0x54   0x....'....        BL       __aeabi_assert
   \       0x58   0x....'....        BL       __iar_EmptyStepPoint
   1371          
   1372          #if FSL_FEATURE_USDHC_HAS_EXT_DMA
   1373              /* disable the external DMA if support */
   1374              base->VEND_SPEC &= ~USDHC_VEND_SPEC_EXT_DMA_EN_MASK;
   1375          #endif
   1376          
   1377              if (dmaConfig->dmaMode == kUSDHC_DmaModeSimple)
   \                     ??USDHC_SetInternalDmaConfig_3: (+1)
   \       0x5C   0x7820             LDRB     R0,[R4, #+0]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD10B             BNE.N    ??USDHC_SetInternalDmaConfig_4
   1378              {
   1379                  /* check DMA data buffer address align or not */
   1380                  if (((uint32_t)dataAddr % USDHC_ADMA2_ADDRESS_ALIGN) != 0U)
   \       0x62   0xF015 0x0003      ANDS     R0,R5,#0x3
   \       0x66   0xD002             BEQ.N    ??USDHC_SetInternalDmaConfig_5
   1381                  {
   1382                      return kStatus_USDHC_DMADataAddrNotAlign;
   \       0x68   0xF641 0x1068      MOVW     R0,#+6504
   \       0x6C   0xBDF2             POP      {R1,R4-R7,PC}
   1383                  }
   1384                  /* in simple DMA mode if use auto CMD23, address should load to ADMA addr,
   1385                       and block count should load to DS_ADDR*/
   1386                  if (enAutoCmd23)
   \                     ??USDHC_SetInternalDmaConfig_5: (+1)
   \       0x6E   0x2F00             CMP      R7,#+0
   \       0x70   0xD001             BEQ.N    ??USDHC_SetInternalDmaConfig_6
   1387                  {
   1388                      base->ADMA_SYS_ADDR = (uint32_t)dataAddr;
   \       0x72   0x65B5             STR      R5,[R6, #+88]
   \       0x74   0xE005             B.N      ??USDHC_SetInternalDmaConfig_7
   1389                  }
   1390                  else
   1391                  {
   1392                      base->DS_ADDR = (uint32_t)dataAddr;
   \                     ??USDHC_SetInternalDmaConfig_6: (+1)
   \       0x76   0x6035             STR      R5,[R6, #+0]
   \       0x78   0xE003             B.N      ??USDHC_SetInternalDmaConfig_7
   1393                  }
   1394              }
   1395              else
   1396              {
   1397                  /* When use ADMA, disable simple DMA */
   1398                  base->DS_ADDR = 0U;
   \                     ??USDHC_SetInternalDmaConfig_4: (+1)
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x6030             STR      R0,[R6, #+0]
   1399                  base->ADMA_SYS_ADDR = (uint32_t)(dmaConfig->admaTable);
   \       0x7E   0x6860             LDR      R0,[R4, #+4]
   \       0x80   0x65B0             STR      R0,[R6, #+88]
   1400              }
   1401          
   1402              /* select DMA mode and config the burst length */
   1403              base->PROT_CTRL &= ~(USDHC_PROT_CTRL_DMASEL_MASK | USDHC_PROT_CTRL_BURST_LEN_EN_MASK);
   \                     ??USDHC_SetInternalDmaConfig_7: (+1)
   \       0x82   0x6AB1             LDR      R1,[R6, #+40]
   \       0x84   0x....'....        LDR.W    R0,??DataTable28_11  ;; 0xc7fffcff
   \       0x88   0x4001             ANDS     R1,R0,R1
   \       0x8A   0x62B1             STR      R1,[R6, #+40]
   1404              base->PROT_CTRL |= USDHC_PROT_CTRL_DMASEL(dmaConfig->dmaMode) | USDHC_PROT_CTRL_BURST_LEN_EN(dmaConfig->burstLen);
   \       0x8C   0x6AB0             LDR      R0,[R6, #+40]
   \       0x8E   0x7821             LDRB     R1,[R4, #+0]
   \       0x90   0x0209             LSLS     R1,R1,#+8
   \       0x92   0xF401 0x7140      AND      R1,R1,#0x300
   \       0x96   0x7862             LDRB     R2,[R4, #+1]
   \       0x98   0x06D2             LSLS     R2,R2,#+27
   \       0x9A   0xF002 0x5260      AND      R2,R2,#0x38000000
   \       0x9E   0x4311             ORRS     R1,R2,R1
   \       0xA0   0x4308             ORRS     R0,R1,R0
   \       0xA2   0x62B0             STR      R0,[R6, #+40]
   1405              /* enable DMA */
   1406              base->MIX_CTRL |= USDHC_MIX_CTRL_DMAEN_MASK;
   \       0xA4   0x6CB0             LDR      R0,[R6, #+72]
   \       0xA6   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0xAA   0x64B0             STR      R0,[R6, #+72]
   1407          
   1408              return kStatus_Success;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1409          }
   1410          
   1411          /*!
   1412           * brief Sets the DMA descriptor table configuration.
   1413           * A high level DMA descriptor configuration function.
   1414           * param base USDHC peripheral base address.
   1415           * param adma configuration
   1416           * param data Data descriptor
   1417           * param flags ADAM descriptor flag, used to indicate to create multiple or single descriptor, please
   1418           *  reference _usdhc_adma_flag
   1419           * retval kStatus_OutOfRange ADMA descriptor table length isn't enough to describe data.
   1420           * retval kStatus_Success Operate successfully.
   1421           */

   \                                 In section .text, align 2, keep-with-next
   1422          status_t USDHC_SetAdmaTableConfig(USDHC_Type *base,
   1423                                            usdhc_adma_config_t *dmaConfig,
   1424                                            usdhc_data_t *dataConfig,
   1425                                            uint32_t flags)
   1426          {
   \                     USDHC_SetAdmaTableConfig: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461F             MOV      R7,R3
   1427              assert(NULL != dmaConfig);
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD109             BNE.N    ??USDHC_SetAdmaTableConfig_0
   \       0x10   0xF240 0x5293      MOVW     R2,#+1427
   \       0x14   0x....'....        LDR.W    R1,??DataTable28_7
   \       0x18   0x....'....        LDR.W    R0,??DataTable28_12
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1428              assert((NULL != dmaConfig->admaTable) &&
   1429                     (((USDHC_ADMA_TABLE_ADDRESS_ALIGN - 1U) & (uint32_t)dmaConfig->admaTable) == 0U));
   \                     ??USDHC_SetAdmaTableConfig_0: (+1)
   \       0x24   0x6860             LDR      R0,[R4, #+4]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD003             BEQ.N    ??USDHC_SetAdmaTableConfig_1
   \       0x2A   0x7920             LDRB     R0,[R4, #+4]
   \       0x2C   0xF010 0x0F03      TST      R0,#0x3
   \       0x30   0xD009             BEQ.N    ??USDHC_SetAdmaTableConfig_2
   \                     ??USDHC_SetAdmaTableConfig_1: (+1)
   \       0x32   0xF240 0x5295      MOVW     R2,#+1429
   \       0x36   0x....'....        LDR.W    R1,??DataTable28_7
   \       0x3A   0x....'....        LDR.W    R0,??DataTable28_10
   \       0x3E   0x....'....        BL       __aeabi_assert
   \       0x42   0x....'....        BL       __iar_EmptyStepPoint
   1430              assert(NULL != dataConfig);
   \                     ??USDHC_SetAdmaTableConfig_2: (+1)
   \       0x46   0x2D00             CMP      R5,#+0
   \       0x48   0xD109             BNE.N    ??USDHC_SetAdmaTableConfig_3
   \       0x4A   0xF240 0x5296      MOVW     R2,#+1430
   \       0x4E   0x....'....        LDR.W    R1,??DataTable28_7
   \       0x52   0x....'....        LDR.W    R0,??DataTable28_13
   \       0x56   0x....'....        BL       __aeabi_assert
   \       0x5A   0x....'....        BL       __iar_EmptyStepPoint
   1431          
   1432              status_t error = kStatus_Fail;
   1433              uint32_t bootDummyOffset = dataConfig->dataType == kUSDHC_TransferDataBootcontinous ? sizeof(uint32_t) : 0U;
   \                     ??USDHC_SetAdmaTableConfig_3: (+1)
   \       0x5E   0x78E8             LDRB     R0,[R5, #+3]
   \       0x60   0x2803             CMP      R0,#+3
   \       0x62   0xD101             BNE.N    ??USDHC_SetAdmaTableConfig_4
   \       0x64   0x2304             MOVS     R3,#+4
   \       0x66   0xE000             B.N      ??USDHC_SetAdmaTableConfig_5
   \                     ??USDHC_SetAdmaTableConfig_4: (+1)
   \       0x68   0x2300             MOVS     R3,#+0
   1434              const uint32_t *data =
   1435                  (const uint32_t *)((uint32_t)((dataConfig->rxData == NULL) ? dataConfig->txData : dataConfig->rxData) +
   1436                                     bootDummyOffset);
   \                     ??USDHC_SetAdmaTableConfig_5: (+1)
   \       0x6A   0x68E8             LDR      R0,[R5, #+12]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD102             BNE.N    ??USDHC_SetAdmaTableConfig_6
   \       0x70   0xF8D5 0x8010      LDR      R8,[R5, #+16]
   \       0x74   0xE000             B.N      ??USDHC_SetAdmaTableConfig_7
   \                     ??USDHC_SetAdmaTableConfig_6: (+1)
   \       0x76   0x4680             MOV      R8,R0
   \                     ??USDHC_SetAdmaTableConfig_7: (+1)
   \       0x78   0x4498             ADD      R8,R3,R8
   1437              uint32_t blockSize = dataConfig->blockSize * dataConfig->blockCount - bootDummyOffset;
   \       0x7A   0x6869             LDR      R1,[R5, #+4]
   \       0x7C   0x68A8             LDR      R0,[R5, #+8]
   \       0x7E   0x4341             MULS     R1,R0,R1
   \       0x80   0x1ACB             SUBS     R3,R1,R3
   1438          
   1439              switch (dmaConfig->dmaMode)
   \       0x82   0x7820             LDRB     R0,[R4, #+0]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD003             BEQ.N    ??USDHC_SetAdmaTableConfig_8
   \       0x88   0x2802             CMP      R0,#+2
   \       0x8A   0xD01B             BEQ.N    ??USDHC_SetAdmaTableConfig_9
   \       0x8C   0xD313             BCC.N    ??USDHC_SetAdmaTableConfig_10
   \       0x8E   0xE020             B.N      ??USDHC_SetAdmaTableConfig_11
   1440              {
   1441          #if FSL_FEATURE_USDHC_HAS_EXT_DMA
   1442                  case kUSDHC_ExternalDMA:
   1443                      /* enable the external DMA */
   1444                      base->VEND_SPEC |= USDHC_VEND_SPEC_EXT_DMA_EN_MASK;
   1445                      break;
   1446          #endif
   1447                  case kUSDHC_DmaModeSimple:
   1448                      error = kStatus_Success;
   \                     ??USDHC_SetAdmaTableConfig_8: (+1)
   \       0x90   0x2000             MOVS     R0,#+0
   1449                      break;
   1450          
   1451                  case kUSDHC_DmaModeAdma1:
   1452                      error = USDHC_SetADMA1Descriptor(dmaConfig->admaTable, dmaConfig->admaTableWords, data, blockSize, flags);
   1453                      break;
   1454          
   1455                  case kUSDHC_DmaModeAdma2:
   1456                      error = USDHC_SetADMA2Descriptor(dmaConfig->admaTable, dmaConfig->admaTableWords, data, blockSize, flags);
   1457                      break;
   1458                  default:
   1459                      return kStatus_USDHC_PrepareAdmaDescriptorFailed;
   1460              }
   1461          
   1462              /* for internal dma, internal DMA configurations should not update the configurations when continous transfer the
   1463               * boot data, only the DMA descriptor need update */
   1464              if ((dmaConfig->dmaMode != kUSDHC_ExternalDMA) && (error == kStatus_Success) &&
   1465                  (dataConfig->dataType != kUSDHC_TransferDataBootcontinous))
   \                     ??USDHC_SetAdmaTableConfig_12: (+1)
   \       0x92   0x7821             LDRB     R1,[R4, #+0]
   \       0x94   0x2903             CMP      R1,#+3
   \       0x96   0xD00C             BEQ.N    ??USDHC_SetAdmaTableConfig_13
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD10A             BNE.N    ??USDHC_SetAdmaTableConfig_13
   \       0x9C   0x78E9             LDRB     R1,[R5, #+3]
   \       0x9E   0x2903             CMP      R1,#+3
   \       0xA0   0xD007             BEQ.N    ??USDHC_SetAdmaTableConfig_13
   1466              {
   1467                  error = USDHC_SetInternalDmaConfig(base, dmaConfig, data, dataConfig->enableAutoCommand23);
   \       0xA2   0x786B             LDRB     R3,[R5, #+1]
   \       0xA4   0x4642             MOV      R2,R8
   \       0xA6   0x4621             MOV      R1,R4
   \       0xA8   0x4630             MOV      R0,R6
   \       0xAA   0xB002             ADD      SP,SP,#+8
   \       0xAC   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xB0   0x....             B.N      USDHC_SetInternalDmaConfig
   1468              }
   1469          
   1470              return error;
   \                     ??USDHC_SetAdmaTableConfig_13: (+1)
   \       0xB2   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   \                     ??USDHC_SetAdmaTableConfig_10: (+1)
   \       0xB6   0x9700             STR      R7,[SP, #+0]
   \       0xB8   0x4642             MOV      R2,R8
   \       0xBA   0x68A1             LDR      R1,[R4, #+8]
   \       0xBC   0x6860             LDR      R0,[R4, #+4]
   \       0xBE   0x....'....        BL       USDHC_SetADMA1Descriptor
   \       0xC2   0xE7E6             B.N      ??USDHC_SetAdmaTableConfig_12
   \                     ??USDHC_SetAdmaTableConfig_9: (+1)
   \       0xC4   0x9700             STR      R7,[SP, #+0]
   \       0xC6   0x4642             MOV      R2,R8
   \       0xC8   0x68A1             LDR      R1,[R4, #+8]
   \       0xCA   0x6860             LDR      R0,[R4, #+4]
   \       0xCC   0x....'....        BL       USDHC_SetADMA2Descriptor
   \       0xD0   0xE7DF             B.N      ??USDHC_SetAdmaTableConfig_12
   \                     ??USDHC_SetAdmaTableConfig_11: (+1)
   \       0xD2   0xF641 0x1065      MOVW     R0,#+6501
   \       0xD6   0xE7EC             B.N      ??USDHC_SetAdmaTableConfig_13
   1471          }
   1472          
   1473          /*!
   1474           * brief Transfers the command/data using a blocking method.
   1475           *
   1476           * This function waits until the command response/data is received or the USDHC encounters an error by polling the
   1477           * status
   1478           * flag.
   1479           * The application must not call this API in multiple threads at the same time. Because of that this API doesn't support
   1480           * the re-entry mechanism.
   1481           *
   1482           * note There is no need to call the API 'USDHC_TransferCreateHandle' when calling this API.
   1483           *
   1484           * param base USDHC peripheral base address.
   1485           * param adma configuration
   1486           * param transfer Transfer content.
   1487           * retval kStatus_InvalidArgument Argument is invalid.
   1488           * retval kStatus_USDHC_PrepareAdmaDescriptorFailed Prepare ADMA descriptor failed.
   1489           * retval kStatus_USDHC_SendCommandFailed Send command failed.
   1490           * retval kStatus_USDHC_TransferDataFailed Transfer data failed.
   1491           * retval kStatus_Success Operate successfully.
   1492           */

   \                                 In section .text, align 2, keep-with-next
   1493          status_t USDHC_TransferBlocking(USDHC_Type *base, usdhc_adma_config_t *dmaConfig, usdhc_transfer_t *transfer)
   1494          {
   \                     USDHC_TransferBlocking: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x0014             MOVS     R4,R2
   1495              assert(transfer);
   \        0xA   0xD109             BNE.N    ??USDHC_TransferBlocking_0
   \        0xC   0xF240 0x52D7      MOVW     R2,#+1495
   \       0x10   0x....'....        LDR.W    R1,??DataTable28_7
   \       0x14   0x....'....        LDR.W    R0,??DataTable28_14
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
   1496          
   1497              status_t error = kStatus_Fail;
   \                     ??USDHC_TransferBlocking_0: (+1)
   \       0x20   0x2601             MOVS     R6,#+1
   1498              usdhc_command_t *command = transfer->command;
   \       0x22   0xF8D4 0x8004      LDR      R8,[R4, #+4]
   1499              usdhc_data_t *data = transfer->data;
   \       0x26   0x6824             LDR      R4,[R4, #+0]
   1500              bool enDMA = true;
   \       0x28   0x46B1             MOV      R9,R6
   1501              bool executeTuning = ((data == NULL) ? false : data->dataType == kUSDHC_TransferDataTuning);
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD101             BNE.N    ??USDHC_TransferBlocking_1
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xE005             B.N      ??USDHC_TransferBlocking_2
   \                     ??USDHC_TransferBlocking_1: (+1)
   \       0x32   0x78E0             LDRB     R0,[R4, #+3]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD101             BNE.N    ??USDHC_TransferBlocking_3
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0xE000             B.N      ??USDHC_TransferBlocking_2
   \                     ??USDHC_TransferBlocking_3: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??USDHC_TransferBlocking_2: (+1)
   \       0x3E   0x4682             MOV      R10,R0
   \       0x40   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \       0x44   0xEB6A 0x0A0A      SBC      R10,R10,R10
   \       0x48   0xEA6F 0x0A0A      MVN      R10,R10
   \       0x4C   0xEA4F 0x7ADA      LSR      R10,R10,#+31
   1502          
   1503              /*check re-tuning request*/
   1504              if ((USDHC_GetInterruptStatusFlags(base) & kUSDHC_ReTuningEventFlag) != 0U)
   \       0x50   0x4638             MOV      R0,R7
   \       0x52   0x....'....        BL       USDHC_GetInterruptStatusFlags
   \       0x56   0x04C0             LSLS     R0,R0,#+19
   \       0x58   0xD507             BPL.N    ??USDHC_TransferBlocking_4
   1505              {
   1506                  USDHC_ClearInterruptStatusFlags(base, kUSDHC_ReTuningEventFlag);
   \       0x5A   0xF44F 0x5180      MOV      R1,#+4096
   \       0x5E   0x4638             MOV      R0,R7
   \       0x60   0x....'....        BL       USDHC_ClearInterruptStatusFlags
   1507                  return kStatus_USDHC_ReTuningRequest;
   \       0x64   0xF641 0x1069      MOVW     R0,#+6505
   \       0x68   0xE03C             B.N      ??USDHC_TransferBlocking_5
   1508              }
   1509          
   1510              /* Update ADMA descriptor table according to different DMA mode(no DMA, ADMA1, ADMA2).*/
   1511              if ((data != NULL) && (dmaConfig != NULL) && (!executeTuning))
   \                     ??USDHC_TransferBlocking_4: (+1)
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD00E             BEQ.N    ??USDHC_TransferBlocking_6
   \       0x6E   0x2D00             CMP      R5,#+0
   \       0x70   0xD00C             BEQ.N    ??USDHC_TransferBlocking_6
   \       0x72   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x76   0xD109             BNE.N    ??USDHC_TransferBlocking_6
   1512              {
   1513                  error = USDHC_SetAdmaTableConfig(base, dmaConfig, data, (data->dataType & kUSDHC_TransferDataBoot) ?
   1514                                                                              kUSDHC_AdmaDescriptorMultipleFlag :
   1515                                                                              kUSDHC_AdmaDescriptorSingleFlag);
   \       0x78   0x78E3             LDRB     R3,[R4, #+3]
   \       0x7A   0x085B             LSRS     R3,R3,#+1
   \       0x7C   0xF003 0x0301      AND      R3,R3,#0x1
   \       0x80   0x4622             MOV      R2,R4
   \       0x82   0x4629             MOV      R1,R5
   \       0x84   0x4638             MOV      R0,R7
   \       0x86   0x....'....        BL       USDHC_SetAdmaTableConfig
   \       0x8A   0x4606             MOV      R6,R0
   1516              }
   1517          
   1518              /* if the DMA desciptor configure fail or not needed , disable it */
   1519              if (error != kStatus_Success)
   \                     ??USDHC_TransferBlocking_6: (+1)
   \       0x8C   0x2E00             CMP      R6,#+0
   \       0x8E   0xD005             BEQ.N    ??USDHC_TransferBlocking_7
   1520              {
   1521                  enDMA = false;
   \       0x90   0xF04F 0x0900      MOV      R9,#+0
   1522                  /* disable DMA, using polling mode in this situation */
   1523                  USDHC_EnableInternalDMA(base, false);
   \       0x94   0x4649             MOV      R1,R9
   \       0x96   0x4638             MOV      R0,R7
   \       0x98   0x....'....        BL       USDHC_EnableInternalDMA
   1524              }
   1525          #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
   1526              else
   1527              {
   1528                  if (data->txData != NULL)
   1529                  {
   1530                      /* clear the DCACHE */
   1531                      DCACHE_CleanByRange((uint32_t)data->txData, (data->blockSize) * (data->blockCount));
   1532                  }
   1533                  else
   1534                  {
   1535                      /* clear the DCACHE */
   1536                      DCACHE_CleanInvalidateByRange((uint32_t)data->rxData, (data->blockSize) * (data->blockCount));
   1537                  }
   1538              }
   1539          #endif
   1540          
   1541              /* config the data transfer parameter */
   1542              error = USDHC_SetDataTransferConfig(base, data, &(command->flags), enDMA);
   \                     ??USDHC_TransferBlocking_7: (+1)
   \       0x9C   0x464B             MOV      R3,R9
   \       0x9E   0xF108 0x0220      ADD      R2,R8,#+32
   \       0xA2   0x4621             MOV      R1,R4
   \       0xA4   0x4638             MOV      R0,R7
   \       0xA6   0x....'....        BL       USDHC_SetDataTransferConfig
   1543              if (kStatus_Success != error)
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD11A             BNE.N    ??USDHC_TransferBlocking_5
   1544              {
   1545                  return error;
   1546              }
   1547              /* send command first */
   1548              USDHC_SendCommand(base, command);
   \       0xAE   0x4641             MOV      R1,R8
   \       0xB0   0x4638             MOV      R0,R7
   \       0xB2   0x....'....        BL       USDHC_SendCommand
   1549              /* wait command done */
   1550              error = USDHC_WaitCommandDone(base, command, (data == NULL) || (data->dataType == kUSDHC_TransferDataNormal));
   \       0xB6   0x2C00             CMP      R4,#+0
   \       0xB8   0xD004             BEQ.N    ??USDHC_TransferBlocking_8
   \       0xBA   0x78E0             LDRB     R0,[R4, #+3]
   \       0xBC   0x1E42             SUBS     R2,R0,#+1
   \       0xBE   0x4192             SBCS     R2,R2,R2
   \       0xC0   0x0FD2             LSRS     R2,R2,#+31
   \       0xC2   0xE000             B.N      ??USDHC_TransferBlocking_9
   \                     ??USDHC_TransferBlocking_8: (+1)
   \       0xC4   0x2201             MOVS     R2,#+1
   \                     ??USDHC_TransferBlocking_9: (+1)
   \       0xC6   0x4641             MOV      R1,R8
   \       0xC8   0x4638             MOV      R0,R7
   \       0xCA   0x....'....        BL       USDHC_WaitCommandDone
   1551          
   1552              /* wait transfer data finsih */
   1553              if ((data != NULL) && (error == kStatus_Success))
   \       0xCE   0x2C00             CMP      R4,#+0
   \       0xD0   0xD008             BEQ.N    ??USDHC_TransferBlocking_5
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD106             BNE.N    ??USDHC_TransferBlocking_5
   1554              {
   1555                  return USDHC_TransferDataBlocking(base, data, enDMA);
   \       0xD6   0x464A             MOV      R2,R9
   \       0xD8   0x4621             MOV      R1,R4
   \       0xDA   0x4638             MOV      R0,R7
   \       0xDC   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \       0xE0   0x....'....        B.W      USDHC_TransferDataBlocking
   1556              }
   1557          
   1558              return error;
   \                     ??USDHC_TransferBlocking_5: (+1)
   \       0xE4   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1559          }
   1560          
   1561          /*!
   1562           * brief Transfers the command/data using an interrupt and an asynchronous method.
   1563           *
   1564           * This function sends a command and data and returns immediately. It doesn't wait the transfer complete or encounter an
   1565           * error.
   1566           * The application must not call this API in multiple threads at the same time. Because of that this API doesn't support
   1567           * the re-entry mechanism.
   1568           *
   1569           * note Call the API 'USDHC_TransferCreateHandle' when calling this API.
   1570           *
   1571           * param base USDHC peripheral base address.
   1572           * param handle USDHC handle.
   1573           * param adma configuration.
   1574           * param transfer Transfer content.
   1575           * retval kStatus_InvalidArgument Argument is invalid.
   1576           * retval kStatus_USDHC_BusyTransferring Busy transferring.
   1577           * retval kStatus_USDHC_PrepareAdmaDescriptorFailed Prepare ADMA descriptor failed.
   1578           * retval kStatus_Success Operate successfully.
   1579           */

   \                                 In section .text, align 2, keep-with-next
   1580          status_t USDHC_TransferNonBlocking(USDHC_Type *base,
   1581                                             usdhc_handle_t *handle,
   1582                                             usdhc_adma_config_t *dmaConfig,
   1583                                             usdhc_transfer_t *transfer)
   1584          {
   \                     USDHC_TransferNonBlocking: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4693             MOV      R11,R2
   \        0xA   0x461C             MOV      R4,R3
   1585              assert(handle);
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD109             BNE.N    ??USDHC_TransferNonBlocking_0
   \       0x10   0xF240 0x6231      MOVW     R2,#+1585
   \       0x14   0x....'....        LDR.W    R1,??DataTable28_7
   \       0x18   0x....'....        LDR.W    R0,??DataTable28_15
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1586              assert(transfer);
   \                     ??USDHC_TransferNonBlocking_0: (+1)
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD109             BNE.N    ??USDHC_TransferNonBlocking_1
   \       0x28   0xF240 0x6232      MOVW     R2,#+1586
   \       0x2C   0x....'....        LDR.W    R1,??DataTable28_7
   \       0x30   0x....'....        LDR.W    R0,??DataTable28_14
   \       0x34   0x....'....        BL       __aeabi_assert
   \       0x38   0x....'....        BL       __iar_EmptyStepPoint
   1587          
   1588              status_t error = kStatus_Fail;
   \                     ??USDHC_TransferNonBlocking_1: (+1)
   \       0x3C   0x2501             MOVS     R5,#+1
   1589              usdhc_command_t *command = transfer->command;
   \       0x3E   0x6867             LDR      R7,[R4, #+4]
   1590              usdhc_data_t *data = transfer->data;
   \       0x40   0x6824             LDR      R4,[R4, #+0]
   1591              bool executeTuning = ((data == NULL) ? false : data->dataType == kUSDHC_TransferDataTuning);
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD101             BNE.N    ??USDHC_TransferNonBlocking_2
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xE005             B.N      ??USDHC_TransferNonBlocking_3
   \                     ??USDHC_TransferNonBlocking_2: (+1)
   \       0x4A   0x78E0             LDRB     R0,[R4, #+3]
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD101             BNE.N    ??USDHC_TransferNonBlocking_4
   \       0x50   0x4628             MOV      R0,R5
   \       0x52   0xE000             B.N      ??USDHC_TransferNonBlocking_3
   \                     ??USDHC_TransferNonBlocking_4: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??USDHC_TransferNonBlocking_3: (+1)
   \       0x56   0x4681             MOV      R9,R0
   \       0x58   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \       0x5C   0xEB69 0x0909      SBC      R9,R9,R9
   \       0x60   0xEA6F 0x0909      MVN      R9,R9
   \       0x64   0xEA4F 0x79D9      LSR      R9,R9,#+31
   1592              bool enDMA = true;
   \       0x68   0x46AA             MOV      R10,R5
   1593          
   1594              /*check re-tuning request*/
   1595              if ((USDHC_GetInterruptStatusFlags(base) & (kUSDHC_ReTuningEventFlag)) != 0U)
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0x....'....        BL       USDHC_GetInterruptStatusFlags
   \       0x70   0x04C0             LSLS     R0,R0,#+19
   \       0x72   0xD507             BPL.N    ??USDHC_TransferNonBlocking_5
   1596              {
   1597                  USDHC_ClearInterruptStatusFlags(base, kUSDHC_ReTuningEventFlag);
   \       0x74   0xF44F 0x5180      MOV      R1,#+4096
   \       0x78   0x4640             MOV      R0,R8
   \       0x7A   0x....'....        BL       USDHC_ClearInterruptStatusFlags
   1598                  return kStatus_USDHC_ReTuningRequest;
   \       0x7E   0xF641 0x1069      MOVW     R0,#+6505
   \       0x82   0xE02A             B.N      ??USDHC_TransferNonBlocking_6
   1599              }
   1600          
   1601              /* Save command and data into handle before transferring. */
   1602          
   1603              handle->command = command;
   \                     ??USDHC_TransferNonBlocking_5: (+1)
   \       0x84   0x6077             STR      R7,[R6, #+4]
   1604              handle->data = data;
   \       0x86   0x6034             STR      R4,[R6, #+0]
   1605              /* transferredWords will only be updated in ISR when transfer way is DATAPORT. */
   1606              handle->transferredWords = 0U;
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0x60B0             STR      R0,[R6, #+8]
   1607          
   1608              /* Update ADMA descriptor table according to different DMA mode(no DMA, ADMA1, ADMA2).*/
   1609              if ((data != NULL) && (dmaConfig != NULL) && (!executeTuning))
   \       0x8C   0x2C00             CMP      R4,#+0
   \       0x8E   0xD00E             BEQ.N    ??USDHC_TransferNonBlocking_7
   \       0x90   0x4659             MOV      R1,R11
   \       0x92   0x2900             CMP      R1,#+0
   \       0x94   0xD00B             BEQ.N    ??USDHC_TransferNonBlocking_7
   \       0x96   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x9A   0xD108             BNE.N    ??USDHC_TransferNonBlocking_7
   1610              {
   1611                  error = USDHC_SetAdmaTableConfig(base, dmaConfig, data, (data->dataType & kUSDHC_TransferDataBoot) ?
   1612                                                                              kUSDHC_AdmaDescriptorMultipleFlag :
   1613                                                                              kUSDHC_AdmaDescriptorSingleFlag);
   \       0x9C   0x78E3             LDRB     R3,[R4, #+3]
   \       0x9E   0x085B             LSRS     R3,R3,#+1
   \       0xA0   0xF003 0x0301      AND      R3,R3,#0x1
   \       0xA4   0x4622             MOV      R2,R4
   \       0xA6   0x4640             MOV      R0,R8
   \       0xA8   0x....'....        BL       USDHC_SetAdmaTableConfig
   \       0xAC   0x4605             MOV      R5,R0
   1614              }
   1615          
   1616              /* if the DMA desciptor configure fail or not needed , disable it */
   1617              if (error != kStatus_Success)
   \                     ??USDHC_TransferNonBlocking_7: (+1)
   \       0xAE   0x2D00             CMP      R5,#+0
   \       0xB0   0xD005             BEQ.N    ??USDHC_TransferNonBlocking_8
   1618              {
   1619                  /* disable DMA, using polling mode in this situation */
   1620                  USDHC_EnableInternalDMA(base, false);
   \       0xB2   0x2100             MOVS     R1,#+0
   \       0xB4   0x4640             MOV      R0,R8
   \       0xB6   0x....'....        BL       USDHC_EnableInternalDMA
   1621                  enDMA = false;
   \       0xBA   0xF04F 0x0A00      MOV      R10,#+0
   1622              }
   1623          #if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
   1624              else
   1625              {
   1626                  if (data->txData != NULL)
   1627                  {
   1628                      /* clear the DCACHE */
   1629                      DCACHE_CleanByRange((uint32_t)data->txData, (data->blockSize) * (data->blockCount));
   1630                  }
   1631                  else
   1632                  {
   1633                      /* clear the DCACHE */
   1634                      DCACHE_CleanInvalidateByRange((uint32_t)data->rxData, (data->blockSize) * (data->blockCount));
   1635                  }
   1636              }
   1637          #endif
   1638          
   1639              error = USDHC_SetDataTransferConfig(base, data, &(command->flags), enDMA);
   \                     ??USDHC_TransferNonBlocking_8: (+1)
   \       0xBE   0x4653             MOV      R3,R10
   \       0xC0   0xF107 0x0220      ADD      R2,R7,#+32
   \       0xC4   0x4621             MOV      R1,R4
   \       0xC6   0x4640             MOV      R0,R8
   \       0xC8   0x....'....        BL       USDHC_SetDataTransferConfig
   1640              if (kStatus_Success != error)
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD104             BNE.N    ??USDHC_TransferNonBlocking_6
   1641              {
   1642                  return error;
   1643              }
   1644          
   1645              /* send command first */
   1646              USDHC_SendCommand(base, command);
   \       0xD0   0x4639             MOV      R1,R7
   \       0xD2   0x4640             MOV      R0,R8
   \       0xD4   0x....'....        BL       USDHC_SendCommand
   1647          
   1648              return kStatus_Success;
   \       0xD8   0x2000             MOVS     R0,#+0
   \                     ??USDHC_TransferNonBlocking_6: (+1)
   \       0xDA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1649          }
   1650          
   1651          #if defined(FSL_FEATURE_USDHC_HAS_SDR50_MODE) && (FSL_FEATURE_USDHC_HAS_SDR50_MODE)
   1652          /*!
   1653           * brief manual tuning trigger or abort
   1654           * User should handle the tuning cmd and find the boundary of the delay
   1655           * then calucate a average value which will be config to the CLK_TUNE_CTRL_STATUS
   1656           * This function should called before USDHC_AdjustDelayforSDR104 function
   1657           * param base USDHC peripheral base address.
   1658           * param tuning enable flag
   1659           */

   \                                 In section .text, align 2, keep-with-next
   1660          void USDHC_EnableManualTuning(USDHC_Type *base, bool enable)
   1661          {
   1662              if (enable)
   \                     USDHC_EnableManualTuning: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0xD00E             BEQ.N    ??USDHC_EnableManualTuning_0
   1663              {
   1664                  /* make sure std_tun_en bit is clear */
   1665                  base->TUNING_CTRL &= ~USDHC_TUNING_CTRL_STD_TUNING_EN_MASK;
   \        0x4   0xF8D0 0x10CC      LDR      R1,[R0, #+204]
   \        0x8   0xF021 0x7180      BIC      R1,R1,#0x1000000
   \        0xC   0xF8C0 0x10CC      STR      R1,[R0, #+204]
   1666                  /* disable auto tuning here */
   1667                  base->MIX_CTRL &= ~USDHC_MIX_CTRL_AUTO_TUNE_EN_MASK;
   \       0x10   0x6C81             LDR      R1,[R0, #+72]
   \       0x12   0xF021 0x7180      BIC      R1,R1,#0x1000000
   \       0x16   0x6481             STR      R1,[R0, #+72]
   1668                  /* execute tuning for SDR104 mode */
   1669                  base->MIX_CTRL |=
   1670                      USDHC_MIX_CTRL_EXE_TUNE_MASK | USDHC_MIX_CTRL_SMP_CLK_SEL_MASK | USDHC_MIX_CTRL_FBCLK_SEL_MASK;
   \       0x18   0x6C81             LDR      R1,[R0, #+72]
   \       0x1A   0xF041 0x7130      ORR      R1,R1,#0x2C00000
   \       0x1E   0x6481             STR      R1,[R0, #+72]
   \       0x20   0x4770             BX       LR
   1671              }
   1672              else
   1673              { /* abort the tuning */
   1674                  base->MIX_CTRL &= ~(USDHC_MIX_CTRL_EXE_TUNE_MASK | USDHC_MIX_CTRL_SMP_CLK_SEL_MASK);
   \                     ??USDHC_EnableManualTuning_0: (+1)
   \       0x22   0x6C81             LDR      R1,[R0, #+72]
   \       0x24   0xF421 0x0140      BIC      R1,R1,#0xC00000
   \       0x28   0x6481             STR      R1,[R0, #+72]
   1675              }
   1676          }
   \       0x2A   0x4770             BX       LR               ;; return
   1677          
   1678          /*!
   1679           * brief the SDR104 mode delay setting adjust
   1680           * This function should called after USDHC_ManualTuningForSDR104
   1681           * param base USDHC peripheral base address.
   1682           * param delay setting configuration
   1683           * retval kStatus_Fail config the delay setting fail
   1684           * retval kStatus_Success config the delay setting success
   1685           */

   \                                 In section .text, align 2, keep-with-next
   1686          status_t USDHC_AdjustDelayForManualTuning(USDHC_Type *base, uint32_t delay)
   1687          {
   1688              uint32_t clkTuneCtrl = 0U;
   1689          
   1690              clkTuneCtrl = base->CLK_TUNE_CTRL_STATUS;
   \                     USDHC_AdjustDelayForManualTuning: (+1)
   \        0x0   0x6E82             LDR      R2,[R0, #+104]
   1691          
   1692              clkTuneCtrl &= ~USDHC_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_PRE_MASK;
   1693          
   1694              clkTuneCtrl |= USDHC_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_PRE(delay);
   1695          
   1696              /* load the delay setting */
   1697              base->CLK_TUNE_CTRL_STATUS = clkTuneCtrl;
   \        0x2   0xF361 0x220E      BFI      R2,R1,#+8,#+7
   \        0x6   0x6682             STR      R2,[R0, #+104]
   1698              /* check delat setting error */
   1699              if (base->CLK_TUNE_CTRL_STATUS &
   1700                  (USDHC_CLK_TUNE_CTRL_STATUS_PRE_ERR_MASK | USDHC_CLK_TUNE_CTRL_STATUS_NXT_ERR_MASK))
   \        0x8   0x6E80             LDR      R0,[R0, #+104]
   \        0xA   0xF000 0x2080      AND      R0,R0,#0x80008000
   \        0xE   0x1E40             SUBS     R0,R0,#+1
   \       0x10   0x4180             SBCS     R0,R0,R0
   \       0x12   0x43C0             MVNS     R0,R0
   \       0x14   0x0FC0             LSRS     R0,R0,#+31
   1701              {
   1702                  return kStatus_Fail;
   1703              }
   1704          
   1705              return kStatus_Success;
   \       0x16   0x4770             BX       LR               ;; return
   1706          }
   1707          
   1708          /*!
   1709           * brief the enable standard tuning function
   1710           * The standard tuning window and tuning counter use the default config
   1711           * tuning cmd is send by the software, user need to check the tuning result
   1712           * can be used for SDR50,SDR104,HS200 mode tuning
   1713           * param base USDHC peripheral base address.
   1714           * param tuning start tap
   1715           * param tuning step
   1716           * param enable/disable flag
   1717           */

   \                                 In section .text, align 2, keep-with-next
   1718          void USDHC_EnableStandardTuning(USDHC_Type *base, uint32_t tuningStartTap, uint32_t step, bool enable)
   1719          {
   \                     USDHC_EnableStandardTuning: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1720              uint32_t tuningCtrl = 0U;
   1721          
   1722              if (enable)
   \        0x2   0x2B00             CMP      R3,#+0
   \        0x4   0xD018             BEQ.N    ??USDHC_EnableStandardTuning_0
   1723              {
   1724                  /* feedback clock */
   1725                  base->MIX_CTRL |= USDHC_MIX_CTRL_FBCLK_SEL_MASK;
   \        0x6   0x6C83             LDR      R3,[R0, #+72]
   \        0x8   0xF043 0x7300      ORR      R3,R3,#0x2000000
   \        0xC   0x6483             STR      R3,[R0, #+72]
   1726                  /* config tuning start and step */
   1727                  tuningCtrl = base->TUNING_CTRL;
   \        0xE   0xF8D0 0x40CC      LDR      R4,[R0, #+204]
   1728                  tuningCtrl &= ~(USDHC_TUNING_CTRL_TUNING_START_TAP_MASK | USDHC_TUNING_CTRL_TUNING_STEP_MASK);
   1729                  tuningCtrl |= (USDHC_TUNING_CTRL_TUNING_START_TAP(tuningStartTap) | USDHC_TUNING_CTRL_TUNING_STEP(step) |
   1730                                 USDHC_TUNING_CTRL_STD_TUNING_EN_MASK);
   1731                  base->TUNING_CTRL = tuningCtrl;
   \       0x12   0x....'....        LDR.W    R3,??DataTable28_16  ;; 0xfff8ff00
   \       0x16   0x401C             ANDS     R4,R3,R4
   \       0x18   0xF001 0x01FF      AND      R1,R1,#0xFF
   \       0x1C   0x4321             ORRS     R1,R1,R4
   \       0x1E   0x0412             LSLS     R2,R2,#+16
   \       0x20   0xF402 0x22E0      AND      R2,R2,#0x70000
   \       0x24   0x4311             ORRS     R1,R2,R1
   \       0x26   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \       0x2A   0xF8C0 0x10CC      STR      R1,[R0, #+204]
   1732          
   1733                  /* excute tuning */
   1734                  base->AUTOCMD12_ERR_STATUS |=
   1735                      (USDHC_AUTOCMD12_ERR_STATUS_EXECUTE_TUNING_MASK | USDHC_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL_MASK);
   \       0x2E   0x6BC1             LDR      R1,[R0, #+60]
   \       0x30   0xF441 0x0140      ORR      R1,R1,#0xC00000
   \       0x34   0x63C1             STR      R1,[R0, #+60]
   \       0x36   0xE009             B.N      ??USDHC_EnableStandardTuning_1
   1736              }
   1737              else
   1738              {
   1739                  /* disable the standard tuning */
   1740                  base->TUNING_CTRL &= ~USDHC_TUNING_CTRL_STD_TUNING_EN_MASK;
   \                     ??USDHC_EnableStandardTuning_0: (+1)
   \       0x38   0xF8D0 0x10CC      LDR      R1,[R0, #+204]
   \       0x3C   0xF021 0x7180      BIC      R1,R1,#0x1000000
   \       0x40   0xF8C0 0x10CC      STR      R1,[R0, #+204]
   1741                  /* clear excute tuning */
   1742                  base->AUTOCMD12_ERR_STATUS &=
   1743                      ~(USDHC_AUTOCMD12_ERR_STATUS_EXECUTE_TUNING_MASK | USDHC_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL_MASK);
   \       0x44   0x6BC1             LDR      R1,[R0, #+60]
   \       0x46   0xF421 0x0140      BIC      R1,R1,#0xC00000
   \       0x4A   0x63C1             STR      R1,[R0, #+60]
   1744              }
   1745          }
   \                     ??USDHC_EnableStandardTuning_1: (+1)
   \       0x4C   0xBC10             POP      {R4}
   \       0x4E   0x4770             BX       LR               ;; return
   1746          
   1747          /*!
   1748           * brief the auto tuning enbale for CMD/DATA line
   1749           *
   1750           * param base USDHC peripheral base address.
   1751           */

   \                                 In section .text, align 2, keep-with-next
   1752          void USDHC_EnableAutoTuningForCmdAndData(USDHC_Type *base)
   1753          {
   1754              uint32_t busWidth = 0U;
   1755          
   1756              base->VEND_SPEC2 |= USDHC_VEND_SPEC2_TUNING_CMD_EN_MASK;
   \                     USDHC_EnableAutoTuningForCmdAndData: (+1)
   \        0x0   0xF8D0 0x10C8      LDR      R1,[R0, #+200]
   \        0x4   0xF041 0x0140      ORR      R1,R1,#0x40
   \        0x8   0xF8C0 0x10C8      STR      R1,[R0, #+200]
   1757              busWidth = (base->PROT_CTRL & USDHC_PROT_CTRL_DTW_MASK) >> USDHC_PROT_CTRL_DTW_SHIFT;
   \        0xC   0x6A81             LDR      R1,[R0, #+40]
   \        0xE   0xF3C1 0x0141      UBFX     R1,R1,#+1,#+2
   1758              if (busWidth == kUSDHC_DataBusWidth1Bit)
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD10C             BNE.N    ??USDHC_EnableAutoTuningForCmdAndData_0
   1759              {
   1760                  base->VEND_SPEC2 &= ~USDHC_VEND_SPEC2_TUNING_8bit_EN_MASK;
   \       0x16   0xF8D0 0x10C8      LDR      R1,[R0, #+200]
   \       0x1A   0xF021 0x0110      BIC      R1,R1,#0x10
   \       0x1E   0xF8C0 0x10C8      STR      R1,[R0, #+200]
   1761                  base->VEND_SPEC2 |= USDHC_VEND_SPEC2_TUNING_1bit_EN_MASK;
   \       0x22   0xF8D0 0x10C8      LDR      R1,[R0, #+200]
   \       0x26   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0x2A   0xF8C0 0x10C8      STR      R1,[R0, #+200]
   \       0x2E   0x4770             BX       LR
   1762              }
   1763              else if (busWidth == kUSDHC_DataBusWidth4Bit)
   \                     ??USDHC_EnableAutoTuningForCmdAndData_0: (+1)
   \       0x30   0x2901             CMP      R1,#+1
   \       0x32   0xD10C             BNE.N    ??USDHC_EnableAutoTuningForCmdAndData_1
   1764              {
   1765                  base->VEND_SPEC2 &= ~USDHC_VEND_SPEC2_TUNING_8bit_EN_MASK;
   \       0x34   0xF8D0 0x10C8      LDR      R1,[R0, #+200]
   \       0x38   0xF021 0x0110      BIC      R1,R1,#0x10
   \       0x3C   0xF8C0 0x10C8      STR      R1,[R0, #+200]
   1766                  base->VEND_SPEC2 &= ~USDHC_VEND_SPEC2_TUNING_1bit_EN_MASK;
   \       0x40   0xF8D0 0x10C8      LDR      R1,[R0, #+200]
   \       0x44   0xF021 0x0120      BIC      R1,R1,#0x20
   \       0x48   0xF8C0 0x10C8      STR      R1,[R0, #+200]
   \       0x4C   0x4770             BX       LR
   1767              }
   1768              else if (busWidth == kUSDHC_DataBusWidth8Bit)
   \                     ??USDHC_EnableAutoTuningForCmdAndData_1: (+1)
   \       0x4E   0x2902             CMP      R1,#+2
   \       0x50   0xD10B             BNE.N    ??USDHC_EnableAutoTuningForCmdAndData_2
   1769              {
   1770                  base->VEND_SPEC2 |= USDHC_VEND_SPEC2_TUNING_8bit_EN_MASK;
   \       0x52   0xF8D0 0x10C8      LDR      R1,[R0, #+200]
   \       0x56   0xF041 0x0110      ORR      R1,R1,#0x10
   \       0x5A   0xF8C0 0x10C8      STR      R1,[R0, #+200]
   1771                  base->VEND_SPEC2 &= ~USDHC_VEND_SPEC2_TUNING_1bit_EN_MASK;
   \       0x5E   0xF8D0 0x10C8      LDR      R1,[R0, #+200]
   \       0x62   0xF021 0x0120      BIC      R1,R1,#0x20
   \       0x66   0xF8C0 0x10C8      STR      R1,[R0, #+200]
   1772              }
   1773              else
   1774              {
   1775              }
   1776          }
   \                     ??USDHC_EnableAutoTuningForCmdAndData_2: (+1)
   \       0x6A   0x4770             BX       LR               ;; return
   1777          #endif /* FSL_FEATURE_USDHC_HAS_SDR50_MODE */
   1778          

   \                                 In section .text, align 2, keep-with-next
   1779          static void USDHC_TransferHandleCardDetect(USDHC_Type *base, usdhc_handle_t *handle, uint32_t interruptFlags)
   1780          {
   \                     USDHC_TransferHandleCardDetect: (+1)
   \        0x0   0x460B             MOV      R3,R1
   1781              if (interruptFlags & kUSDHC_CardInsertionFlag)
   \        0x2   0x0651             LSLS     R1,R2,#+25
   \        0x4   0xD505             BPL.N    ??USDHC_TransferHandleCardDetect_0
   1782              {
   1783                  if (handle->callback.CardInserted)
   \        0x6   0x68D9             LDR      R1,[R3, #+12]
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD008             BEQ.N    ??USDHC_TransferHandleCardDetect_1
   1784                  {
   1785                      handle->callback.CardInserted(base, handle->userData);
   \        0xC   0x6A59             LDR      R1,[R3, #+36]
   \        0xE   0x68DA             LDR      R2,[R3, #+12]
   \       0x10   0x4710             BX       R2
   1786                  }
   1787              }
   1788              else
   1789              {
   1790                  if (handle->callback.CardRemoved)
   \                     ??USDHC_TransferHandleCardDetect_0: (+1)
   \       0x12   0x6919             LDR      R1,[R3, #+16]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD002             BEQ.N    ??USDHC_TransferHandleCardDetect_1
   1791                  {
   1792                      handle->callback.CardRemoved(base, handle->userData);
   \       0x18   0x6A59             LDR      R1,[R3, #+36]
   \       0x1A   0x691A             LDR      R2,[R3, #+16]
   \       0x1C   0x4710             BX       R2
   1793                  }
   1794              }
   1795          }
   \                     ??USDHC_TransferHandleCardDetect_1: (+1)
   \       0x1E   0x4770             BX       LR               ;; return
   1796          

   \                                 In section .text, align 2, keep-with-next
   1797          static void USDHC_TransferHandleCommand(USDHC_Type *base, usdhc_handle_t *handle, uint32_t interruptFlags)
   1798          {
   \                     USDHC_TransferHandleCommand: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   1799              assert(handle->command);
   \        0x8   0x6868             LDR      R0,[R5, #+4]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD107             BNE.N    ??USDHC_TransferHandleCommand_0
   \        0xE   0xF240 0x7207      MOVW     R2,#+1799
   \       0x12   0x....             LDR.N    R1,??DataTable28_7
   \       0x14   0x....             LDR.N    R0,??DataTable28_17
   \       0x16   0x....'....        BL       __aeabi_assert
   \       0x1A   0x....'....        BL       __iar_EmptyStepPoint
   1800          
   1801              if (interruptFlags & kUSDHC_CommandErrorFlag)
   \                     ??USDHC_TransferHandleCommand_0: (+1)
   \       0x1E   0xF416 0x2F70      TST      R6,#0xF0000
   \       0x22   0xD105             BNE.N    ??USDHC_TransferHandleCommand_1
   1802              {
   1803                  if (handle->callback.TransferComplete)
   1804                  {
   1805                      handle->callback.TransferComplete(base, handle, kStatus_USDHC_SendCommandFailed, handle->userData);
   1806                  }
   1807              }
   1808              else
   1809              {
   1810                  /* Receive response */
   1811                  if (kStatus_Success != USDHC_ReceiveCommandResponse(base, handle->command))
   \       0x24   0x6869             LDR      R1,[R5, #+4]
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       USDHC_ReceiveCommandResponse
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD00A             BEQ.N    ??USDHC_TransferHandleCommand_2
   1812                  {
   1813                      if (handle->callback.TransferComplete)
   \                     ??USDHC_TransferHandleCommand_1: (+1)
   \       0x30   0x69E8             LDR      R0,[R5, #+28]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD013             BEQ.N    ??USDHC_TransferHandleCommand_3
   1814                      {
   1815                          handle->callback.TransferComplete(base, handle, kStatus_USDHC_SendCommandFailed, handle->userData);
   \       0x36   0x6A6B             LDR      R3,[R5, #+36]
   \       0x38   0xF641 0x1266      MOVW     R2,#+6502
   \       0x3C   0x4629             MOV      R1,R5
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0x69EC             LDR      R4,[R5, #+28]
   \       0x42   0x47A0             BLX      R4
   \       0x44   0xBD70             POP      {R4-R6,PC}
   1816                      }
   1817                  }
   1818                  else if ((!(handle->data)) && (handle->callback.TransferComplete))
   \                     ??USDHC_TransferHandleCommand_2: (+1)
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD108             BNE.N    ??USDHC_TransferHandleCommand_3
   \       0x4C   0x69E8             LDR      R0,[R5, #+28]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD005             BEQ.N    ??USDHC_TransferHandleCommand_3
   1819                  {
   1820                      if (handle->callback.TransferComplete)
   1821                      {
   1822                          handle->callback.TransferComplete(base, handle, kStatus_Success, handle->userData);
   \       0x52   0x6A6B             LDR      R3,[R5, #+36]
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x4629             MOV      R1,R5
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x69EC             LDR      R4,[R5, #+28]
   \       0x5C   0x47A0             BLX      R4
   1823                      }
   1824                  }
   1825                  else
   1826                  {
   1827                  }
   1828              }
   1829          }
   \                     ??USDHC_TransferHandleCommand_3: (+1)
   \       0x5E   0xBD70             POP      {R4-R6,PC}       ;; return
   1830          

   \                                 In section .text, align 2, keep-with-next
   1831          static void USDHC_TransferHandleData(USDHC_Type *base, usdhc_handle_t *handle, uint32_t interruptFlags)
   1832          {
   \                     USDHC_TransferHandleData: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   1833              assert(handle->data);
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD107             BNE.N    ??USDHC_TransferHandleData_0
   \        0xE   0xF240 0x7229      MOVW     R2,#+1833
   \       0x12   0x....             LDR.N    R1,??DataTable28_7
   \       0x14   0x....             LDR.N    R0,??DataTable28_18
   \       0x16   0x....'....        BL       __aeabi_assert
   \       0x1A   0x....'....        BL       __iar_EmptyStepPoint
   1834          
   1835              if ((!(handle->data->enableIgnoreError)) && ((interruptFlags & (kUSDHC_DataErrorFlag | kUSDHC_DmaErrorFlag))))
   \                     ??USDHC_TransferHandleData_0: (+1)
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x7880             LDRB     R0,[R0, #+2]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10D             BNE.N    ??USDHC_TransferHandleData_1
   \       0x26   0x....             LDR.N    R0,??DataTable23  ;; 0x11700000
   \       0x28   0x4206             TST      R6,R0
   \       0x2A   0xD00A             BEQ.N    ??USDHC_TransferHandleData_1
   1836              {
   1837                  if (handle->callback.TransferComplete)
   \       0x2C   0x69E0             LDR      R0,[R4, #+28]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD037             BEQ.N    ??USDHC_TransferHandleData_2
   1838                  {
   1839                      handle->callback.TransferComplete(base, handle, kStatus_USDHC_TransferDataFailed, handle->userData);
   \       0x32   0x6A63             LDR      R3,[R4, #+36]
   \       0x34   0xF641 0x1267      MOVW     R2,#+6503
   \       0x38   0x4621             MOV      R1,R4
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0x69E4             LDR      R4,[R4, #+28]
   \       0x3E   0x47A0             BLX      R4
   \       0x40   0xBD70             POP      {R4-R6,PC}
   1840                  }
   1841              }
   1842              else
   1843              {
   1844                  if (interruptFlags & kUSDHC_BufferReadReadyFlag)
   \                     ??USDHC_TransferHandleData_1: (+1)
   \       0x42   0x06B0             LSLS     R0,R6,#+26
   \       0x44   0xD50E             BPL.N    ??USDHC_TransferHandleData_3
   1845                  {
   1846                      /* std tuning process only need to wait BRR */
   1847                      if (handle->data->dataType == kUSDHC_TransferDataTuning)
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x78C0             LDRB     R0,[R0, #+3]
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD103             BNE.N    ??USDHC_TransferHandleData_4
   1848                      {
   1849                          if (handle->callback.TransferComplete)
   \       0x4E   0x69E0             LDR      R0,[R4, #+28]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD026             BEQ.N    ??USDHC_TransferHandleData_2
   \       0x54   0xE01F             B.N      ??USDHC_TransferHandleData_5
   1850                          {
   1851                              handle->callback.TransferComplete(base, handle, kStatus_Success, handle->userData);
   1852                          }
   1853                      }
   1854                      else
   1855                      {
   1856                          handle->transferredWords = USDHC_ReadDataPort(base, handle->data, handle->transferredWords);
   \                     ??USDHC_TransferHandleData_4: (+1)
   \       0x56   0x68A2             LDR      R2,[R4, #+8]
   \       0x58   0x6821             LDR      R1,[R4, #+0]
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0x....'....        BL       USDHC_ReadDataPort
   \       0x60   0x60A0             STR      R0,[R4, #+8]
   \       0x62   0xBD70             POP      {R4-R6,PC}
   1857                      }
   1858                  }
   1859                  else if (interruptFlags & kUSDHC_BufferWriteReadyFlag)
   \                     ??USDHC_TransferHandleData_3: (+1)
   \       0x64   0x06F0             LSLS     R0,R6,#+27
   \       0x66   0xD506             BPL.N    ??USDHC_TransferHandleData_6
   1860                  {
   1861                      handle->transferredWords = USDHC_WriteDataPort(base, handle->data, handle->transferredWords);
   \       0x68   0x68A2             LDR      R2,[R4, #+8]
   \       0x6A   0x6821             LDR      R1,[R4, #+0]
   \       0x6C   0x4628             MOV      R0,R5
   \       0x6E   0x....'....        BL       USDHC_WriteDataPort
   \       0x72   0x60A0             STR      R0,[R4, #+8]
   \       0x74   0xBD70             POP      {R4-R6,PC}
   1862                  }
   1863                  else
   1864                  {
   1865                      if ((interruptFlags & kUSDHC_DmaCompleteFlag) &&
   1866                          (handle->data->dataType == kUSDHC_TransferDataBootcontinous))
   \                     ??USDHC_TransferHandleData_6: (+1)
   \       0x76   0x0730             LSLS     R0,R6,#+28
   \       0x78   0xD508             BPL.N    ??USDHC_TransferHandleData_7
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x78C0             LDRB     R0,[R0, #+3]
   \       0x7E   0x2803             CMP      R0,#+3
   \       0x80   0xD104             BNE.N    ??USDHC_TransferHandleData_7
   1867                      {
   1868                          *(handle->data->rxData) = s_usdhcBootDummy;
   \       0x82   0x....             LDR.N    R0,??DataTable25
   \       0x84   0x6800             LDR      R0,[R0, #+0]
   \       0x86   0x6821             LDR      R1,[R4, #+0]
   \       0x88   0x68C9             LDR      R1,[R1, #+12]
   \       0x8A   0x6008             STR      R0,[R1, #+0]
   1869                      }
   1870          
   1871                      if ((handle->callback.TransferComplete) && (interruptFlags & kUSDHC_DataCompleteFlag))
   \                     ??USDHC_TransferHandleData_7: (+1)
   \       0x8C   0x69E0             LDR      R0,[R4, #+28]
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD007             BEQ.N    ??USDHC_TransferHandleData_2
   \       0x92   0x07B0             LSLS     R0,R6,#+30
   \       0x94   0xD505             BPL.N    ??USDHC_TransferHandleData_2
   1872                      {
   1873                          handle->callback.TransferComplete(base, handle, kStatus_Success, handle->userData);
   \                     ??USDHC_TransferHandleData_5: (+1)
   \       0x96   0x6A63             LDR      R3,[R4, #+36]
   \       0x98   0x2200             MOVS     R2,#+0
   \       0x9A   0x4621             MOV      R1,R4
   \       0x9C   0x4628             MOV      R0,R5
   \       0x9E   0x69E4             LDR      R4,[R4, #+28]
   \       0xA0   0x47A0             BLX      R4
   1874                      }
   1875                  }
   1876              }
   1877          }
   \                     ??USDHC_TransferHandleData_2: (+1)
   \       0xA2   0xBD70             POP      {R4-R6,PC}       ;; return
   1878          

   \                                 In section .text, align 2, keep-with-next
   1879          static void USDHC_TransferHandleSdioInterrupt(USDHC_Type *base, usdhc_handle_t *handle)
   1880          {
   \                     USDHC_TransferHandleSdioInterrupt: (+1)
   \        0x0   0x460A             MOV      R2,R1
   1881              if (handle->callback.SdioInterrupt)
   \        0x2   0x6951             LDR      R1,[R2, #+20]
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD002             BEQ.N    ??USDHC_TransferHandleSdioInterrupt_0
   1882              {
   1883                  handle->callback.SdioInterrupt(base, handle->userData);
   \        0x8   0x6A51             LDR      R1,[R2, #+36]
   \        0xA   0x6952             LDR      R2,[R2, #+20]
   \        0xC   0x4710             BX       R2
   1884              }
   1885          }
   \                     ??USDHC_TransferHandleSdioInterrupt_0: (+1)
   \        0xE   0x4770             BX       LR               ;; return
   1886          

   \                                 In section .text, align 2, keep-with-next
   1887          static void USDHC_TransferHandleReTuning(USDHC_Type *base, usdhc_handle_t *handle, uint32_t interruptFlags)
   1888          {
   \                     USDHC_TransferHandleReTuning: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   1889              assert(handle->callback.ReTuning);
   \        0x8   0x6A28             LDR      R0,[R5, #+32]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD107             BNE.N    ??USDHC_TransferHandleReTuning_0
   \        0xE   0xF240 0x7261      MOVW     R2,#+1889
   \       0x12   0x....             LDR.N    R1,??DataTable28_7
   \       0x14   0x....             LDR.N    R0,??DataTable28_19
   \       0x16   0x....'....        BL       __aeabi_assert
   \       0x1A   0x....'....        BL       __iar_EmptyStepPoint
   1890              /* retuning request */
   1891              if ((interruptFlags & kUSDHC_TuningErrorFlag) == kUSDHC_TuningErrorFlag)
   \                     ??USDHC_TransferHandleReTuning_0: (+1)
   \       0x1E   0x0170             LSLS     R0,R6,#+5
   \       0x20   0xD505             BPL.N    ??USDHC_TransferHandleReTuning_1
   1892              {
   1893                  handle->callback.ReTuning(base, handle->userData); /* retuning fail */
   \       0x22   0x6A69             LDR      R1,[R5, #+36]
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x6A2A             LDR      R2,[R5, #+32]
   \       0x28   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x2C   0x4710             BX       R2
   1894              }
   1895          }
   \                     ??USDHC_TransferHandleReTuning_1: (+1)
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
   1896          

   \                                 In section .text, align 2, keep-with-next
   1897          static void USDHC_TransferHandleBlockGap(USDHC_Type *base, usdhc_handle_t *handle)
   1898          {
   \                     USDHC_TransferHandleBlockGap: (+1)
   \        0x0   0x460A             MOV      R2,R1
   1899              if (handle->callback.BlockGap)
   \        0x2   0x6991             LDR      R1,[R2, #+24]
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD002             BEQ.N    ??USDHC_TransferHandleBlockGap_0
   1900              {
   1901                  handle->callback.BlockGap(base, handle->userData);
   \        0x8   0x6A51             LDR      R1,[R2, #+36]
   \        0xA   0x6992             LDR      R2,[R2, #+24]
   \        0xC   0x4710             BX       R2
   1902              }
   1903          }
   \                     ??USDHC_TransferHandleBlockGap_0: (+1)
   \        0xE   0x4770             BX       LR               ;; return
   1904          
   1905          /*!
   1906           * brief Creates the USDHC handle.
   1907           *
   1908           * param base USDHC peripheral base address.
   1909           * param handle USDHC handle pointer.
   1910           * param callback Structure pointer to contain all callback functions.
   1911           * param userData Callback function parameter.
   1912           */

   \                                 In section .text, align 2, keep-with-next
   1913          void USDHC_TransferCreateHandle(USDHC_Type *base,
   1914                                          usdhc_handle_t *handle,
   1915                                          const usdhc_transfer_callback_t *callback,
   1916                                          void *userData)
   1917          {
   \                     USDHC_TransferCreateHandle: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461F             MOV      R7,R3
   1918              assert(handle);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD107             BNE.N    ??USDHC_TransferCreateHandle_0
   \        0xE   0xF240 0x727E      MOVW     R2,#+1918
   \       0x12   0x....             LDR.N    R1,??DataTable28_7
   \       0x14   0x....             LDR.N    R0,??DataTable28_15
   \       0x16   0x....'....        BL       __aeabi_assert
   \       0x1A   0x....'....        BL       __iar_EmptyStepPoint
   1919              assert(callback);
   \                     ??USDHC_TransferCreateHandle_0: (+1)
   \       0x1E   0x2D00             CMP      R5,#+0
   \       0x20   0xD107             BNE.N    ??USDHC_TransferCreateHandle_1
   \       0x22   0xF240 0x727F      MOVW     R2,#+1919
   \       0x26   0x....             LDR.N    R1,??DataTable28_7
   \       0x28   0x....             LDR.N    R0,??DataTable28_20
   \       0x2A   0x....'....        BL       __aeabi_assert
   \       0x2E   0x....'....        BL       __iar_EmptyStepPoint
   1920          
   1921              /* Zero the handle. */
   1922              memset(handle, 0, sizeof(*handle));
   \                     ??USDHC_TransferCreateHandle_1: (+1)
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x2128             MOVS     R1,#+40
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x....'....        BL       __aeabi_memset4
   1923          
   1924              /* Set the callback. */
   1925              handle->callback.CardInserted = callback->CardInserted;
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x60E0             STR      R0,[R4, #+12]
   1926              handle->callback.CardRemoved = callback->CardRemoved;
   \       0x40   0x6868             LDR      R0,[R5, #+4]
   \       0x42   0x6120             STR      R0,[R4, #+16]
   1927              handle->callback.SdioInterrupt = callback->SdioInterrupt;
   \       0x44   0x68A8             LDR      R0,[R5, #+8]
   \       0x46   0x6160             STR      R0,[R4, #+20]
   1928              handle->callback.BlockGap = callback->BlockGap;
   \       0x48   0x68E8             LDR      R0,[R5, #+12]
   \       0x4A   0x61A0             STR      R0,[R4, #+24]
   1929              handle->callback.TransferComplete = callback->TransferComplete;
   \       0x4C   0x6928             LDR      R0,[R5, #+16]
   \       0x4E   0x61E0             STR      R0,[R4, #+28]
   1930              handle->callback.ReTuning = callback->ReTuning;
   \       0x50   0x6968             LDR      R0,[R5, #+20]
   \       0x52   0x6220             STR      R0,[R4, #+32]
   1931              handle->userData = userData;
   \       0x54   0x6267             STR      R7,[R4, #+36]
   1932          
   1933              /* Save the handle in global variables to support the double weak mechanism. */
   1934              s_usdhcHandle[USDHC_GetInstance(base)] = handle;
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0x....'....        BL       USDHC_GetInstance
   \       0x5C   0x....             LDR.N    R1,??DataTable28_21
   \       0x5E   0xF841 0x4020      STR      R4,[R1, R0, LSL #+2]
   1935          
   1936              /* Enable interrupt in NVIC. */
   1937              USDHC_SetTransferInterrupt(base, true);
   \       0x62   0x2101             MOVS     R1,#+1
   \       0x64   0x4630             MOV      R0,R6
   \       0x66   0x....'....        BL       USDHC_SetTransferInterrupt
   1938              /* save IRQ handler */
   1939              s_usdhcIsr = USDHC_TransferHandleIRQ;
   \       0x6A   0x....'....        ADR.W    R0,USDHC_TransferHandleIRQ
   \       0x6E   0x....             LDR.N    R1,??DataTable28_22
   \       0x70   0x6008             STR      R0,[R1, #+0]
   1940          
   1941              EnableIRQ(s_usdhcIRQ[USDHC_GetInstance(base)]);
   \       0x72   0x4630             MOV      R0,R6
   \       0x74   0x....'....        BL       USDHC_GetInstance
   \       0x78   0x....             LDR.N    R1,??DataTable28_23
   \       0x7A   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x7E   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x82   0x....'....        B.W      EnableIRQ
   1942          }
   1943          
   1944          /*!
   1945           * brief IRQ handler for the USDHC.
   1946           *
   1947           * This function deals with the IRQs on the given host controller.
   1948           *
   1949           * param base USDHC peripheral base address.
   1950           * param handle USDHC handle.
   1951           */

   \                                 In section .text, align 4, keep-with-next
   1952          void USDHC_TransferHandleIRQ(USDHC_Type *base, usdhc_handle_t *handle)
   1953          {
   \                     USDHC_TransferHandleIRQ: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1954              assert(handle);
   \        0x6   0xD107             BNE.N    ??USDHC_TransferHandleIRQ_0
   \        0x8   0xF240 0x72A2      MOVW     R2,#+1954
   \        0xC   0x....             LDR.N    R1,??DataTable28_7
   \        0xE   0x....             LDR.N    R0,??DataTable28_15
   \       0x10   0x....'....        BL       __aeabi_assert
   \       0x14   0x....'....        BL       __iar_EmptyStepPoint
   1955          
   1956              uint32_t interruptFlags;
   1957          
   1958              interruptFlags = USDHC_GetEnabledInterruptStatusFlags(base);
   \                     ??USDHC_TransferHandleIRQ_0: (+1)
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       USDHC_GetEnabledInterruptStatusFlags
   \       0x1E   0x4606             MOV      R6,R0
   1959          
   1960              if (interruptFlags & kUSDHC_CardDetectFlag)
   \       0x20   0xF016 0x0FC0      TST      R6,#0xC0
   \       0x24   0xD005             BEQ.N    ??USDHC_TransferHandleIRQ_1
   1961              {
   1962                  USDHC_TransferHandleCardDetect(base, handle, (interruptFlags & kUSDHC_CardDetectFlag));
   \       0x26   0xF006 0x02C0      AND      R2,R6,#0xC0
   \       0x2A   0x4621             MOV      R1,R4
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x....'....        BL       USDHC_TransferHandleCardDetect
   1963              }
   1964              if (interruptFlags & kUSDHC_CommandFlag)
   \                     ??USDHC_TransferHandleIRQ_1: (+1)
   \       0x32   0x....             LDR.N    R2,??DataTable28_24  ;; 0xf0001
   \       0x34   0x4216             TST      R6,R2
   \       0x36   0xD004             BEQ.N    ??USDHC_TransferHandleIRQ_2
   1965              {
   1966                  USDHC_TransferHandleCommand(base, handle, (interruptFlags & kUSDHC_CommandFlag));
   \       0x38   0x4032             ANDS     R2,R2,R6
   \       0x3A   0x4621             MOV      R1,R4
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x....'....        BL       USDHC_TransferHandleCommand
   1967              }
   1968              if (interruptFlags & kUSDHC_DataFlag)
   \                     ??USDHC_TransferHandleIRQ_2: (+1)
   \       0x42   0x....             LDR.N    R2,??DataTable28_25  ;; 0x1170003a
   \       0x44   0x4216             TST      R6,R2
   \       0x46   0xD004             BEQ.N    ??USDHC_TransferHandleIRQ_3
   1969              {
   1970                  USDHC_TransferHandleData(base, handle, (interruptFlags & kUSDHC_DataFlag));
   \       0x48   0x4032             ANDS     R2,R2,R6
   \       0x4A   0x4621             MOV      R1,R4
   \       0x4C   0x4628             MOV      R0,R5
   \       0x4E   0x....'....        BL       USDHC_TransferHandleData
   1971              }
   1972              if (interruptFlags & kUSDHC_CardInterruptFlag)
   \                     ??USDHC_TransferHandleIRQ_3: (+1)
   \       0x52   0x05F0             LSLS     R0,R6,#+23
   \       0x54   0xD503             BPL.N    ??USDHC_TransferHandleIRQ_4
   1973              {
   1974                  USDHC_TransferHandleSdioInterrupt(base, handle);
   \       0x56   0x4621             MOV      R1,R4
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       USDHC_TransferHandleSdioInterrupt
   1975              }
   1976              if (interruptFlags & kUSDHC_BlockGapEventFlag)
   \                     ??USDHC_TransferHandleIRQ_4: (+1)
   \       0x5E   0x0770             LSLS     R0,R6,#+29
   \       0x60   0xD503             BPL.N    ??USDHC_TransferHandleIRQ_5
   1977              {
   1978                  USDHC_TransferHandleBlockGap(base, handle);
   \       0x62   0x4621             MOV      R1,R4
   \       0x64   0x4628             MOV      R0,R5
   \       0x66   0x....'....        BL       USDHC_TransferHandleBlockGap
   1979              }
   1980              if (interruptFlags & kUSDHC_SDR104TuningFlag)
   \                     ??USDHC_TransferHandleIRQ_5: (+1)
   \       0x6A   0x....             LDR.N    R2,??DataTable28_26  ;; 0x4005000
   \       0x6C   0x4216             TST      R6,R2
   \       0x6E   0xD004             BEQ.N    ??USDHC_TransferHandleIRQ_6
   1981              {
   1982                  USDHC_TransferHandleReTuning(base, handle, (interruptFlags & kUSDHC_SDR104TuningFlag));
   \       0x70   0x4032             ANDS     R2,R2,R6
   \       0x72   0x4621             MOV      R1,R4
   \       0x74   0x4628             MOV      R0,R5
   \       0x76   0x....'....        BL       USDHC_TransferHandleReTuning
   1983              }
   1984              USDHC_ClearInterruptStatusFlags(base, interruptFlags);
   \                     ??USDHC_TransferHandleIRQ_6: (+1)
   \       0x7A   0x4631             MOV      R1,R6
   \       0x7C   0x4628             MOV      R0,R5
   \       0x7E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x82   0x....'....        B.W      USDHC_ClearInterruptStatusFlags
   1985          }
   1986          
   1987          #ifdef USDHC0
   1988          void USDHC0_DriverIRQHandler(void)
   1989          {
   1990              s_usdhcIsr(s_usdhcBase[0U], s_usdhcHandle[0U]);
   1991          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   1992            exception return operation might vector to incorrect interrupt */
   1993          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   1994              __DSB();
   1995          #endif
   1996          }
   1997          #endif
   1998          
   1999          #ifdef USDHC1

   \                                 In section .text, align 2, keep-with-next
   2000          void USDHC1_DriverIRQHandler(void)
   2001          {
   2002              s_usdhcIsr(s_usdhcBase[1U], s_usdhcHandle[1U]);
   \                     USDHC1_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable28_21
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0x....             LDR.N    R0,??DataTable28_27  ;; 0x402c0000
   \        0x6   0x....             LDR.N    R2,??DataTable28_22
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   2003          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   2004            exception return operation might vector to incorrect interrupt */
   2005          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   2006              __DSB();
   2007          #endif
   2008          }
   2009          #endif
   2010          
   2011          #ifdef USDHC2

   \                                 In section .text, align 2, keep-with-next
   2012          void USDHC2_DriverIRQHandler(void)
   2013          {
   2014              s_usdhcIsr(s_usdhcBase[2U], s_usdhcHandle[2U]);
   \                     USDHC2_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable28_21
   \        0x2   0x6881             LDR      R1,[R0, #+8]
   \        0x4   0x....             LDR.N    R0,??DataTable28_28  ;; 0x402c4000
   \        0x6   0x....             LDR.N    R2,??DataTable28_22
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   2015          /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping
   2016            exception return operation might vector to incorrect interrupt */
   2017          #if defined __CORTEX_M && (__CORTEX_M == 4U)
   2018              __DSB();
   2019          #endif
   2020          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x400F'C068        DC32     0x400fc068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     s_usdhcBase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x157F'513F        DC32     0x157f513f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x....'....        DC32     s_usdhcIRQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x157F'50FF        DC32     0x157f50ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x0570'0020        DC32     0x5700020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x0570'0010        DC32     0x5700010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x0170'0002        DC32     0x1700002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0xC004'FFFF        DC32     0xc004ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x000F'0001        DC32     0xf0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0x1570'0002        DC32     0x15700002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x1170'0000        DC32     0x11700000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x040F'0001        DC32     0x40f0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x....'....        DC32     s_usdhcBootDummy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x1570'4002        DC32     0x15704002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     s_usdhcClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \        0x0   0x....'....        DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \        0x0   0xC7FF'FCFF        DC32     0xc7fffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_12:
   \        0x0   0x....'....        DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_13:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_14:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_15:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_16:
   \        0x0   0xFFF8'FF00        DC32     0xfff8ff00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_17:
   \        0x0   0x....'....        DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_18:
   \        0x0   0x....'....        DC32     ?_24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_19:
   \        0x0   0x....'....        DC32     ?_25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_20:
   \        0x0   0x....'....        DC32     ?_26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_21:
   \        0x0   0x....'....        DC32     s_usdhcHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_22:
   \        0x0   0x....'....        DC32     s_usdhcIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_23:
   \        0x0   0x....'....        DC32     s_usdhcIRQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_24:
   \        0x0   0x000F'0001        DC32     0xf0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_25:
   \        0x0   0x1170'003A        DC32     0x1170003a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_26:
   \        0x0   0x0400'5000        DC32     0x4005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_27:
   \        0x0   0x402C'0000        DC32     0x402c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_28:
   \        0x0   0x402C'4000        DC32     0x402c4000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x6E          DC8 "index <= 6"
   \              0x64 0x65    
   \              0x78 0x20    
   \              0x3C 0x3D    
   \              0x20 0x36    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
   \              0x5C 0x44    
   \              0x65 0x76    
   \              0x65 0x6C    
   \        0x8   0x6F 0x70          DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73    
   \       0x10   0x6D 0x61          DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
   \              0x72 0x74    
   \              0x5F 0x77    
   \              0x61 0x73    
   \       0x18   0x68 0x69          DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
   \              0x6E 0x67    
   \              0x5F 0x6D    
   \              0x61 0x63    
   \       0x20   0x68 0x69          DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
   \              0x6E 0x65    
   \              0x5F 0x33    
   \              0x30 0x38    
   \       0x28   0x30 0x5C          DC8 30H, 5CH, 64H, 72H, 69H, 76H, 65H, 72H
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \       0x30   0x73 0x5C          DC8 73H, 5CH, 66H, 73H, 6CH, 5FH, 63H, 6CH
   \              0x66 0x73    
   \              0x6C 0x5F    
   \              0x63 0x6C    
   \       0x38   0x6F 0x63          DC8 6FH, 63H, 6BH, 2EH, 68H, 0
   \              0x6B 0x2E    
   \              0x68 0x00    
   \       0x3E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x69 0x6E          DC8 69H, 6EH, 73H, 74H, 61H, 6EH, 63H, 65H
   \              0x73 0x74    
   \              0x61 0x6E    
   \              0x63 0x65    
   \        0x8   0x20 0x3C          DC8 20H, 3CH, 20H, 28H, 73H, 69H, 7AH, 65H
   \              0x20 0x28    
   \              0x73 0x69    
   \              0x7A 0x65    
   \       0x10   0x6F 0x66          DC8 6FH, 66H, 28H, 73H, 5FH, 75H, 73H, 64H
   \              0x28 0x73    
   \              0x5F 0x75    
   \              0x73 0x64    
   \       0x18   0x68 0x63          DC8 68H, 63H, 42H, 61H, 73H, 65H, 29H, 20H
   \              0x42 0x61    
   \              0x73 0x65    
   \              0x29 0x20    
   \       0x20   0x2F 0x20          DC8 2FH, 20H, 73H, 69H, 7AH, 65H, 6FH, 66H
   \              0x73 0x69    
   \              0x7A 0x65    
   \              0x6F 0x66    
   \       0x28   0x28 0x28          DC8 28H, 28H, 73H, 5FH, 75H, 73H, 64H, 68H
   \              0x73 0x5F    
   \              0x75 0x73    
   \              0x64 0x68    
   \       0x30   0x63 0x42          DC8 63H, 42H, 61H, 73H, 65H, 29H, 5BH, 30H
   \              0x61 0x73    
   \              0x65 0x29    
   \              0x5B 0x30    
   \       0x38   0x5D 0x29          DC8 5DH, 29H, 29H, 0
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
   \              0x5C 0x44    
   \              0x65 0x76    
   \              0x65 0x6C    
   \        0x8   0x6F 0x70          DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73    
   \       0x10   0x6D 0x61          DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
   \              0x72 0x74    
   \              0x5F 0x77    
   \              0x61 0x73    
   \       0x18   0x68 0x69          DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
   \              0x6E 0x67    
   \              0x5F 0x6D    
   \              0x61 0x63    
   \       0x20   0x68 0x69          DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
   \              0x6E 0x65    
   \              0x5F 0x33    
   \              0x30 0x38    
   \       0x28   0x30 0x5C          DC8 30H, 5CH, 64H, 72H, 69H, 76H, 65H, 72H
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \       0x30   0x73 0x5C          DC8 73H, 5CH, 66H, 73H, 6CH, 5FH, 75H, 73H
   \              0x66 0x73    
   \              0x6C 0x5F    
   \              0x75 0x73    
   \       0x38   0x64 0x68          DC8 64H, 68H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \       0x3E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x30 0x20          DC8 "0 != command"
   \              0x21 0x3D    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x63 0x6F          DC8 "config"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x28 0x63          DC8 28H, 63H, 6FH, 6EH, 66H, 69H, 67H, 2DH
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x2D    
   \        0x8   0x3E 0x77          DC8 3EH, 77H, 72H, 69H, 74H, 65H, 57H, 61H
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x57 0x61    
   \       0x10   0x74 0x65          DC8 74H, 65H, 72H, 6DH, 61H, 72H, 6BH, 4CH
   \              0x72 0x6D    
   \              0x61 0x72    
   \              0x6B 0x4C    
   \       0x18   0x65 0x76          DC8 65H, 76H, 65H, 6CH, 20H, 3EH, 3DH, 20H
   \              0x65 0x6C    
   \              0x20 0x3E    
   \              0x3D 0x20    
   \       0x20   0x31 0x55          DC8 31H, 55H, 29H, 20H, 26H, 26H, 20H, 28H
   \              0x29 0x20    
   \              0x26 0x26    
   \              0x20 0x28    
   \       0x28   0x63 0x6F          DC8 63H, 6FH, 6EH, 66H, 69H, 67H, 2DH, 3EH
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x2D 0x3E    
   \       0x30   0x77 0x72          DC8 77H, 72H, 69H, 74H, 65H, 57H, 61H, 74H
   \              0x69 0x74    
   \              0x65 0x57    
   \              0x61 0x74    
   \       0x38   0x65 0x72          DC8 65H, 72H, 6DH, 61H, 72H, 6BH, 4CH, 65H
   \              0x6D 0x61    
   \              0x72 0x6B    
   \              0x4C 0x65    
   \       0x40   0x76 0x65          DC8 76H, 65H, 6CH, 20H, 3CH, 3DH, 20H, 31H
   \              0x6C 0x20    
   \              0x3C 0x3D    
   \              0x20 0x31    
   \       0x48   0x32 0x38          DC8 32H, 38H, 55H, 29H, 0
   \              0x55 0x29    
   \              0x00         
   \       0x4D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x28 0x63          DC8 28H, 63H, 6FH, 6EH, 66H, 69H, 67H, 2DH
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x2D    
   \        0x8   0x3E 0x72          DC8 3EH, 72H, 65H, 61H, 64H, 57H, 61H, 74H
   \              0x65 0x61    
   \              0x64 0x57    
   \              0x61 0x74    
   \       0x10   0x65 0x72          DC8 65H, 72H, 6DH, 61H, 72H, 6BH, 4CH, 65H
   \              0x6D 0x61    
   \              0x72 0x6B    
   \              0x4C 0x65    
   \       0x18   0x76 0x65          DC8 76H, 65H, 6CH, 20H, 3EH, 3DH, 20H, 31H
   \              0x6C 0x20    
   \              0x3E 0x3D    
   \              0x20 0x31    
   \       0x20   0x55 0x29          DC8 55H, 29H, 20H, 26H, 26H, 20H, 28H, 63H
   \              0x20 0x26    
   \              0x26 0x20    
   \              0x28 0x63    
   \       0x28   0x6F 0x6E          DC8 6FH, 6EH, 66H, 69H, 67H, 2DH, 3EH, 72H
   \              0x66 0x69    
   \              0x67 0x2D    
   \              0x3E 0x72    
   \       0x30   0x65 0x61          DC8 65H, 61H, 64H, 57H, 61H, 74H, 65H, 72H
   \              0x64 0x57    
   \              0x61 0x74    
   \              0x65 0x72    
   \       0x38   0x6D 0x61          DC8 6DH, 61H, 72H, 6BH, 4CH, 65H, 76H, 65H
   \              0x72 0x6B    
   \              0x4C 0x65    
   \              0x76 0x65    
   \       0x40   0x6C 0x20          DC8 6CH, 20H, 3CH, 3DH, 20H, 31H, 32H, 38H
   \              0x3C 0x3D    
   \              0x20 0x31    
   \              0x32 0x38    
   \       0x48   0x55 0x29          DC8 55H, 29H, 0
   \              0x00         
   \       0x4B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x63 0x6F          DC8 "config->writeBurstLen <= 16U"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x2D 0x3E    
   \              0x77 0x72    
   \              0x69 0x74    
   \              0x65 0x42    
   \              0x75 0x72    
   \              0x73 0x74    
   \              0x4C 0x65    
   \              0x6E 0x20    
   \              0x3C 0x3D    
   \              0x20 0x31    
   \              0x36 0x55    
   \              0x00         
   \       0x1D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x63 0x61          DC8 "capability"
   \              0x70 0x61    
   \              0x62 0x69    
   \              0x6C 0x69    
   \              0x74 0x79    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x73 0x72          DC8 "srcClock_Hz != 0U"
   \              0x63 0x43    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x5F 0x48    
   \              0x7A 0x20    
   \              0x21 0x3D    
   \              0x20 0x30    
   \              0x55 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x28 0x62          DC8 28H, 62H, 75H, 73H, 43H, 6CH, 6FH, 63H
   \              0x75 0x73    
   \              0x43 0x6C    
   \              0x6F 0x63    
   \        0x8   0x6B 0x5F          DC8 6BH, 5FH, 48H, 7AH, 20H, 21H, 3DH, 20H
   \              0x48 0x7A    
   \              0x20 0x21    
   \              0x3D 0x20    
   \       0x10   0x30 0x55          DC8 30H, 55H, 29H, 20H, 26H, 26H, 20H, 28H
   \              0x29 0x20    
   \              0x26 0x26    
   \              0x20 0x28    
   \       0x18   0x62 0x75          DC8 62H, 75H, 73H, 43H, 6CH, 6FH, 63H, 6BH
   \              0x73 0x43    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \       0x20   0x5F 0x48          DC8 5FH, 48H, 7AH, 20H, 3CH, 3DH, 20H, 73H
   \              0x7A 0x20    
   \              0x3C 0x3D    
   \              0x20 0x73    
   \       0x28   0x72 0x63          DC8 72H, 63H, 43H, 6CH, 6FH, 63H, 6BH, 5FH
   \              0x43 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x5F    
   \       0x30   0x48 0x7A          DC8 48H, 7AH, 29H, 0
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x63 0x6F          DC8 "config->ackTimeoutCount <= ((0xFU) >> (0U))"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x2D 0x3E    
   \              0x61 0x63    
   \              0x6B 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x20    
   \              0x3C 0x3D    
   \              0x20 0x28    
   \              0x28 0x30    
   \              0x78 0x46    
   \              0x55 0x29    
   \              0x20 0x3E    
   \              0x3E 0x20    
   \              0x28 0x30    
   \              0x55 0x29    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x63 0x6F          DC8 "config->blockCount <= ((0xFFFF0000U) >> (16U))"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x2D 0x3E    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x43    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x20 0x3C    
   \              0x3D 0x20    
   \              0x28 0x28    
   \              0x30 0x78    
   \              0x46 0x46    
   \              0x46 0x46    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x55 0x29    
   \              0x20 0x3E    
   \              0x3E 0x20    
   \              0x28 0x31    
   \              0x36 0x55    
   \              0x29 0x29    
   \              0x00         
   \       0x2F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x30 0x20          DC8 "0 != admaTable"
   \              0x21 0x3D    
   \              0x20 0x61    
   \              0x64 0x6D    
   \              0x61 0x54    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x00         
   \        0xF   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x30 0x20          DC8 "0 != dataBufferAddr"
   \              0x21 0x3D    
   \              0x20 0x64    
   \              0x61 0x74    
   \              0x61 0x42    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x41    
   \              0x64 0x64    
   \              0x72 0x00    

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x64 0x6D          DC8 "dmaConfig"
   \              0x61 0x43    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x64 0x61          DC8 "dataAddr"
   \              0x74 0x61    
   \              0x41 0x64    
   \              0x64 0x72    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x28 0x30          DC8 28H, 30H, 20H, 21H, 3DH, 20H, 64H, 6DH
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x64 0x6D    
   \        0x8   0x61 0x43          DC8 61H, 43H, 6FH, 6EH, 66H, 69H, 67H, 2DH
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x2D    
   \       0x10   0x3E 0x61          DC8 3EH, 61H, 64H, 6DH, 61H, 54H, 61H, 62H
   \              0x64 0x6D    
   \              0x61 0x54    
   \              0x61 0x62    
   \       0x18   0x6C 0x65          DC8 6CH, 65H, 29H, 20H, 26H, 26H, 20H, 28H
   \              0x29 0x20    
   \              0x26 0x26    
   \              0x20 0x28    
   \       0x20   0x28 0x28          DC8 28H, 28H, 28H, 34H, 55H, 29H, 20H, 2DH
   \              0x28 0x34    
   \              0x55 0x29    
   \              0x20 0x2D    
   \       0x28   0x20 0x31          DC8 20H, 31H, 55H, 29H, 20H, 26H, 20H, 28H
   \              0x55 0x29    
   \              0x20 0x26    
   \              0x20 0x28    
   \       0x30   0x75 0x69          DC8 75H, 69H, 6EH, 74H, 33H, 32H, 5FH, 74H
   \              0x6E 0x74    
   \              0x33 0x32    
   \              0x5F 0x74    
   \       0x38   0x29 0x64          DC8 29H, 64H, 6DH, 61H, 43H, 6FH, 6EH, 66H
   \              0x6D 0x61    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \       0x40   0x69 0x67          DC8 69H, 67H, 2DH, 3EH, 61H, 64H, 6DH, 61H
   \              0x2D 0x3E    
   \              0x61 0x64    
   \              0x6D 0x61    
   \       0x48   0x54 0x61          DC8 54H, 61H, 62H, 6CH, 65H, 29H, 20H, 3DH
   \              0x62 0x6C    
   \              0x65 0x29    
   \              0x20 0x3D    
   \       0x50   0x3D 0x20          DC8 3DH, 20H, 30H, 55H, 29H, 0
   \              0x30 0x55    
   \              0x29 0x00    
   \       0x56   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x30 0x20          DC8 "0 != dmaConfig"
   \              0x21 0x3D    
   \              0x20 0x64    
   \              0x6D 0x61    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x00         
   \        0xF   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x30 0x20          DC8 "0 != dataConfig"
   \              0x21 0x3D    
   \              0x20 0x64    
   \              0x61 0x74    
   \              0x61 0x43    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x00    

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x74 0x72          DC8 "transfer"
   \              0x61 0x6E    
   \              0x73 0x66    
   \              0x65 0x72    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x68 0x61          DC8 "handle"
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_23:
   \        0x0   0x68 0x61          DC8 "handle->command"
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x2D 0x3E    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     ?_24:
   \        0x0   0x68 0x61          DC8 "handle->data"
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x2D 0x3E    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_25:
   \        0x0   0x68 0x61          DC8 "handle->callback.ReTuning"
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x2D 0x3E    
   \              0x63 0x61    
   \              0x6C 0x6C    
   \              0x62 0x61    
   \              0x63 0x6B    
   \              0x2E 0x52    
   \              0x65 0x54    
   \              0x75 0x6E    
   \              0x69 0x6E    
   \              0x67 0x00    
   \       0x1A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_26:
   \        0x0   0x63 0x61          DC8 "callback"
   \              0x6C 0x6C    
   \              0x62 0x61    
   \              0x63 0x6B    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   2021          
   2022          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CLOCK_ControlGate
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   CLOCK_DisableClock
         0   -> CLOCK_ControlGate
       0   CLOCK_EnableClock
         0   -> CLOCK_ControlGate
       8   DisableIRQ
         8   -> __NVIC_DisableIRQ
       8   EnableIRQ
         8   -> __NVIC_EnableIRQ
       0   USDHC1_DriverIRQHandler
         0   -- Indirect call
       0   USDHC2_DriverIRQHandler
         0   -- Indirect call
       0   USDHC_AdjustDelayForManualTuning
       0   USDHC_ClearInterruptStatusFlags
       8   USDHC_Deinit
         0   -> CLOCK_DisableClock
         8   -> USDHC_GetInstance
       0   USDHC_DisableInterruptSignal
       0   USDHC_DisableInterruptStatus
       0   USDHC_EnableAutoTuningForCmdAndData
       0   USDHC_EnableDDRMode
       0   USDHC_EnableInternalDMA
       0   USDHC_EnableInterruptSignal
       0   USDHC_EnableInterruptStatus
       0   USDHC_EnableManualTuning
       4   USDHC_EnableStandardTuning
      16   USDHC_GetCapability
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   USDHC_GetEnabledInterruptStatusFlags
       8   USDHC_GetInstance
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   USDHC_GetInterruptStatusFlags
      16   USDHC_Init
        16   -> CLOCK_EnableClock
        16   -> USDHC_GetInstance
        16   -> USDHC_Reset
         0   -> USDHC_SetTransferInterrupt
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      32   USDHC_ReadByDataPortBlocking
        32   -> USDHC_ClearInterruptStatusFlags
        32   -> USDHC_GetInterruptStatusFlags
        32   -> USDHC_ReadDataPort
       0   USDHC_ReadData
      24   USDHC_ReadDataPort
        24   -> USDHC_ReadData
       0   USDHC_ReceiveCommandResponse
       4   USDHC_Reset
      16   USDHC_SendCommand
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   USDHC_SetADMA1Descriptor
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   USDHC_SetADMA2Descriptor
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      32   USDHC_SetAdmaTableConfig
        32   -> USDHC_SetADMA1Descriptor
        32   -> USDHC_SetADMA2Descriptor
         0   -> USDHC_SetInternalDmaConfig
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
       0   USDHC_SetCardActive
      12   USDHC_SetDataTransferConfig
      24   USDHC_SetInternalDmaConfig
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      16   USDHC_SetMmcBootConfig
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   USDHC_SetSdClock
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   USDHC_SetTransferInterrupt
        16   -> DisableIRQ
        16   -> USDHC_DisableInterruptSignal
        16   -> USDHC_DisableInterruptStatus
         0   -> USDHC_EnableInterruptSignal
        16   -> USDHC_EnableInterruptStatus
        16   -> USDHC_GetInstance
      32   USDHC_TransferBlocking
        32   -> USDHC_ClearInterruptStatusFlags
        32   -> USDHC_EnableInternalDMA
        32   -> USDHC_GetInterruptStatusFlags
        32   -> USDHC_SendCommand
        32   -> USDHC_SetAdmaTableConfig
        32   -> USDHC_SetDataTransferConfig
         0   -> USDHC_TransferDataBlocking
        32   -> USDHC_WaitCommandDone
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
      24   USDHC_TransferCreateHandle
         0   -> EnableIRQ
        24   -> USDHC_GetInstance
        24   -> USDHC_SetTransferInterrupt
        24   -> __aeabi_assert
        24   -> __aeabi_memset4
        24   -> __iar_EmptyStepPoint
      16   USDHC_TransferDataBlocking
        16   -> USDHC_ClearInterruptStatusFlags
        16   -> USDHC_GetInterruptStatusFlags
        16   -> USDHC_ReadByDataPortBlocking
        16   -> USDHC_WriteByDataPortBlocking
       0   USDHC_TransferHandleBlockGap
         0   -- Indirect call
       0   USDHC_TransferHandleCardDetect
         0   -- Indirect call
      16   USDHC_TransferHandleCommand
        16   -- Indirect call
        16   -> USDHC_ReceiveCommandResponse
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   USDHC_TransferHandleData
        16   -- Indirect call
        16   -> USDHC_ReadDataPort
        16   -> USDHC_WriteDataPort
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   USDHC_TransferHandleIRQ
         0   -> USDHC_ClearInterruptStatusFlags
        16   -> USDHC_GetEnabledInterruptStatusFlags
        16   -> USDHC_TransferHandleBlockGap
        16   -> USDHC_TransferHandleCardDetect
        16   -> USDHC_TransferHandleCommand
        16   -> USDHC_TransferHandleData
        16   -> USDHC_TransferHandleReTuning
        16   -> USDHC_TransferHandleSdioInterrupt
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   USDHC_TransferHandleReTuning
         0   -- Indirect call
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   USDHC_TransferHandleSdioInterrupt
         0   -- Indirect call
      40   USDHC_TransferNonBlocking
        40   -> USDHC_ClearInterruptStatusFlags
        40   -> USDHC_EnableInternalDMA
        40   -> USDHC_GetInterruptStatusFlags
        40   -> USDHC_SendCommand
        40   -> USDHC_SetAdmaTableConfig
        40   -> USDHC_SetDataTransferConfig
        40   -> __aeabi_assert
        40   -> __iar_EmptyStepPoint
      24   USDHC_WaitCommandDone
        24   -> USDHC_ClearInterruptStatusFlags
        24   -> USDHC_GetInterruptStatusFlags
        24   -> USDHC_ReceiveCommandResponse
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      32   USDHC_WriteByDataPortBlocking
        32   -> USDHC_ClearInterruptStatusFlags
        32   -> USDHC_GetInterruptStatusFlags
        32   -> USDHC_WriteDataPort
       0   USDHC_WriteData
      24   USDHC_WriteDataPort
        24   -> USDHC_WriteData
       0   __NVIC_DisableIRQ
       0   __NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable26
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_13
       4  ??DataTable28_14
       4  ??DataTable28_15
       4  ??DataTable28_16
       4  ??DataTable28_17
       4  ??DataTable28_18
       4  ??DataTable28_19
       4  ??DataTable28_2
       4  ??DataTable28_20
       4  ??DataTable28_21
       4  ??DataTable28_22
       4  ??DataTable28_23
       4  ??DataTable28_24
       4  ??DataTable28_25
       4  ??DataTable28_26
       4  ??DataTable28_27
       4  ??DataTable28_28
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
      12  ?_0
      64  ?_1
      20  ?_10
      52  ?_11
      44  ?_12
      48  ?_13
      16  ?_14
      20  ?_15
      12  ?_16
      12  ?_17
      88  ?_18
      16  ?_19
      60  ?_2
      16  ?_20
      12  ?_21
       8  ?_22
      16  ?_23
      16  ?_24
      28  ?_25
      12  ?_26
      64  ?_3
      16  ?_4
       8  ?_5
      80  ?_6
      76  ?_7
      32  ?_8
      12  ?_9
      64  CLOCK_ControlGate
       4  CLOCK_DisableClock
       4  CLOCK_EnableClock
      24  DisableIRQ
      24  EnableIRQ
      12  USDHC1_DriverIRQHandler
      12  USDHC2_DriverIRQHandler
      24  USDHC_AdjustDelayForManualTuning
       4  USDHC_ClearInterruptStatusFlags
      20  USDHC_Deinit
      10  USDHC_DisableInterruptSignal
      10  USDHC_DisableInterruptStatus
     108  USDHC_EnableAutoTuningForCmdAndData
      64  USDHC_EnableDDRMode
      30  USDHC_EnableInternalDMA
       8  USDHC_EnableInterruptSignal
       8  USDHC_EnableInterruptStatus
      44  USDHC_EnableManualTuning
      80  USDHC_EnableStandardTuning
      96  USDHC_GetCapability
      10  USDHC_GetEnabledInterruptStatusFlags
      52  USDHC_GetInstance
       4  USDHC_GetInterruptStatusFlags
     228  USDHC_Init
     192  USDHC_ReadByDataPortBlocking
       4  USDHC_ReadData
     110  USDHC_ReadDataPort
     116  USDHC_ReceiveCommandResponse
      48  USDHC_Reset
     142  USDHC_SendCommand
     228  USDHC_SetADMA1Descriptor
     306  USDHC_SetADMA2Descriptor
     216  USDHC_SetAdmaTableConfig
      42  USDHC_SetCardActive
     252  USDHC_SetDataTransferConfig
     176  USDHC_SetInternalDmaConfig
     190  USDHC_SetMmcBootConfig
     242  USDHC_SetSdClock
      70  USDHC_SetTransferInterrupt
     232  USDHC_TransferBlocking
     134  USDHC_TransferCreateHandle
     116  USDHC_TransferDataBlocking
      16  USDHC_TransferHandleBlockGap
      32  USDHC_TransferHandleCardDetect
      96  USDHC_TransferHandleCommand
     164  USDHC_TransferHandleData
     134  USDHC_TransferHandleIRQ
      48  USDHC_TransferHandleReTuning
      16  USDHC_TransferHandleSdioInterrupt
     222  USDHC_TransferNonBlocking
     102  USDHC_WaitCommandDone
     192  USDHC_WriteByDataPortBlocking
       4  USDHC_WriteData
     110  USDHC_WriteDataPort
      32  __NVIC_DisableIRQ
      24  __NVIC_EnableIRQ
      12  s_usdhcBase
       4  s_usdhcBootDummy
       8  s_usdhcClock
      12  s_usdhcHandle
       8  s_usdhcIRQ
       4  s_usdhcIsr

 
    16 bytes in section .bss
   888 bytes in section .rodata
 5 176 bytes in section .text
     4 bytes in section NonCacheable
 
 5 176 bytes of CODE  memory
   888 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: none
