###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:06
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\cJSON.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWA3C8.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\cJSON.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\cJSON.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\cJSON.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\cJSON.c
      1          /*
      2          Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
      3          Permission is hereby granted, free of charge, to any person obtaining a copy
      4          of this software and associated documentation files (the "Software"), to deal
      5          in the Software without restriction, including without limitation the rights
      6          to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      7          copies of the Software, and to permit persons to whom the Software is
      8          furnished to do so, subject to the following conditions:
      9          The above copyright notice and this permission notice shall be included in
     10          all copies or substantial portions of the Software.
     11          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     12          IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     13          FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     14          AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     15          LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     16          OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     17          THE SOFTWARE.
     18          */
     19          
     20          /* cJSON */
     21          /* JSON parser in C. */
     22          
     23          #ifdef __GNUC__
     24              #pragma GCC visibility push(default)
     25          #endif
     26          
     27          #include <string.h>
     28          #include <stdio.h>
     29          #include <stdint.h>
     30          #include <math.h>
     31          #include <stdlib.h>
     32          #include <float.h>
     33          #include <limits.h>
     34          #include <ctype.h>
     35          #include <locale.h>
     36          
     37          #ifdef __GNUC__
     38              #pragma GCC visibility pop
     39          #endif
     40          
     41          #include "cJSON.h"
     42          
     43          /* define our own boolean type */
     44          #define true ((cJSON_bool)1)
     45          #define false ((cJSON_bool)0)
     46          
     47          typedef struct {
     48              const unsigned char *json;
     49              size_t position;
     50          } error;

   \                                 In section .bss, align 4
     51          static error global_error = { NULL, 0 };
   \                     global_error:
   \        0x0                      DS8 8
     52          

   \                                 In section .text, align 2, keep-with-next
     53          CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
     54          {
     55              return (const char *)(global_error.json + global_error.position);
   \                     cJSON_GetErrorPtr: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable14
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x6840             LDR      R0,[R0, #+4]
   \        0x8   0x4408             ADD      R0,R1,R0
   \        0xA   0x4770             BX       LR               ;; return
     56          }
     57          
     58          /* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
     59          #if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 5) || (CJSON_VERSION_PATCH != 3)
     60              #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
     61          #endif
     62          

   \                                 In section .text, align 2, keep-with-next
     63          CJSON_PUBLIC(const char *) cJSON_Version(void)
     64          {
   \                     cJSON_Version: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
     65              static char version[15];
     66              sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
   \        0x2   0x....'....        LDR.W    R4,??DataTable13
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x9000             STR      R0,[SP, #+0]
   \        0xA   0x2305             MOVS     R3,#+5
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0x....'....        LDR.W    R1,??DataTable14_1
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x....'....        BL       sprintf
     67          
     68              return version;
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     69          }

   \                                 In section .bss, align 4
   \                     `cJSON_Version::version`:
   \        0x0                      DS8 16
     70          
     71          /* Case insensitive string comparison, doesn't consider two NULL pointers equal though */

   \                                 In section .text, align 2, keep-with-next
     72          static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
     73          {
   \                     case_insensitive_strcmp: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
     74              if ((string1 == NULL) || (string2 == NULL)) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD001             BEQ.N    ??case_insensitive_strcmp_0
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??case_insensitive_strcmp_1
     75                  return 1;
   \                     ??case_insensitive_strcmp_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xBD70             POP      {R4-R6,PC}
     76              }
     77          
     78              if (string1 == string2) {
   \                     ??case_insensitive_strcmp_1: (+1)
   \       0x12   0x42A5             CMP      R5,R4
   \       0x14   0xD102             BNE.N    ??case_insensitive_strcmp_2
   \       0x16   0xE00D             B.N      ??case_insensitive_strcmp_3
     79                  return 0;
     80              }
     81          
     82              for (; tolower(*string1) == tolower(*string2); (void)string1++, string2++) {
   \                     ??case_insensitive_strcmp_4: (+1)
   \       0x18   0x1C6D             ADDS     R5,R5,#+1
   \       0x1A   0x1C64             ADDS     R4,R4,#+1
   \                     ??case_insensitive_strcmp_2: (+1)
   \       0x1C   0x7828             LDRB     R0,[R5, #+0]
   \       0x1E   0x....'....        BL       tolower
   \       0x22   0x4606             MOV      R6,R0
   \       0x24   0x7820             LDRB     R0,[R4, #+0]
   \       0x26   0x....'....        BL       tolower
   \       0x2A   0x4286             CMP      R6,R0
   \       0x2C   0x7828             LDRB     R0,[R5, #+0]
   \       0x2E   0xD103             BNE.N    ??case_insensitive_strcmp_5
     83                  if (*string1 == '\0') {
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD1F1             BNE.N    ??case_insensitive_strcmp_4
     84                      return 0;
   \                     ??case_insensitive_strcmp_3: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD70             POP      {R4-R6,PC}
     85                  }
     86              }
     87          
     88              return tolower(*string1) - tolower(*string2);
   \                     ??case_insensitive_strcmp_5: (+1)
   \       0x38   0x....'....        BL       tolower
   \       0x3C   0x4605             MOV      R5,R0
   \       0x3E   0x7820             LDRB     R0,[R4, #+0]
   \       0x40   0x....'....        BL       tolower
   \       0x44   0x1A2D             SUBS     R5,R5,R0
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0xBD70             POP      {R4-R6,PC}       ;; return
     89          }
     90          
     91          typedef struct internal_hooks {
     92              void *(*allocate)(uint32_t size);
     93              void(*deallocate)(void *pointer);
     94              void *(*reallocate)(void *pointer, size_t size);
     95          } internal_hooks;
     96          
     97          extern void *HAL_Malloc(uint32_t size);
     98          extern void HAL_Free(void *ptr);

   \                                 In section .data, align 4
     99          static internal_hooks global_hooks = { HAL_Malloc, HAL_Free, realloc };
   \                     global_hooks:
   \        0x0   0x....'....        DC32 HAL_Malloc, HAL_Free, realloc
   \              0x....'....  
   \              0x....'....  
    100          

   \                                 In section .text, align 2, keep-with-next
    101          static unsigned char *cJSON_strdup(const unsigned char *string, const internal_hooks *const hooks)
    102          {
   \                     cJSON_strdup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    103              size_t length = 0;
    104              unsigned char *copy = NULL;
    105          
    106              if (string == NULL) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD101             BNE.N    ??cJSON_strdup_0
    107                  return NULL;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD70             POP      {R4-R6,PC}
    108              }
    109          
    110              length = strlen((const char *)string) + sizeof("");
   \                     ??cJSON_strdup_0: (+1)
   \        0xE   0x....'....        BL       strlen
   \       0x12   0x4606             MOV      R6,R0
   \       0x14   0x1C76             ADDS     R6,R6,#+1
    111              if (!(copy = (unsigned char *)hooks->allocate(length))) {
   \       0x16   0x4630             MOV      R0,R6
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x4788             BLX      R1
   \       0x1C   0x0004             MOVS     R4,R0
   \       0x1E   0xD101             BNE.N    ??cJSON_strdup_1
    112                  return NULL;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD70             POP      {R4-R6,PC}
    113              }
    114              memcpy(copy, string, length);
   \                     ??cJSON_strdup_1: (+1)
   \       0x24   0x4632             MOV      R2,R6
   \       0x26   0x4629             MOV      R1,R5
   \       0x28   0x....'....        BL       __aeabi_memcpy
    115          
    116              return copy;
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
    117          }
    118          
    119          /* Internal constructor. */

   \                                 In section .text, align 2, keep-with-next
    120          static cJSON *cJSON_New_Item(const internal_hooks *const hooks)
    121          {
   \                     cJSON_New_Item: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4601             MOV      R1,R0
    122              cJSON *node = (cJSON *)hooks->allocate(sizeof(cJSON));
   \        0x4   0x2028             MOVS     R0,#+40
   \        0x6   0x6809             LDR      R1,[R1, #+0]
   \        0x8   0x4788             BLX      R1
   \        0xA   0x0004             MOVS     R4,R0
    123              if (node) {
   \        0xC   0xD003             BEQ.N    ??cJSON_New_Item_0
    124                  memset(node, '\0', sizeof(cJSON));
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x2128             MOVS     R1,#+40
   \       0x12   0x....'....        BL       __aeabi_memset4
    125              }
    126          
    127              return node;
   \                     ??cJSON_New_Item_0: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    128          }
    129          
    130          /* Delete a cJSON structure. */

   \                                 In section .text, align 2, keep-with-next
    131          CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
    132          {
   \                     cJSON_Delete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    133              cJSON *next = NULL;
   \        0x4   0xE022             B.N      ??cJSON_Delete_0
    134              while (item != NULL) {
    135                  next = item->next;
   \                     ??cJSON_Delete_1: (+1)
   \        0x6   0x6825             LDR      R5,[R4, #+0]
    136                  if (!(item->type & cJSON_IsReference) && (item->child != NULL)) {
   \        0x8   0x68E0             LDR      R0,[R4, #+12]
   \        0xA   0x05C0             LSLS     R0,R0,#+23
   \        0xC   0xD404             BMI.N    ??cJSON_Delete_2
   \        0xE   0x68A0             LDR      R0,[R4, #+8]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD001             BEQ.N    ??cJSON_Delete_2
    137                      cJSON_Delete(item->child);
   \       0x14   0xF7FF 0xFFF4      BL       cJSON_Delete
    138                  }
    139                  if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL)) {
   \                     ??cJSON_Delete_2: (+1)
   \       0x18   0x68E0             LDR      R0,[R4, #+12]
   \       0x1A   0x05C0             LSLS     R0,R0,#+23
   \       0x1C   0xD406             BMI.N    ??cJSON_Delete_3
   \       0x1E   0x6920             LDR      R0,[R4, #+16]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD003             BEQ.N    ??cJSON_Delete_3
    140                      global_hooks.deallocate(item->valuestring);
   \       0x24   0x....'....        LDR.W    R1,??DataTable14_2
   \       0x28   0x6849             LDR      R1,[R1, #+4]
   \       0x2A   0x4788             BLX      R1
    141                  }
    142                  if (!(item->type & cJSON_StringIsConst) && (item->string != NULL)) {
   \                     ??cJSON_Delete_3: (+1)
   \       0x2C   0x68E0             LDR      R0,[R4, #+12]
   \       0x2E   0x0580             LSLS     R0,R0,#+22
   \       0x30   0xD406             BMI.N    ??cJSON_Delete_4
   \       0x32   0x6A20             LDR      R0,[R4, #+32]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD003             BEQ.N    ??cJSON_Delete_4
    143                      global_hooks.deallocate(item->string);
   \       0x38   0x....'....        LDR.W    R1,??DataTable14_2
   \       0x3C   0x6849             LDR      R1,[R1, #+4]
   \       0x3E   0x4788             BLX      R1
    144                  }
    145                  global_hooks.deallocate(item);
   \                     ??cJSON_Delete_4: (+1)
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x....'....        LDR.W    R1,??DataTable14_2
   \       0x46   0x6849             LDR      R1,[R1, #+4]
   \       0x48   0x4788             BLX      R1
    146                  item = next;
   \       0x4A   0x002C             MOVS     R4,R5
    147              }
   \                     ??cJSON_Delete_0: (+1)
   \       0x4C   0xD1DB             BNE.N    ??cJSON_Delete_1
    148          }
   \       0x4E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    149          
    150          /* get the decimal point character of the current locale */

   \                                 In section .text, align 2, keep-with-next
    151          static unsigned char get_decimal_point(void)
    152          {
   \                     get_decimal_point: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    153              struct lconv *lconv = (struct lconv *)localeconv();
                                                           ^
Warning[Pe223]: function "localeconv" declared implicitly
   \        0x2   0x....'....        BL       localeconv
    154              return (unsigned char)lconv->decimal_point[0];
   \        0x6   0x6A40             LDR      R0,[R0, #+36]
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0xBD02             POP      {R1,PC}          ;; return
    155          }
    156          
    157          typedef struct {
    158              const unsigned char *content;
    159              size_t length;
    160              size_t offset;
    161              size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
    162              internal_hooks hooks;
    163          } parse_buffer;
    164          
    165          /* check if the given size is left to read in a given parse buffer (starting with 1) */
    166          #define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
    167          #define cannot_read(buffer, size) (!can_read(buffer, size))
    168          /* check if the buffer can be accessed at the given index (starting with 0) */
    169          #define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
    170          #define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
    171          /* get a pointer to the buffer at the position */
    172          #define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
    173          
    174          /* Parse the input text to generate a number, and populate the result into item. */

   \                                 In section .text, align 4, keep-with-next
    175          static cJSON_bool parse_number(cJSON *const item, parse_buffer *const input_buffer)
    176          {
   \                     parse_number: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB091             SUB      SP,SP,#+68
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460C             MOV      R4,R1
    177              double number = 0;
    178              unsigned char *after_end = NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
    179              unsigned char number_c_string[64];
    180              unsigned char decimal_point = get_decimal_point();
   \        0xC   0x....'....        BL       get_decimal_point
   \       0x10   0x4601             MOV      R1,R0
    181              size_t i = 0;
   \       0x12   0x2200             MOVS     R2,#+0
    182          
    183              if ((input_buffer == NULL) || (input_buffer->content == NULL)) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD059             BEQ.N    ??parse_number_0
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD056             BEQ.N    ??parse_number_0
    184                  return false;
    185              }
    186          
    187              /* copy the number into a temporary buffer and replace '.' with the decimal point
    188              * of the current locale (for strtod)
    189              * This also takes care of '\0' not necessarily being available for marking the end of the input */
    190              for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++) {
   \                     ??parse_number_1: (+1)
   \       0x1E   0x2A3F             CMP      R2,#+63
   \       0x20   0xD249             BCS.N    ??parse_number_2
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD047             BEQ.N    ??parse_number_2
   \       0x26   0x68A0             LDR      R0,[R4, #+8]
   \       0x28   0x1810             ADDS     R0,R2,R0
   \       0x2A   0x6863             LDR      R3,[R4, #+4]
   \       0x2C   0x4298             CMP      R0,R3
   \       0x2E   0xD242             BCS.N    ??parse_number_2
    191                  switch (buffer_at_offset(input_buffer)[i]) {
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x68A3             LDR      R3,[R4, #+8]
   \       0x34   0x4418             ADD      R0,R0,R3
   \       0x36   0x5C80             LDRB     R0,[R0, R2]
   \       0x38   0x382B             SUBS     R0,R0,#+43
   \       0x3A   0xD00E             BEQ.N    ??parse_number_3
   \       0x3C   0x1E80             SUBS     R0,R0,#+2
   \       0x3E   0xD00C             BEQ.N    ??parse_number_3
   \       0x40   0x1E40             SUBS     R0,R0,#+1
   \       0x42   0xD007             BEQ.N    ??parse_number_4
   \       0x44   0x1E80             SUBS     R0,R0,#+2
   \       0x46   0x2809             CMP      R0,#+9
   \       0x48   0xD907             BLS.N    ??parse_number_3
   \       0x4A   0x3815             SUBS     R0,R0,#+21
   \       0x4C   0xD005             BEQ.N    ??parse_number_3
   \       0x4E   0x3820             SUBS     R0,R0,#+32
   \       0x50   0xD003             BEQ.N    ??parse_number_3
   \       0x52   0xE030             B.N      ??parse_number_2
    192                      case '0':
    193                      case '1':
    194                      case '2':
    195                      case '3':
    196                      case '4':
    197                      case '5':
    198                      case '6':
    199                      case '7':
    200                      case '8':
    201                      case '9':
    202                      case '+':
    203                      case '-':
    204                      case 'e':
    205                      case 'E':
    206                          number_c_string[i] = buffer_at_offset(input_buffer)[i];
    207                          break;
    208          
    209                      case '.':
    210                          number_c_string[i] = decimal_point;
   \                     ??parse_number_4: (+1)
   \       0x54   0xA801             ADD      R0,SP,#+4
   \       0x56   0x5481             STRB     R1,[R0, R2]
    211                          break;
   \       0x58   0xE004             B.N      ??parse_number_5
   \                     ??parse_number_3: (+1)
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x4418             ADD      R0,R0,R3
   \       0x5E   0x5C80             LDRB     R0,[R0, R2]
   \       0x60   0xAB01             ADD      R3,SP,#+4
   \       0x62   0x5498             STRB     R0,[R3, R2]
    212          
    213                      default:
    214                          goto loop_end;
    215                  }
    216              }
   \                     ??parse_number_5: (+1)
   \       0x64   0x1C52             ADDS     R2,R2,#+1
   \       0x66   0xE7DA             B.N      ??parse_number_1
    217          loop_end:
    218              number_c_string[i] = '\0';
    219          
    220              number = strtod((const char *)number_c_string, (char **)&after_end);
    221              if (number_c_string == after_end) {
    222                  return false; /* parse_error */
    223              }
    224          
    225              item->valuedouble = number;
   \                     ??parse_number_6: (+1)
   \       0x68   0xED85 0x0B06      VSTR     D0,[R5, #+24]
    226          
    227              /* use saturation in case of overflow */
    228              if (number >= INT_MAX) {
   \       0x6C   0xED9F 0x....      VLDR.W   D2,??DataTable5
   \       0x70   0xEEB4 0x0B42      VCMP.F64 D0,D2
   \       0x74   0xEEF1 0xFA10      FMSTAT   
   \       0x78   0xDB03             BLT.N    ??parse_number_7
    229                  item->valueint = INT_MAX;
   \       0x7A   0xF06F 0x4000      MVN      R0,#-2147483648
   \       0x7E   0x6168             STR      R0,[R5, #+20]
   \       0x80   0xE00E             B.N      ??parse_number_8
    230              } else if (number <= INT_MIN) {
   \                     ??parse_number_7: (+1)
   \       0x82   0xED9F 0x....      VLDR.W   D2,??DataTable5_1
   \       0x86   0xEEB4 0x0B42      VCMP.F64 D0,D2
   \       0x8A   0xEEF1 0xFA10      FMSTAT   
   \       0x8E   0xD503             BPL.N    ??parse_number_9
    231                  item->valueint = INT_MIN;
   \       0x90   0xF04F 0x4000      MOV      R0,#-2147483648
   \       0x94   0x6168             STR      R0,[R5, #+20]
   \       0x96   0xE003             B.N      ??parse_number_8
    232              } else {
    233                  item->valueint = (int)number;
   \                     ??parse_number_9: (+1)
   \       0x98   0xEEBD 0x0BC0      VCVT.S32.F64 S0,D0
   \       0x9C   0xED85 0x0A05      VSTR     S0,[R5, #+20]
    234              }
    235          
    236              item->type = cJSON_Number;
   \                     ??parse_number_8: (+1)
   \       0xA0   0x2008             MOVS     R0,#+8
   \       0xA2   0x60E8             STR      R0,[R5, #+12]
    237          
    238              input_buffer->offset += (size_t)(after_end - number_c_string);
   \       0xA4   0x68A1             LDR      R1,[R4, #+8]
   \       0xA6   0x9800             LDR      R0,[SP, #+0]
   \       0xA8   0x1841             ADDS     R1,R0,R1
   \       0xAA   0xA801             ADD      R0,SP,#+4
   \       0xAC   0x1A09             SUBS     R1,R1,R0
   \       0xAE   0x60A1             STR      R1,[R4, #+8]
    239              return true;
   \       0xB0   0x2001             MOVS     R0,#+1
   \                     ??parse_number_10: (+1)
   \       0xB2   0xB011             ADD      SP,SP,#+68
   \       0xB4   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??parse_number_2: (+1)
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0xA901             ADD      R1,SP,#+4
   \       0xBA   0x5488             STRB     R0,[R1, R2]
   \       0xBC   0x4669             MOV      R1,SP
   \       0xBE   0xA801             ADD      R0,SP,#+4
   \       0xC0   0x....'....        BL       strtod
   \       0xC4   0xA801             ADD      R0,SP,#+4
   \       0xC6   0x9900             LDR      R1,[SP, #+0]
   \       0xC8   0x4288             CMP      R0,R1
   \       0xCA   0xD1CD             BNE.N    ??parse_number_6
   \                     ??parse_number_0: (+1)
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0xE7F0             B.N      ??parse_number_10
    240          }
    241          
    242          /* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */

   \                                 In section .text, align 4, keep-with-next
    243          CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
    244          {
    245              if (number >= INT_MAX) {
   \                     cJSON_SetNumberHelper: (+1)
   \        0x0   0xED9F 0x....      VLDR.W   D2,??DataTable5
   \        0x4   0xEEB4 0x0B42      VCMP.F64 D0,D2
   \        0x8   0xEEF1 0xFA10      FMSTAT   
   \        0xC   0xDB03             BLT.N    ??cJSON_SetNumberHelper_0
    246                  object->valueint = INT_MAX;
   \        0xE   0xF06F 0x4100      MVN      R1,#-2147483648
   \       0x12   0x6141             STR      R1,[R0, #+20]
   \       0x14   0xE00E             B.N      ??cJSON_SetNumberHelper_1
    247              } else if (number <= INT_MIN) {
   \                     ??cJSON_SetNumberHelper_0: (+1)
   \       0x16   0xED9F 0x....      VLDR.W   D2,??DataTable5_1
   \       0x1A   0xEEB4 0x0B42      VCMP.F64 D0,D2
   \       0x1E   0xEEF1 0xFA10      FMSTAT   
   \       0x22   0xD503             BPL.N    ??cJSON_SetNumberHelper_2
    248                  object->valueint = INT_MIN;
   \       0x24   0xF04F 0x4100      MOV      R1,#-2147483648
   \       0x28   0x6141             STR      R1,[R0, #+20]
   \       0x2A   0xE003             B.N      ??cJSON_SetNumberHelper_1
    249              } else {
    250                  object->valueint = (int)number;
   \                     ??cJSON_SetNumberHelper_2: (+1)
   \       0x2C   0xEEBD 0x1BC0      VCVT.S32.F64 S2,D0
   \       0x30   0xED80 0x1A05      VSTR     S2,[R0, #+20]
    251              }
    252          
    253              return object->valuedouble = number;
   \                     ??cJSON_SetNumberHelper_1: (+1)
   \       0x34   0xED80 0x0B06      VSTR     D0,[R0, #+24]
   \       0x38   0x4770             BX       LR               ;; return
    254          }
    255          
    256          typedef struct {
    257              unsigned char *buffer;
    258              size_t length;
    259              size_t offset;
    260              size_t depth; /* current nesting depth (for formatted printing) */
    261              cJSON_bool noalloc;
    262              cJSON_bool format; /* is this print a formatted print */
    263              internal_hooks hooks;
    264          } printbuffer;
    265          
    266          /* realloc printbuffer if necessary to have at least "needed" bytes more */

   \                                 In section .text, align 2, keep-with-next
    267          static unsigned char *ensure(printbuffer *const p, size_t needed)
    268          {
   \                     ensure: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    269              unsigned char *newbuffer = NULL;
    270              size_t newsize = 0;
    271          
    272              if ((p == NULL) || (p->buffer == NULL)) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD022             BEQ.N    ??ensure_0
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD01F             BEQ.N    ??ensure_0
    273                  return NULL;
    274              }
    275          
    276              if ((p->length > 0) && (p->offset >= p->length)) {
   \       0x10   0x6868             LDR      R0,[R5, #+4]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD003             BEQ.N    ??ensure_1
   \       0x16   0x68A8             LDR      R0,[R5, #+8]
   \       0x18   0x6869             LDR      R1,[R5, #+4]
   \       0x1A   0x4288             CMP      R0,R1
   \       0x1C   0xD218             BCS.N    ??ensure_0
    277                  /* make sure that offset is valid */
    278                  return NULL;
    279              }
    280          
    281              if (needed > INT_MAX) {
   \                     ??ensure_1: (+1)
   \       0x1E   0xF1B6 0x4F00      CMP      R6,#-2147483648
   \       0x22   0xD215             BCS.N    ??ensure_0
    282                  /* sizes bigger than INT_MAX are currently not supported */
    283                  return NULL;
    284              }
    285          
    286              needed += p->offset + 1;
   \       0x24   0x68A8             LDR      R0,[R5, #+8]
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \       0x28   0x1986             ADDS     R6,R0,R6
    287              if (needed <= p->length) {
   \       0x2A   0x6868             LDR      R0,[R5, #+4]
   \       0x2C   0x42B0             CMP      R0,R6
   \       0x2E   0xD303             BCC.N    ??ensure_2
    288                  return p->buffer + p->offset;
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x68A9             LDR      R1,[R5, #+8]
   \       0x34   0x4408             ADD      R0,R0,R1
   \       0x36   0xBD70             POP      {R4-R6,PC}
    289              }
    290          
    291              if (p->noalloc) {
   \                     ??ensure_2: (+1)
   \       0x38   0x6928             LDR      R0,[R5, #+16]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD108             BNE.N    ??ensure_0
    292                  return NULL;
    293              }
    294          
    295              /* calculate new buffer size */
    296              if (needed > (INT_MAX / 2)) {
   \       0x3E   0xF1B6 0x4F80      CMP      R6,#+1073741824
   \       0x42   0xD307             BCC.N    ??ensure_3
    297                  /* overflow of int, use INT_MAX if possible */
    298                  if (needed <= INT_MAX) {
   \       0x44   0xF1B6 0x4F00      CMP      R6,#-2147483648
   \       0x48   0xD202             BCS.N    ??ensure_0
    299                      newsize = INT_MAX;
   \       0x4A   0xF06F 0x4600      MVN      R6,#-2147483648
   \       0x4E   0xE002             B.N      ??ensure_4
    300                  } else {
    301                      return NULL;
   \                     ??ensure_0: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xBD70             POP      {R4-R6,PC}
    302                  }
    303              } else {
    304                  newsize = needed * 2;
   \                     ??ensure_3: (+1)
   \       0x54   0x0076             LSLS     R6,R6,#+1
    305              }
    306          
    307              if (p->hooks.reallocate != NULL) {
   \                     ??ensure_4: (+1)
   \       0x56   0x6A28             LDR      R0,[R5, #+32]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD005             BEQ.N    ??ensure_5
    308                  /* reallocate with realloc if available */
    309                  newbuffer = (unsigned char *)p->hooks.reallocate(p->buffer, newsize);
   \       0x5C   0x4631             MOV      R1,R6
   \       0x5E   0x6828             LDR      R0,[R5, #+0]
   \       0x60   0x6A2A             LDR      R2,[R5, #+32]
   \       0x62   0x4790             BLX      R2
   \       0x64   0x4604             MOV      R4,R0
   \       0x66   0xE014             B.N      ??ensure_6
    310              } else {
    311                  /* otherwise reallocate manually */
    312                  newbuffer = (unsigned char *)p->hooks.allocate(newsize);
   \                     ??ensure_5: (+1)
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0x69A9             LDR      R1,[R5, #+24]
   \       0x6C   0x4788             BLX      R1
   \       0x6E   0x0004             MOVS     R4,R0
    313                  if (!newbuffer) {
   \       0x70   0xD106             BNE.N    ??ensure_7
    314                      p->hooks.deallocate(p->buffer);
   \       0x72   0x6828             LDR      R0,[R5, #+0]
   \       0x74   0x69E9             LDR      R1,[R5, #+28]
   \       0x76   0x4788             BLX      R1
    315                      p->length = 0;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x6068             STR      R0,[R5, #+4]
    316                      p->buffer = NULL;
   \       0x7C   0x6028             STR      R0,[R5, #+0]
    317          
    318                      return NULL;
   \       0x7E   0xBD70             POP      {R4-R6,PC}
    319                  }
    320                  if (newbuffer) {
   \                     ??ensure_7: (+1)
   \       0x80   0xD004             BEQ.N    ??ensure_8
    321                      memcpy(newbuffer, p->buffer, p->offset + 1);
   \       0x82   0x68AA             LDR      R2,[R5, #+8]
   \       0x84   0x1C52             ADDS     R2,R2,#+1
   \       0x86   0x6829             LDR      R1,[R5, #+0]
   \       0x88   0x....'....        BL       __aeabi_memcpy
    322                  }
    323                  p->hooks.deallocate(p->buffer);
   \                     ??ensure_8: (+1)
   \       0x8C   0x6828             LDR      R0,[R5, #+0]
   \       0x8E   0x69E9             LDR      R1,[R5, #+28]
   \       0x90   0x4788             BLX      R1
    324              }
    325              p->length = newsize;
   \                     ??ensure_6: (+1)
   \       0x92   0x606E             STR      R6,[R5, #+4]
    326              p->buffer = newbuffer;
   \       0x94   0x602C             STR      R4,[R5, #+0]
    327          
    328              return newbuffer + p->offset;
   \       0x96   0x68A8             LDR      R0,[R5, #+8]
   \       0x98   0x4420             ADD      R0,R4,R0
   \       0x9A   0xBD70             POP      {R4-R6,PC}       ;; return
    329          }
    330          
    331          /* calculate the new length of the string in a printbuffer and update the offset */

   \                                 In section .text, align 2, keep-with-next
    332          static void update_offset(printbuffer *const buffer)
    333          {
   \                     update_offset: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    334              const unsigned char *buffer_pointer = NULL;
    335              if ((buffer == NULL) || (buffer->buffer == NULL)) {
   \        0x4   0xD009             BEQ.N    ??update_offset_0
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??update_offset_0
    336                  return;
    337              }
    338              buffer_pointer = buffer->buffer + buffer->offset;
    339          
    340              buffer->offset += strlen((const char *)buffer_pointer);
   \        0xC   0x68A1             LDR      R1,[R4, #+8]
   \        0xE   0x4408             ADD      R0,R0,R1
   \       0x10   0x....'....        BL       strlen
   \       0x14   0x68A1             LDR      R1,[R4, #+8]
   \       0x16   0x1840             ADDS     R0,R0,R1
   \       0x18   0x60A0             STR      R0,[R4, #+8]
    341          }
   \                     ??update_offset_0: (+1)
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
    342          
    343          /* Render the number nicely from the given item into a string. */

   \                                 In section .text, align 4, keep-with-next
    344          static cJSON_bool print_number(const cJSON *const item, printbuffer *const output_buffer)
    345          {
   \                     print_number: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xED2D 0x8B02      VPUSH    {D8}
   \        0x6   0xB08A             SUB      SP,SP,#+40
   \        0x8   0x460C             MOV      R4,R1
    346              unsigned char *output_pointer = NULL;
    347              double d = item->valuedouble;
   \        0xA   0xED90 0x8B06      VLDR     D8,[R0, #+24]
    348              int length = 0;
    349              size_t i = 0;
   \        0xE   0x2500             MOVS     R5,#+0
    350              unsigned char number_buffer[26]; /* temporary buffer to print the number into */
    351              unsigned char decimal_point = get_decimal_point();
   \       0x10   0x....'....        BL       get_decimal_point
   \       0x14   0x4606             MOV      R6,R0
    352              double test;
    353          
    354              if (output_buffer == NULL) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD037             BEQ.N    ??print_number_0
    355                  return false;
    356              }
    357          
    358              /* This checks for NaN and Infinity */
    359              if ((d * 0) != 0) {
   \       0x1A   0xED9F 0x....      VLDR.W   D1,??DataTable6
   \       0x1E   0xEE28 0x0B01      VMUL.F64 D0,D8,D1
   \       0x22   0xED9F 0x....      VLDR.W   D2,??DataTable6
   \       0x26   0xEEB4 0x0B42      VCMP.F64 D0,D2
   \       0x2A   0xEEF1 0xFA10      FMSTAT   
   \       0x2E   0xD006             BEQ.N    ??print_number_1
    360                  length = sprintf((char *)number_buffer, "null");
   \       0x30   0x....'....        LDR.W    R1,??DataTable14_3
   \       0x34   0xA802             ADD      R0,SP,#+8
   \       0x36   0x....'....        BL       sprintf
   \       0x3A   0x4607             MOV      R7,R0
   \       0x3C   0xE01D             B.N      ??print_number_2
    361              } else {
    362                  /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
    363                  length = sprintf((char *)number_buffer, "%1.15g", d);
   \                     ??print_number_1: (+1)
   \       0x3E   0xEC53 0x2B18      VMOV     R2,R3,D8
   \       0x42   0x....'....        LDR.W    R1,??DataTable14_4
   \       0x46   0xA802             ADD      R0,SP,#+8
   \       0x48   0x....'....        BL       sprintf
   \       0x4C   0x4607             MOV      R7,R0
    364          
    365                  /* Check whether the original double can be recovered */
    366                  if ((sscanf((char *)number_buffer, "%lg", &test) != 1) || ((double)test != d)) {
   \       0x4E   0x466A             MOV      R2,SP
   \       0x50   0x....             ADR.N    R1,??DataTable6_1  ;; "%lg"
   \       0x52   0xA802             ADD      R0,SP,#+8
   \       0x54   0x....'....        BL       sscanf
   \       0x58   0x2801             CMP      R0,#+1
   \       0x5A   0xD106             BNE.N    ??print_number_3
   \       0x5C   0xED9D 0x0B00      VLDR     D0,[SP, #+0]
   \       0x60   0xEEB4 0x0B48      VCMP.F64 D0,D8
   \       0x64   0xEEF1 0xFA10      FMSTAT   
   \       0x68   0xD007             BEQ.N    ??print_number_2
    367                      /* If not, print with 17 decimal places of precision */
    368                      length = sprintf((char *)number_buffer, "%1.17g", d);
   \                     ??print_number_3: (+1)
   \       0x6A   0xEC53 0x2B18      VMOV     R2,R3,D8
   \       0x6E   0x....'....        LDR.W    R1,??DataTable14_5
   \       0x72   0xA802             ADD      R0,SP,#+8
   \       0x74   0x....'....        BL       sprintf
   \       0x78   0x4607             MOV      R7,R0
    369                  }
    370              }
    371          
    372              /* sprintf failed or buffer overrun occured */
    373              if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1))) {
   \                     ??print_number_2: (+1)
   \       0x7A   0x2F1A             CMP      R7,#+26
   \       0x7C   0xD205             BCS.N    ??print_number_0
    374                  return false;
    375              }
    376          
    377              /* reserve appropriate space in the output */
    378              output_pointer = ensure(output_buffer, (size_t)length);
   \       0x7E   0x4639             MOV      R1,R7
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0x....'....        BL       ensure
    379              if (output_pointer == NULL) {
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD10B             BNE.N    ??print_number_4
    380                  return false;
   \                     ??print_number_0: (+1)
   \       0x8A   0x4628             MOV      R0,R5
   \       0x8C   0xE011             B.N      ??print_number_5
    381              }
    382          
    383              /* copy the printed number to the output and replace locale
    384              * dependent decimal point with '.' */
    385              for (i = 0; i < ((size_t)length); i++) {
    386                  if (number_buffer[i] == decimal_point) {
    387                      output_pointer[i] = '.';
    388                      continue;
    389                  }
    390          
    391                  output_pointer[i] = number_buffer[i];
   \                     ??print_number_6: (+1)
   \       0x8E   0x4611             MOV      R1,R2
   \       0x90   0x5541             STRB     R1,[R0, R5]
   \       0x92   0xE005             B.N      ??print_number_7
   \                     ??print_number_8: (+1)
   \       0x94   0xA902             ADD      R1,SP,#+8
   \       0x96   0x5D4A             LDRB     R2,[R1, R5]
   \       0x98   0x42B2             CMP      R2,R6
   \       0x9A   0xD1F8             BNE.N    ??print_number_6
   \       0x9C   0x212E             MOVS     R1,#+46
   \       0x9E   0x5541             STRB     R1,[R0, R5]
    392              }
   \                     ??print_number_7: (+1)
   \       0xA0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??print_number_4: (+1)
   \       0xA2   0x42BD             CMP      R5,R7
   \       0xA4   0xD3F6             BCC.N    ??print_number_8
    393              output_pointer[i] = '\0';
   \       0xA6   0x2100             MOVS     R1,#+0
   \       0xA8   0x5541             STRB     R1,[R0, R5]
    394          
    395              output_buffer->offset += (size_t)length;
   \       0xAA   0x68A0             LDR      R0,[R4, #+8]
   \       0xAC   0x183F             ADDS     R7,R7,R0
   \       0xAE   0x60A7             STR      R7,[R4, #+8]
    396          
    397              return true;
   \       0xB0   0x2001             MOVS     R0,#+1
   \                     ??print_number_5: (+1)
   \       0xB2   0xB00A             ADD      SP,SP,#+40
   \       0xB4   0xECBD 0x8B02      VPOP     {D8}
   \       0xB8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    398          }
    399          
    400          /* parse 4 digit hexadecimal number */

   \                                 In section .text, align 2, keep-with-next
    401          static unsigned parse_hex4(const unsigned char *const input)
    402          {
   \                     parse_hex4: (+1)
   \        0x0   0x4601             MOV      R1,R0
    403              unsigned int h = 0;
   \        0x2   0x2000             MOVS     R0,#+0
    404              size_t i = 0;
   \        0x4   0x4602             MOV      R2,R0
    405          
    406              for (i = 0; i < 4; i++) {
   \        0x6   0xE00C             B.N      ??parse_hex4_0
    407                  /* parse digit */
    408                  if ((input[i] >= '0') && (input[i] <= '9')) {
    409                      h += (unsigned int)input[i] - '0';
   \                     ??parse_hex4_1: (+1)
   \        0x8   0x3B30             SUBS     R3,R3,#+48
   \        0xA   0x1818             ADDS     R0,R3,R0
   \        0xC   0xE005             B.N      ??parse_hex4_2
    410                  } else if ((input[i] >= 'A') && (input[i] <= 'F')) {
    411                      h += (unsigned int)10 + input[i] - 'A';
    412                  } else if ((input[i] >= 'a') && (input[i] <= 'f')) {
   \                     ??parse_hex4_3: (+1)
   \        0xE   0x3B61             SUBS     R3,R3,#+97
   \       0x10   0x2B06             CMP      R3,#+6
   \       0x12   0xD215             BCS.N    ??parse_hex4_4
    413                      h += (unsigned int)10 + input[i] - 'a';
   \       0x14   0x5C8B             LDRB     R3,[R1, R2]
   \       0x16   0x3B57             SUBS     R3,R3,#+87
   \       0x18   0x1818             ADDS     R0,R3,R0
    414                  } else { /* invalid */
    415                      return 0;
    416                  }
    417          
    418                  if (i < 3) {
   \                     ??parse_hex4_2: (+1)
   \       0x1A   0x2A03             CMP      R2,#+3
   \       0x1C   0xD200             BCS.N    ??parse_hex4_5
    419                      /* shift left to make place for the next nibble */
    420                      h = h << 4;
   \       0x1E   0x0100             LSLS     R0,R0,#+4
    421                  }
   \                     ??parse_hex4_5: (+1)
   \       0x20   0x1C52             ADDS     R2,R2,#+1
   \                     ??parse_hex4_0: (+1)
   \       0x22   0x2A04             CMP      R2,#+4
   \       0x24   0xD20B             BCS.N    ??parse_hex4_6
   \       0x26   0x5C8B             LDRB     R3,[R1, R2]
   \       0x28   0x3B30             SUBS     R3,R3,#+48
   \       0x2A   0x2B0A             CMP      R3,#+10
   \       0x2C   0x5C8B             LDRB     R3,[R1, R2]
   \       0x2E   0xD3EB             BCC.N    ??parse_hex4_1
   \       0x30   0x3B41             SUBS     R3,R3,#+65
   \       0x32   0x2B06             CMP      R3,#+6
   \       0x34   0x5C8B             LDRB     R3,[R1, R2]
   \       0x36   0xD2EA             BCS.N    ??parse_hex4_3
   \       0x38   0x3B37             SUBS     R3,R3,#+55
   \       0x3A   0x1818             ADDS     R0,R3,R0
   \       0x3C   0xE7ED             B.N      ??parse_hex4_2
    422              }
    423          
    424              return h;
   \                     ??parse_hex4_6: (+1)
   \       0x3E   0x4770             BX       LR               ;; return
   \                     ??parse_hex4_4: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x4770             BX       LR
    425          }
    426          
    427          /* converts a UTF-16 literal to UTF-8
    428          * A literal can be one or two sequences of the form \uXXXX */

   \                                 In section .text, align 2, keep-with-next
    429          static unsigned char utf16_literal_to_utf8(const unsigned char *const input_pointer,
    430                  const unsigned char *const input_end, unsigned char **output_pointer)
    431          {
   \                     utf16_literal_to_utf8: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4615             MOV      R5,R2
    432              long unsigned int codepoint = 0;
    433              unsigned int first_code = 0;
    434              const unsigned char *first_sequence = input_pointer;
    435              unsigned char utf8_length = 0;
    436              unsigned char utf8_position = 0;
    437              unsigned char sequence_length = 0;
    438              unsigned char first_byte_mark = 0;
   \        0xA   0x2600             MOVS     R6,#+0
    439          
    440              if ((input_end - first_sequence) < 6) {
   \        0xC   0xEBA8 0x0007      SUB      R0,R8,R7
   \       0x10   0x2806             CMP      R0,#+6
   \       0x12   0xDB65             BLT.N    ??utf16_literal_to_utf8_0
    441                  /* input ends unexpectedly */
    442                  goto fail;
    443              }
    444          
    445              /* get the first utf16 sequence */
    446              first_code = parse_hex4(first_sequence + 2);
   \       0x14   0x1CB8             ADDS     R0,R7,#+2
   \       0x16   0x....'....        BL       parse_hex4
   \       0x1A   0x4604             MOV      R4,R0
    447          
    448              /* check that the code is valid */
    449              if (((first_code >= 0xDC00) && (first_code <= 0xDFFF))) {
   \       0x1C   0xF5A4 0x405C      SUB      R0,R4,#+56320
   \       0x20   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x24   0xD35C             BCC.N    ??utf16_literal_to_utf8_0
    450                  goto fail;
    451              }
    452          
    453              /* UTF16 surrogate pair */
    454              if ((first_code >= 0xD800) && (first_code <= 0xDBFF)) {
   \       0x26   0xF5A4 0x4058      SUB      R0,R4,#+55296
   \       0x2A   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x2E   0xD21E             BCS.N    ??utf16_literal_to_utf8_1
    455                  const unsigned char *second_sequence = first_sequence + 6;
   \       0x30   0x1DB8             ADDS     R0,R7,#+6
    456                  unsigned int second_code = 0;
    457                  sequence_length = 12; /* \uXXXX\uXXXX */
   \       0x32   0x270C             MOVS     R7,#+12
    458          
    459                  if ((input_end - second_sequence) < 6) {
   \       0x34   0xEBA8 0x0800      SUB      R8,R8,R0
   \       0x38   0xF1B8 0x0F06      CMP      R8,#+6
   \       0x3C   0xDB50             BLT.N    ??utf16_literal_to_utf8_0
    460                      /* input ends unexpectedly */
    461                      goto fail;
    462                  }
    463          
    464                  if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u')) {
   \       0x3E   0x7801             LDRB     R1,[R0, #+0]
   \       0x40   0x295C             CMP      R1,#+92
   \       0x42   0xD14D             BNE.N    ??utf16_literal_to_utf8_0
   \       0x44   0x7841             LDRB     R1,[R0, #+1]
   \       0x46   0x2975             CMP      R1,#+117
   \       0x48   0xD14A             BNE.N    ??utf16_literal_to_utf8_0
    465                      /* missing second half of the surrogate pair */
    466                      goto fail;
    467                  }
    468          
    469                  /* get the second utf16 sequence */
    470                  second_code = parse_hex4(second_sequence + 2);
   \       0x4A   0x1C80             ADDS     R0,R0,#+2
   \       0x4C   0x....'....        BL       parse_hex4
    471                  /* check that the code is valid */
    472                  if ((second_code < 0xDC00) || (second_code > 0xDFFF)) {
   \       0x50   0xF5A0 0x415C      SUB      R1,R0,#+56320
   \       0x54   0xF5B1 0x6F80      CMP      R1,#+1024
   \       0x58   0xD242             BCS.N    ??utf16_literal_to_utf8_0
    473                      /* invalid second half of the surrogate pair */
    474                      goto fail;
    475                  }
    476          
    477          
    478                  /* calculate the unicode codepoint from the surrogate pair */
    479                  codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
   \       0x5A   0x....'....        LDR.W    R1,??DataTable14_6  ;; 0xffc00
   \       0x5E   0xEA01 0x2184      AND      R1,R1,R4, LSL #+10
   \       0x62   0xF3C0 0x0009      UBFX     R0,R0,#+0,#+10
   \       0x66   0x4308             ORRS     R0,R0,R1
   \       0x68   0xF500 0x3080      ADD      R0,R0,#+65536
   \       0x6C   0xE001             B.N      ??utf16_literal_to_utf8_2
    480              } else {
    481                  sequence_length = 6; /* \uXXXX */
   \                     ??utf16_literal_to_utf8_1: (+1)
   \       0x6E   0x2706             MOVS     R7,#+6
    482                  codepoint = first_code;
   \       0x70   0x4620             MOV      R0,R4
    483              }
    484          
    485              /* encode as UTF-8
    486              * takes at maximum 4 bytes to encode:
    487              * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    488              if (codepoint < 0x80) {
   \                     ??utf16_literal_to_utf8_2: (+1)
   \       0x72   0x2880             CMP      R0,#+128
   \       0x74   0xD201             BCS.N    ??utf16_literal_to_utf8_3
    489                  /* normal ascii, encoding 0xxxxxxx */
    490                  utf8_length = 1;
   \       0x76   0x2101             MOVS     R1,#+1
   \       0x78   0xE010             B.N      ??utf16_literal_to_utf8_4
    491              } else if (codepoint < 0x800) {
   \                     ??utf16_literal_to_utf8_3: (+1)
   \       0x7A   0xF5B0 0x6F00      CMP      R0,#+2048
   \       0x7E   0xD202             BCS.N    ??utf16_literal_to_utf8_5
    492                  /* two bytes, encoding 110xxxxx 10xxxxxx */
    493                  utf8_length = 2;
   \       0x80   0x2102             MOVS     R1,#+2
    494                  first_byte_mark = 0xC0; /* 11000000 */
   \       0x82   0x26C0             MOVS     R6,#+192
   \       0x84   0xE00A             B.N      ??utf16_literal_to_utf8_4
    495              } else if (codepoint < 0x10000) {
   \                     ??utf16_literal_to_utf8_5: (+1)
   \       0x86   0xF5B0 0x3F80      CMP      R0,#+65536
   \       0x8A   0xD202             BCS.N    ??utf16_literal_to_utf8_6
    496                  /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
    497                  utf8_length = 3;
   \       0x8C   0x2103             MOVS     R1,#+3
    498                  first_byte_mark = 0xE0; /* 11100000 */
   \       0x8E   0x26E0             MOVS     R6,#+224
   \       0x90   0xE004             B.N      ??utf16_literal_to_utf8_4
    499              } else if (codepoint <= 0x10FFFF) {
   \                     ??utf16_literal_to_utf8_6: (+1)
   \       0x92   0xF5B0 0x1F88      CMP      R0,#+1114112
   \       0x96   0xD223             BCS.N    ??utf16_literal_to_utf8_0
    500                  /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
    501                  utf8_length = 4;
   \       0x98   0x2104             MOVS     R1,#+4
    502                  first_byte_mark = 0xF0; /* 11110000 */
   \       0x9A   0x26F0             MOVS     R6,#+240
    503              } else {
    504                  /* invalid unicode codepoint */
    505                  goto fail;
    506              }
    507          
    508              /* encode as utf8 */
    509              for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--) {
   \                     ??utf16_literal_to_utf8_4: (+1)
   \       0x9C   0x1E4A             SUBS     R2,R1,#+1
   \       0x9E   0xE00B             B.N      ??utf16_literal_to_utf8_7
    510                  /* 10xxxxxx */
    511                  (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
   \                     ??utf16_literal_to_utf8_8: (+1)
   \       0xA0   0xF000 0x03BF      AND      R3,R0,#0xBF
   \       0xA4   0xF043 0x0380      ORR      R3,R3,#0x80
   \       0xA8   0x682C             LDR      R4,[R5, #+0]
   \       0xAA   0x4694             MOV      R12,R2
   \       0xAC   0xFA5F 0xFC8C      UXTB     R12,R12
   \       0xB0   0xF804 0x300C      STRB     R3,[R4, R12]
    512                  codepoint >>= 6;
   \       0xB4   0x0980             LSRS     R0,R0,#+6
    513              }
   \       0xB6   0x1E52             SUBS     R2,R2,#+1
   \                     ??utf16_literal_to_utf8_7: (+1)
   \       0xB8   0x4613             MOV      R3,R2
   \       0xBA   0xB2DB             UXTB     R3,R3
   \       0xBC   0x2B00             CMP      R3,#+0
   \       0xBE   0xD1EF             BNE.N    ??utf16_literal_to_utf8_8
    514              /* encode first byte */
    515              if (utf8_length > 1) {
   \       0xC0   0x460A             MOV      R2,R1
   \       0xC2   0x2A02             CMP      R2,#+2
   \       0xC4   0xDB03             BLT.N    ??utf16_literal_to_utf8_9
    516                  (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
   \       0xC6   0x4306             ORRS     R6,R6,R0
   \       0xC8   0x6828             LDR      R0,[R5, #+0]
   \       0xCA   0x7006             STRB     R6,[R0, #+0]
   \       0xCC   0xE003             B.N      ??utf16_literal_to_utf8_10
    517              } else {
    518                  (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
   \                     ??utf16_literal_to_utf8_9: (+1)
   \       0xCE   0xF000 0x007F      AND      R0,R0,#0x7F
   \       0xD2   0x682A             LDR      R2,[R5, #+0]
   \       0xD4   0x7010             STRB     R0,[R2, #+0]
    519              }
    520          
    521              *output_pointer += utf8_length;
   \                     ??utf16_literal_to_utf8_10: (+1)
   \       0xD6   0x6828             LDR      R0,[R5, #+0]
   \       0xD8   0x4408             ADD      R0,R0,R1
   \       0xDA   0x6028             STR      R0,[R5, #+0]
    522          
    523              return sequence_length;
   \       0xDC   0x4638             MOV      R0,R7
   \       0xDE   0xE000             B.N      ??utf16_literal_to_utf8_11
    524          
    525          fail:
    526              return 0;
   \                     ??utf16_literal_to_utf8_0: (+1)
   \       0xE0   0x4630             MOV      R0,R6
   \                     ??utf16_literal_to_utf8_11: (+1)
   \       0xE2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    527          }
    528          
    529          /* Parse the input text into an unescaped cinput, and populate item. */

   \                                 In section .text, align 2, keep-with-next
    530          static cJSON_bool parse_string(cJSON *const item, parse_buffer *const input_buffer)
    531          {
   \                     parse_string: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
    532              const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
   \        0x8   0x6838             LDR      R0,[R7, #+0]
   \        0xA   0x68B9             LDR      R1,[R7, #+8]
   \        0xC   0x4408             ADD      R0,R0,R1
   \        0xE   0x1C45             ADDS     R5,R0,#+1
    533              const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
   \       0x10   0x6838             LDR      R0,[R7, #+0]
   \       0x12   0x4408             ADD      R0,R0,R1
   \       0x14   0xF100 0x0801      ADD      R8,R0,#+1
    534              unsigned char *output_pointer = NULL;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x9000             STR      R0,[SP, #+0]
    535              unsigned char *output = NULL;
   \       0x1C   0x4604             MOV      R4,R0
    536          
    537              /* not a string */
    538              if (buffer_at_offset(input_buffer)[0] != '\"') {
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x68B9             LDR      R1,[R7, #+8]
   \       0x22   0x5C40             LDRB     R0,[R0, R1]
   \       0x24   0x2822             CMP      R0,#+34
   \       0x26   0xD170             BNE.N    ??parse_string_0
    539                  goto fail;
    540              }
    541          
    542              {
    543                  /* calculate approximate size of the output (overestimate) */
    544                  size_t allocation_length = 0;
    545                  size_t skipped_bytes = 0;
   \       0x28   0x4620             MOV      R0,R4
    546                  while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"')) {
   \                     ??parse_string_1: (+1)
   \       0x2A   0x6839             LDR      R1,[R7, #+0]
   \       0x2C   0xEBA8 0x0101      SUB      R1,R8,R1
   \       0x30   0x687A             LDR      R2,[R7, #+4]
   \       0x32   0x4291             CMP      R1,R2
   \       0x34   0xD276             BCS.N    ??parse_string_2
   \       0x36   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \       0x3A   0x2922             CMP      R1,#+34
   \       0x3C   0xD072             BEQ.N    ??parse_string_2
    547                      /* is escape sequence */
    548                      if (input_end[0] == '\\') {
   \       0x3E   0x295C             CMP      R1,#+92
   \       0x40   0xD109             BNE.N    ??parse_string_3
    549                          if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length) {
   \       0x42   0xF108 0x0101      ADD      R1,R8,#+1
   \       0x46   0x683A             LDR      R2,[R7, #+0]
   \       0x48   0x1A89             SUBS     R1,R1,R2
   \       0x4A   0x687A             LDR      R2,[R7, #+4]
   \       0x4C   0x4291             CMP      R1,R2
   \       0x4E   0xD25C             BCS.N    ??parse_string_0
    550                              /* prevent buffer overflow when last input character is a backslash */
    551                              goto fail;
    552                          }
    553                          skipped_bytes++;
   \       0x50   0x1C40             ADDS     R0,R0,#+1
    554                          input_end++;
   \       0x52   0xF108 0x0801      ADD      R8,R8,#+1
    555                      }
    556                      input_end++;
   \                     ??parse_string_3: (+1)
   \       0x56   0xF108 0x0801      ADD      R8,R8,#+1
   \       0x5A   0xE7E6             B.N      ??parse_string_1
    557                  }
    558                  if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"')) {
    559                      goto fail; /* string ended unexpectedly */
    560                  }
    561          
    562                  /* This is at most how much we need for the output */
    563                  allocation_length = (size_t)(input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
    564                  output = (unsigned char *)input_buffer->hooks.allocate(allocation_length + sizeof(""));
    565                  if (output == NULL) {
    566                      goto fail; /* allocation failure */
    567                  }
    568              }
    569          
    570              output_pointer = output;
    571              /* loop through the string literal */
    572              while (input_pointer < input_end) {
    573                  if (*input_pointer != '\\') {
    574                      *output_pointer++ = *input_pointer++;
   \                     ??parse_string_4: (+1)
   \       0x5C   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \       0x60   0x9900             LDR      R1,[SP, #+0]
   \       0x62   0x7008             STRB     R0,[R1, #+0]
   \       0x64   0x9800             LDR      R0,[SP, #+0]
   \       0x66   0x1C40             ADDS     R0,R0,#+1
   \       0x68   0x9000             STR      R0,[SP, #+0]
    575                  }
   \                     ??parse_string_5: (+1)
   \       0x6A   0x4545             CMP      R5,R8
   \       0x6C   0xD270             BCS.N    ??parse_string_6
   \       0x6E   0x7828             LDRB     R0,[R5, #+0]
   \       0x70   0x285C             CMP      R0,#+92
   \       0x72   0xD1F3             BNE.N    ??parse_string_4
    576                  /* escape sequence */
    577                  else {
    578                      unsigned char sequence_length = 2;
   \       0x74   0x2002             MOVS     R0,#+2
    579                      if ((input_end - input_pointer) < 1) {
   \       0x76   0xEBA8 0x0105      SUB      R1,R8,R5
   \       0x7A   0x2901             CMP      R1,#+1
   \       0x7C   0xDB45             BLT.N    ??parse_string_0
    580                          goto fail;
    581                      }
    582          
    583                      switch (input_pointer[1]) {
   \       0x7E   0x7869             LDRB     R1,[R5, #+1]
   \       0x80   0x2922             CMP      R1,#+34
   \       0x82   0xD033             BEQ.N    ??parse_string_7
   \       0x84   0x292F             CMP      R1,#+47
   \       0x86   0xD031             BEQ.N    ??parse_string_7
   \       0x88   0x295C             CMP      R1,#+92
   \       0x8A   0xD02F             BEQ.N    ??parse_string_7
   \       0x8C   0x2962             CMP      R1,#+98
   \       0x8E   0xD00A             BEQ.N    ??parse_string_8
   \       0x90   0x2966             CMP      R1,#+102
   \       0x92   0xD00F             BEQ.N    ??parse_string_9
   \       0x94   0x296E             CMP      R1,#+110
   \       0x96   0xD014             BEQ.N    ??parse_string_10
   \       0x98   0x2972             CMP      R1,#+114
   \       0x9A   0xD019             BEQ.N    ??parse_string_11
   \       0x9C   0x2974             CMP      R1,#+116
   \       0x9E   0xD01E             BEQ.N    ??parse_string_12
   \       0xA0   0x2975             CMP      R1,#+117
   \       0xA2   0xD029             BEQ.N    ??parse_string_13
   \       0xA4   0xE031             B.N      ??parse_string_0
    584                          case 'b':
    585                              *output_pointer++ = '\b';
   \                     ??parse_string_8: (+1)
   \       0xA6   0x2108             MOVS     R1,#+8
   \       0xA8   0x9A00             LDR      R2,[SP, #+0]
   \       0xAA   0x7011             STRB     R1,[R2, #+0]
   \       0xAC   0x9900             LDR      R1,[SP, #+0]
   \       0xAE   0x1C49             ADDS     R1,R1,#+1
   \       0xB0   0x9100             STR      R1,[SP, #+0]
    586                              break;
   \       0xB2   0xE028             B.N      ??parse_string_14
    587                          case 'f':
    588                              *output_pointer++ = '\f';
   \                     ??parse_string_9: (+1)
   \       0xB4   0x210C             MOVS     R1,#+12
   \       0xB6   0x9A00             LDR      R2,[SP, #+0]
   \       0xB8   0x7011             STRB     R1,[R2, #+0]
   \       0xBA   0x9900             LDR      R1,[SP, #+0]
   \       0xBC   0x1C49             ADDS     R1,R1,#+1
   \       0xBE   0x9100             STR      R1,[SP, #+0]
    589                              break;
   \       0xC0   0xE021             B.N      ??parse_string_14
    590                          case 'n':
    591                              *output_pointer++ = '\n';
   \                     ??parse_string_10: (+1)
   \       0xC2   0x210A             MOVS     R1,#+10
   \       0xC4   0x9A00             LDR      R2,[SP, #+0]
   \       0xC6   0x7011             STRB     R1,[R2, #+0]
   \       0xC8   0x9900             LDR      R1,[SP, #+0]
   \       0xCA   0x1C49             ADDS     R1,R1,#+1
   \       0xCC   0x9100             STR      R1,[SP, #+0]
    592                              break;
   \       0xCE   0xE01A             B.N      ??parse_string_14
    593                          case 'r':
    594                              *output_pointer++ = '\r';
   \                     ??parse_string_11: (+1)
   \       0xD0   0x210D             MOVS     R1,#+13
   \       0xD2   0x9A00             LDR      R2,[SP, #+0]
   \       0xD4   0x7011             STRB     R1,[R2, #+0]
   \       0xD6   0x9900             LDR      R1,[SP, #+0]
   \       0xD8   0x1C49             ADDS     R1,R1,#+1
   \       0xDA   0x9100             STR      R1,[SP, #+0]
    595                              break;
   \       0xDC   0xE013             B.N      ??parse_string_14
    596                          case 't':
    597                              *output_pointer++ = '\t';
   \                     ??parse_string_12: (+1)
   \       0xDE   0x2109             MOVS     R1,#+9
   \       0xE0   0x9A00             LDR      R2,[SP, #+0]
   \       0xE2   0x7011             STRB     R1,[R2, #+0]
   \       0xE4   0x9900             LDR      R1,[SP, #+0]
   \       0xE6   0x1C49             ADDS     R1,R1,#+1
   \       0xE8   0x9100             STR      R1,[SP, #+0]
    598                              break;
   \       0xEA   0xE00C             B.N      ??parse_string_14
    599                          case '\"':
    600                          case '\\':
    601                          case '/':
    602                              *output_pointer++ = input_pointer[1];
   \                     ??parse_string_7: (+1)
   \       0xEC   0x9A00             LDR      R2,[SP, #+0]
   \       0xEE   0x7011             STRB     R1,[R2, #+0]
   \       0xF0   0x9900             LDR      R1,[SP, #+0]
   \       0xF2   0x1C49             ADDS     R1,R1,#+1
   \       0xF4   0x9100             STR      R1,[SP, #+0]
    603                              break;
   \       0xF6   0xE006             B.N      ??parse_string_14
    604          
    605                          /* UTF-16 literal */
    606                          case 'u':
    607                              sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
   \                     ??parse_string_13: (+1)
   \       0xF8   0x466A             MOV      R2,SP
   \       0xFA   0x4641             MOV      R1,R8
   \       0xFC   0x4628             MOV      R0,R5
   \       0xFE   0x....'....        BL       utf16_literal_to_utf8
    608                              if (sequence_length == 0) {
   \      0x102   0x0001             MOVS     R1,R0
   \      0x104   0xD001             BEQ.N    ??parse_string_0
    609                                  /* failed to convert UTF16-literal to UTF-8 */
    610                                  goto fail;
    611                              }
    612                              break;
    613          
    614                          default:
    615                              goto fail;
    616                      }
    617                      input_pointer += sequence_length;
   \                     ??parse_string_14: (+1)
   \      0x106   0x4405             ADD      R5,R5,R0
   \      0x108   0xE7AF             B.N      ??parse_string_5
    618                  }
    619              }
    620          
    621              /* zero terminate the output */
    622              *output_pointer = '\0';
    623          
    624              item->type = cJSON_String;
    625              item->valuestring = (char *)output;
    626          
    627              input_buffer->offset = (size_t)(input_end - input_buffer->content);
    628              input_buffer->offset++;
    629          
    630              return true;
    631          
    632          fail:
    633              if (output != NULL) {
   \                     ??parse_string_0: (+1)
   \      0x10A   0x2C00             CMP      R4,#+0
   \      0x10C   0xD002             BEQ.N    ??parse_string_15
    634                  input_buffer->hooks.deallocate(output);
   \      0x10E   0x4620             MOV      R0,R4
   \      0x110   0x6979             LDR      R1,[R7, #+20]
   \      0x112   0x4788             BLX      R1
    635              }
    636          
    637              if (input_pointer != NULL) {
   \                     ??parse_string_15: (+1)
   \      0x114   0x2D00             CMP      R5,#+0
   \      0x116   0xD002             BEQ.N    ??parse_string_16
    638                  input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
   \      0x118   0x6838             LDR      R0,[R7, #+0]
   \      0x11A   0x1A2D             SUBS     R5,R5,R0
   \      0x11C   0x60BD             STR      R5,[R7, #+8]
    639              }
    640          
    641              return false;
   \                     ??parse_string_16: (+1)
   \      0x11E   0x2000             MOVS     R0,#+0
   \                     ??parse_string_17: (+1)
   \      0x120   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   \                     ??parse_string_2: (+1)
   \      0x124   0x6839             LDR      R1,[R7, #+0]
   \      0x126   0xEBA8 0x0101      SUB      R1,R8,R1
   \      0x12A   0x4291             CMP      R1,R2
   \      0x12C   0xD2ED             BCS.N    ??parse_string_0
   \      0x12E   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \      0x132   0x2922             CMP      R1,#+34
   \      0x134   0xD1E9             BNE.N    ??parse_string_0
   \      0x136   0x6839             LDR      R1,[R7, #+0]
   \      0x138   0x68BA             LDR      R2,[R7, #+8]
   \      0x13A   0x4411             ADD      R1,R1,R2
   \      0x13C   0xEBA8 0x0101      SUB      R1,R8,R1
   \      0x140   0x1A08             SUBS     R0,R1,R0
   \      0x142   0x1C40             ADDS     R0,R0,#+1
   \      0x144   0x6939             LDR      R1,[R7, #+16]
   \      0x146   0x4788             BLX      R1
   \      0x148   0x0004             MOVS     R4,R0
   \      0x14A   0xD0DE             BEQ.N    ??parse_string_0
   \      0x14C   0x9400             STR      R4,[SP, #+0]
   \      0x14E   0xE78C             B.N      ??parse_string_5
   \                     ??parse_string_6: (+1)
   \      0x150   0x2000             MOVS     R0,#+0
   \      0x152   0x9900             LDR      R1,[SP, #+0]
   \      0x154   0x7008             STRB     R0,[R1, #+0]
   \      0x156   0x2010             MOVS     R0,#+16
   \      0x158   0x60F0             STR      R0,[R6, #+12]
   \      0x15A   0x6134             STR      R4,[R6, #+16]
   \      0x15C   0x6838             LDR      R0,[R7, #+0]
   \      0x15E   0xEBA8 0x0800      SUB      R8,R8,R0
   \      0x162   0xF8C7 0x8008      STR      R8,[R7, #+8]
   \      0x166   0x4640             MOV      R0,R8
   \      0x168   0x1C40             ADDS     R0,R0,#+1
   \      0x16A   0x60B8             STR      R0,[R7, #+8]
   \      0x16C   0x2001             MOVS     R0,#+1
   \      0x16E   0xE7D7             B.N      ??parse_string_17
    642          }
    643          
    644          /* Render the cstring provided to an escaped version that can be printed. */

   \                                 In section .text, align 2, keep-with-next
    645          static cJSON_bool print_string_ptr(const unsigned char *const input, printbuffer *const output_buffer)
    646          {
   \                     print_string_ptr: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460A             MOV      R2,R1
    647              const unsigned char *input_pointer = NULL;
    648              unsigned char *output = NULL;
    649              unsigned char *output_pointer = NULL;
    650              size_t output_length = 0;
    651              /* numbers of additional characters needed for escaping */
    652              size_t escape_characters = 0;
   \        0x6   0x2500             MOVS     R5,#+0
    653          
    654              if (output_buffer == NULL) {
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD101             BNE.N    ??print_string_ptr_0
    655                  return false;
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
    656              }
    657          
    658              /* empty string */
    659              if (input == NULL) {
   \                     ??print_string_ptr_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD10D             BNE.N    ??print_string_ptr_1
    660                  output = ensure(output_buffer, sizeof("\"\""));
   \       0x14   0x2103             MOVS     R1,#+3
   \       0x16   0x4610             MOV      R0,R2
   \       0x18   0x....'....        BL       ensure
    661                  if (output == NULL) {
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD101             BNE.N    ??print_string_ptr_2
    662                      return false;
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0xBDF2             POP      {R1,R4-R7,PC}
    663                  }
    664                  strcpy((char *)output, "\"\"");
   \                     ??print_string_ptr_2: (+1)
   \       0x24   0x2203             MOVS     R2,#+3
   \       0x26   0x....             ADR.N    R1,??DataTable10  ;; 0x22, 0x22, 0x00, 0x00
   \       0x28   0x....'....        BL       __aeabi_memcpy
    665          
    666                  return true;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xBDF2             POP      {R1,R4-R7,PC}
    667              }
    668          
    669              /* set "flag" to 1 if something needs to be escaped */
    670              for (input_pointer = input; *input_pointer; input_pointer++) {
   \                     ??print_string_ptr_1: (+1)
   \       0x30   0x4627             MOV      R7,R4
   \                     ??print_string_ptr_3: (+1)
   \       0x32   0x7838             LDRB     R0,[R7, #+0]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD060             BEQ.N    ??print_string_ptr_4
    671                  switch (*input_pointer) {
   \       0x38   0x3808             SUBS     R0,R0,#+8
   \       0x3A   0x2802             CMP      R0,#+2
   \       0x3C   0xD90B             BLS.N    ??print_string_ptr_5
   \       0x3E   0x1F00             SUBS     R0,R0,#+4
   \       0x40   0x2801             CMP      R0,#+1
   \       0x42   0xD908             BLS.N    ??print_string_ptr_5
   \       0x44   0x3816             SUBS     R0,R0,#+22
   \       0x46   0xD006             BEQ.N    ??print_string_ptr_5
   \       0x48   0x383A             SUBS     R0,R0,#+58
   \       0x4A   0xD004             BEQ.N    ??print_string_ptr_5
    672                      case '\"':
    673                      case '\\':
    674                      case '\b':
    675                      case '\f':
    676                      case '\n':
    677                      case '\r':
    678                      case '\t':
    679                          /* one character escape sequence */
    680                          escape_characters++;
    681                          break;
    682                      default:
    683                          if (*input_pointer < 32) {
   \       0x4C   0x7838             LDRB     R0,[R7, #+0]
   \       0x4E   0x2820             CMP      R0,#+32
   \       0x50   0xDA02             BGE.N    ??print_string_ptr_6
    684                              /* UTF-16 escape sequence uXXXX */
    685                              escape_characters += 5;
   \       0x52   0x1D6D             ADDS     R5,R5,#+5
   \       0x54   0xE000             B.N      ??print_string_ptr_6
    686                          }
   \                     ??print_string_ptr_5: (+1)
   \       0x56   0x1C6D             ADDS     R5,R5,#+1
    687                          break;
    688                  }
    689              }
   \                     ??print_string_ptr_6: (+1)
   \       0x58   0x1C7F             ADDS     R7,R7,#+1
   \       0x5A   0xE7EA             B.N      ??print_string_ptr_3
    690              output_length = (size_t)(input_pointer - input) + escape_characters;
    691          
    692              output = ensure(output_buffer, output_length + sizeof("\"\""));
    693              if (output == NULL) {
    694                  return false;
    695              }
    696          
    697              /* no characters have to be escaped */
    698              if (escape_characters == 0) {
   \                     ??print_string_ptr_7: (+1)
   \       0x5C   0x2D00             CMP      R5,#+0
   \       0x5E   0xD10D             BNE.N    ??print_string_ptr_8
    699                  output[0] = '\"';
   \       0x60   0x2022             MOVS     R0,#+34
   \       0x62   0x7030             STRB     R0,[R6, #+0]
    700                  memcpy(output + 1, input, output_length);
   \       0x64   0x463A             MOV      R2,R7
   \       0x66   0x4621             MOV      R1,R4
   \       0x68   0x1C70             ADDS     R0,R6,#+1
   \       0x6A   0x....'....        BL       __aeabi_memcpy
    701                  output[output_length + 1] = '\"';
   \       0x6E   0x2022             MOVS     R0,#+34
   \       0x70   0x19F1             ADDS     R1,R6,R7
   \       0x72   0x7048             STRB     R0,[R1, #+1]
    702                  output[output_length + 2] = '\0';
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x7088             STRB     R0,[R1, #+2]
    703          
    704                  return true;
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0xBDF2             POP      {R1,R4-R7,PC}
    705              }
    706          
    707              output[0] = '\"';
   \                     ??print_string_ptr_8: (+1)
   \       0x7C   0x2022             MOVS     R0,#+34
   \       0x7E   0x7030             STRB     R0,[R6, #+0]
    708              output_pointer = output + 1;
   \       0x80   0x1C75             ADDS     R5,R6,#+1
    709              /* copy the string */
    710              for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++) {
   \       0x82   0xE00B             B.N      ??print_string_ptr_9
    711                  if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\')) {
    712                      /* normal character, copy */
    713                      *output_pointer = *input_pointer;
    714                  } else {
    715                      /* character needs to be escaped */
    716                      *output_pointer++ = '\\';
    717                      switch (*input_pointer) {
    718                          case '\\':
    719                              *output_pointer = '\\';
    720                              break;
    721                          case '\"':
    722                              *output_pointer = '\"';
    723                              break;
    724                          case '\b':
    725                              *output_pointer = 'b';
    726                              break;
    727                          case '\f':
    728                              *output_pointer = 'f';
    729                              break;
    730                          case '\n':
    731                              *output_pointer = 'n';
    732                              break;
    733                          case '\r':
    734                              *output_pointer = 'r';
    735                              break;
    736                          case '\t':
    737                              *output_pointer = 't';
    738                              break;
    739                          default:
    740                              /* escape and print as unicode codepoint */
    741                              sprintf((char *)output_pointer, "u%04x", *input_pointer);
   \                     ??print_string_ptr_10: (+1)
   \       0x84   0x4602             MOV      R2,R0
   \       0x86   0x....'....        LDR.W    R1,??DataTable18
   \       0x8A   0x4628             MOV      R0,R5
   \       0x8C   0x....'....        BL       sprintf
    742                              output_pointer += 4;
   \       0x90   0x1D2D             ADDS     R5,R5,#+4
    743                              break;
   \       0x92   0xE001             B.N      ??print_string_ptr_11
   \                     ??print_string_ptr_12: (+1)
   \       0x94   0x2074             MOVS     R0,#+116
   \       0x96   0x7028             STRB     R0,[R5, #+0]
   \                     ??print_string_ptr_11: (+1)
   \       0x98   0x1C64             ADDS     R4,R4,#+1
   \       0x9A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??print_string_ptr_9: (+1)
   \       0x9C   0x7820             LDRB     R0,[R4, #+0]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD035             BEQ.N    ??print_string_ptr_13
   \       0xA2   0x2820             CMP      R0,#+32
   \       0xA4   0xDB05             BLT.N    ??print_string_ptr_14
   \       0xA6   0x2822             CMP      R0,#+34
   \       0xA8   0xD003             BEQ.N    ??print_string_ptr_14
   \       0xAA   0x285C             CMP      R0,#+92
   \       0xAC   0xD001             BEQ.N    ??print_string_ptr_14
   \       0xAE   0x7028             STRB     R0,[R5, #+0]
   \       0xB0   0xE7F2             B.N      ??print_string_ptr_11
   \                     ??print_string_ptr_14: (+1)
   \       0xB2   0x205C             MOVS     R0,#+92
   \       0xB4   0xF805 0x0B01      STRB     R0,[R5], #+1
   \       0xB8   0x7820             LDRB     R0,[R4, #+0]
   \       0xBA   0x2808             CMP      R0,#+8
   \       0xBC   0xD011             BEQ.N    ??print_string_ptr_15
   \       0xBE   0x2809             CMP      R0,#+9
   \       0xC0   0xD0E8             BEQ.N    ??print_string_ptr_12
   \       0xC2   0x280A             CMP      R0,#+10
   \       0xC4   0xD013             BEQ.N    ??print_string_ptr_16
   \       0xC6   0x280C             CMP      R0,#+12
   \       0xC8   0xD00E             BEQ.N    ??print_string_ptr_17
   \       0xCA   0x280D             CMP      R0,#+13
   \       0xCC   0xD012             BEQ.N    ??print_string_ptr_18
   \       0xCE   0x2822             CMP      R0,#+34
   \       0xD0   0xD004             BEQ.N    ??print_string_ptr_19
   \       0xD2   0x285C             CMP      R0,#+92
   \       0xD4   0xD1D6             BNE.N    ??print_string_ptr_10
   \       0xD6   0x205C             MOVS     R0,#+92
   \       0xD8   0x7028             STRB     R0,[R5, #+0]
   \       0xDA   0xE7DD             B.N      ??print_string_ptr_11
   \                     ??print_string_ptr_19: (+1)
   \       0xDC   0x2022             MOVS     R0,#+34
   \       0xDE   0x7028             STRB     R0,[R5, #+0]
   \       0xE0   0xE7DA             B.N      ??print_string_ptr_11
   \                     ??print_string_ptr_15: (+1)
   \       0xE2   0x2062             MOVS     R0,#+98
   \       0xE4   0x7028             STRB     R0,[R5, #+0]
   \       0xE6   0xE7D7             B.N      ??print_string_ptr_11
   \                     ??print_string_ptr_17: (+1)
   \       0xE8   0x2066             MOVS     R0,#+102
   \       0xEA   0x7028             STRB     R0,[R5, #+0]
   \       0xEC   0xE7D4             B.N      ??print_string_ptr_11
   \                     ??print_string_ptr_16: (+1)
   \       0xEE   0x206E             MOVS     R0,#+110
   \       0xF0   0x7028             STRB     R0,[R5, #+0]
   \       0xF2   0xE7D1             B.N      ??print_string_ptr_11
   \                     ??print_string_ptr_18: (+1)
   \       0xF4   0x2072             MOVS     R0,#+114
   \       0xF6   0x7028             STRB     R0,[R5, #+0]
   \       0xF8   0xE7CE             B.N      ??print_string_ptr_11
    744                      }
    745                  }
    746              }
   \                     ??print_string_ptr_4: (+1)
   \       0xFA   0x1B3F             SUBS     R7,R7,R4
   \       0xFC   0x19EF             ADDS     R7,R5,R7
   \       0xFE   0x1CF9             ADDS     R1,R7,#+3
   \      0x100   0x4610             MOV      R0,R2
   \      0x102   0x....'....        BL       ensure
   \      0x106   0x0006             MOVS     R6,R0
   \      0x108   0xD1A8             BNE.N    ??print_string_ptr_7
   \      0x10A   0x2000             MOVS     R0,#+0
   \      0x10C   0xBDF2             POP      {R1,R4-R7,PC}
    747              output[output_length + 1] = '\"';
   \                     ??print_string_ptr_13: (+1)
   \      0x10E   0x2022             MOVS     R0,#+34
   \      0x110   0x19F1             ADDS     R1,R6,R7
   \      0x112   0x7048             STRB     R0,[R1, #+1]
    748              output[output_length + 2] = '\0';
   \      0x114   0x2000             MOVS     R0,#+0
   \      0x116   0x7088             STRB     R0,[R1, #+2]
    749          
    750              return true;
   \      0x118   0x2001             MOVS     R0,#+1
   \      0x11A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    751          }
    752          
    753          /* Invoke print_string_ptr (which is useful) on an item. */

   \                                 In section .text, align 2, keep-with-next
    754          static cJSON_bool print_string(const cJSON *const item, printbuffer *const p)
    755          {
    756              return print_string_ptr((unsigned char *)item->valuestring, p);
   \                     print_string: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0x....             B.N      print_string_ptr
    757          }
    758          
    759          /* Predeclare these prototypes. */
    760          static cJSON_bool parse_value(cJSON *const item, parse_buffer *const input_buffer);
    761          static cJSON_bool print_value(const cJSON *const item, printbuffer *const output_buffer);
    762          static cJSON_bool parse_array(cJSON *const item, parse_buffer *const input_buffer);
    763          static cJSON_bool print_array(const cJSON *const item, printbuffer *const output_buffer);
    764          static cJSON_bool parse_object(cJSON *const item, parse_buffer *const input_buffer);
    765          static cJSON_bool print_object(const cJSON *const item, printbuffer *const output_buffer);
    766          
    767          /* Utility to jump whitespace and cr/lf */

   \                                 In section .text, align 2, keep-with-next
    768          static parse_buffer *buffer_skip_whitespace(parse_buffer *const buffer)
    769          {
    770              if ((buffer == NULL) || (buffer->content == NULL)) {
   \                     buffer_skip_whitespace: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD002             BEQ.N    ??buffer_skip_whitespace_0
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD109             BNE.N    ??buffer_skip_whitespace_1
    771                  return NULL;
   \                     ??buffer_skip_whitespace_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    772              }
    773          
    774              while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32)) {
   \                     ??buffer_skip_whitespace_2: (+1)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x6882             LDR      R2,[R0, #+8]
   \       0x12   0x5C89             LDRB     R1,[R1, R2]
   \       0x14   0x2921             CMP      R1,#+33
   \       0x16   0xDA06             BGE.N    ??buffer_skip_whitespace_3
    775                  buffer->offset++;
   \       0x18   0x4611             MOV      R1,R2
   \       0x1A   0x1C49             ADDS     R1,R1,#+1
   \       0x1C   0x6081             STR      R1,[R0, #+8]
    776              }
   \                     ??buffer_skip_whitespace_1: (+1)
   \       0x1E   0x6881             LDR      R1,[R0, #+8]
   \       0x20   0x6842             LDR      R2,[R0, #+4]
   \       0x22   0x4291             CMP      R1,R2
   \       0x24   0xD3F3             BCC.N    ??buffer_skip_whitespace_2
    777          
    778              if (buffer->offset == buffer->length) {
   \                     ??buffer_skip_whitespace_3: (+1)
   \       0x26   0x6881             LDR      R1,[R0, #+8]
   \       0x28   0x6842             LDR      R2,[R0, #+4]
   \       0x2A   0x4291             CMP      R1,R2
   \       0x2C   0xD101             BNE.N    ??buffer_skip_whitespace_4
    779                  buffer->offset--;
   \       0x2E   0x1E49             SUBS     R1,R1,#+1
   \       0x30   0x6081             STR      R1,[R0, #+8]
    780              }
    781          
    782              return buffer;
   \                     ??buffer_skip_whitespace_4: (+1)
   \       0x32   0x4770             BX       LR               ;; return
    783          }
    784          
    785          /* Parse an object - create a new root, and populate. */

   \                                 In section .text, align 2, keep-with-next
    786          CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end,
    787                  cJSON_bool require_null_terminated)
    788          {
   \                     cJSON_ParseWithOpts: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4617             MOV      R7,R2
    789              parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x211C             MOVS     R1,#+28
   \       0x10   0x....'....        BL       __aeabi_memclr4
    790              cJSON *item = NULL;
   \       0x14   0x2600             MOVS     R6,#+0
    791          
    792              /* reset error position */
    793              global_error.json = NULL;
   \       0x16   0x....'....        LDR.W    R8,??DataTable14
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0xF8C8 0x0000      STR      R0,[R8, #+0]
    794              global_error.position = 0;
   \       0x20   0xF8C8 0x0004      STR      R0,[R8, #+4]
    795          
    796              if (value == NULL) {
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD031             BEQ.N    ??cJSON_ParseWithOpts_0
    797                  goto fail;
    798              }
    799          
    800              buffer.content = (const unsigned char *)value;
   \       0x28   0x9400             STR      R4,[SP, #+0]
    801              buffer.length = strlen((const char *)value) + sizeof("");
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       strlen
   \       0x30   0x1C40             ADDS     R0,R0,#+1
   \       0x32   0x9001             STR      R0,[SP, #+4]
    802              buffer.offset = 0;
   \       0x34   0x4630             MOV      R0,R6
   \       0x36   0x9002             STR      R0,[SP, #+8]
    803              buffer.hooks = global_hooks;
   \       0x38   0x....'....        LDR.W    R0,??DataTable14_2
   \       0x3C   0xA904             ADD      R1,SP,#+16
   \       0x3E   0xE890 0x004C      LDM      R0,{R2,R3,R6}
   \       0x42   0xE881 0x004C      STM      R1,{R2,R3,R6}
    804          
    805              item = cJSON_New_Item(&global_hooks);
   \       0x46   0x....'....        BL       cJSON_New_Item
   \       0x4A   0x0006             MOVS     R6,R0
    806              if (item == NULL) { /* memory fail */
   \       0x4C   0xD01E             BEQ.N    ??cJSON_ParseWithOpts_0
    807                  goto fail;
    808              }
    809          
    810              if (!parse_value(item, buffer_skip_whitespace(&buffer))) {
   \       0x4E   0x4668             MOV      R0,SP
   \       0x50   0x....'....        BL       buffer_skip_whitespace
   \       0x54   0x4601             MOV      R1,R0
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0x....'....        BL       parse_value
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD015             BEQ.N    ??cJSON_ParseWithOpts_0
    811                  /* parse failure. ep is set. */
    812                  goto fail;
    813              }
    814          
    815              /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
    816              if (require_null_terminated) {
   \       0x60   0x2F00             CMP      R7,#+0
   \       0x62   0xD00B             BEQ.N    ??cJSON_ParseWithOpts_1
    817                  buffer_skip_whitespace(&buffer);
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x....'....        BL       buffer_skip_whitespace
    818                  if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0') {
   \       0x6A   0x9802             LDR      R0,[SP, #+8]
   \       0x6C   0x9901             LDR      R1,[SP, #+4]
   \       0x6E   0x4288             CMP      R0,R1
   \       0x70   0xD20C             BCS.N    ??cJSON_ParseWithOpts_0
   \       0x72   0x9800             LDR      R0,[SP, #+0]
   \       0x74   0x9902             LDR      R1,[SP, #+8]
   \       0x76   0x5C40             LDRB     R0,[R0, R1]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD107             BNE.N    ??cJSON_ParseWithOpts_0
    819                      goto fail;
    820                  }
    821              }
    822              if (return_parse_end) {
   \                     ??cJSON_ParseWithOpts_1: (+1)
   \       0x7C   0x2D00             CMP      R5,#+0
   \       0x7E   0xD003             BEQ.N    ??cJSON_ParseWithOpts_2
    823                  *return_parse_end = (const char *)buffer_at_offset(&buffer);
   \       0x80   0x9800             LDR      R0,[SP, #+0]
   \       0x82   0x9902             LDR      R1,[SP, #+8]
   \       0x84   0x4408             ADD      R0,R0,R1
   \       0x86   0x6028             STR      R0,[R5, #+0]
    824              }
    825          
    826              return item;
   \                     ??cJSON_ParseWithOpts_2: (+1)
   \       0x88   0x4630             MOV      R0,R6
   \       0x8A   0xE01C             B.N      ??cJSON_ParseWithOpts_3
    827          
    828          fail:
    829              if (item != NULL) {
   \                     ??cJSON_ParseWithOpts_0: (+1)
   \       0x8C   0x2E00             CMP      R6,#+0
   \       0x8E   0xD002             BEQ.N    ??cJSON_ParseWithOpts_4
    830                  cJSON_Delete(item);
   \       0x90   0x4630             MOV      R0,R6
   \       0x92   0x....'....        BL       cJSON_Delete
    831              }
    832          
    833              if (value != NULL) {
   \                     ??cJSON_ParseWithOpts_4: (+1)
   \       0x96   0x2C00             CMP      R4,#+0
   \       0x98   0xD014             BEQ.N    ??cJSON_ParseWithOpts_5
    834                  error local_error;
    835                  local_error.json = (const unsigned char *)value;
    836                  local_error.position = 0;
   \       0x9A   0x2100             MOVS     R1,#+0
    837          
    838                  if (buffer.offset < buffer.length) {
   \       0x9C   0x9802             LDR      R0,[SP, #+8]
   \       0x9E   0x9A01             LDR      R2,[SP, #+4]
   \       0xA0   0x4290             CMP      R0,R2
   \       0xA2   0xD201             BCS.N    ??cJSON_ParseWithOpts_6
    839                      local_error.position = buffer.offset;
   \       0xA4   0x4601             MOV      R1,R0
   \       0xA6   0xE004             B.N      ??cJSON_ParseWithOpts_7
    840                  } else if (buffer.length > 0) {
   \                     ??cJSON_ParseWithOpts_6: (+1)
   \       0xA8   0x4610             MOV      R0,R2
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD001             BEQ.N    ??cJSON_ParseWithOpts_7
    841                      local_error.position = buffer.length - 1;
   \       0xAE   0x4601             MOV      R1,R0
   \       0xB0   0x1E49             SUBS     R1,R1,#+1
    842                  }
    843          
    844                  if (return_parse_end != NULL) {
   \                     ??cJSON_ParseWithOpts_7: (+1)
   \       0xB2   0x2D00             CMP      R5,#+0
   \       0xB4   0xD002             BEQ.N    ??cJSON_ParseWithOpts_8
    845                      *return_parse_end = (const char *)local_error.json + local_error.position;
   \       0xB6   0x1860             ADDS     R0,R4,R1
   \       0xB8   0x6028             STR      R0,[R5, #+0]
   \       0xBA   0xE003             B.N      ??cJSON_ParseWithOpts_5
    846                  } else {
    847                      global_error = local_error;
   \                     ??cJSON_ParseWithOpts_8: (+1)
   \       0xBC   0xF8C8 0x4000      STR      R4,[R8, #+0]
   \       0xC0   0xF8C8 0x1004      STR      R1,[R8, #+4]
    848                  }
    849              }
    850          
    851              return NULL;
   \                     ??cJSON_ParseWithOpts_5: (+1)
   \       0xC4   0x2000             MOVS     R0,#+0
   \                     ??cJSON_ParseWithOpts_3: (+1)
   \       0xC6   0xB008             ADD      SP,SP,#+32
   \       0xC8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    852          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0H, 0, 0, 0, 0H, 0H, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
    853          
    854          /* Default options for cJSON_Parse */

   \                                 In section .text, align 2, keep-with-next
    855          CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
    856          {
    857              return cJSON_ParseWithOpts(value, 0, 0);
   \                     cJSON_Parse: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x4611             MOV      R1,R2
   \        0x4   0x....             B.N      cJSON_ParseWithOpts
    858          }
    859          
    860          #define cjson_min(a, b) ((a < b) ? a : b)
    861          

   \                                 In section .text, align 2, keep-with-next
    862          static unsigned char *print(const cJSON *const item, cJSON_bool format, const internal_hooks *const hooks)
    863          {
   \                     print: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
    864              printbuffer buffer[1];
    865              unsigned char *printed = NULL;
    866          
    867              memset(buffer, 0, sizeof(buffer));
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2124             MOVS     R1,#+36
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x....'....        BL       __aeabi_memset4
    868          
    869              /* create buffer */
    870              buffer->buffer = (unsigned char *)hooks->allocate(256);
   \       0x14   0xF44F 0x7080      MOV      R0,#+256
   \       0x18   0x6829             LDR      R1,[R5, #+0]
   \       0x1A   0x4788             BLX      R1
   \       0x1C   0x9000             STR      R0,[SP, #+0]
    871              buffer->format = format;
   \       0x1E   0x9605             STR      R6,[SP, #+20]
    872              buffer->hooks = *hooks;
   \       0x20   0xA806             ADD      R0,SP,#+24
   \       0x22   0xE895 0x000E      LDM      R5,{R1-R3}
   \       0x26   0xE880 0x000E      STM      R0,{R1-R3}
    873              if (buffer->buffer == NULL) {
   \       0x2A   0x9800             LDR      R0,[SP, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD014             BEQ.N    ??print_0
    874                  goto fail;
    875              }
    876          
    877              /* print the value */
    878              if (!print_value(item, buffer)) {
   \       0x30   0x4669             MOV      R1,SP
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x....'....        BL       print_value
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD00E             BEQ.N    ??print_0
    879                  goto fail;
    880              }
    881              update_offset(buffer);
   \       0x3C   0x4668             MOV      R0,SP
   \       0x3E   0x....'....        BL       update_offset
    882          
    883              /* check if reallocate is available */
    884              if (hooks->reallocate != NULL) {
   \       0x42   0x68A8             LDR      R0,[R5, #+8]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD010             BEQ.N    ??print_1
    885                  printed = (unsigned char *)hooks->reallocate(buffer->buffer, buffer->length);
   \       0x48   0x9901             LDR      R1,[SP, #+4]
   \       0x4A   0x9800             LDR      R0,[SP, #+0]
   \       0x4C   0x68AA             LDR      R2,[R5, #+8]
   \       0x4E   0x4790             BLX      R2
   \       0x50   0x4604             MOV      R4,R0
    886                  buffer->buffer = NULL;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x9000             STR      R0,[SP, #+0]
    887                  if (printed == NULL) {
   \       0x56   0x2C00             CMP      R4,#+0
   \       0x58   0xD121             BNE.N    ??print_2
    888                      goto fail;
    889                  }
    890              } else { /* otherwise copy the JSON over to a new buffer */
    891                  printed = (unsigned char *)hooks->allocate(buffer->offset + 1);
    892                  if (printed == NULL) {
    893                      goto fail;
    894                  }
    895                  memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
    896                  printed[buffer->offset] = '\0'; /* just to be sure */
    897          
    898                  /* free the buffer */
    899                  hooks->deallocate(buffer->buffer);
    900              }
    901          
    902              return printed;
    903          
    904          fail:
    905              if (buffer->buffer != NULL) {
   \                     ??print_0: (+1)
   \       0x5A   0x9800             LDR      R0,[SP, #+0]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD001             BEQ.N    ??print_3
    906                  hooks->deallocate(buffer->buffer);
   \       0x60   0x6869             LDR      R1,[R5, #+4]
   \       0x62   0x4788             BLX      R1
    907              }
    908          
    909          #if 0
    910              if (printed != NULL) {
    911                  hooks->deallocate(printed);
    912              }
    913          #endif
    914          
    915              return NULL;
   \                     ??print_3: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \                     ??print_4: (+1)
   \       0x66   0xB00A             ADD      SP,SP,#+40
   \       0x68   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??print_1: (+1)
   \       0x6A   0x466E             MOV      R6,SP
   \       0x6C   0x68B0             LDR      R0,[R6, #+8]
   \       0x6E   0x1C40             ADDS     R0,R0,#+1
   \       0x70   0x6829             LDR      R1,[R5, #+0]
   \       0x72   0x4788             BLX      R1
   \       0x74   0x0004             MOVS     R4,R0
   \       0x76   0xD0F0             BEQ.N    ??print_0
   \       0x78   0x6870             LDR      R0,[R6, #+4]
   \       0x7A   0x68B1             LDR      R1,[R6, #+8]
   \       0x7C   0x1C49             ADDS     R1,R1,#+1
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0xD201             BCS.N    ??print_5
   \       0x82   0x4602             MOV      R2,R0
   \       0x84   0xE001             B.N      ??print_6
   \                     ??print_5: (+1)
   \       0x86   0x68B2             LDR      R2,[R6, #+8]
   \       0x88   0x1C52             ADDS     R2,R2,#+1
   \                     ??print_6: (+1)
   \       0x8A   0x9900             LDR      R1,[SP, #+0]
   \       0x8C   0x4620             MOV      R0,R4
   \       0x8E   0x....'....        BL       __aeabi_memcpy
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x68B1             LDR      R1,[R6, #+8]
   \       0x96   0x5460             STRB     R0,[R4, R1]
   \       0x98   0x9800             LDR      R0,[SP, #+0]
   \       0x9A   0x6869             LDR      R1,[R5, #+4]
   \       0x9C   0x4788             BLX      R1
   \                     ??print_2: (+1)
   \       0x9E   0x4620             MOV      R0,R4
   \       0xA0   0xE7E1             B.N      ??print_4
    916          }
    917          
    918          /* Render a cJSON item/entity/structure to text. */

   \                                 In section .text, align 2, keep-with-next
    919          CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
    920          {
    921              return (char *)print(item, true, &global_hooks);
   \                     cJSON_Print: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable14_2
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x....             B.N      print
    922          }
    923          

   \                                 In section .text, align 2, keep-with-next
    924          CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
    925          {
    926              return (char *)print(item, false, &global_hooks);
   \                     cJSON_PrintUnformatted: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable14_2
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x....             B.N      print
    927          }
    928          

   \                                 In section .text, align 2, keep-with-next
    929          CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
    930          {
   \                     cJSON_PrintBuffered: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
    931              printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x2124             MOVS     R1,#+36
   \        0xE   0x....'....        BL       __aeabi_memclr4
    932          
    933              if (prebuffer < 0) {
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD501             BPL.N    ??cJSON_PrintBuffered_0
    934                  return NULL;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE01B             B.N      ??cJSON_PrintBuffered_1
    935              }
    936          
    937              p.buffer = (unsigned char *)global_hooks.allocate((size_t)prebuffer);
   \                     ??cJSON_PrintBuffered_0: (+1)
   \       0x1A   0x....             LDR.N    R7,??DataTable14_2
   \       0x1C   0x4630             MOV      R0,R6
   \       0x1E   0x6839             LDR      R1,[R7, #+0]
   \       0x20   0x4788             BLX      R1
   \       0x22   0x9000             STR      R0,[SP, #+0]
    938              if (!p.buffer) {
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD101             BNE.N    ??cJSON_PrintBuffered_2
    939                  return NULL;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE012             B.N      ??cJSON_PrintBuffered_1
    940              }
    941          
    942              p.length = (size_t)prebuffer;
   \                     ??cJSON_PrintBuffered_2: (+1)
   \       0x2C   0x9601             STR      R6,[SP, #+4]
    943              p.offset = 0;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x9002             STR      R0,[SP, #+8]
    944              p.noalloc = false;
   \       0x32   0x9004             STR      R0,[SP, #+16]
    945              p.format = fmt;
   \       0x34   0x9505             STR      R5,[SP, #+20]
    946              p.hooks = global_hooks;
   \       0x36   0xA806             ADD      R0,SP,#+24
   \       0x38   0xE897 0x000E      LDM      R7,{R1-R3}
   \       0x3C   0xE880 0x000E      STM      R0,{R1-R3}
    947          
    948              if (!print_value(item, &p)) {
   \       0x40   0x4669             MOV      R1,SP
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0x....'....        BL       print_value
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD101             BNE.N    ??cJSON_PrintBuffered_3
    949                  return NULL;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xE000             B.N      ??cJSON_PrintBuffered_1
    950              }
    951          
    952              return (char *)p.buffer;
   \                     ??cJSON_PrintBuffered_3: (+1)
   \       0x50   0x9800             LDR      R0,[SP, #+0]
   \                     ??cJSON_PrintBuffered_1: (+1)
   \       0x52   0xB009             ADD      SP,SP,#+36
   \       0x54   0xBDF0             POP      {R4-R7,PC}       ;; return
    953          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0H, 0, 0, 0, 0, 0, 0H, 0H, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
    954          

   \                                 In section .text, align 2, keep-with-next
    955          CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)
    956          {
   \                     cJSON_PrintPreallocated: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461D             MOV      R5,R3
    957              printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x2124             MOVS     R1,#+36
   \       0x10   0x....'....        BL       __aeabi_memclr4
    958          
    959              if (len < 0) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD501             BPL.N    ??cJSON_PrintPreallocated_0
    960                  return false;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE010             B.N      ??cJSON_PrintPreallocated_1
    961              }
    962          
    963              p.buffer = (unsigned char *)buf;
   \                     ??cJSON_PrintPreallocated_0: (+1)
   \       0x1C   0x9700             STR      R7,[SP, #+0]
    964              p.length = (size_t)len;
   \       0x1E   0x9401             STR      R4,[SP, #+4]
    965              p.offset = 0;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x9002             STR      R0,[SP, #+8]
    966              p.noalloc = true;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x9004             STR      R0,[SP, #+16]
    967              p.format = fmt;
   \       0x28   0x9505             STR      R5,[SP, #+20]
    968              p.hooks = global_hooks;
   \       0x2A   0xA806             ADD      R0,SP,#+24
   \       0x2C   0x....             LDR.N    R1,??DataTable14_2
   \       0x2E   0xE891 0x001C      LDM      R1,{R2-R4}
   \       0x32   0xE880 0x001C      STM      R0,{R2-R4}
    969          
    970              return print_value(item, &p);
   \       0x36   0x4669             MOV      R1,SP
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x....'....        BL       print_value
   \                     ??cJSON_PrintPreallocated_1: (+1)
   \       0x3E   0xB009             ADD      SP,SP,#+36
   \       0x40   0xBDF0             POP      {R4-R7,PC}       ;; return
    971          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0H, 0, 0, 0, 0, 0, 0H, 0H, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
    972          
    973          /* Parser core - when encountering text, process appropriately. */

   \                                 In section .text, align 2, keep-with-next
    974          static cJSON_bool parse_value(cJSON *const item, parse_buffer *const input_buffer)
    975          {
   \                     parse_value: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    976              if ((input_buffer == NULL) || (input_buffer->content == NULL)) {
   \        0x6   0xF000 0x8085      BEQ.W    ??parse_value_0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xF000 0x8081      BEQ.W    ??parse_value_0
    977                  return false; /* no input */
    978              }
    979          
    980              /* parse the different types of values */
    981              /* null */
    982              if (can_read(input_buffer, 4) && (strncmp((const char *)buffer_at_offset(input_buffer), "null", 4) == 0)) {
   \       0x12   0x6860             LDR      R0,[R4, #+4]
   \       0x14   0x68A1             LDR      R1,[R4, #+8]
   \       0x16   0x1D09             ADDS     R1,R1,#+4
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xD30F             BCC.N    ??parse_value_1
   \       0x1C   0x2204             MOVS     R2,#+4
   \       0x1E   0x....             LDR.N    R1,??DataTable14_3
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x68A3             LDR      R3,[R4, #+8]
   \       0x24   0x4418             ADD      R0,R0,R3
   \       0x26   0x....'....        BL       strncmp
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD106             BNE.N    ??parse_value_1
    983                  item->type = cJSON_NULL;
   \       0x2E   0x2004             MOVS     R0,#+4
   \       0x30   0x60E8             STR      R0,[R5, #+12]
    984                  input_buffer->offset += 4;
   \       0x32   0x68A0             LDR      R0,[R4, #+8]
   \       0x34   0x1D00             ADDS     R0,R0,#+4
   \       0x36   0x60A0             STR      R0,[R4, #+8]
    985                  return true;
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
    986              }
    987              /* false */
    988              if (can_read(input_buffer, 5) && (strncmp((const char *)buffer_at_offset(input_buffer), "false", 5) == 0)) {
   \                     ??parse_value_1: (+1)
   \       0x3C   0x6860             LDR      R0,[R4, #+4]
   \       0x3E   0x68A1             LDR      R1,[R4, #+8]
   \       0x40   0x1D49             ADDS     R1,R1,#+5
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xD310             BCC.N    ??parse_value_2
   \       0x46   0x2205             MOVS     R2,#+5
   \       0x48   0x....'....        LDR.W    R1,??DataTable28
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x68A3             LDR      R3,[R4, #+8]
   \       0x50   0x4418             ADD      R0,R0,R3
   \       0x52   0x....'....        BL       strncmp
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD106             BNE.N    ??parse_value_2
    989                  item->type = cJSON_False;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x60E8             STR      R0,[R5, #+12]
    990                  input_buffer->offset += 5;
   \       0x5E   0x68A0             LDR      R0,[R4, #+8]
   \       0x60   0x1D40             ADDS     R0,R0,#+5
   \       0x62   0x60A0             STR      R0,[R4, #+8]
    991                  return true;
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xBD32             POP      {R1,R4,R5,PC}
    992              }
    993              /* true */
    994              if (can_read(input_buffer, 4) && (strncmp((const char *)buffer_at_offset(input_buffer), "true", 4) == 0)) {
   \                     ??parse_value_2: (+1)
   \       0x68   0x6860             LDR      R0,[R4, #+4]
   \       0x6A   0x68A1             LDR      R1,[R4, #+8]
   \       0x6C   0x1D09             ADDS     R1,R1,#+4
   \       0x6E   0x4288             CMP      R0,R1
   \       0x70   0xD312             BCC.N    ??parse_value_3
   \       0x72   0x2204             MOVS     R2,#+4
   \       0x74   0x....'....        LDR.W    R1,??DataTable28_2
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x68A3             LDR      R3,[R4, #+8]
   \       0x7C   0x4418             ADD      R0,R0,R3
   \       0x7E   0x....'....        BL       strncmp
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD108             BNE.N    ??parse_value_3
    995                  item->type = cJSON_True;
   \       0x86   0x2002             MOVS     R0,#+2
   \       0x88   0x60E8             STR      R0,[R5, #+12]
    996                  item->valueint = 1;
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0x6168             STR      R0,[R5, #+20]
    997                  input_buffer->offset += 4;
   \       0x8E   0x68A0             LDR      R0,[R4, #+8]
   \       0x90   0x1D00             ADDS     R0,R0,#+4
   \       0x92   0x60A0             STR      R0,[R4, #+8]
    998                  return true;
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0xBD32             POP      {R1,R4,R5,PC}
    999              }
   1000              /* string */
   1001              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"')) {
   \                     ??parse_value_3: (+1)
   \       0x98   0x68A0             LDR      R0,[R4, #+8]
   \       0x9A   0x6861             LDR      R1,[R4, #+4]
   \       0x9C   0x4288             CMP      R0,R1
   \       0x9E   0xD209             BCS.N    ??parse_value_4
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x68A1             LDR      R1,[R4, #+8]
   \       0xA4   0x5C40             LDRB     R0,[R0, R1]
   \       0xA6   0x2822             CMP      R0,#+34
   \       0xA8   0xD104             BNE.N    ??parse_value_4
   1002                  return parse_string(item, input_buffer);
   \       0xAA   0x4621             MOV      R1,R4
   \       0xAC   0x4628             MOV      R0,R5
   \       0xAE   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0xB2   0x....             B.N      parse_string
   1003              }
   1004              /* number */
   1005              if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-')
   1006                      || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9')))) {
   \                     ??parse_value_4: (+1)
   \       0xB4   0x68A0             LDR      R0,[R4, #+8]
   \       0xB6   0x6861             LDR      R1,[R4, #+4]
   \       0xB8   0x4288             CMP      R0,R1
   \       0xBA   0xD20F             BCS.N    ??parse_value_5
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x68A1             LDR      R1,[R4, #+8]
   \       0xC0   0x5C40             LDRB     R0,[R0, R1]
   \       0xC2   0x282D             CMP      R0,#+45
   \       0xC4   0xD004             BEQ.N    ??parse_value_6
   \       0xC6   0x6820             LDR      R0,[R4, #+0]
   \       0xC8   0x5C40             LDRB     R0,[R0, R1]
   \       0xCA   0x3830             SUBS     R0,R0,#+48
   \       0xCC   0x280A             CMP      R0,#+10
   \       0xCE   0xD205             BCS.N    ??parse_value_5
   1007                  return parse_number(item, input_buffer);
   \                     ??parse_value_6: (+1)
   \       0xD0   0x4621             MOV      R1,R4
   \       0xD2   0x4628             MOV      R0,R5
   \       0xD4   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0xD8   0x....'....        B.W      parse_number
   1008              }
   1009              /* array */
   1010              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '[')) {
   \                     ??parse_value_5: (+1)
   \       0xDC   0x68A0             LDR      R0,[R4, #+8]
   \       0xDE   0x6861             LDR      R1,[R4, #+4]
   \       0xE0   0x4288             CMP      R0,R1
   \       0xE2   0xD209             BCS.N    ??parse_value_7
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0x68A1             LDR      R1,[R4, #+8]
   \       0xE8   0x5C40             LDRB     R0,[R0, R1]
   \       0xEA   0x285B             CMP      R0,#+91
   \       0xEC   0xD104             BNE.N    ??parse_value_7
   1011                  return parse_array(item, input_buffer);
   \       0xEE   0x4621             MOV      R1,R4
   \       0xF0   0x4628             MOV      R0,R5
   \       0xF2   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0xF6   0x....             B.N      parse_array
   1012              }
   1013              /* object */
   1014              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{')) {
   \                     ??parse_value_7: (+1)
   \       0xF8   0x68A0             LDR      R0,[R4, #+8]
   \       0xFA   0x6861             LDR      R1,[R4, #+4]
   \       0xFC   0x4288             CMP      R0,R1
   \       0xFE   0xD209             BCS.N    ??parse_value_0
   \      0x100   0x6820             LDR      R0,[R4, #+0]
   \      0x102   0x68A1             LDR      R1,[R4, #+8]
   \      0x104   0x5C40             LDRB     R0,[R0, R1]
   \      0x106   0x287B             CMP      R0,#+123
   \      0x108   0xD104             BNE.N    ??parse_value_0
   1015                  return parse_object(item, input_buffer);
   \      0x10A   0x4621             MOV      R1,R4
   \      0x10C   0x4628             MOV      R0,R5
   \      0x10E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \      0x112   0x....             B.N      parse_object
   1016              }
   1017          
   1018          
   1019              return false;
   \                     ??parse_value_0: (+1)
   \      0x114   0x2000             MOVS     R0,#+0
   \      0x116   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1020          }
   1021          
   1022          /* Render a value to text. */

   \                                 In section .text, align 2, keep-with-next
   1023          static cJSON_bool print_value(const cJSON *const item, printbuffer *const output_buffer)
   1024          {
   \                     print_value: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1025              unsigned char *output = NULL;
   1026          
   1027              if ((item == NULL) || (output_buffer == NULL)) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??print_value_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??print_value_1
   1028                  return false;
   \                     ??print_value_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD70             POP      {R4-R6,PC}
   1029              }
   1030          
   1031              switch ((item->type) & 0xFF) {
   \                     ??print_value_1: (+1)
   \       0x12   0x68E0             LDR      R0,[R4, #+12]
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD01C             BEQ.N    ??print_value_2
   \       0x1A   0x2802             CMP      R0,#+2
   \       0x1C   0xD029             BEQ.N    ??print_value_3
   \       0x1E   0x2804             CMP      R0,#+4
   \       0x20   0xD00A             BEQ.N    ??print_value_4
   \       0x22   0x2808             CMP      R0,#+8
   \       0x24   0xD034             BEQ.N    ??print_value_5
   \       0x26   0x2810             CMP      R0,#+16
   \       0x28   0xD054             BEQ.N    ??print_value_6
   \       0x2A   0x2820             CMP      R0,#+32
   \       0x2C   0xD056             BEQ.N    ??print_value_7
   \       0x2E   0x2840             CMP      R0,#+64
   \       0x30   0xD058             BEQ.N    ??print_value_8
   \       0x32   0x2880             CMP      R0,#+128
   \       0x34   0xD031             BEQ.N    ??print_value_9
   \       0x36   0xE059             B.N      ??print_value_10
   1032                  case cJSON_NULL:
   1033                      output = ensure(output_buffer, 5);
   \                     ??print_value_4: (+1)
   \       0x38   0x2105             MOVS     R1,#+5
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0x....'....        BL       ensure
   1034                      if (output == NULL) {
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD101             BNE.N    ??print_value_11
   1035                          return false;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD70             POP      {R4-R6,PC}
   1036                      }
   1037                      strcpy((char *)output, "null");
   \                     ??print_value_11: (+1)
   \       0x48   0x2205             MOVS     R2,#+5
   \       0x4A   0x....             LDR.N    R1,??DataTable14_3
   \       0x4C   0x....'....        BL       __aeabi_memcpy
   1038                      return true;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xBD70             POP      {R4-R6,PC}
   1039          
   1040                  case cJSON_False:
   1041                      output = ensure(output_buffer, 6);
   \                     ??print_value_2: (+1)
   \       0x54   0x2106             MOVS     R1,#+6
   \       0x56   0x4628             MOV      R0,R5
   \       0x58   0x....'....        BL       ensure
   1042                      if (output == NULL) {
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD101             BNE.N    ??print_value_12
   1043                          return false;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xBD70             POP      {R4-R6,PC}
   1044                      }
   1045                      strcpy((char *)output, "false");
   \                     ??print_value_12: (+1)
   \       0x64   0x2206             MOVS     R2,#+6
   \       0x66   0x....'....        LDR.W    R1,??DataTable28
   \       0x6A   0x....'....        BL       __aeabi_memcpy
   1046                      return true;
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0xBD70             POP      {R4-R6,PC}
   1047          
   1048                  case cJSON_True:
   1049                      output = ensure(output_buffer, 5);
   \                     ??print_value_3: (+1)
   \       0x72   0x2105             MOVS     R1,#+5
   \       0x74   0x4628             MOV      R0,R5
   \       0x76   0x....'....        BL       ensure
   1050                      if (output == NULL) {
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD101             BNE.N    ??print_value_13
   1051                          return false;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xBD70             POP      {R4-R6,PC}
   1052                      }
   1053                      strcpy((char *)output, "true");
   \                     ??print_value_13: (+1)
   \       0x82   0x2205             MOVS     R2,#+5
   \       0x84   0x....'....        LDR.W    R1,??DataTable28_2
   \       0x88   0x....'....        BL       __aeabi_memcpy
   1054                      return true;
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xBD70             POP      {R4-R6,PC}
   1055          
   1056                  case cJSON_Number:
   1057                      return print_number(item, output_buffer);
   \                     ??print_value_5: (+1)
   \       0x90   0x4620             MOV      R0,R4
   \       0x92   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x96   0x....'....        B.W      print_number
   1058          
   1059                  case cJSON_Raw: {
   1060                      size_t raw_length = 0;
   1061                      if (item->valuestring == NULL) {
   \                     ??print_value_9: (+1)
   \       0x9A   0x6920             LDR      R0,[R4, #+16]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD107             BNE.N    ??print_value_14
   1062                          if (!output_buffer->noalloc) {
   \       0xA0   0x6928             LDR      R0,[R5, #+16]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD102             BNE.N    ??print_value_15
   1063                              output_buffer->hooks.deallocate(output_buffer->buffer);
   \       0xA6   0x6828             LDR      R0,[R5, #+0]
   \       0xA8   0x69E9             LDR      R1,[R5, #+28]
   \       0xAA   0x4788             BLX      R1
   1064                          }
   1065                          return false;
   \                     ??print_value_15: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xBD70             POP      {R4-R6,PC}
   1066                      }
   1067          
   1068                      raw_length = strlen(item->valuestring) + sizeof("");
   \                     ??print_value_14: (+1)
   \       0xB0   0x....'....        BL       strlen
   \       0xB4   0x4606             MOV      R6,R0
   \       0xB6   0x1C76             ADDS     R6,R6,#+1
   1069                      output = ensure(output_buffer, raw_length);
   \       0xB8   0x4631             MOV      R1,R6
   \       0xBA   0x4628             MOV      R0,R5
   \       0xBC   0x....'....        BL       ensure
   1070                      if (output == NULL) {
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD101             BNE.N    ??print_value_16
   1071                          return false;
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0xBD70             POP      {R4-R6,PC}
   1072                      }
   1073                      memcpy(output, item->valuestring, raw_length);
   \                     ??print_value_16: (+1)
   \       0xC8   0x4632             MOV      R2,R6
   \       0xCA   0x6921             LDR      R1,[R4, #+16]
   \       0xCC   0x....'....        BL       __aeabi_memcpy
   1074                      return true;
   \       0xD0   0x2001             MOVS     R0,#+1
   \       0xD2   0xBD70             POP      {R4-R6,PC}
   1075                  }
   1076          
   1077                  case cJSON_String:
   1078                      return print_string(item, output_buffer);
   \                     ??print_value_6: (+1)
   \       0xD4   0x4620             MOV      R0,R4
   \       0xD6   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xDA   0x....             B.N      print_string
   1079          
   1080                  case cJSON_Array:
   1081                      return print_array(item, output_buffer);
   \                     ??print_value_7: (+1)
   \       0xDC   0x4620             MOV      R0,R4
   \       0xDE   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xE2   0x....             B.N      print_array
   1082          
   1083                  case cJSON_Object:
   1084                      return print_object(item, output_buffer);
   \                     ??print_value_8: (+1)
   \       0xE4   0x4620             MOV      R0,R4
   \       0xE6   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xEA   0x....             B.N      print_object
   1085          
   1086                  default:
   1087                      return false;
   \                     ??print_value_10: (+1)
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0xBD70             POP      {R4-R6,PC}       ;; return
   1088              }
   1089          }
   1090          
   1091          /* Build an array from input text. */

   \                                 In section .text, align 2, keep-with-next
   1092          static cJSON_bool parse_array(cJSON *const item, parse_buffer *const input_buffer)
   1093          {
   \                     parse_array: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   1094              cJSON *head = NULL; /* head of the linked list */
   \        0x6   0x2500             MOVS     R5,#+0
   1095              cJSON *current_item = NULL;
   \        0x8   0x462F             MOV      R7,R5
   1096          
   1097              if (input_buffer->depth >= CJSON_NESTING_LIMIT) {
   \        0xA   0x68E0             LDR      R0,[R4, #+12]
   \        0xC   0xF5B0 0x7F7A      CMP      R0,#+1000
   \       0x10   0xD225             BCS.N    ??parse_array_0
   1098                  return false; /* to deeply nested */
   1099              }
   1100              input_buffer->depth++;
   \       0x12   0x1C40             ADDS     R0,R0,#+1
   \       0x14   0x60E0             STR      R0,[R4, #+12]
   1101          
   1102              if (buffer_at_offset(input_buffer)[0] != '[') {
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x68A1             LDR      R1,[R4, #+8]
   \       0x1A   0x5C40             LDRB     R0,[R0, R1]
   \       0x1C   0x285B             CMP      R0,#+91
   \       0x1E   0xD119             BNE.N    ??parse_array_1
   1103                  /* not an array */
   1104                  goto fail;
   1105              }
   1106          
   1107              input_buffer->offset++;
   \       0x20   0x68A0             LDR      R0,[R4, #+8]
   \       0x22   0x1C40             ADDS     R0,R0,#+1
   \       0x24   0x60A0             STR      R0,[R4, #+8]
   1108              buffer_skip_whitespace(input_buffer);
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       buffer_skip_whitespace
   1109              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']')) {
   \       0x2C   0x2C00             CMP      R4,#+0
   \       0x2E   0xD008             BEQ.N    ??parse_array_2
   \       0x30   0x68A0             LDR      R0,[R4, #+8]
   \       0x32   0x6861             LDR      R1,[R4, #+4]
   \       0x34   0x4288             CMP      R0,R1
   \       0x36   0xD204             BCS.N    ??parse_array_2
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x68A1             LDR      R1,[R4, #+8]
   \       0x3C   0x5C40             LDRB     R0,[R0, R1]
   \       0x3E   0x285D             CMP      R0,#+93
   \       0x40   0xD044             BEQ.N    ??parse_array_3
   1110                  /* empty array */
   1111                  goto success;
   1112              }
   1113          
   1114              /* check if we skipped to the end of the buffer */
   1115              if (cannot_access_at_index(input_buffer, 0)) {
   \                     ??parse_array_2: (+1)
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD003             BEQ.N    ??parse_array_4
   \       0x46   0x68A0             LDR      R0,[R4, #+8]
   \       0x48   0x6861             LDR      R1,[R4, #+4]
   \       0x4A   0x4288             CMP      R0,R1
   \       0x4C   0xD309             BCC.N    ??parse_array_5
   1116                  input_buffer->offset--;
   \                     ??parse_array_4: (+1)
   \       0x4E   0x68A0             LDR      R0,[R4, #+8]
   \       0x50   0x1E40             SUBS     R0,R0,#+1
   \       0x52   0x60A0             STR      R0,[R4, #+8]
   1117                  goto fail;
   1118              }
   1119          
   1120              /* step back to character in front of the first element */
   1121              input_buffer->offset--;
   1122              /* loop through the comma separated array elements */
   1123              do {
   1124                  /* allocate next item */
   1125                  cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
   1126                  if (new_item == NULL) {
   1127                      goto fail; /* allocation failure */
   1128                  }
   1129          
   1130                  /* attach next item to list */
   1131                  if (head == NULL) {
   1132                      /* start the linked list */
   1133                      current_item = head = new_item;
   1134                  } else {
   1135                      /* add to the end and advance */
   1136                      current_item->next = new_item;
   1137                      new_item->prev = current_item;
   1138                      current_item = new_item;
   1139                  }
   1140          
   1141                  /* parse next value */
   1142                  input_buffer->offset++;
   1143                  buffer_skip_whitespace(input_buffer);
   1144                  if (!parse_value(current_item, input_buffer)) {
   1145                      goto fail; /* failed to parse value */
   1146                  }
   1147                  buffer_skip_whitespace(input_buffer);
   1148              } while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
   1149          
   1150              if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']') {
   1151                  goto fail; /* expected end of array */
   1152              }
   1153          
   1154          success:
   1155              input_buffer->depth--;
   1156          
   1157              item->type = cJSON_Array;
   1158              item->child = head;
   1159          
   1160              input_buffer->offset++;
   1161          
   1162              return true;
   1163          
   1164          fail:
   1165              if (head != NULL) {
   \                     ??parse_array_1: (+1)
   \       0x54   0x2D00             CMP      R5,#+0
   \       0x56   0xD002             BEQ.N    ??parse_array_0
   1166                  cJSON_Delete(head);
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       cJSON_Delete
   1167              }
   1168          
   1169              return false;
   \                     ??parse_array_0: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??parse_array_5: (+1)
   \       0x62   0x1E40             SUBS     R0,R0,#+1
   \       0x64   0x60A0             STR      R0,[R4, #+8]
   \                     ??parse_array_6: (+1)
   \       0x66   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x6A   0x....'....        BL       cJSON_New_Item
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD0F0             BEQ.N    ??parse_array_1
   \       0x72   0x2D00             CMP      R5,#+0
   \       0x74   0xD102             BNE.N    ??parse_array_7
   \       0x76   0x4605             MOV      R5,R0
   \       0x78   0x462F             MOV      R7,R5
   \       0x7A   0xE002             B.N      ??parse_array_8
   \                     ??parse_array_7: (+1)
   \       0x7C   0x6038             STR      R0,[R7, #+0]
   \       0x7E   0x6047             STR      R7,[R0, #+4]
   \       0x80   0x4607             MOV      R7,R0
   \                     ??parse_array_8: (+1)
   \       0x82   0x68A0             LDR      R0,[R4, #+8]
   \       0x84   0x1C40             ADDS     R0,R0,#+1
   \       0x86   0x60A0             STR      R0,[R4, #+8]
   \       0x88   0x4620             MOV      R0,R4
   \       0x8A   0x....'....        BL       buffer_skip_whitespace
   \       0x8E   0x4621             MOV      R1,R4
   \       0x90   0x4638             MOV      R0,R7
   \       0x92   0x....'....        BL       parse_value
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD0DC             BEQ.N    ??parse_array_1
   \       0x9A   0x4620             MOV      R0,R4
   \       0x9C   0x....'....        BL       buffer_skip_whitespace
   \       0xA0   0x2C00             CMP      R4,#+0
   \       0xA2   0xD008             BEQ.N    ??parse_array_9
   \       0xA4   0x68A0             LDR      R0,[R4, #+8]
   \       0xA6   0x6861             LDR      R1,[R4, #+4]
   \       0xA8   0x4288             CMP      R0,R1
   \       0xAA   0xD204             BCS.N    ??parse_array_9
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x68A1             LDR      R1,[R4, #+8]
   \       0xB0   0x5C40             LDRB     R0,[R0, R1]
   \       0xB2   0x282C             CMP      R0,#+44
   \       0xB4   0xD0D7             BEQ.N    ??parse_array_6
   \                     ??parse_array_9: (+1)
   \       0xB6   0x2C00             CMP      R4,#+0
   \       0xB8   0xD0CC             BEQ.N    ??parse_array_1
   \       0xBA   0x68A0             LDR      R0,[R4, #+8]
   \       0xBC   0x6861             LDR      R1,[R4, #+4]
   \       0xBE   0x4288             CMP      R0,R1
   \       0xC0   0xD2C8             BCS.N    ??parse_array_1
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x68A1             LDR      R1,[R4, #+8]
   \       0xC6   0x5C40             LDRB     R0,[R0, R1]
   \       0xC8   0x285D             CMP      R0,#+93
   \       0xCA   0xD1C3             BNE.N    ??parse_array_1
   \                     ??parse_array_3: (+1)
   \       0xCC   0x68E0             LDR      R0,[R4, #+12]
   \       0xCE   0x1E40             SUBS     R0,R0,#+1
   \       0xD0   0x60E0             STR      R0,[R4, #+12]
   \       0xD2   0x2020             MOVS     R0,#+32
   \       0xD4   0x60F0             STR      R0,[R6, #+12]
   \       0xD6   0x60B5             STR      R5,[R6, #+8]
   \       0xD8   0x68A0             LDR      R0,[R4, #+8]
   \       0xDA   0x1C40             ADDS     R0,R0,#+1
   \       0xDC   0x60A0             STR      R0,[R4, #+8]
   \       0xDE   0x2001             MOVS     R0,#+1
   \       0xE0   0xBDF2             POP      {R1,R4-R7,PC}
   1170          }
   1171          
   1172          /* Render an array to text */

   \                                 In section .text, align 2, keep-with-next
   1173          static cJSON_bool print_array(const cJSON *const item, printbuffer *const output_buffer)
   1174          {
   \                     print_array: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x000E             MOVS     R6,R1
   1175              unsigned char *output_pointer = NULL;
   1176              size_t length = 0;
   1177              cJSON *current_element = item->child;
   \        0x4   0x6884             LDR      R4,[R0, #+8]
   1178          
   1179              if (output_buffer == NULL) {
   \        0x6   0xD101             BNE.N    ??print_array_0
   1180                  return false;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD70             POP      {R4-R6,PC}
   1181              }
   1182          
   1183              /* Compose the output array. */
   1184              /* opening square bracket */
   1185              output_pointer = ensure(output_buffer, 1);
   \                     ??print_array_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0x....'....        BL       ensure
   1186              if (output_pointer == NULL) {
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??print_array_1
   1187                  return false;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD70             POP      {R4-R6,PC}
   1188              }
   1189          
   1190              *output_pointer = '[';
   \                     ??print_array_1: (+1)
   \       0x1C   0x215B             MOVS     R1,#+91
   \       0x1E   0x7001             STRB     R1,[R0, #+0]
   1191              output_buffer->offset++;
   \       0x20   0x68B0             LDR      R0,[R6, #+8]
   \       0x22   0x1C40             ADDS     R0,R0,#+1
   \       0x24   0x60B0             STR      R0,[R6, #+8]
   1192              output_buffer->depth++;
   \       0x26   0x68F0             LDR      R0,[R6, #+12]
   \       0x28   0x1C40             ADDS     R0,R0,#+1
   \       0x2A   0x60F0             STR      R0,[R6, #+12]
   \       0x2C   0xE00E             B.N      ??print_array_2
   1193          
   1194              while (current_element != NULL) {
   1195                  if (!print_value(current_element, output_buffer)) {
   1196                      return false;
   1197                  }
   1198                  update_offset(output_buffer);
   1199                  if (current_element->next) {
   1200                      length = (size_t)(output_buffer->format ? 2 : 1);
   1201                      output_pointer = ensure(output_buffer, length + 1);
   1202                      if (output_pointer == NULL) {
   1203                          return false;
   1204                      }
   1205                      *output_pointer++ = ',';
   \                     ??print_array_3: (+1)
   \       0x2E   0x212C             MOVS     R1,#+44
   \       0x30   0xF800 0x1B01      STRB     R1,[R0], #+1
   1206                      if (output_buffer->format) {
   \       0x34   0x6971             LDR      R1,[R6, #+20]
   \       0x36   0x2900             CMP      R1,#+0
   \       0x38   0xD002             BEQ.N    ??print_array_4
   1207                          *output_pointer++ = ' ';
   \       0x3A   0x2120             MOVS     R1,#+32
   \       0x3C   0xF800 0x1B01      STRB     R1,[R0], #+1
   1208                      }
   1209                      *output_pointer = '\0';
   \                     ??print_array_4: (+1)
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x7001             STRB     R1,[R0, #+0]
   1210                      output_buffer->offset += length;
   \       0x44   0x68B0             LDR      R0,[R6, #+8]
   \       0x46   0x182D             ADDS     R5,R5,R0
   \       0x48   0x60B5             STR      R5,[R6, #+8]
   1211                  }
   1212                  current_element = current_element->next;
   \                     ??print_array_5: (+1)
   \       0x4A   0x6824             LDR      R4,[R4, #+0]
   \                     ??print_array_2: (+1)
   \       0x4C   0x2C00             CMP      R4,#+0
   \       0x4E   0xD024             BEQ.N    ??print_array_6
   \       0x50   0x4631             MOV      R1,R6
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x....'....        BL       print_value
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD00A             BEQ.N    ??print_array_7
   \       0x5C   0x4630             MOV      R0,R6
   \       0x5E   0x....'....        BL       update_offset
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD0F0             BEQ.N    ??print_array_5
   \       0x68   0x6970             LDR      R0,[R6, #+20]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD003             BEQ.N    ??print_array_8
   \       0x6E   0x2502             MOVS     R5,#+2
   \       0x70   0xE002             B.N      ??print_array_9
   \                     ??print_array_7: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xBD70             POP      {R4-R6,PC}
   \                     ??print_array_8: (+1)
   \       0x76   0x2501             MOVS     R5,#+1
   \                     ??print_array_9: (+1)
   \       0x78   0x1C69             ADDS     R1,R5,#+1
   \       0x7A   0x4630             MOV      R0,R6
   \       0x7C   0x....'....        BL       ensure
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD1D4             BNE.N    ??print_array_3
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xBD70             POP      {R4-R6,PC}
   1213              }
   1214          
   1215              output_pointer = ensure(output_buffer, 2);
   1216              if (output_pointer == NULL) {
   1217                  return false;
   1218              }
   1219              *output_pointer++ = ']';
   \                     ??print_array_10: (+1)
   \       0x88   0x215D             MOVS     R1,#+93
   \       0x8A   0x7001             STRB     R1,[R0, #+0]
   1220              *output_pointer = '\0';
   \       0x8C   0x2100             MOVS     R1,#+0
   \       0x8E   0x7041             STRB     R1,[R0, #+1]
   1221              output_buffer->depth--;
   \       0x90   0x68F0             LDR      R0,[R6, #+12]
   \       0x92   0x1E40             SUBS     R0,R0,#+1
   \       0x94   0x60F0             STR      R0,[R6, #+12]
   1222          
   1223              return true;
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??print_array_6: (+1)
   \       0x9A   0x2102             MOVS     R1,#+2
   \       0x9C   0x4630             MOV      R0,R6
   \       0x9E   0x....'....        BL       ensure
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD1F0             BNE.N    ??print_array_10
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xBD70             POP      {R4-R6,PC}
   1224          }
   1225          
   1226          /* Build an object from the text. */

   \                                 In section .text, align 2, keep-with-next
   1227          static cJSON_bool parse_object(cJSON *const item, parse_buffer *const input_buffer)
   1228          {
   \                     parse_object: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   1229              cJSON *head = NULL; /* linked list head */
   \        0x6   0x2500             MOVS     R5,#+0
   1230              cJSON *current_item = NULL;
   \        0x8   0x462F             MOV      R7,R5
   1231          
   1232              if (input_buffer->depth >= CJSON_NESTING_LIMIT) {
   \        0xA   0x68E0             LDR      R0,[R4, #+12]
   \        0xC   0xF5B0 0x7F7A      CMP      R0,#+1000
   \       0x10   0xD22B             BCS.N    ??parse_object_0
   1233                  return false; /* to deeply nested */
   1234              }
   1235              input_buffer->depth++;
   \       0x12   0x1C40             ADDS     R0,R0,#+1
   \       0x14   0x60E0             STR      R0,[R4, #+12]
   1236          
   1237              if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{')) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD022             BEQ.N    ??parse_object_1
   \       0x1A   0x68A0             LDR      R0,[R4, #+8]
   \       0x1C   0x6861             LDR      R1,[R4, #+4]
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD21E             BCS.N    ??parse_object_1
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x68A1             LDR      R1,[R4, #+8]
   \       0x26   0x5C40             LDRB     R0,[R0, R1]
   \       0x28   0x287B             CMP      R0,#+123
   \       0x2A   0xD119             BNE.N    ??parse_object_1
   1238                  goto fail; /* not an object */
   1239              }
   1240          
   1241              input_buffer->offset++;
   \       0x2C   0x4608             MOV      R0,R1
   \       0x2E   0x1C40             ADDS     R0,R0,#+1
   \       0x30   0x60A0             STR      R0,[R4, #+8]
   1242              buffer_skip_whitespace(input_buffer);
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x....'....        BL       buffer_skip_whitespace
   1243              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}')) {
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD008             BEQ.N    ??parse_object_2
   \       0x3C   0x68A0             LDR      R0,[R4, #+8]
   \       0x3E   0x6861             LDR      R1,[R4, #+4]
   \       0x40   0x4288             CMP      R0,R1
   \       0x42   0xD204             BCS.N    ??parse_object_2
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68A1             LDR      R1,[R4, #+8]
   \       0x48   0x5C40             LDRB     R0,[R0, R1]
   \       0x4A   0x287D             CMP      R0,#+125
   \       0x4C   0xD062             BEQ.N    ??parse_object_3
   1244                  goto success; /* empty object */
   1245              }
   1246          
   1247              /* check if we skipped to the end of the buffer */
   1248              if (cannot_access_at_index(input_buffer, 0)) {
   \                     ??parse_object_2: (+1)
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xD003             BEQ.N    ??parse_object_4
   \       0x52   0x68A0             LDR      R0,[R4, #+8]
   \       0x54   0x6861             LDR      R1,[R4, #+4]
   \       0x56   0x4288             CMP      R0,R1
   \       0x58   0xD309             BCC.N    ??parse_object_5
   1249                  input_buffer->offset--;
   \                     ??parse_object_4: (+1)
   \       0x5A   0x68A0             LDR      R0,[R4, #+8]
   \       0x5C   0x1E40             SUBS     R0,R0,#+1
   \       0x5E   0x60A0             STR      R0,[R4, #+8]
   1250                  goto fail;
   1251              }
   1252          
   1253              /* step back to character in front of the first element */
   1254              input_buffer->offset--;
   1255              /* loop through the comma separated array elements */
   1256              do {
   1257                  /* allocate next item */
   1258                  cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
   1259                  if (new_item == NULL) {
   1260                      goto fail; /* allocation failure */
   1261                  }
   1262          
   1263                  /* attach next item to list */
   1264                  if (head == NULL) {
   1265                      /* start the linked list */
   1266                      current_item = head = new_item;
   1267                  } else {
   1268                      /* add to the end and advance */
   1269                      current_item->next = new_item;
   1270                      new_item->prev = current_item;
   1271                      current_item = new_item;
   1272                  }
   1273          
   1274                  /* parse the name of the child */
   1275                  input_buffer->offset++;
   1276                  buffer_skip_whitespace(input_buffer);
   1277                  if (!parse_string(current_item, input_buffer)) {
   1278                      goto fail; /* faile to parse name */
   1279                  }
   1280                  buffer_skip_whitespace(input_buffer);
   1281          
   1282                  /* swap valuestring and string, because we parsed the name */
   1283                  current_item->string = current_item->valuestring;
   1284                  current_item->valuestring = NULL;
   1285          
   1286                  if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':')) {
   1287                      goto fail; /* invalid object */
   1288                  }
   1289          
   1290                  /* parse the value */
   1291                  input_buffer->offset++;
   1292                  buffer_skip_whitespace(input_buffer);
   1293                  if (!parse_value(current_item, input_buffer)) {
   1294                      goto fail; /* failed to parse value */
   1295                  }
   1296                  buffer_skip_whitespace(input_buffer);
   1297              } while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
   1298          
   1299              if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}')) {
   1300                  goto fail; /* expected end of object */
   1301              }
   1302          
   1303          success:
   1304              input_buffer->depth--;
   1305          
   1306              item->type = cJSON_Object;
   1307              item->child = head;
   1308          
   1309              input_buffer->offset++;
   1310              return true;
   1311          
   1312          fail:
   1313              if (head != NULL) {
   \                     ??parse_object_1: (+1)
   \       0x60   0x2D00             CMP      R5,#+0
   \       0x62   0xD002             BEQ.N    ??parse_object_0
   1314                  cJSON_Delete(head);
   \       0x64   0x4628             MOV      R0,R5
   \       0x66   0x....'....        BL       cJSON_Delete
   1315              }
   1316          
   1317              return false;
   \                     ??parse_object_0: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??parse_object_5: (+1)
   \       0x6E   0x1E40             SUBS     R0,R0,#+1
   \       0x70   0x60A0             STR      R0,[R4, #+8]
   \                     ??parse_object_6: (+1)
   \       0x72   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x76   0x....'....        BL       cJSON_New_Item
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD0F0             BEQ.N    ??parse_object_1
   \       0x7E   0x2D00             CMP      R5,#+0
   \       0x80   0xD102             BNE.N    ??parse_object_7
   \       0x82   0x4605             MOV      R5,R0
   \       0x84   0x462F             MOV      R7,R5
   \       0x86   0xE002             B.N      ??parse_object_8
   \                     ??parse_object_7: (+1)
   \       0x88   0x6038             STR      R0,[R7, #+0]
   \       0x8A   0x6047             STR      R7,[R0, #+4]
   \       0x8C   0x4607             MOV      R7,R0
   \                     ??parse_object_8: (+1)
   \       0x8E   0x68A0             LDR      R0,[R4, #+8]
   \       0x90   0x1C40             ADDS     R0,R0,#+1
   \       0x92   0x60A0             STR      R0,[R4, #+8]
   \       0x94   0x4620             MOV      R0,R4
   \       0x96   0x....'....        BL       buffer_skip_whitespace
   \       0x9A   0x4621             MOV      R1,R4
   \       0x9C   0x4638             MOV      R0,R7
   \       0x9E   0x....'....        BL       parse_string
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD0DC             BEQ.N    ??parse_object_1
   \       0xA6   0x4620             MOV      R0,R4
   \       0xA8   0x....'....        BL       buffer_skip_whitespace
   \       0xAC   0x6938             LDR      R0,[R7, #+16]
   \       0xAE   0x6238             STR      R0,[R7, #+32]
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x6138             STR      R0,[R7, #+16]
   \       0xB4   0x2C00             CMP      R4,#+0
   \       0xB6   0xD0D3             BEQ.N    ??parse_object_1
   \       0xB8   0x68A0             LDR      R0,[R4, #+8]
   \       0xBA   0x6861             LDR      R1,[R4, #+4]
   \       0xBC   0x4288             CMP      R0,R1
   \       0xBE   0xD2CF             BCS.N    ??parse_object_1
   \       0xC0   0x6820             LDR      R0,[R4, #+0]
   \       0xC2   0x68A1             LDR      R1,[R4, #+8]
   \       0xC4   0x5C40             LDRB     R0,[R0, R1]
   \       0xC6   0x283A             CMP      R0,#+58
   \       0xC8   0xD1CA             BNE.N    ??parse_object_1
   \       0xCA   0x4608             MOV      R0,R1
   \       0xCC   0x1C40             ADDS     R0,R0,#+1
   \       0xCE   0x60A0             STR      R0,[R4, #+8]
   \       0xD0   0x4620             MOV      R0,R4
   \       0xD2   0x....'....        BL       buffer_skip_whitespace
   \       0xD6   0x4621             MOV      R1,R4
   \       0xD8   0x4638             MOV      R0,R7
   \       0xDA   0x....'....        BL       parse_value
   \       0xDE   0x2800             CMP      R0,#+0
   \       0xE0   0xD0BE             BEQ.N    ??parse_object_1
   \       0xE2   0x4620             MOV      R0,R4
   \       0xE4   0x....'....        BL       buffer_skip_whitespace
   \       0xE8   0x2C00             CMP      R4,#+0
   \       0xEA   0xD008             BEQ.N    ??parse_object_9
   \       0xEC   0x68A0             LDR      R0,[R4, #+8]
   \       0xEE   0x6861             LDR      R1,[R4, #+4]
   \       0xF0   0x4288             CMP      R0,R1
   \       0xF2   0xD204             BCS.N    ??parse_object_9
   \       0xF4   0x6820             LDR      R0,[R4, #+0]
   \       0xF6   0x68A1             LDR      R1,[R4, #+8]
   \       0xF8   0x5C40             LDRB     R0,[R0, R1]
   \       0xFA   0x282C             CMP      R0,#+44
   \       0xFC   0xD0B9             BEQ.N    ??parse_object_6
   \                     ??parse_object_9: (+1)
   \       0xFE   0x2C00             CMP      R4,#+0
   \      0x100   0xD0AE             BEQ.N    ??parse_object_1
   \      0x102   0x68A0             LDR      R0,[R4, #+8]
   \      0x104   0x6861             LDR      R1,[R4, #+4]
   \      0x106   0x4288             CMP      R0,R1
   \      0x108   0xD2AA             BCS.N    ??parse_object_1
   \      0x10A   0x6820             LDR      R0,[R4, #+0]
   \      0x10C   0x68A1             LDR      R1,[R4, #+8]
   \      0x10E   0x5C40             LDRB     R0,[R0, R1]
   \      0x110   0x287D             CMP      R0,#+125
   \      0x112   0xD1A5             BNE.N    ??parse_object_1
   \                     ??parse_object_3: (+1)
   \      0x114   0x68E0             LDR      R0,[R4, #+12]
   \      0x116   0x1E40             SUBS     R0,R0,#+1
   \      0x118   0x60E0             STR      R0,[R4, #+12]
   \      0x11A   0x2040             MOVS     R0,#+64
   \      0x11C   0x60F0             STR      R0,[R6, #+12]
   \      0x11E   0x60B5             STR      R5,[R6, #+8]
   \      0x120   0x68A0             LDR      R0,[R4, #+8]
   \      0x122   0x1C40             ADDS     R0,R0,#+1
   \      0x124   0x60A0             STR      R0,[R4, #+8]
   \      0x126   0x2001             MOVS     R0,#+1
   \      0x128   0xBDF2             POP      {R1,R4-R7,PC}
   1318          }
   1319          
   1320          /* Render an object to text. */

   \                                 In section .text, align 2, keep-with-next
   1321          static cJSON_bool print_object(const cJSON *const item, printbuffer *const output_buffer)
   1322          {
   \                     print_object: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x000D             MOVS     R5,R1
   1323              unsigned char *output_pointer = NULL;
   1324              size_t length = 0;
   1325              cJSON *current_item = item->child;
   \        0x4   0x6884             LDR      R4,[R0, #+8]
   1326          
   1327              if (output_buffer == NULL) {
   \        0x6   0xF000 0x8089      BEQ.W    ??print_object_0
   1328                  return false;
   1329              }
   1330          
   1331              /* Compose the output: */
   1332              length = (size_t)(output_buffer->format ? 2 : 1); /* fmt: {\n */
   \        0xA   0x6968             LDR      R0,[R5, #+20]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD001             BEQ.N    ??print_object_1
   \       0x10   0x2602             MOVS     R6,#+2
   \       0x12   0xE000             B.N      ??print_object_2
   \                     ??print_object_1: (+1)
   \       0x14   0x2601             MOVS     R6,#+1
   1333              output_pointer = ensure(output_buffer, length + 1);
   \                     ??print_object_2: (+1)
   \       0x16   0x1C71             ADDS     R1,R6,#+1
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       ensure
   1334              if (output_pointer == NULL) {
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD07C             BEQ.N    ??print_object_0
   1335                  return false;
   1336              }
   1337          
   1338              *output_pointer++ = '{';
   \       0x22   0x217B             MOVS     R1,#+123
   \       0x24   0x7001             STRB     R1,[R0, #+0]
   1339              output_buffer->depth++;
   \       0x26   0x68E9             LDR      R1,[R5, #+12]
   \       0x28   0x1C49             ADDS     R1,R1,#+1
   \       0x2A   0x60E9             STR      R1,[R5, #+12]
   1340              if (output_buffer->format) {
   \       0x2C   0x6969             LDR      R1,[R5, #+20]
   \       0x2E   0x2900             CMP      R1,#+0
   \       0x30   0xD001             BEQ.N    ??print_object_3
   1341                  *output_pointer++ = '\n';
   \       0x32   0x210A             MOVS     R1,#+10
   \       0x34   0x7041             STRB     R1,[R0, #+1]
   1342              }
   1343              output_buffer->offset += length;
   \                     ??print_object_3: (+1)
   \       0x36   0x68A8             LDR      R0,[R5, #+8]
   \       0x38   0x1836             ADDS     R6,R6,R0
   \       0x3A   0x60AE             STR      R6,[R5, #+8]
   \       0x3C   0xE03D             B.N      ??print_object_4
   1344          
   1345              while (current_item) {
   1346                  if (output_buffer->format) {
   1347                      size_t i;
   1348                      output_pointer = ensure(output_buffer, output_buffer->depth);
   1349                      if (output_pointer == NULL) {
   1350                          return false;
   1351                      }
   1352                      for (i = 0; i < output_buffer->depth; i++) {
   1353                          *output_pointer++ = '\t';
   1354                      }
   1355                      output_buffer->offset += output_buffer->depth;
   1356                  }
   1357          
   1358                  /* print key */
   1359                  if (!print_string_ptr((unsigned char *)current_item->string, output_buffer)) {
   1360                      return false;
   1361                  }
   1362                  update_offset(output_buffer);
   1363          
   1364                  length = (size_t)(output_buffer->format ? 2 : 1);
   1365                  output_pointer = ensure(output_buffer, length);
   1366                  if (output_pointer == NULL) {
   1367                      return false;
   1368                  }
   1369                  *output_pointer++ = ':';
   1370                  if (output_buffer->format) {
   1371                      *output_pointer++ = '\t';
   1372                  }
   1373                  output_buffer->offset += length;
   1374          
   1375                  /* print value */
   1376                  if (!print_value(current_item, output_buffer)) {
   1377                      return false;
   1378                  }
   1379                  update_offset(output_buffer);
   1380          
   1381                  /* print comma if not last */
   1382                  length = (size_t)((output_buffer->format ? 1 : 0) + (current_item->next ? 1 : 0));
   \                     ??print_object_5: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE021             B.N      ??print_object_6
   \                     ??print_object_7: (+1)
   \       0x42   0x2601             MOVS     R6,#+1
   \                     ??print_object_8: (+1)
   \       0x44   0x4631             MOV      R1,R6
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x....'....        BL       ensure
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD065             BEQ.N    ??print_object_0
   \       0x50   0x213A             MOVS     R1,#+58
   \       0x52   0x7001             STRB     R1,[R0, #+0]
   \       0x54   0x6969             LDR      R1,[R5, #+20]
   \       0x56   0x2900             CMP      R1,#+0
   \       0x58   0xD001             BEQ.N    ??print_object_9
   \       0x5A   0x2109             MOVS     R1,#+9
   \       0x5C   0x7041             STRB     R1,[R0, #+1]
   \                     ??print_object_9: (+1)
   \       0x5E   0x68A8             LDR      R0,[R5, #+8]
   \       0x60   0x1836             ADDS     R6,R6,R0
   \       0x62   0x60AE             STR      R6,[R5, #+8]
   \       0x64   0x4629             MOV      R1,R5
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0x....'....        BL       print_value
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD055             BEQ.N    ??print_object_0
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x....'....        BL       update_offset
   \       0x76   0x6968             LDR      R0,[R5, #+20]
   \       0x78   0x1E46             SUBS     R6,R0,#+1
   \       0x7A   0x41B6             SBCS     R6,R6,R6
   \       0x7C   0x43F6             MVNS     R6,R6
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD0DC             BEQ.N    ??print_object_5
   \       0x84   0x2001             MOVS     R0,#+1
   \                     ??print_object_6: (+1)
   \       0x86   0xEB10 0x76D6      ADDS     R6,R0,R6, LSR #+31
   1383                  output_pointer = ensure(output_buffer, length + 1);
   \       0x8A   0x1C71             ADDS     R1,R6,#+1
   \       0x8C   0x4628             MOV      R0,R5
   \       0x8E   0x....'....        BL       ensure
   1384                  if (output_pointer == NULL) {
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD042             BEQ.N    ??print_object_0
   1385                      return false;
   1386                  }
   1387                  if (current_item->next) {
   \       0x96   0x6821             LDR      R1,[R4, #+0]
   \       0x98   0x2900             CMP      R1,#+0
   \       0x9A   0xD002             BEQ.N    ??print_object_10
   1388                      *output_pointer++ = ',';
   \       0x9C   0x212C             MOVS     R1,#+44
   \       0x9E   0xF800 0x1B01      STRB     R1,[R0], #+1
   1389                  }
   1390          
   1391                  if (output_buffer->format) {
   \                     ??print_object_10: (+1)
   \       0xA2   0x6969             LDR      R1,[R5, #+20]
   \       0xA4   0x2900             CMP      R1,#+0
   \       0xA6   0xD002             BEQ.N    ??print_object_11
   1392                      *output_pointer++ = '\n';
   \       0xA8   0x210A             MOVS     R1,#+10
   \       0xAA   0xF800 0x1B01      STRB     R1,[R0], #+1
   1393                  }
   1394                  *output_pointer = '\0';
   \                     ??print_object_11: (+1)
   \       0xAE   0x2100             MOVS     R1,#+0
   \       0xB0   0x7001             STRB     R1,[R0, #+0]
   1395                  output_buffer->offset += length;
   \       0xB2   0x68A8             LDR      R0,[R5, #+8]
   \       0xB4   0x1836             ADDS     R6,R6,R0
   \       0xB6   0x60AE             STR      R6,[R5, #+8]
   1396          
   1397                  current_item = current_item->next;
   \       0xB8   0x6824             LDR      R4,[R4, #+0]
   \                     ??print_object_4: (+1)
   \       0xBA   0x2C00             CMP      R4,#+0
   \       0xBC   0x6968             LDR      R0,[R5, #+20]
   \       0xBE   0xD022             BEQ.N    ??print_object_12
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD012             BEQ.N    ??print_object_13
   \       0xC4   0x68E9             LDR      R1,[R5, #+12]
   \       0xC6   0x4628             MOV      R0,R5
   \       0xC8   0x....'....        BL       ensure
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD025             BEQ.N    ??print_object_0
   \       0xD0   0x2100             MOVS     R1,#+0
   \       0xD2   0xE003             B.N      ??print_object_14
   \                     ??print_object_15: (+1)
   \       0xD4   0x2209             MOVS     R2,#+9
   \       0xD6   0xF800 0x2B01      STRB     R2,[R0], #+1
   \       0xDA   0x1C49             ADDS     R1,R1,#+1
   \                     ??print_object_14: (+1)
   \       0xDC   0x68EA             LDR      R2,[R5, #+12]
   \       0xDE   0x4291             CMP      R1,R2
   \       0xE0   0xD3F8             BCC.N    ??print_object_15
   \       0xE2   0x68A9             LDR      R1,[R5, #+8]
   \       0xE4   0x4610             MOV      R0,R2
   \       0xE6   0x1841             ADDS     R1,R0,R1
   \       0xE8   0x60A9             STR      R1,[R5, #+8]
   \                     ??print_object_13: (+1)
   \       0xEA   0x4629             MOV      R1,R5
   \       0xEC   0x6A20             LDR      R0,[R4, #+32]
   \       0xEE   0x....'....        BL       print_string_ptr
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xD012             BEQ.N    ??print_object_0
   \       0xF6   0x4628             MOV      R0,R5
   \       0xF8   0x....'....        BL       update_offset
   \       0xFC   0x6968             LDR      R0,[R5, #+20]
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD09F             BEQ.N    ??print_object_7
   \      0x102   0x2602             MOVS     R6,#+2
   \      0x104   0xE79E             B.N      ??print_object_8
   1398              }
   1399          
   1400              output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
   \                     ??print_object_12: (+1)
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD002             BEQ.N    ??print_object_16
   \      0x10A   0x68E9             LDR      R1,[R5, #+12]
   \      0x10C   0x1C49             ADDS     R1,R1,#+1
   \      0x10E   0xE000             B.N      ??print_object_17
   \                     ??print_object_16: (+1)
   \      0x110   0x2102             MOVS     R1,#+2
   \                     ??print_object_17: (+1)
   \      0x112   0x4628             MOV      R0,R5
   \      0x114   0x....'....        BL       ensure
   1401              if (output_pointer == NULL) {
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD101             BNE.N    ??print_object_18
   1402                  return false;
   \                     ??print_object_0: (+1)
   \      0x11C   0x2000             MOVS     R0,#+0
   \      0x11E   0xBD70             POP      {R4-R6,PC}
   1403              }
   1404              if (output_buffer->format) {
   \                     ??print_object_18: (+1)
   \      0x120   0x6969             LDR      R1,[R5, #+20]
   \      0x122   0x2900             CMP      R1,#+0
   \      0x124   0xD009             BEQ.N    ??print_object_19
   1405                  size_t i;
   1406                  for (i = 0; i < (output_buffer->depth - 1); i++) {
   \      0x126   0x2100             MOVS     R1,#+0
   \      0x128   0xE003             B.N      ??print_object_20
   1407                      *output_pointer++ = '\t';
   \                     ??print_object_21: (+1)
   \      0x12A   0x2209             MOVS     R2,#+9
   \      0x12C   0xF800 0x2B01      STRB     R2,[R0], #+1
   1408                  }
   \      0x130   0x1C49             ADDS     R1,R1,#+1
   \                     ??print_object_20: (+1)
   \      0x132   0x68EA             LDR      R2,[R5, #+12]
   \      0x134   0x1E52             SUBS     R2,R2,#+1
   \      0x136   0x4291             CMP      R1,R2
   \      0x138   0xD3F7             BCC.N    ??print_object_21
   1409              }
   1410              *output_pointer++ = '}';
   \                     ??print_object_19: (+1)
   \      0x13A   0x217D             MOVS     R1,#+125
   \      0x13C   0x7001             STRB     R1,[R0, #+0]
   1411              *output_pointer = '\0';
   \      0x13E   0x2100             MOVS     R1,#+0
   \      0x140   0x7041             STRB     R1,[R0, #+1]
   1412              output_buffer->depth--;
   \      0x142   0x68E8             LDR      R0,[R5, #+12]
   \      0x144   0x1E40             SUBS     R0,R0,#+1
   \      0x146   0x60E8             STR      R0,[R5, #+12]
   1413          
   1414              return true;
   \      0x148   0x2001             MOVS     R0,#+1
   \      0x14A   0xBD70             POP      {R4-R6,PC}       ;; return
   1415          }
   1416          
   1417          /* Get Array size/item / object item. */

   \                                 In section .text, align 2, keep-with-next
   1418          CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
   1419          {
   1420              cJSON *c = array->child;
   \                     cJSON_GetArraySize: (+1)
   \        0x0   0x6881             LDR      R1,[R0, #+8]
   1421              size_t i = 0;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xE001             B.N      ??cJSON_GetArraySize_0
   1422              while (c) {
   1423                  i++;
   \                     ??cJSON_GetArraySize_1: (+1)
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   1424                  c = c->next;
   \        0x8   0x6809             LDR      R1,[R1, #+0]
   1425              }
   \                     ??cJSON_GetArraySize_0: (+1)
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD1FB             BNE.N    ??cJSON_GetArraySize_1
   1426          
   1427              /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
   1428          
   1429              return (int)i;
   \        0xE   0x4770             BX       LR               ;; return
   1430          }
   1431          

   \                                 In section .text, align 2, keep-with-next
   1432          static cJSON *get_array_item(const cJSON *array, size_t index)
   1433          {
   1434              cJSON *current_child = NULL;
   1435          
   1436              if (array == NULL) {
   \                     get_array_item: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??get_array_item_0
   1437                  return NULL;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   1438              }
   1439          
   1440              current_child = array->child;
   \                     ??get_array_item_0: (+1)
   \        0x8   0x6880             LDR      R0,[R0, #+8]
   1441              while ((current_child != NULL) && (index > 0)) {
   \                     ??get_array_item_1: (+1)
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD004             BEQ.N    ??get_array_item_2
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD002             BEQ.N    ??get_array_item_2
   1442                  index--;
   \       0x12   0x1E49             SUBS     R1,R1,#+1
   1443                  current_child = current_child->next;
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0xE7F8             B.N      ??get_array_item_1
   1444              }
   1445          
   1446              return current_child;
   \                     ??get_array_item_2: (+1)
   \       0x18   0x4770             BX       LR               ;; return
   1447          }
   1448          

   \                                 In section .text, align 2, keep-with-next
   1449          CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
   1450          {
   1451              if (index < 0) {
   \                     cJSON_GetArrayItem: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0xD501             BPL.N    ??cJSON_GetArrayItem_0
   1452                  return NULL;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   1453              }
   1454          
   1455              return get_array_item(array, (size_t)index);
   \                     ??cJSON_GetArrayItem_0: (+1)
   \        0x8   0x....             B.N      get_array_item
   1456          }
   1457          

   \                                 In section .text, align 2, keep-with-next
   1458          static cJSON *get_object_item(const cJSON *const object, const char *const name, const cJSON_bool case_sensitive)
   1459          {
   \                     get_object_item: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   1460              cJSON *current_element = NULL;
   1461          
   1462              if ((object == NULL) || (name == NULL)) {
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD001             BEQ.N    ??get_object_item_0
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD101             BNE.N    ??get_object_item_1
   1463                  return NULL;
   \                     ??get_object_item_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
   1464              }
   1465          
   1466              current_element = object->child;
   \                     ??get_object_item_1: (+1)
   \       0x10   0x6884             LDR      R4,[R0, #+8]
   1467              if (case_sensitive) {
   \       0x12   0x2A00             CMP      R2,#+0
   \       0x14   0xD010             BEQ.N    ??get_object_item_2
   1468                  while ((current_element != NULL) && (strcmp(name, current_element->string) != 0)) {
   \                     ??get_object_item_3: (+1)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD010             BEQ.N    ??get_object_item_4
   \       0x1A   0x6A21             LDR      R1,[R4, #+32]
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x....'....        BL       strcmp
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD00A             BEQ.N    ??get_object_item_4
   1469                      current_element = current_element->next;
   \       0x26   0x6824             LDR      R4,[R4, #+0]
   \       0x28   0xE7F5             B.N      ??get_object_item_3
   1470                  }
   1471              } else {
   1472                  while ((current_element != NULL)
   1473                         && (case_insensitive_strcmp((const unsigned char *)name, (const unsigned char *)(current_element->string)) != 0)) {
   \                     ??get_object_item_5: (+1)
   \       0x2A   0x6A21             LDR      R1,[R4, #+32]
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x....'....        BL       case_insensitive_strcmp
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD002             BEQ.N    ??get_object_item_4
   1474                      current_element = current_element->next;
   \       0x36   0x6824             LDR      R4,[R4, #+0]
   1475                  }
   \                     ??get_object_item_2: (+1)
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD1F6             BNE.N    ??get_object_item_5
   1476              }
   1477          
   1478              return current_element;
   \                     ??get_object_item_4: (+1)
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1479          }
   1480          

   \                                 In section .text, align 2, keep-with-next
   1481          CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON *const object, const char *const string)
   1482          {
   1483              return get_object_item(object, string, false);
   \                     cJSON_GetObjectItem: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x....             B.N      get_object_item
   1484          }
   1485          

   \                                 In section .text, align 2, keep-with-next
   1486          CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON *const object, const char *const string)
   1487          {
   1488              return get_object_item(object, string, true);
   \                     cJSON_GetObjectItemCaseSensitive: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0x....             B.N      get_object_item
   1489          }
   1490          

   \                                 In section .text, align 2, keep-with-next
   1491          CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
   1492          {
   \                     cJSON_HasObjectItem: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1493              return cJSON_GetObjectItem(object, string) ? 1 : 0;
   \        0x2   0x....'....        BL       cJSON_GetObjectItem
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??cJSON_HasObjectItem_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xBD02             POP      {R1,PC}
   \                     ??cJSON_HasObjectItem_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
   1494          }
   1495          
   1496          /* Utility for array list handling. */

   \                                 In section .text, align 2, keep-with-next
   1497          static void suffix_object(cJSON *prev, cJSON *item)
   1498          {
   1499              prev->next = item;
   \                     suffix_object: (+1)
   \        0x0   0x6001             STR      R1,[R0, #+0]
   1500              item->prev = prev;
   \        0x2   0x6048             STR      R0,[R1, #+4]
   1501          }
   \        0x4   0x4770             BX       LR               ;; return
   1502          
   1503          /* Utility for handling references. */

   \                                 In section .text, align 2, keep-with-next
   1504          static cJSON *create_reference(const cJSON *item, const internal_hooks *const hooks)
   1505          {
   \                     create_reference: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   1506              cJSON *ref = cJSON_New_Item(hooks);
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0x....'....        BL       cJSON_New_Item
   \        0xA   0x0004             MOVS     R4,R0
   1507              if (!ref) {
   \        0xC   0xD101             BNE.N    ??create_reference_0
   1508                  return NULL;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
   1509              }
   1510              memcpy(ref, item, sizeof(cJSON));
   \                     ??create_reference_0: (+1)
   \       0x12   0x2228             MOVS     R2,#+40
   \       0x14   0x4629             MOV      R1,R5
   \       0x16   0x....'....        BL       __aeabi_memcpy4
   1511              ref->string = NULL;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6220             STR      R0,[R4, #+32]
   1512              ref->type |= cJSON_IsReference;
   \       0x1E   0x68E0             LDR      R0,[R4, #+12]
   \       0x20   0xF440 0x7080      ORR      R0,R0,#0x100
   \       0x24   0x60E0             STR      R0,[R4, #+12]
   1513              ref->next = ref->prev = NULL;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6060             STR      R0,[R4, #+4]
   \       0x2A   0x6020             STR      R0,[R4, #+0]
   1514              return ref;
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1515          }
   1516          
   1517          /* Add item to array/object. */

   \                                 In section .text, align 2, keep-with-next
   1518          CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
   1519          {
   1520              cJSON *child = NULL;
   1521          
   1522              if ((item == NULL) || (array == NULL)) {
   \                     cJSON_AddItemToArray: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0xD00C             BEQ.N    ??cJSON_AddItemToArray_0
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD00A             BEQ.N    ??cJSON_AddItemToArray_0
   1523                  return;
   1524              }
   1525          
   1526              child = array->child;
   \        0x8   0x6882             LDR      R2,[R0, #+8]
   1527          
   1528              if (child == NULL) {
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD102             BNE.N    ??cJSON_AddItemToArray_1
   1529                  /* list is empty, start new one */
   1530                  array->child = item;
   \        0xE   0x6081             STR      R1,[R0, #+8]
   \       0x10   0x4770             BX       LR
   1531              } else {
   1532                  /* append to the end */
   1533                  while (child->next) {
   1534                      child = child->next;
   \                     ??cJSON_AddItemToArray_2: (+1)
   \       0x12   0x4602             MOV      R2,R0
   1535                  }
   \                     ??cJSON_AddItemToArray_1: (+1)
   \       0x14   0x6810             LDR      R0,[R2, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD1FB             BNE.N    ??cJSON_AddItemToArray_2
   1536                  suffix_object(child, item);
   \       0x1A   0x4610             MOV      R0,R2
   \       0x1C   0x....             B.N      suffix_object
   1537              }
   1538          }
   \                     ??cJSON_AddItemToArray_0: (+1)
   \       0x1E   0x4770             BX       LR               ;; return
   1539          

   \                                 In section .text, align 2, keep-with-next
   1540          CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
   1541          {
   \                     cJSON_AddItemToObject: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0x4615             MOV      R5,R2
   1542              /* call cJSON_AddItemToObjectCS for code reuse */
   1543              cJSON_AddItemToObjectCS(object, (char *)cJSON_strdup((const unsigned char *)string, &global_hooks), item);
   \        0x8   0x....'....        LDR.W    R1,??DataTable31
   \        0xC   0x....'....        BL       cJSON_strdup
   \       0x10   0x4601             MOV      R1,R0
   \       0x12   0x462A             MOV      R2,R5
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       cJSON_AddItemToObjectCS
   1544              /* remove cJSON_StringIsConst flag */
   1545              item->type &= ~cJSON_StringIsConst;
   \       0x1A   0x68E8             LDR      R0,[R5, #+12]
   \       0x1C   0xF420 0x7000      BIC      R0,R0,#0x200
   \       0x20   0x60E8             STR      R0,[R5, #+12]
   1546          }
   \       0x22   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1547          
   1548          #if defined (__clang__) || ((__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
   1549              #pragma GCC diagnostic push
   1550          #endif
   1551          #ifdef __GNUC__
   1552              #pragma GCC diagnostic ignored "-Wcast-qual"
   1553          #endif
   1554          
   1555          /* Add an item to an object with constant string as key */

   \                                 In section .text, align 2, keep-with-next
   1556          CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
   1557          {
   \                     cJSON_AddItemToObjectCS: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   1558              if (!item) {
   \        0x8   0xD013             BEQ.N    ??cJSON_AddItemToObjectCS_0
   1559                  return;
   1560              }
   1561              if (!(item->type & cJSON_StringIsConst) && item->string) {
   \        0xA   0x68E0             LDR      R0,[R4, #+12]
   \        0xC   0x0580             LSLS     R0,R0,#+22
   \        0xE   0xD406             BMI.N    ??cJSON_AddItemToObjectCS_1
   \       0x10   0x6A20             LDR      R0,[R4, #+32]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD003             BEQ.N    ??cJSON_AddItemToObjectCS_1
   1562                  global_hooks.deallocate(item->string);
   \       0x16   0x....'....        LDR.W    R1,??DataTable31
   \       0x1A   0x6849             LDR      R1,[R1, #+4]
   \       0x1C   0x4788             BLX      R1
   1563              }
   1564              item->string = (char *)string;
   \                     ??cJSON_AddItemToObjectCS_1: (+1)
   \       0x1E   0x6226             STR      R6,[R4, #+32]
   1565              item->type |= cJSON_StringIsConst;
   \       0x20   0x68E0             LDR      R0,[R4, #+12]
   \       0x22   0xF440 0x7000      ORR      R0,R0,#0x200
   \       0x26   0x60E0             STR      R0,[R4, #+12]
   1566              cJSON_AddItemToArray(object, item);
   \       0x28   0x4621             MOV      R1,R4
   \       0x2A   0x4628             MOV      R0,R5
   \       0x2C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x30   0x....             B.N      cJSON_AddItemToArray
   \                     ??cJSON_AddItemToObjectCS_0: (+1)
   \       0x32   0xBD70             POP      {R4-R6,PC}       ;; return
   1567          }
   1568          #if defined (__clang__) || ((__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
   1569              #pragma GCC diagnostic pop
   1570          #endif
   1571          

   \                                 In section .text, align 2, keep-with-next
   1572          CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
   1573          {
   \                     cJSON_AddItemReferenceToArray: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4608             MOV      R0,R1
   1574              cJSON_AddItemToArray(array, create_reference(item, &global_hooks));
   \        0x6   0x....'....        LDR.W    R1,??DataTable31
   \        0xA   0x....'....        BL       create_reference
   \        0xE   0x4601             MOV      R1,R0
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0xE8BD 0x4010      POP      {R4,LR}
   \       0x16   0x....             B.N      cJSON_AddItemToArray
   1575          }
   1576          

   \                                 In section .text, align 2, keep-with-next
   1577          CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
   1578          {
   \                     cJSON_AddItemReferenceToObject: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4610             MOV      R0,R2
   1579              cJSON_AddItemToObject(object, string, create_reference(item, &global_hooks));
   \        0x8   0x....'....        LDR.W    R1,??DataTable31
   \        0xC   0x....'....        BL       create_reference
   \       0x10   0x4602             MOV      R2,R0
   \       0x12   0x4629             MOV      R1,R5
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x1A   0x....             B.N      cJSON_AddItemToObject
   1580          }
   1581          

   \                                 In section .text, align 2, keep-with-next
   1582          CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON *const item)
   1583          {
   1584              if ((parent == NULL) || (item == NULL)) {
   \                     cJSON_DetachItemViaPointer: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??cJSON_DetachItemViaPointer_0
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??cJSON_DetachItemViaPointer_1
   1585                  return NULL;
   \                     ??cJSON_DetachItemViaPointer_0: (+1)
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
   1586              }
   1587          
   1588              if (item->prev != NULL) {
   \                     ??cJSON_DetachItemViaPointer_1: (+1)
   \        0xC   0x684A             LDR      R2,[R1, #+4]
   \        0xE   0x2A00             CMP      R2,#+0
   \       0x10   0xD002             BEQ.N    ??cJSON_DetachItemViaPointer_2
   1589                  /* not the first element */
   1590                  item->prev->next = item->next;
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0x684B             LDR      R3,[R1, #+4]
   \       0x16   0x601A             STR      R2,[R3, #+0]
   1591              }
   1592              if (item->next != NULL) {
   \                     ??cJSON_DetachItemViaPointer_2: (+1)
   \       0x18   0x680A             LDR      R2,[R1, #+0]
   \       0x1A   0x2A00             CMP      R2,#+0
   \       0x1C   0xD002             BEQ.N    ??cJSON_DetachItemViaPointer_3
   1593                  /* not the last element */
   1594                  item->next->prev = item->prev;
   \       0x1E   0x684A             LDR      R2,[R1, #+4]
   \       0x20   0x680B             LDR      R3,[R1, #+0]
   \       0x22   0x605A             STR      R2,[R3, #+4]
   1595              }
   1596          
   1597              if (item == parent->child) {
   \                     ??cJSON_DetachItemViaPointer_3: (+1)
   \       0x24   0x6882             LDR      R2,[R0, #+8]
   \       0x26   0x4291             CMP      R1,R2
   \       0x28   0xD101             BNE.N    ??cJSON_DetachItemViaPointer_4
   1598                  /* first element */
   1599                  parent->child = item->next;
   \       0x2A   0x680A             LDR      R2,[R1, #+0]
   \       0x2C   0x6082             STR      R2,[R0, #+8]
   1600              }
   1601              /* make sure the detached item doesn't point anywhere anymore */
   1602              item->prev = NULL;
   \                     ??cJSON_DetachItemViaPointer_4: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x6048             STR      R0,[R1, #+4]
   1603              item->next = NULL;
   \       0x32   0x6008             STR      R0,[R1, #+0]
   1604          
   1605              return item;
   \       0x34   0x4608             MOV      R0,R1
   \       0x36   0x4770             BX       LR               ;; return
   1606          }
   1607          

   \                                 In section .text, align 2, keep-with-next
   1608          CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
   1609          {
   \                     cJSON_DetachItemFromArray: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1610              if (which < 0) {
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD501             BPL.N    ??cJSON_DetachItemFromArray_0
   1611                  return NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   1612              }
   1613          
   1614              return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
   \                     ??cJSON_DetachItemFromArray_0: (+1)
   \        0xC   0x....'....        BL       get_array_item
   \       0x10   0x4601             MOV      R1,R0
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xE8BD 0x4010      POP      {R4,LR}
   \       0x18   0x....             B.N      cJSON_DetachItemViaPointer
   1615          }
   1616          

   \                                 In section .text, align 2, keep-with-next
   1617          CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
   1618          {
   \                     cJSON_DeleteItemFromArray: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1619              cJSON_Delete(cJSON_DetachItemFromArray(array, which));
   \        0x2   0x....'....        BL       cJSON_DetachItemFromArray
   \        0x6   0xE8BD 0x4002      POP      {R1,LR}
   \        0xA   0x....'....        B.W      cJSON_Delete
   1620          }
   1621          

   \                                 In section .text, align 2, keep-with-next
   1622          CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
   1623          {
   \                     cJSON_DetachItemFromObject: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1624              cJSON *to_detach = cJSON_GetObjectItem(object, string);
   \        0x4   0x....'....        BL       cJSON_GetObjectItem
   \        0x8   0x4601             MOV      R1,R0
   1625          
   1626              return cJSON_DetachItemViaPointer(object, to_detach);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0xE8BD 0x4010      POP      {R4,LR}
   \       0x10   0x....             B.N      cJSON_DetachItemViaPointer
   1627          }
   1628          

   \                                 In section .text, align 2, keep-with-next
   1629          CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
   1630          {
   \                     cJSON_DetachItemFromObjectCaseSensitive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1631              cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
   \        0x4   0x....'....        BL       cJSON_GetObjectItemCaseSensitive
   \        0x8   0x4601             MOV      R1,R0
   1632          
   1633              return cJSON_DetachItemViaPointer(object, to_detach);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0xE8BD 0x4010      POP      {R4,LR}
   \       0x10   0x....             B.N      cJSON_DetachItemViaPointer
   1634          }
   1635          

   \                                 In section .text, align 2, keep-with-next
   1636          CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
   1637          {
   \                     cJSON_DeleteItemFromObject: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1638              cJSON_Delete(cJSON_DetachItemFromObject(object, string));
   \        0x2   0x....'....        BL       cJSON_DetachItemFromObject
   \        0x6   0xE8BD 0x4002      POP      {R1,LR}
   \        0xA   0x....'....        B.W      cJSON_Delete
   1639          }
   1640          

   \                                 In section .text, align 2, keep-with-next
   1641          CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
   1642          {
   \                     cJSON_DeleteItemFromObjectCaseSensitive: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1643              cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
   \        0x2   0x....'....        BL       cJSON_DetachItemFromObjectCaseSensitive
   \        0x6   0xE8BD 0x4002      POP      {R1,LR}
   \        0xA   0x....'....        B.W      cJSON_Delete
   1644          }
   1645          
   1646          /* Replace array/object items with new ones. */

   \                                 In section .text, align 2, keep-with-next
   1647          CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
   1648          {
   \                     cJSON_InsertItemInArray: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4615             MOV      R5,R2
   1649              cJSON *after_inserted = NULL;
   1650          
   1651              if (which < 0) {
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD413             BMI.N    ??cJSON_InsertItemInArray_0
   1652                  return;
   1653              }
   1654          
   1655              after_inserted = get_array_item(array, (size_t)which);
   \        0xA   0x....'....        BL       get_array_item
   1656              if (after_inserted == NULL) {
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD104             BNE.N    ??cJSON_InsertItemInArray_1
   1657                  cJSON_AddItemToArray(array, newitem);
   \       0x12   0x4629             MOV      R1,R5
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x1A   0x....             B.N      cJSON_AddItemToArray
   1658                  return;
   1659              }
   1660          
   1661              newitem->next = after_inserted;
   \                     ??cJSON_InsertItemInArray_1: (+1)
   \       0x1C   0x6028             STR      R0,[R5, #+0]
   1662              newitem->prev = after_inserted->prev;
   \       0x1E   0x6841             LDR      R1,[R0, #+4]
   \       0x20   0x6069             STR      R1,[R5, #+4]
   1663              after_inserted->prev = newitem;
   \       0x22   0x6045             STR      R5,[R0, #+4]
   1664              if (after_inserted == array->child) {
   \       0x24   0x68A1             LDR      R1,[R4, #+8]
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD101             BNE.N    ??cJSON_InsertItemInArray_2
   1665                  array->child = newitem;
   \       0x2A   0x60A5             STR      R5,[R4, #+8]
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}
   1666              } else {
   1667                  newitem->prev->next = newitem;
   \                     ??cJSON_InsertItemInArray_2: (+1)
   \       0x2E   0x6868             LDR      R0,[R5, #+4]
   \       0x30   0x6005             STR      R5,[R0, #+0]
   1668              }
   1669          }
   \                     ??cJSON_InsertItemInArray_0: (+1)
   \       0x32   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1670          

   \                                 In section .text, align 2, keep-with-next
   1671          CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON *const parent, cJSON *const item, cJSON *replacement)
   1672          {
   \                     cJSON_ReplaceItemViaPointer: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4603             MOV      R3,R0
   \        0x4   0x4608             MOV      R0,R1
   1673              if ((parent == NULL) || (replacement == NULL)) {
   \        0x6   0x2B00             CMP      R3,#+0
   \        0x8   0xD001             BEQ.N    ??cJSON_ReplaceItemViaPointer_0
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD101             BNE.N    ??cJSON_ReplaceItemViaPointer_1
   1674                  return false;
   \                     ??cJSON_ReplaceItemViaPointer_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD02             POP      {R1,PC}
   1675              }
   1676          
   1677              if (replacement == item) {
   \                     ??cJSON_ReplaceItemViaPointer_1: (+1)
   \       0x12   0x4282             CMP      R2,R0
   \       0x14   0xD101             BNE.N    ??cJSON_ReplaceItemViaPointer_2
   1678                  return true;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBD02             POP      {R1,PC}
   1679              }
   1680          
   1681              replacement->next = item->next;
   \                     ??cJSON_ReplaceItemViaPointer_2: (+1)
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x6011             STR      R1,[R2, #+0]
   1682              replacement->prev = item->prev;
   \       0x1E   0x6841             LDR      R1,[R0, #+4]
   \       0x20   0x6051             STR      R1,[R2, #+4]
   1683          
   1684              if (replacement->next != NULL) {
   \       0x22   0x6811             LDR      R1,[R2, #+0]
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD000             BEQ.N    ??cJSON_ReplaceItemViaPointer_3
   1685                  replacement->next->prev = replacement;
   \       0x28   0x604A             STR      R2,[R1, #+4]
   1686              }
   1687              if (replacement->prev != NULL) {
   \                     ??cJSON_ReplaceItemViaPointer_3: (+1)
   \       0x2A   0x6851             LDR      R1,[R2, #+4]
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xD000             BEQ.N    ??cJSON_ReplaceItemViaPointer_4
   1688                  replacement->prev->next = replacement;
   \       0x30   0x600A             STR      R2,[R1, #+0]
   1689              }
   1690              if (parent->child == item) {
   \                     ??cJSON_ReplaceItemViaPointer_4: (+1)
   \       0x32   0x6899             LDR      R1,[R3, #+8]
   \       0x34   0x4281             CMP      R1,R0
   \       0x36   0xD100             BNE.N    ??cJSON_ReplaceItemViaPointer_5
   1691                  parent->child = replacement;
   \       0x38   0x609A             STR      R2,[R3, #+8]
   1692              }
   1693          
   1694              item->next = NULL;
   \                     ??cJSON_ReplaceItemViaPointer_5: (+1)
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x6001             STR      R1,[R0, #+0]
   1695              item->prev = NULL;
   \       0x3E   0x6041             STR      R1,[R0, #+4]
   1696              cJSON_Delete(item);
   \       0x40   0x....'....        BL       cJSON_Delete
   1697          
   1698              return true;
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xBD02             POP      {R1,PC}          ;; return
   1699          }
   1700          

   \                                 In section .text, align 2, keep-with-next
   1701          CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
   1702          {
   \                     cJSON_ReplaceItemInArray: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4615             MOV      R5,R2
   1703              cJSON *obj = NULL;
   1704          
   1705              if (which < 0) {
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD408             BMI.N    ??cJSON_ReplaceItemInArray_0
   1706                  return;
   1707              }
   1708          
   1709              obj = get_array_item(array, (size_t)which);
   \        0xA   0x....'....        BL       get_array_item
   \        0xE   0x0001             MOVS     R1,R0
   1710              if (obj == NULL) {
   \       0x10   0xD004             BEQ.N    ??cJSON_ReplaceItemInArray_0
   1711                  return;
   1712              }
   1713          
   1714              cJSON_ReplaceItemViaPointer(array, obj, newitem);
   \       0x12   0x462A             MOV      R2,R5
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x1A   0x....             B.N      cJSON_ReplaceItemViaPointer
   \                     ??cJSON_ReplaceItemInArray_0: (+1)
   \       0x1C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1715          }
   1716          

   \                                 In section .text, align 2, keep-with-next
   1717          static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement,
   1718                  cJSON_bool case_sensitive)
   1719          {
   \                     replace_item_in_object: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461F             MOV      R7,R3
   1720              cJSON *obj = NULL;
   1721          
   1722              if (replacement == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??replace_item_in_object_0
   1723                  return false;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBDF2             POP      {R1,R4-R7,PC}
   1724              }
   1725          
   1726              /* replace the name in the replacement */
   1727              if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL)) {
   \                     ??replace_item_in_object_0: (+1)
   \       0x12   0x68E0             LDR      R0,[R4, #+12]
   \       0x14   0x0580             LSLS     R0,R0,#+22
   \       0x16   0xD404             BMI.N    ??replace_item_in_object_1
   \       0x18   0x6A20             LDR      R0,[R4, #+32]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??replace_item_in_object_1
   1728                  cJSON_free(replacement->string);
   \       0x1E   0x....'....        BL       cJSON_free
   1729              }
   1730              replacement->string = (char *)cJSON_strdup((const unsigned char *)string, &global_hooks);
   \                     ??replace_item_in_object_1: (+1)
   \       0x22   0x....'....        LDR.W    R1,??DataTable31
   \       0x26   0x4630             MOV      R0,R6
   \       0x28   0x....'....        BL       cJSON_strdup
   \       0x2C   0x6220             STR      R0,[R4, #+32]
   1731              replacement->type &= ~cJSON_StringIsConst;
   \       0x2E   0x68E0             LDR      R0,[R4, #+12]
   \       0x30   0xF420 0x7000      BIC      R0,R0,#0x200
   \       0x34   0x60E0             STR      R0,[R4, #+12]
   1732          
   1733              obj = get_object_item(object, string, case_sensitive);
   \       0x36   0x463A             MOV      R2,R7
   \       0x38   0x4631             MOV      R1,R6
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0x....'....        BL       get_object_item
   1734              if (obj == NULL) {
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD101             BNE.N    ??replace_item_in_object_2
   1735                  return false;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBDF2             POP      {R1,R4-R7,PC}
   1736              }
   1737          
   1738              cJSON_ReplaceItemViaPointer(object, obj, replacement);
   \                     ??replace_item_in_object_2: (+1)
   \       0x48   0x4622             MOV      R2,R4
   \       0x4A   0x4601             MOV      R1,R0
   \       0x4C   0x4628             MOV      R0,R5
   \       0x4E   0x....'....        BL       cJSON_ReplaceItemViaPointer
   1739          
   1740              return true;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1741          }
   1742          

   \                                 In section .text, align 2, keep-with-next
   1743          CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
   1744          {
   1745              replace_item_in_object(object, string, newitem, false);
   \                     cJSON_ReplaceItemInObject: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x....             B.N      replace_item_in_object
   1746          }
   1747          

   \                                 In section .text, align 2, keep-with-next
   1748          CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
   1749          {
   1750              replace_item_in_object(object, string, newitem, true);
   \                     cJSON_ReplaceItemInObjectCaseSensitive: (+1)
   \        0x0   0x2301             MOVS     R3,#+1
   \        0x2   0x....             B.N      replace_item_in_object
   1751          }
   1752          
   1753          /* Create basic types: */

   \                                 In section .text, align 2, keep-with-next
   1754          CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
   1755          {
   \                     cJSON_CreateNull: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1756              cJSON *item = cJSON_New_Item(&global_hooks);
   \        0x2   0x....'....        LDR.W    R0,??DataTable31
   \        0x6   0x....'....        BL       cJSON_New_Item
   1757              if (item) {
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??cJSON_CreateNull_0
   1758                  item->type = cJSON_NULL;
   \        0xE   0x2104             MOVS     R1,#+4
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   1759              }
   1760          
   1761              return item;
   \                     ??cJSON_CreateNull_0: (+1)
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
   1762          }
   1763          

   \                                 In section .text, align 2, keep-with-next
   1764          CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
   1765          {
   \                     cJSON_CreateTrue: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1766              cJSON *item = cJSON_New_Item(&global_hooks);
   \        0x2   0x....'....        LDR.W    R0,??DataTable31
   \        0x6   0x....'....        BL       cJSON_New_Item
   1767              if (item) {
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??cJSON_CreateTrue_0
   1768                  item->type = cJSON_True;
   \        0xE   0x2102             MOVS     R1,#+2
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   1769              }
   1770          
   1771              return item;
   \                     ??cJSON_CreateTrue_0: (+1)
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
   1772          }
   1773          

   \                                 In section .text, align 2, keep-with-next
   1774          CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
   1775          {
   \                     cJSON_CreateFalse: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1776              cJSON *item = cJSON_New_Item(&global_hooks);
   \        0x2   0x....'....        LDR.W    R0,??DataTable31
   \        0x6   0x....'....        BL       cJSON_New_Item
   1777              if (item) {
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??cJSON_CreateFalse_0
   1778                  item->type = cJSON_False;
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   1779              }
   1780          
   1781              return item;
   \                     ??cJSON_CreateFalse_0: (+1)
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
   1782          }
   1783          

   \                                 In section .text, align 2, keep-with-next
   1784          CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool b)
   1785          {
   \                     cJSON_CreateBool: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1786              cJSON *item = cJSON_New_Item(&global_hooks);
   \        0x4   0x....'....        LDR.W    R0,??DataTable31
   \        0x8   0x....'....        BL       cJSON_New_Item
   1787              if (item) {
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD005             BEQ.N    ??cJSON_CreateBool_0
   1788                  item->type = b ? cJSON_True : cJSON_False;
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD001             BEQ.N    ??cJSON_CreateBool_1
   \       0x14   0x2102             MOVS     R1,#+2
   \       0x16   0xE000             B.N      ??cJSON_CreateBool_2
   \                     ??cJSON_CreateBool_1: (+1)
   \       0x18   0x2101             MOVS     R1,#+1
   \                     ??cJSON_CreateBool_2: (+1)
   \       0x1A   0x60C1             STR      R1,[R0, #+12]
   1789              }
   1790          
   1791              return item;
   \                     ??cJSON_CreateBool_0: (+1)
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
   1792          }
   1793          

   \                                 In section .text, align 4, keep-with-next
   1794          CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
   1795          {
   \                     cJSON_CreateNumber: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xED2D 0x8B02      VPUSH    {D8}
   \        0x6   0xEEB0 0x8B40      VMOV.F64 D8,D0
   1796              cJSON *item = cJSON_New_Item(&global_hooks);
   \        0xA   0x....'....        LDR.W    R0,??DataTable31
   \        0xE   0x....'....        BL       cJSON_New_Item
   1797              if (item) {
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD01D             BEQ.N    ??cJSON_CreateNumber_0
   1798                  item->type = cJSON_Number;
   \       0x16   0x2108             MOVS     R1,#+8
   \       0x18   0x60C1             STR      R1,[R0, #+12]
   1799                  item->valuedouble = num;
   \       0x1A   0xED80 0x8B06      VSTR     D8,[R0, #+24]
   1800          
   1801                  /* use saturation in case of overflow */
   1802                  if (num >= INT_MAX) {
   \       0x1E   0xED9F 0x....      VLDR.W   D1,??DataTable28_1
   \       0x22   0xEEB4 0x8B41      VCMP.F64 D8,D1
   \       0x26   0xEEF1 0xFA10      FMSTAT   
   \       0x2A   0xDB03             BLT.N    ??cJSON_CreateNumber_1
   1803                      item->valueint = INT_MAX;
   \       0x2C   0xF06F 0x4100      MVN      R1,#-2147483648
   \       0x30   0x6141             STR      R1,[R0, #+20]
   \       0x32   0xE00E             B.N      ??cJSON_CreateNumber_0
   1804                  } else if (num <= INT_MIN) {
   \                     ??cJSON_CreateNumber_1: (+1)
   \       0x34   0xED9F 0x....      VLDR.W   D1,??DataTable29
   \       0x38   0xEEB4 0x8B41      VCMP.F64 D8,D1
   \       0x3C   0xEEF1 0xFA10      FMSTAT   
   \       0x40   0xD503             BPL.N    ??cJSON_CreateNumber_2
   1805                      item->valueint = INT_MIN;
   \       0x42   0xF04F 0x4100      MOV      R1,#-2147483648
   \       0x46   0x6141             STR      R1,[R0, #+20]
   \       0x48   0xE003             B.N      ??cJSON_CreateNumber_0
   1806                  } else {
   1807                      item->valueint = (int)num;
   \                     ??cJSON_CreateNumber_2: (+1)
   \       0x4A   0xEEBD 0x0BC8      VCVT.S32.F64 S0,D8
   \       0x4E   0xED80 0x0A05      VSTR     S0,[R0, #+20]
   1808                  }
   1809              }
   1810          
   1811              return item;
   \                     ??cJSON_CreateNumber_0: (+1)
   \       0x52   0xECBD 0x8B02      VPOP     {D8}
   \       0x56   0xBD02             POP      {R1,PC}          ;; return
   1812          }
   1813          

   \                                 In section .text, align 2, keep-with-next
   1814          CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
   1815          {
   \                     cJSON_CreateString: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   1816              cJSON *item = cJSON_New_Item(&global_hooks);
   \        0x4   0x....'....        LDR.W    R6,??DataTable31
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x....'....        BL       cJSON_New_Item
   \        0xE   0x0004             MOVS     R4,R0
   1817              if (item) {
   \       0x10   0xD00D             BEQ.N    ??cJSON_CreateString_0
   1818                  item->type = cJSON_String;
   \       0x12   0x2010             MOVS     R0,#+16
   \       0x14   0x60E0             STR      R0,[R4, #+12]
   1819                  item->valuestring = (char *)cJSON_strdup((const unsigned char *)string, &global_hooks);
   \       0x16   0x4631             MOV      R1,R6
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       cJSON_strdup
   \       0x1E   0x6120             STR      R0,[R4, #+16]
   1820                  if (!item->valuestring) {
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD104             BNE.N    ??cJSON_CreateString_0
   1821                      cJSON_Delete(item);
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       cJSON_Delete
   1822                      return NULL;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD70             POP      {R4-R6,PC}
   1823                  }
   1824              }
   1825          
   1826              return item;
   \                     ??cJSON_CreateString_0: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0xBD70             POP      {R4-R6,PC}       ;; return
   1827          }
   1828          

   \                                 In section .text, align 2, keep-with-next
   1829          CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
   1830          {
   \                     cJSON_CreateRaw: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   1831              cJSON *item = cJSON_New_Item(&global_hooks);
   \        0x4   0x....'....        LDR.W    R6,??DataTable31
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x....'....        BL       cJSON_New_Item
   \        0xE   0x0004             MOVS     R4,R0
   1832              if (item) {
   \       0x10   0xD00D             BEQ.N    ??cJSON_CreateRaw_0
   1833                  item->type = cJSON_Raw;
   \       0x12   0x2080             MOVS     R0,#+128
   \       0x14   0x60E0             STR      R0,[R4, #+12]
   1834                  item->valuestring = (char *)cJSON_strdup((const unsigned char *)raw, &global_hooks);
   \       0x16   0x4631             MOV      R1,R6
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       cJSON_strdup
   \       0x1E   0x6120             STR      R0,[R4, #+16]
   1835                  if (!item->valuestring) {
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD104             BNE.N    ??cJSON_CreateRaw_0
   1836                      cJSON_Delete(item);
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       cJSON_Delete
   1837                      return NULL;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD70             POP      {R4-R6,PC}
   1838                  }
   1839              }
   1840          
   1841              return item;
   \                     ??cJSON_CreateRaw_0: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0xBD70             POP      {R4-R6,PC}       ;; return
   1842          }
   1843          

   \                                 In section .text, align 2, keep-with-next
   1844          CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
   1845          {
   \                     cJSON_CreateArray: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1846              cJSON *item = cJSON_New_Item(&global_hooks);
   \        0x2   0x....'....        LDR.W    R0,??DataTable31
   \        0x6   0x....'....        BL       cJSON_New_Item
   1847              if (item) {
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??cJSON_CreateArray_0
   1848                  item->type = cJSON_Array;
   \        0xE   0x2120             MOVS     R1,#+32
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   1849              }
   1850          
   1851              return item;
   \                     ??cJSON_CreateArray_0: (+1)
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
   1852          }
   1853          

   \                                 In section .text, align 2, keep-with-next
   1854          CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
   1855          {
   \                     cJSON_CreateObject: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1856              cJSON *item = cJSON_New_Item(&global_hooks);
   \        0x2   0x....'....        LDR.W    R0,??DataTable31
   \        0x6   0x....'....        BL       cJSON_New_Item
   1857              if (item) {
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??cJSON_CreateObject_0
   1858                  item->type = cJSON_Object;
   \        0xE   0x2140             MOVS     R1,#+64
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   1859              }
   1860          
   1861              return item;
   \                     ??cJSON_CreateObject_0: (+1)
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
   1862          }
   1863          
   1864          /* Create Arrays: */

   \                                 In section .text, align 2, keep-with-next
   1865          CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
   1866          {
   \                     cJSON_CreateIntArray: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
   1867              size_t i = 0;
   \        0x8   0x2600             MOVS     R6,#+0
   1868              cJSON *n = NULL;
   1869              cJSON *p = NULL;
   \        0xA   0x46B1             MOV      R9,R6
   1870              cJSON *a = NULL;
   1871          
   1872              if (count < 0) {
   \        0xC   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x10   0xD501             BPL.N    ??cJSON_CreateIntArray_0
   1873                  return NULL;
   \       0x12   0x4630             MOV      R0,R6
   \       0x14   0xE021             B.N      ??cJSON_CreateIntArray_1
   1874              }
   1875          
   1876              a = cJSON_CreateArray();
   \                     ??cJSON_CreateIntArray_0: (+1)
   \       0x16   0x....'....        BL       cJSON_CreateArray
   \       0x1A   0x4605             MOV      R5,R0
   1877              for (i = 0; a && (i < (size_t)count); i++) {
   \       0x1C   0xE009             B.N      ??cJSON_CreateIntArray_2
   1878                  n = cJSON_CreateNumber(numbers[i]);
   1879                  if (!n) {
   1880                      cJSON_Delete(a);
   1881                      return NULL;
   1882                  }
   1883                  if (!i) {
   1884                      a->child = n;
   1885                  } else {
   1886                      suffix_object(p, n);
   \                     ??cJSON_CreateIntArray_3: (+1)
   \       0x1E   0x4621             MOV      R1,R4
   \       0x20   0x4648             MOV      R0,R9
   \       0x22   0x....'....        BL       suffix_object
   \       0x26   0xE002             B.N      ??cJSON_CreateIntArray_4
   1887                  }
   \                     ??cJSON_CreateIntArray_5: (+1)
   \       0x28   0x2E00             CMP      R6,#+0
   \       0x2A   0xD1F8             BNE.N    ??cJSON_CreateIntArray_3
   \       0x2C   0x60AC             STR      R4,[R5, #+8]
   1888                  p = n;
   \                     ??cJSON_CreateIntArray_4: (+1)
   \       0x2E   0x46A1             MOV      R9,R4
   \       0x30   0x1C76             ADDS     R6,R6,#+1
   \                     ??cJSON_CreateIntArray_2: (+1)
   \       0x32   0x2D00             CMP      R5,#+0
   \       0x34   0xD010             BEQ.N    ??cJSON_CreateIntArray_6
   \       0x36   0x4546             CMP      R6,R8
   \       0x38   0xD20E             BCS.N    ??cJSON_CreateIntArray_6
   \       0x3A   0xEB07 0x0086      ADD      R0,R7,R6, LSL #+2
   \       0x3E   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \       0x42   0xEEB8 0x0BC0      VCVT.F64.S32 D0,S0
   \       0x46   0x....'....        BL       cJSON_CreateNumber
   \       0x4A   0x0004             MOVS     R4,R0
   \       0x4C   0xD1EC             BNE.N    ??cJSON_CreateIntArray_5
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0x....'....        BL       cJSON_Delete
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xE000             B.N      ??cJSON_CreateIntArray_1
   1889              }
   1890          
   1891              return a;
   \                     ??cJSON_CreateIntArray_6: (+1)
   \       0x58   0x4628             MOV      R0,R5
   \                     ??cJSON_CreateIntArray_1: (+1)
   \       0x5A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1892          }
   1893          

   \                                 In section .text, align 2, keep-with-next
   1894          CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
   1895          {
   \                     cJSON_CreateFloatArray: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
   1896              size_t i = 0;
   \        0x8   0x2600             MOVS     R6,#+0
   1897              cJSON *n = NULL;
   1898              cJSON *p = NULL;
   \        0xA   0x46B1             MOV      R9,R6
   1899              cJSON *a = NULL;
   1900          
   1901              if (count < 0) {
   \        0xC   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x10   0xD501             BPL.N    ??cJSON_CreateFloatArray_0
   1902                  return NULL;
   \       0x12   0x4630             MOV      R0,R6
   \       0x14   0xE021             B.N      ??cJSON_CreateFloatArray_1
   1903              }
   1904          
   1905              a = cJSON_CreateArray();
   \                     ??cJSON_CreateFloatArray_0: (+1)
   \       0x16   0x....'....        BL       cJSON_CreateArray
   \       0x1A   0x4605             MOV      R5,R0
   1906          
   1907              for (i = 0; a && (i < (size_t)count); i++) {
   \       0x1C   0xE009             B.N      ??cJSON_CreateFloatArray_2
   1908                  n = cJSON_CreateNumber((double)numbers[i]);
   1909                  if (!n) {
   1910                      cJSON_Delete(a);
   1911                      return NULL;
   1912                  }
   1913                  if (!i) {
   1914                      a->child = n;
   1915                  } else {
   1916                      suffix_object(p, n);
   \                     ??cJSON_CreateFloatArray_3: (+1)
   \       0x1E   0x4621             MOV      R1,R4
   \       0x20   0x4648             MOV      R0,R9
   \       0x22   0x....'....        BL       suffix_object
   \       0x26   0xE002             B.N      ??cJSON_CreateFloatArray_4
   1917                  }
   \                     ??cJSON_CreateFloatArray_5: (+1)
   \       0x28   0x2E00             CMP      R6,#+0
   \       0x2A   0xD1F8             BNE.N    ??cJSON_CreateFloatArray_3
   \       0x2C   0x60AC             STR      R4,[R5, #+8]
   1918                  p = n;
   \                     ??cJSON_CreateFloatArray_4: (+1)
   \       0x2E   0x46A1             MOV      R9,R4
   \       0x30   0x1C76             ADDS     R6,R6,#+1
   \                     ??cJSON_CreateFloatArray_2: (+1)
   \       0x32   0x2D00             CMP      R5,#+0
   \       0x34   0xD010             BEQ.N    ??cJSON_CreateFloatArray_6
   \       0x36   0x4546             CMP      R6,R8
   \       0x38   0xD20E             BCS.N    ??cJSON_CreateFloatArray_6
   \       0x3A   0xEB07 0x0086      ADD      R0,R7,R6, LSL #+2
   \       0x3E   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \       0x42   0xEEB7 0x0AC0      VCVT.F64.F32 D0,S0
   \       0x46   0x....'....        BL       cJSON_CreateNumber
   \       0x4A   0x0004             MOVS     R4,R0
   \       0x4C   0xD1EC             BNE.N    ??cJSON_CreateFloatArray_5
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0x....'....        BL       cJSON_Delete
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xE000             B.N      ??cJSON_CreateFloatArray_1
   1919              }
   1920          
   1921              return a;
   \                     ??cJSON_CreateFloatArray_6: (+1)
   \       0x58   0x4628             MOV      R0,R5
   \                     ??cJSON_CreateFloatArray_1: (+1)
   \       0x5A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1922          }
   1923          

   \                                 In section .text, align 2, keep-with-next
   1924          CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
   1925          {
   \                     cJSON_CreateDoubleArray: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
   1926              size_t i = 0;
   \        0x8   0x2600             MOVS     R6,#+0
   1927              cJSON *n = NULL;
   1928              cJSON *p = NULL;
   \        0xA   0x46B1             MOV      R9,R6
   1929              cJSON *a = NULL;
   1930          
   1931              if (count < 0) {
   \        0xC   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x10   0xD501             BPL.N    ??cJSON_CreateDoubleArray_0
   1932                  return NULL;
   \       0x12   0x4630             MOV      R0,R6
   \       0x14   0xE01F             B.N      ??cJSON_CreateDoubleArray_1
   1933              }
   1934          
   1935              a = cJSON_CreateArray();
   \                     ??cJSON_CreateDoubleArray_0: (+1)
   \       0x16   0x....'....        BL       cJSON_CreateArray
   \       0x1A   0x4605             MOV      R5,R0
   1936          
   1937              for (i = 0; a && (i < (size_t)count); i++) {
   \       0x1C   0xE009             B.N      ??cJSON_CreateDoubleArray_2
   1938                  n = cJSON_CreateNumber(numbers[i]);
   1939                  if (!n) {
   1940                      cJSON_Delete(a);
   1941                      return NULL;
   1942                  }
   1943                  if (!i) {
   1944                      a->child = n;
   1945                  } else {
   1946                      suffix_object(p, n);
   \                     ??cJSON_CreateDoubleArray_3: (+1)
   \       0x1E   0x4621             MOV      R1,R4
   \       0x20   0x4648             MOV      R0,R9
   \       0x22   0x....'....        BL       suffix_object
   \       0x26   0xE002             B.N      ??cJSON_CreateDoubleArray_4
   1947                  }
   \                     ??cJSON_CreateDoubleArray_5: (+1)
   \       0x28   0x2E00             CMP      R6,#+0
   \       0x2A   0xD1F8             BNE.N    ??cJSON_CreateDoubleArray_3
   \       0x2C   0x60AC             STR      R4,[R5, #+8]
   1948                  p = n;
   \                     ??cJSON_CreateDoubleArray_4: (+1)
   \       0x2E   0x46A1             MOV      R9,R4
   \       0x30   0x1C76             ADDS     R6,R6,#+1
   \                     ??cJSON_CreateDoubleArray_2: (+1)
   \       0x32   0x2D00             CMP      R5,#+0
   \       0x34   0xD00E             BEQ.N    ??cJSON_CreateDoubleArray_6
   \       0x36   0x4546             CMP      R6,R8
   \       0x38   0xD20C             BCS.N    ??cJSON_CreateDoubleArray_6
   \       0x3A   0xEB07 0x00C6      ADD      R0,R7,R6, LSL #+3
   \       0x3E   0xED90 0x0B00      VLDR     D0,[R0, #0]
   \       0x42   0x....'....        BL       cJSON_CreateNumber
   \       0x46   0x0004             MOVS     R4,R0
   \       0x48   0xD1EE             BNE.N    ??cJSON_CreateDoubleArray_5
   \       0x4A   0x4628             MOV      R0,R5
   \       0x4C   0x....'....        BL       cJSON_Delete
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE000             B.N      ??cJSON_CreateDoubleArray_1
   1949              }
   1950          
   1951              return a;
   \                     ??cJSON_CreateDoubleArray_6: (+1)
   \       0x54   0x4628             MOV      R0,R5
   \                     ??cJSON_CreateDoubleArray_1: (+1)
   \       0x56   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1952          }
   1953          

   \                                 In section .text, align 2, keep-with-next
   1954          CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)
   1955          {
   \                     cJSON_CreateStringArray: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
   1956              size_t i = 0;
   \        0x8   0x2600             MOVS     R6,#+0
   1957              cJSON *n = NULL;
   1958              cJSON *p = NULL;
   \        0xA   0x46B1             MOV      R9,R6
   1959              cJSON *a = NULL;
   1960          
   1961              if (count < 0) {
   \        0xC   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x10   0xD501             BPL.N    ??cJSON_CreateStringArray_0
   1962                  return NULL;
   \       0x12   0x4630             MOV      R0,R6
   \       0x14   0xE01D             B.N      ??cJSON_CreateStringArray_1
   1963              }
   1964          
   1965              a = cJSON_CreateArray();
   \                     ??cJSON_CreateStringArray_0: (+1)
   \       0x16   0x....'....        BL       cJSON_CreateArray
   \       0x1A   0x4605             MOV      R5,R0
   1966          
   1967              for (i = 0; a && (i < (size_t)count); i++) {
   \       0x1C   0xE009             B.N      ??cJSON_CreateStringArray_2
   1968                  n = cJSON_CreateString(strings[i]);
   1969                  if (!n) {
   1970                      cJSON_Delete(a);
   1971                      return NULL;
   1972                  }
   1973                  if (!i) {
   1974                      a->child = n;
   1975                  } else {
   1976                      suffix_object(p, n);
   \                     ??cJSON_CreateStringArray_3: (+1)
   \       0x1E   0x4621             MOV      R1,R4
   \       0x20   0x4648             MOV      R0,R9
   \       0x22   0x....'....        BL       suffix_object
   \       0x26   0xE002             B.N      ??cJSON_CreateStringArray_4
   1977                  }
   \                     ??cJSON_CreateStringArray_5: (+1)
   \       0x28   0x2E00             CMP      R6,#+0
   \       0x2A   0xD1F8             BNE.N    ??cJSON_CreateStringArray_3
   \       0x2C   0x60AC             STR      R4,[R5, #+8]
   1978                  p = n;
   \                     ??cJSON_CreateStringArray_4: (+1)
   \       0x2E   0x46A1             MOV      R9,R4
   \       0x30   0x1C76             ADDS     R6,R6,#+1
   \                     ??cJSON_CreateStringArray_2: (+1)
   \       0x32   0x2D00             CMP      R5,#+0
   \       0x34   0xD00C             BEQ.N    ??cJSON_CreateStringArray_6
   \       0x36   0x4546             CMP      R6,R8
   \       0x38   0xD20A             BCS.N    ??cJSON_CreateStringArray_6
   \       0x3A   0xF857 0x0026      LDR      R0,[R7, R6, LSL #+2]
   \       0x3E   0x....'....        BL       cJSON_CreateString
   \       0x42   0x0004             MOVS     R4,R0
   \       0x44   0xD1F0             BNE.N    ??cJSON_CreateStringArray_5
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x....'....        BL       cJSON_Delete
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xE000             B.N      ??cJSON_CreateStringArray_1
   1979              }
   1980          
   1981              return a;
   \                     ??cJSON_CreateStringArray_6: (+1)
   \       0x50   0x4628             MOV      R0,R5
   \                     ??cJSON_CreateStringArray_1: (+1)
   \       0x52   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1982          }
   1983          
   1984          /* Duplication */

   \                                 In section .text, align 2, keep-with-next
   1985          CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
   1986          {
   \                     cJSON_Duplicate: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   1987              cJSON *newitem = NULL;
   \        0x8   0x2500             MOVS     R5,#+0
   1988              cJSON *child = NULL;
   1989              cJSON *next = NULL;
   \        0xA   0x462C             MOV      R4,R5
   1990              cJSON *newchild = NULL;
   1991          
   1992              /* Bail on bad ptr */
   1993              if (!item) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD03F             BEQ.N    ??cJSON_Duplicate_0
   1994                  goto fail;
   1995              }
   1996              /* Create new item */
   1997              newitem = cJSON_New_Item(&global_hooks);
   \       0x10   0x....'....        LDR.W    R8,??DataTable31
   \       0x14   0x4640             MOV      R0,R8
   \       0x16   0x....'....        BL       cJSON_New_Item
   \       0x1A   0x0005             MOVS     R5,R0
   1998              if (!newitem) {
   \       0x1C   0xD038             BEQ.N    ??cJSON_Duplicate_0
   1999                  goto fail;
   2000              }
   2001              /* Copy over all vars */
   2002              newitem->type = item->type & (~cJSON_IsReference);
   \       0x1E   0x68F0             LDR      R0,[R6, #+12]
   \       0x20   0xF420 0x7080      BIC      R0,R0,#0x100
   \       0x24   0x60E8             STR      R0,[R5, #+12]
   2003              newitem->valueint = item->valueint;
   \       0x26   0x6970             LDR      R0,[R6, #+20]
   \       0x28   0x6168             STR      R0,[R5, #+20]
   2004              newitem->valuedouble = item->valuedouble;
   \       0x2A   0xED96 0x0B06      VLDR     D0,[R6, #+24]
   \       0x2E   0xED85 0x0B06      VSTR     D0,[R5, #+24]
   2005              if (item->valuestring) {
   \       0x32   0x6930             LDR      R0,[R6, #+16]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD005             BEQ.N    ??cJSON_Duplicate_1
   2006                  newitem->valuestring = (char *)cJSON_strdup((unsigned char *)item->valuestring, &global_hooks);
   \       0x38   0x4641             MOV      R1,R8
   \       0x3A   0x....'....        BL       cJSON_strdup
   \       0x3E   0x6128             STR      R0,[R5, #+16]
   2007                  if (!newitem->valuestring) {
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD025             BEQ.N    ??cJSON_Duplicate_0
   2008                      goto fail;
   2009                  }
   2010              }
   2011              if (item->string) {
   \                     ??cJSON_Duplicate_1: (+1)
   \       0x44   0x6A30             LDR      R0,[R6, #+32]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD00B             BEQ.N    ??cJSON_Duplicate_2
   2012                  newitem->string = (item->type & cJSON_StringIsConst) ? item->string : (char *)cJSON_strdup((
   2013                                                unsigned char *)item->string, &global_hooks);
   \       0x4A   0x68F0             LDR      R0,[R6, #+12]
   \       0x4C   0x0580             LSLS     R0,R0,#+22
   \       0x4E   0xD501             BPL.N    ??cJSON_Duplicate_3
   \       0x50   0x6A30             LDR      R0,[R6, #+32]
   \       0x52   0xE003             B.N      ??cJSON_Duplicate_4
   \                     ??cJSON_Duplicate_3: (+1)
   \       0x54   0x4641             MOV      R1,R8
   \       0x56   0x6A30             LDR      R0,[R6, #+32]
   \       0x58   0x....'....        BL       cJSON_strdup
   \                     ??cJSON_Duplicate_4: (+1)
   \       0x5C   0x6228             STR      R0,[R5, #+32]
   2014                  if (!newitem->string) {
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD016             BEQ.N    ??cJSON_Duplicate_0
   2015                      goto fail;
   2016                  }
   2017              }
   2018              /* If non-recursive, then we're done! */
   2019              if (!recurse) {
   \                     ??cJSON_Duplicate_2: (+1)
   \       0x62   0x2F00             CMP      R7,#+0
   \       0x64   0xD012             BEQ.N    ??cJSON_Duplicate_5
   2020                  return newitem;
   2021              }
   2022              /* Walk the ->next chain for the child. */
   2023              child = item->child;
   \       0x66   0x68B6             LDR      R6,[R6, #+8]
   2024              while (child != NULL) {
   \                     ??cJSON_Duplicate_6: (+1)
   \       0x68   0x2E00             CMP      R6,#+0
   \       0x6A   0xD00F             BEQ.N    ??cJSON_Duplicate_5
   2025                  newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
   \       0x6C   0x2101             MOVS     R1,#+1
   \       0x6E   0x4630             MOV      R0,R6
   \       0x70   0xF7FF 0xFFC6      BL       cJSON_Duplicate
   2026                  if (!newchild) {
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD00B             BEQ.N    ??cJSON_Duplicate_0
   2027                      goto fail;
   2028                  }
   2029                  if (next != NULL) {
   \       0x78   0x2C00             CMP      R4,#+0
   \       0x7A   0xD102             BNE.N    ??cJSON_Duplicate_7
   2030                      /* If newitem->child already set, then crosswire ->prev and ->next and move on */
   2031                      next->next = newchild;
   2032                      newchild->prev = next;
   2033                      next = newchild;
   2034                  } else {
   2035                      /* Set newitem->child and move to it */
   2036                      newitem->child = newchild;
   \       0x7C   0x60A8             STR      R0,[R5, #+8]
   2037                      next = newchild;
   \       0x7E   0x4604             MOV      R4,R0
   \       0x80   0xE002             B.N      ??cJSON_Duplicate_8
   2038                  }
   \                     ??cJSON_Duplicate_7: (+1)
   \       0x82   0x6020             STR      R0,[R4, #+0]
   \       0x84   0x6044             STR      R4,[R0, #+4]
   \       0x86   0x4604             MOV      R4,R0
   2039                  child = child->next;
   \                     ??cJSON_Duplicate_8: (+1)
   \       0x88   0x6836             LDR      R6,[R6, #+0]
   \       0x8A   0xE7ED             B.N      ??cJSON_Duplicate_6
   2040              }
   2041          
   2042              return newitem;
   \                     ??cJSON_Duplicate_5: (+1)
   \       0x8C   0x4628             MOV      R0,R5
   \       0x8E   0xE005             B.N      ??cJSON_Duplicate_9
   2043          
   2044          fail:
   2045              if (newitem != NULL) {
   \                     ??cJSON_Duplicate_0: (+1)
   \       0x90   0x2D00             CMP      R5,#+0
   \       0x92   0xD002             BEQ.N    ??cJSON_Duplicate_10
   2046                  cJSON_Delete(newitem);
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0x....'....        BL       cJSON_Delete
   2047              }
   2048          
   2049              return NULL;
   \                     ??cJSON_Duplicate_10: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \                     ??cJSON_Duplicate_9: (+1)
   \       0x9C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2050          }
   2051          

   \                                 In section .text, align 2, keep-with-next
   2052          CJSON_PUBLIC(void) cJSON_Minify(char *json)
   2053          {
   \                     cJSON_Minify: (+1)
   \        0x0   0x4601             MOV      R1,R0
   2054              unsigned char *into = (unsigned char *)json;
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0xE000             B.N      ??cJSON_Minify_0
   2055              while (*json) {
   2056                  if (*json == ' ') {
   2057                      json++;
   2058                  } else if (*json == '\t') {
   2059                      /* Whitespace characters. */
   2060                      json++;
   2061                  } else if (*json == '\r') {
   2062                      json++;
   2063                  } else if (*json == '\n') {
   2064                      json++;
   \                     ??cJSON_Minify_1: (+1)
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   2065                  } else if ((*json == '/') && (json[1] == '/')) {
   \                     ??cJSON_Minify_0: (+1)
   \        0x8   0x7808             LDRB     R0,[R1, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD038             BEQ.N    ??cJSON_Minify_2
   \        0xE   0x2820             CMP      R0,#+32
   \       0x10   0xD0F9             BEQ.N    ??cJSON_Minify_1
   \       0x12   0x2809             CMP      R0,#+9
   \       0x14   0xD0F7             BEQ.N    ??cJSON_Minify_1
   \       0x16   0x280D             CMP      R0,#+13
   \       0x18   0xD0F5             BEQ.N    ??cJSON_Minify_1
   \       0x1A   0x280A             CMP      R0,#+10
   \       0x1C   0xD0F3             BEQ.N    ??cJSON_Minify_1
   \       0x1E   0x282F             CMP      R0,#+47
   \       0x20   0xD109             BNE.N    ??cJSON_Minify_3
   \       0x22   0x7848             LDRB     R0,[R1, #+1]
   \       0x24   0x282F             CMP      R0,#+47
   \       0x26   0xD106             BNE.N    ??cJSON_Minify_3
   2066                      /* double-slash comments, to end of line. */
   2067                      while (*json && (*json != '\n')) {
   \                     ??cJSON_Minify_4: (+1)
   \       0x28   0x7808             LDRB     R0,[R1, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD0EC             BEQ.N    ??cJSON_Minify_0
   \       0x2E   0x280A             CMP      R0,#+10
   \       0x30   0xD0EA             BEQ.N    ??cJSON_Minify_0
   2068                          json++;
   \       0x32   0x1C49             ADDS     R1,R1,#+1
   \       0x34   0xE7F8             B.N      ??cJSON_Minify_4
   2069                      }
   2070                  } else if ((*json == '/') && (json[1] == '*')) {
   \                     ??cJSON_Minify_3: (+1)
   \       0x36   0x7808             LDRB     R0,[R1, #+0]
   \       0x38   0x282F             CMP      R0,#+47
   \       0x3A   0xD102             BNE.N    ??cJSON_Minify_5
   \       0x3C   0x7848             LDRB     R0,[R1, #+1]
   \       0x3E   0x282A             CMP      R0,#+42
   \       0x40   0xD021             BEQ.N    ??cJSON_Minify_6
   2071                      /* multiline comments. */
   2072                      while (*json && !((*json == '*') && (json[1] == '/'))) {
   2073                          json++;
   2074                      }
   2075                      json += 2;
   2076                  } else if (*json == '\"') {
   \                     ??cJSON_Minify_5: (+1)
   \       0x42   0x7808             LDRB     R0,[R1, #+0]
   \       0x44   0x2822             CMP      R0,#+34
   \       0x46   0xD124             BNE.N    ??cJSON_Minify_7
   2077                      /* string literals, which are \" sensitive. */
   2078                      *into++ = (unsigned char) * json++;
   \       0x48   0xF811 0x0B01      LDRB     R0,[R1], #+1
   \       0x4C   0xF802 0x0B01      STRB     R0,[R2], #+1
   \       0x50   0x4613             MOV      R3,R2
   2079                      while (*json && (*json != '\"')) {
   \                     ??cJSON_Minify_8: (+1)
   \       0x52   0x7808             LDRB     R0,[R1, #+0]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD01B             BEQ.N    ??cJSON_Minify_9
   \       0x58   0x2822             CMP      R0,#+34
   \       0x5A   0xD019             BEQ.N    ??cJSON_Minify_9
   2080                          if (*json == '\\') {
   \       0x5C   0x285C             CMP      R0,#+92
   \       0x5E   0xD103             BNE.N    ??cJSON_Minify_10
   2081                              *into++ = (unsigned char) * json++;
   \       0x60   0xF811 0x0B01      LDRB     R0,[R1], #+1
   \       0x64   0xF803 0x0B01      STRB     R0,[R3], #+1
   2082                          }
   2083                          *into++ = (unsigned char) * json++;
   \                     ??cJSON_Minify_10: (+1)
   \       0x68   0xF811 0x0B01      LDRB     R0,[R1], #+1
   \       0x6C   0xF803 0x0B01      STRB     R0,[R3], #+1
   \       0x70   0xE7EF             B.N      ??cJSON_Minify_8
   2084                      }
   2085                      *into++ = (unsigned char) * json++;
   2086                  } else {
   \                     ??cJSON_Minify_11: (+1)
   \       0x72   0x282A             CMP      R0,#+42
   \       0x74   0xD102             BNE.N    ??cJSON_Minify_12
   \       0x76   0x7848             LDRB     R0,[R1, #+1]
   \       0x78   0x282F             CMP      R0,#+47
   \       0x7A   0xD007             BEQ.N    ??cJSON_Minify_13
   \                     ??cJSON_Minify_12: (+1)
   \       0x7C   0x1C49             ADDS     R1,R1,#+1
   \       0x7E   0xE002             B.N      ??cJSON_Minify_6
   2087                      /* All other characters. */
   2088                      *into++ = (unsigned char) * json++;
   2089                  }
   2090              }
   2091          
   2092              /* and null-terminate. */
   2093              *into = '\0';
   \                     ??cJSON_Minify_2: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x7010             STRB     R0,[R2, #+0]
   2094          }
   \       0x84   0x4770             BX       LR               ;; return
   \                     ??cJSON_Minify_6: (+1)
   \       0x86   0x7808             LDRB     R0,[R1, #+0]
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD1F2             BNE.N    ??cJSON_Minify_11
   \                     ??cJSON_Minify_13: (+1)
   \       0x8C   0x1C89             ADDS     R1,R1,#+2
   \       0x8E   0xE7BB             B.N      ??cJSON_Minify_0
   \                     ??cJSON_Minify_9: (+1)
   \       0x90   0x461A             MOV      R2,R3
   \                     ??cJSON_Minify_7: (+1)
   \       0x92   0xF811 0x0B01      LDRB     R0,[R1], #+1
   \       0x96   0xF802 0x0B01      STRB     R0,[R2], #+1
   \       0x9A   0xE7B5             B.N      ??cJSON_Minify_0
   2095          

   \                                 In section .text, align 2, keep-with-next
   2096          CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON *const item)
   2097          {
   2098              if (item == NULL) {
   \                     cJSON_IsInvalid: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsInvalid_0
   2099                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2100              }
   2101          
   2102              return (item->type & 0xFF) == cJSON_Invalid;
   \                     ??cJSON_IsInvalid_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0x1E40             SUBS     R0,R0,#+1
   \        0xC   0x4180             SBCS     R0,R0,R0
   \        0xE   0x0FC0             LSRS     R0,R0,#+31
   \       0x10   0x4770             BX       LR               ;; return
   2103          }
   2104          

   \                                 In section .text, align 2, keep-with-next
   2105          CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON *const item)
   2106          {
   2107              if (item == NULL) {
   \                     cJSON_IsFalse: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsFalse_0
   2108                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2109              }
   2110          
   2111              return (item->type & 0xFF) == cJSON_False;
   \                     ??cJSON_IsFalse_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??cJSON_IsFalse_1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR
   \                     ??cJSON_IsFalse_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
   2112          }
   2113          

   \                                 In section .text, align 2, keep-with-next
   2114          CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON *const item)
   2115          {
   2116              if (item == NULL) {
   \                     cJSON_IsTrue: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsTrue_0
   2117                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2118              }
   2119          
   2120              return (item->type & 0xff) == cJSON_True;
   \                     ??cJSON_IsTrue_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD101             BNE.N    ??cJSON_IsTrue_1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR
   \                     ??cJSON_IsTrue_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
   2121          }
   2122          
   2123          

   \                                 In section .text, align 2, keep-with-next
   2124          CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON *const item)
   2125          {
   2126              if (item == NULL) {
   \                     cJSON_IsBool: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsBool_0
   2127                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2128              }
   2129          
   2130              return (item->type & (cJSON_True | cJSON_False)) != 0;
   \                     ??cJSON_IsBool_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0xF000 0x0003      AND      R0,R0,#0x3
   \        0xE   0x1E40             SUBS     R0,R0,#+1
   \       0x10   0x4180             SBCS     R0,R0,R0
   \       0x12   0x43C0             MVNS     R0,R0
   \       0x14   0x0FC0             LSRS     R0,R0,#+31
   \       0x16   0x4770             BX       LR               ;; return
   2131          }

   \                                 In section .text, align 2, keep-with-next
   2132          CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON *const item)
   2133          {
   2134              if (item == NULL) {
   \                     cJSON_IsNull: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsNull_0
   2135                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2136              }
   2137          
   2138              return (item->type & 0xFF) == cJSON_NULL;
   \                     ??cJSON_IsNull_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xD101             BNE.N    ??cJSON_IsNull_1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR
   \                     ??cJSON_IsNull_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
   2139          }
   2140          

   \                                 In section .text, align 2, keep-with-next
   2141          CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON *const item)
   2142          {
   2143              if (item == NULL) {
   \                     cJSON_IsNumber: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsNumber_0
   2144                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2145              }
   2146          
   2147              return (item->type & 0xFF) == cJSON_Number;
   \                     ??cJSON_IsNumber_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD101             BNE.N    ??cJSON_IsNumber_1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR
   \                     ??cJSON_IsNumber_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
   2148          }
   2149          

   \                                 In section .text, align 2, keep-with-next
   2150          CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON *const item)
   2151          {
   2152              if (item == NULL) {
   \                     cJSON_IsString: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsString_0
   2153                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2154              }
   2155          
   2156              return (item->type & 0xFF) == cJSON_String;
   \                     ??cJSON_IsString_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xD101             BNE.N    ??cJSON_IsString_1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR
   \                     ??cJSON_IsString_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
   2157          }
   2158          

   \                                 In section .text, align 2, keep-with-next
   2159          CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON *const item)
   2160          {
   2161              if (item == NULL) {
   \                     cJSON_IsArray: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsArray_0
   2162                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2163              }
   2164          
   2165              return (item->type & 0xFF) == cJSON_Array;
   \                     ??cJSON_IsArray_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD101             BNE.N    ??cJSON_IsArray_1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR
   \                     ??cJSON_IsArray_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
   2166          }
   2167          

   \                                 In section .text, align 2, keep-with-next
   2168          CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON *const item)
   2169          {
   2170              if (item == NULL) {
   \                     cJSON_IsObject: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsObject_0
   2171                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2172              }
   2173          
   2174              return (item->type & 0xFF) == cJSON_Object;
   \                     ??cJSON_IsObject_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0x2840             CMP      R0,#+64
   \        0xC   0xD101             BNE.N    ??cJSON_IsObject_1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR
   \                     ??cJSON_IsObject_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
   2175          }
   2176          

   \                                 In section .text, align 2, keep-with-next
   2177          CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON *const item)
   2178          {
   2179              if (item == NULL) {
   \                     cJSON_IsRaw: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??cJSON_IsRaw_0
   2180                  return false;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
   2181              }
   2182          
   2183              return (item->type & 0xFF) == cJSON_Raw;
   \                     ??cJSON_IsRaw_0: (+1)
   \        0x8   0x7B00             LDRB     R0,[R0, #+12]
   \        0xA   0x2880             CMP      R0,#+128
   \        0xC   0xD101             BNE.N    ??cJSON_IsRaw_1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR
   \                     ??cJSON_IsRaw_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
   2184          }
   2185          

   \                                 In section .text, align 2, keep-with-next
   2186          CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON *const a, const cJSON *const b, const cJSON_bool case_sensitive)
   2187          {
   \                     cJSON_Compare: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4617             MOV      R7,R2
   2188              if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a)) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD00A             BEQ.N    ??cJSON_Compare_0
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD008             BEQ.N    ??cJSON_Compare_0
   \       0x10   0x7B20             LDRB     R0,[R4, #+12]
   \       0x12   0x7B31             LDRB     R1,[R6, #+12]
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD104             BNE.N    ??cJSON_Compare_0
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x....'....        BL       cJSON_IsInvalid
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??cJSON_Compare_1
   2189                  return false;
   \                     ??cJSON_Compare_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBDF2             POP      {R1,R4-R7,PC}
   2190              }
   2191          
   2192              /* check if type is valid */
   2193              switch (a->type & 0xFF) {
   \                     ??cJSON_Compare_1: (+1)
   \       0x26   0x68E0             LDR      R0,[R4, #+12]
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD00D             BEQ.N    ??cJSON_Compare_2
   \       0x2E   0x2802             CMP      R0,#+2
   \       0x30   0xD00B             BEQ.N    ??cJSON_Compare_2
   \       0x32   0x2804             CMP      R0,#+4
   \       0x34   0xD009             BEQ.N    ??cJSON_Compare_2
   \       0x36   0x2808             CMP      R0,#+8
   \       0x38   0xD007             BEQ.N    ??cJSON_Compare_2
   \       0x3A   0x2810             CMP      R0,#+16
   \       0x3C   0xD005             BEQ.N    ??cJSON_Compare_2
   \       0x3E   0x2820             CMP      R0,#+32
   \       0x40   0xD003             BEQ.N    ??cJSON_Compare_2
   \       0x42   0x2840             CMP      R0,#+64
   \       0x44   0xD001             BEQ.N    ??cJSON_Compare_2
   \       0x46   0x2880             CMP      R0,#+128
   \       0x48   0xD103             BNE.N    ??cJSON_Compare_3
   2194                  case cJSON_False:
   2195                  case cJSON_True:
   2196                  case cJSON_NULL:
   2197                  case cJSON_Number:
   2198                  case cJSON_String:
   2199                  case cJSON_Raw:
   2200                  case cJSON_Array:
   2201                  case cJSON_Object:
   2202                      break;
   2203          
   2204                  default:
   2205                      return false;
   2206              }
   2207          
   2208              /* identical objects are equal */
   2209              if (a == b) {
   \                     ??cJSON_Compare_2: (+1)
   \       0x4A   0x42B4             CMP      R4,R6
   \       0x4C   0xD103             BNE.N    ??cJSON_Compare_4
   2210                  return true;
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0xBDF2             POP      {R1,R4-R7,PC}
   2211              }
   \                     ??cJSON_Compare_3: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xBDF2             POP      {R1,R4-R7,PC}
   2212          
   2213              switch (a->type & 0xFF) {
   \                     ??cJSON_Compare_4: (+1)
   \       0x56   0x68E0             LDR      R0,[R4, #+12]
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0x2801             CMP      R0,#+1
   \       0x5C   0xD00E             BEQ.N    ??cJSON_Compare_5
   \       0x5E   0x2802             CMP      R0,#+2
   \       0x60   0xD00C             BEQ.N    ??cJSON_Compare_5
   \       0x62   0x2804             CMP      R0,#+4
   \       0x64   0xD00A             BEQ.N    ??cJSON_Compare_5
   \       0x66   0x2808             CMP      R0,#+8
   \       0x68   0xD00A             BEQ.N    ??cJSON_Compare_6
   \       0x6A   0x2810             CMP      R0,#+16
   \       0x6C   0xD015             BEQ.N    ??cJSON_Compare_7
   \       0x6E   0x2820             CMP      R0,#+32
   \       0x70   0xD023             BEQ.N    ??cJSON_Compare_8
   \       0x72   0x2840             CMP      R0,#+64
   \       0x74   0xD033             BEQ.N    ??cJSON_Compare_9
   \       0x76   0x2880             CMP      R0,#+128
   \       0x78   0xD00F             BEQ.N    ??cJSON_Compare_7
   \       0x7A   0xE047             B.N      ??cJSON_Compare_10
   2214                  /* in these cases and equal type is enough */
   2215                  case cJSON_False:
   2216                  case cJSON_True:
   2217                  case cJSON_NULL:
   2218                      return true;
   \                     ??cJSON_Compare_5: (+1)
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xBDF2             POP      {R1,R4-R7,PC}
   2219          
   2220                  case cJSON_Number:
   2221                      if (a->valuedouble == b->valuedouble) {
   \                     ??cJSON_Compare_6: (+1)
   \       0x80   0xED94 0x0B06      VLDR     D0,[R4, #+24]
   \       0x84   0xED96 0x1B06      VLDR     D1,[R6, #+24]
   \       0x88   0xEEB4 0x0B41      VCMP.F64 D0,D1
   \       0x8C   0xEEF1 0xFA10      FMSTAT   
   \       0x90   0xD101             BNE.N    ??cJSON_Compare_11
   2222                          return true;
   \       0x92   0x2001             MOVS     R0,#+1
   \       0x94   0xBDF2             POP      {R1,R4-R7,PC}
   2223                      }
   2224                      return false;
   \                     ??cJSON_Compare_11: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xBDF2             POP      {R1,R4-R7,PC}
   2225          
   2226                  case cJSON_String:
   2227                  case cJSON_Raw:
   2228                      if ((a->valuestring == NULL) || (b->valuestring == NULL)) {
   \                     ??cJSON_Compare_7: (+1)
   \       0x9A   0x6920             LDR      R0,[R4, #+16]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD002             BEQ.N    ??cJSON_Compare_12
   \       0xA0   0x6930             LDR      R0,[R6, #+16]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD101             BNE.N    ??cJSON_Compare_13
   2229                          return false;
   \                     ??cJSON_Compare_12: (+1)
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xBDF2             POP      {R1,R4-R7,PC}
   2230                      }
   2231                      if (strcmp(a->valuestring, b->valuestring) == 0) {
   \                     ??cJSON_Compare_13: (+1)
   \       0xAA   0x4601             MOV      R1,R0
   \       0xAC   0x6920             LDR      R0,[R4, #+16]
   \       0xAE   0x....'....        BL       strcmp
   \       0xB2   0x1E40             SUBS     R0,R0,#+1
   \       0xB4   0x4180             SBCS     R0,R0,R0
   \       0xB6   0x0FC0             LSRS     R0,R0,#+31
   2232                          return true;
   \       0xB8   0xBDF2             POP      {R1,R4-R7,PC}
   2233                      }
   2234          
   2235                      return false;
   2236          
   2237                  case cJSON_Array: {
   2238                      cJSON *a_element = a->child;
   \                     ??cJSON_Compare_8: (+1)
   \       0xBA   0x68A5             LDR      R5,[R4, #+8]
   2239                      cJSON *b_element = b->child;
   \       0xBC   0x68B4             LDR      R4,[R6, #+8]
   \       0xBE   0xE001             B.N      ??cJSON_Compare_14
   2240          
   2241                      for (; (a_element != NULL) && (b_element != NULL);) {
   2242                          if (!cJSON_Compare(a_element, b_element, case_sensitive)) {
   2243                              return false;
   2244                          }
   2245          
   2246                          a_element = a_element->next;
   \                     ??cJSON_Compare_15: (+1)
   \       0xC0   0x682D             LDR      R5,[R5, #+0]
   2247                          b_element = b_element->next;
   \       0xC2   0x6824             LDR      R4,[R4, #+0]
   \                     ??cJSON_Compare_14: (+1)
   \       0xC4   0x2D00             CMP      R5,#+0
   \       0xC6   0xD023             BEQ.N    ??cJSON_Compare_16
   \       0xC8   0x2C00             CMP      R4,#+0
   \       0xCA   0xD021             BEQ.N    ??cJSON_Compare_16
   \       0xCC   0x463A             MOV      R2,R7
   \       0xCE   0x4621             MOV      R1,R4
   \       0xD0   0x4628             MOV      R0,R5
   \       0xD2   0xF7FF 0xFF95      BL       cJSON_Compare
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD1F2             BNE.N    ??cJSON_Compare_15
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0xBDF2             POP      {R1,R4-R7,PC}
   2248                      }
   2249          
   2250                      return true;
   2251                  }
   2252          
   2253                  case cJSON_Object: {
   2254                      cJSON *a_element = NULL;
   2255                      cJSON_ArrayForEach(a_element, a) {
   \                     ??cJSON_Compare_9: (+1)
   \       0xDE   0x68A4             LDR      R4,[R4, #+8]
   \       0xE0   0xE007             B.N      ??cJSON_Compare_17
   2256                          /* TODO This has O(n^2) runtime, which is horrible! */
   2257                          cJSON *b_element = get_object_item(b, a_element->string, case_sensitive);
   2258                          if (b_element == NULL) {
   2259                              return false;
   2260                          }
   2261          
   2262                          if (!cJSON_Compare(a_element, b_element, case_sensitive)) {
   \                     ??cJSON_Compare_18: (+1)
   \       0xE2   0x463A             MOV      R2,R7
   \       0xE4   0x4601             MOV      R1,R0
   \       0xE6   0x4620             MOV      R0,R4
   \       0xE8   0xF7FF 0xFF8A      BL       cJSON_Compare
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD00B             BEQ.N    ??cJSON_Compare_19
   \       0xF0   0x6824             LDR      R4,[R4, #+0]
   \                     ??cJSON_Compare_17: (+1)
   \       0xF2   0x2C00             CMP      R4,#+0
   \       0xF4   0xD00E             BEQ.N    ??cJSON_Compare_20
   \       0xF6   0x463A             MOV      R2,R7
   \       0xF8   0x6A21             LDR      R1,[R4, #+32]
   \       0xFA   0x4630             MOV      R0,R6
   \       0xFC   0x....'....        BL       get_object_item
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD1EE             BNE.N    ??cJSON_Compare_18
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0xBDF2             POP      {R1,R4-R7,PC}
   2263                              return false;
   \                     ??cJSON_Compare_19: (+1)
   \      0x108   0x2000             MOVS     R0,#+0
   \      0x10A   0xBDF2             POP      {R1,R4-R7,PC}
   2264                          }
   2265                      }
   2266          
   2267                      return true;
   2268                  }
   2269          
   2270                  default:
   2271                      return false;
   \                     ??cJSON_Compare_10: (+1)
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??cJSON_Compare_16: (+1)
   \      0x110   0x2001             MOVS     R0,#+1
   \      0x112   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??cJSON_Compare_20: (+1)
   \      0x114   0x2001             MOVS     R0,#+1
   \      0x116   0xBDF2             POP      {R1,R4-R7,PC}
   2272              }
   2273          }
   2274          

   \                                 In section .text, align 2, keep-with-next
   2275          CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
   2276          {
   2277              return global_hooks.allocate(size);
   \                     cJSON_malloc: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable31
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0x4708             BX       R1
   2278          }
   2279          

   \                                 In section .text, align 2, keep-with-next
   2280          CJSON_PUBLIC(void) cJSON_free(void *object)
   2281          {
   2282              global_hooks.deallocate(object);
   \                     cJSON_free: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable31
   \        0x2   0x6849             LDR      R1,[R1, #+4]
   \        0x4   0x4708             BX       R1
   2283          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0xFFC0'0000        DC32     0xFFC00000,0x41DFFFFF
   \              0x41DF'FFFF  

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0xFFFF'FFFF        DC32     0xFFFFFFFF,0xC1DFFFFF
   \              0xC1DF'FFFF  

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x0000'0000        DC32     0x0,0x0
   \              0x0000'0000  

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x25 0x6C          DC8      "%lg"
   \              0x67 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x22 0x22          DC8      0x22, 0x22, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     `cJSON_Version::version`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     global_error

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     global_hooks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x000F'FC00        DC32     0xffc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \        0x0   0xFFC0'0000        DC32     0xFFC00000,0x41DFFFFF
   \              0x41DF'FFFF  

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0xFFFF'FFFF        DC32     0xFFFFFFFF,0xC1DFFFFF
   \              0xC1DF'FFFF  

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x....'....        DC32     global_hooks

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x25 0x69          DC8 "%i.%i.%i"
   \              0x2E 0x25    
   \              0x69 0x2E    
   \              0x25 0x69    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x6E 0x75          DC8 "null"
   \              0x6C 0x6C    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x25 0x31          DC8 "%1.15g"
   \              0x2E 0x31    
   \              0x35 0x67    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \        0x0   0x25 0x6C          DC8 "%lg"
   \              0x67 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x25 0x31          DC8 "%1.17g"
   \              0x2E 0x31    
   \              0x37 0x67    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \        0x0   0x22 0x22          DC8 "\"\""
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x75 0x25          DC8 "u%04x"
   \              0x30 0x34    
   \              0x78 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x66 0x61          DC8 "false"
   \              0x6C 0x73    
   \              0x65 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x74 0x72          DC8 "true"
   \              0x75 0x65    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   buffer_skip_whitespace
       8   cJSON_AddItemReferenceToArray
         0   -> cJSON_AddItemToArray
         8   -> create_reference
      16   cJSON_AddItemReferenceToObject
         0   -> cJSON_AddItemToObject
        16   -> create_reference
       0   cJSON_AddItemToArray
         0   -> suffix_object
      16   cJSON_AddItemToObject
        16   -> cJSON_AddItemToObjectCS
        16   -> cJSON_strdup
      16   cJSON_AddItemToObjectCS
        16   -- Indirect call
         0   -> cJSON_AddItemToArray
      24   cJSON_Compare
        24   -> cJSON_Compare
        24   -> cJSON_IsInvalid
        24   -> get_object_item
        24   -> strcmp
       8   cJSON_CreateArray
         8   -> cJSON_New_Item
       8   cJSON_CreateBool
         8   -> cJSON_New_Item
      32   cJSON_CreateDoubleArray
        32   -> cJSON_CreateArray
        32   -> cJSON_CreateNumber
        32   -> cJSON_Delete
        32   -> suffix_object
       8   cJSON_CreateFalse
         8   -> cJSON_New_Item
      32   cJSON_CreateFloatArray
        32   -> cJSON_CreateArray
        32   -> cJSON_CreateNumber
        32   -> cJSON_Delete
        32   -> suffix_object
      32   cJSON_CreateIntArray
        32   -> cJSON_CreateArray
        32   -> cJSON_CreateNumber
        32   -> cJSON_Delete
        32   -> suffix_object
       8   cJSON_CreateNull
         8   -> cJSON_New_Item
      16   cJSON_CreateNumber
        16   -> cJSON_New_Item
       8   cJSON_CreateObject
         8   -> cJSON_New_Item
      16   cJSON_CreateRaw
        16   -> cJSON_Delete
        16   -> cJSON_New_Item
        16   -> cJSON_strdup
      16   cJSON_CreateString
        16   -> cJSON_Delete
        16   -> cJSON_New_Item
        16   -> cJSON_strdup
      32   cJSON_CreateStringArray
        32   -> cJSON_CreateArray
        32   -> cJSON_CreateString
        32   -> cJSON_Delete
        32   -> suffix_object
       8   cJSON_CreateTrue
         8   -> cJSON_New_Item
      16   cJSON_Delete
        16   -- Indirect call
        16   -> cJSON_Delete
       8   cJSON_DeleteItemFromArray
         0   -> cJSON_Delete
         8   -> cJSON_DetachItemFromArray
       8   cJSON_DeleteItemFromObject
         0   -> cJSON_Delete
         8   -> cJSON_DetachItemFromObject
       8   cJSON_DeleteItemFromObjectCaseSensitive
         0   -> cJSON_Delete
         8   -> cJSON_DetachItemFromObjectCaseSensitive
       8   cJSON_DetachItemFromArray
         0   -> cJSON_DetachItemViaPointer
         8   -> get_array_item
       8   cJSON_DetachItemFromObject
         0   -> cJSON_DetachItemViaPointer
         8   -> cJSON_GetObjectItem
       8   cJSON_DetachItemFromObjectCaseSensitive
         0   -> cJSON_DetachItemViaPointer
         8   -> cJSON_GetObjectItemCaseSensitive
       0   cJSON_DetachItemViaPointer
      24   cJSON_Duplicate
        24   -> cJSON_Delete
        24   -> cJSON_Duplicate
        24   -> cJSON_New_Item
        24   -> cJSON_strdup
       0   cJSON_GetArrayItem
         0   -> get_array_item
       0   cJSON_GetArraySize
       0   cJSON_GetErrorPtr
       0   cJSON_GetObjectItem
         0   -> get_object_item
       0   cJSON_GetObjectItemCaseSensitive
         0   -> get_object_item
       8   cJSON_HasObjectItem
         8   -> cJSON_GetObjectItem
      16   cJSON_InsertItemInArray
         0   -> cJSON_AddItemToArray
        16   -> get_array_item
       0   cJSON_IsArray
       0   cJSON_IsBool
       0   cJSON_IsFalse
       0   cJSON_IsInvalid
       0   cJSON_IsNull
       0   cJSON_IsNumber
       0   cJSON_IsObject
       0   cJSON_IsRaw
       0   cJSON_IsString
       0   cJSON_IsTrue
       0   cJSON_Minify
       8   cJSON_New_Item
         8   -- Indirect call
         8   -> __aeabi_memset4
       0   cJSON_Parse
         0   -> cJSON_ParseWithOpts
      56   cJSON_ParseWithOpts
        56   -> __aeabi_memclr4
        56   -> buffer_skip_whitespace
        56   -> cJSON_Delete
        56   -> cJSON_New_Item
        56   -> parse_value
        56   -> strlen
       0   cJSON_Print
         0   -> print
      56   cJSON_PrintBuffered
        56   -- Indirect call
        56   -> __aeabi_memclr4
        56   -> print_value
      56   cJSON_PrintPreallocated
        56   -> __aeabi_memclr4
        56   -> print_value
       0   cJSON_PrintUnformatted
         0   -> print
      16   cJSON_ReplaceItemInArray
         0   -> cJSON_ReplaceItemViaPointer
        16   -> get_array_item
       0   cJSON_ReplaceItemInObject
         0   -> replace_item_in_object
       0   cJSON_ReplaceItemInObjectCaseSensitive
         0   -> replace_item_in_object
       8   cJSON_ReplaceItemViaPointer
         8   -> cJSON_Delete
       0   cJSON_SetNumberHelper
      16   cJSON_Version
        16   -> sprintf
       0   cJSON_free
         0   -- Indirect call
       0   cJSON_malloc
         0   -- Indirect call
      16   cJSON_strdup
        16   -- Indirect call
        16   -> __aeabi_memcpy
        16   -> strlen
      16   case_insensitive_strcmp
        16   -> tolower
      16   create_reference
        16   -> __aeabi_memcpy4
        16   -> cJSON_New_Item
      16   ensure
        16   -- Indirect call
        16   -> __aeabi_memcpy
       0   get_array_item
       8   get_decimal_point
         8   -> localeconv
      16   get_object_item
        16   -> case_insensitive_strcmp
        16   -> strcmp
      24   parse_array
        24   -> buffer_skip_whitespace
        24   -> cJSON_Delete
        24   -> cJSON_New_Item
        24   -> parse_value
       0   parse_hex4
      80   parse_number
        80   -> get_decimal_point
        80   -> strtod
      24   parse_object
        24   -> buffer_skip_whitespace
        24   -> cJSON_Delete
        24   -> cJSON_New_Item
        24   -> parse_string
        24   -> parse_value
      32   parse_string
        32   -- Indirect call
        32   -> utf16_literal_to_utf8
      16   parse_value
         0   -> parse_array
         0   -> parse_number
         0   -> parse_object
         0   -> parse_string
        16   -> strncmp
      56   print
        56   -- Indirect call
        56   -> __aeabi_memcpy
        56   -> __aeabi_memset4
        56   -> print_value
        56   -> update_offset
      16   print_array
        16   -> ensure
        16   -> print_value
        16   -> update_offset
      72   print_number
        72   -> ensure
        72   -> get_decimal_point
        72   -> sprintf
        72   -> sscanf
      16   print_object
        16   -> ensure
        16   -> print_string_ptr
        16   -> print_value
        16   -> update_offset
       0   print_string
         0   -> print_string_ptr
      24   print_string_ptr
        24   -> __aeabi_memcpy
        24   -> ensure
        24   -> sprintf
      16   print_value
        16   -- Indirect call
        16   -> __aeabi_memcpy
        16   -> ensure
         0   -> print_array
         0   -> print_number
         0   -> print_object
         0   -> print_string
        16   -> strlen
      24   replace_item_in_object
        24   -> cJSON_ReplaceItemViaPointer
        24   -> cJSON_free
        24   -> cJSON_strdup
        24   -> get_object_item
       0   suffix_object
       8   update_offset
         8   -> strlen
      24   utf16_literal_to_utf8
        24   -> parse_hex4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable18
       4  ??DataTable28
       8  ??DataTable28_1
       4  ??DataTable28_2
       8  ??DataTable29
       4  ??DataTable31
       8  ??DataTable5
       8  ??DataTable5_1
       8  ??DataTable6
       4  ??DataTable6_1
      12  ?_0
       8  ?_1
      36  ?_10
      36  ?_11
       8  ?_2
       4  ?_3
       8  ?_4
       4  ?_5
       8  ?_6
       8  ?_7
       8  ?_8
      28  ?_9
      52  buffer_skip_whitespace
      24  cJSON_AddItemReferenceToArray
      28  cJSON_AddItemReferenceToObject
      32  cJSON_AddItemToArray
      36  cJSON_AddItemToObject
      52  cJSON_AddItemToObjectCS
     280  cJSON_Compare
      20  cJSON_CreateArray
      30  cJSON_CreateBool
      90  cJSON_CreateDoubleArray
      20  cJSON_CreateFalse
      94  cJSON_CreateFloatArray
      94  cJSON_CreateIntArray
      20  cJSON_CreateNull
      88  cJSON_CreateNumber
      20  cJSON_CreateObject
      50  cJSON_CreateRaw
      50  cJSON_CreateString
      86  cJSON_CreateStringArray
      20  cJSON_CreateTrue
      80  cJSON_Delete
      14  cJSON_DeleteItemFromArray
      14  cJSON_DeleteItemFromObject
      14  cJSON_DeleteItemFromObjectCaseSensitive
      26  cJSON_DetachItemFromArray
      18  cJSON_DetachItemFromObject
      18  cJSON_DetachItemFromObjectCaseSensitive
      56  cJSON_DetachItemViaPointer
     160  cJSON_Duplicate
      10  cJSON_GetArrayItem
      16  cJSON_GetArraySize
      12  cJSON_GetErrorPtr
       4  cJSON_GetObjectItem
       4  cJSON_GetObjectItemCaseSensitive
      18  cJSON_HasObjectItem
      52  cJSON_InsertItemInArray
      22  cJSON_IsArray
      24  cJSON_IsBool
      22  cJSON_IsFalse
      18  cJSON_IsInvalid
      22  cJSON_IsNull
      22  cJSON_IsNumber
      22  cJSON_IsObject
      22  cJSON_IsRaw
      22  cJSON_IsString
      22  cJSON_IsTrue
     156  cJSON_Minify
      26  cJSON_New_Item
       6  cJSON_Parse
     204  cJSON_ParseWithOpts
       6  cJSON_Print
      86  cJSON_PrintBuffered
      66  cJSON_PrintPreallocated
       6  cJSON_PrintUnformatted
      30  cJSON_ReplaceItemInArray
       4  cJSON_ReplaceItemInObject
       4  cJSON_ReplaceItemInObjectCaseSensitive
      72  cJSON_ReplaceItemViaPointer
      58  cJSON_SetNumberHelper
      28  cJSON_Version
       6  cJSON_free
       6  cJSON_malloc
      48  cJSON_strdup
      74  case_insensitive_strcmp
      48  create_reference
     156  ensure
      26  get_array_item
      12  get_decimal_point
      64  get_object_item
       8  global_error
      12  global_hooks
     226  parse_array
      68  parse_hex4
     208  parse_number
     298  parse_object
     368  parse_string
     280  parse_value
     162  print
     170  print_array
     186  print_number
     332  print_object
       4  print_string
     284  print_string_ptr
     240  print_value
      86  replace_item_in_object
       6  suffix_object
      28  update_offset
     230  utf16_literal_to_utf8
      16  version

 
    24 bytes in section .bss
    12 bytes in section .data
   168 bytes in section .rodata
 6 384 bytes in section .text
 
 6 384 bytes of CODE  memory
   168 bytes of CONST memory
    36 bytes of DATA  memory

Errors: none
Warnings: 1
