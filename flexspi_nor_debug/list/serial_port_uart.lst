###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:46
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\component\serial_manager\serial_port_uart.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW4339.tmp
#        (C:\Development\smart_washing_machine_3080\component\serial_manager\serial_port_uart.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\serial_port_uart.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\serial_port_uart.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\component\serial_manager\serial_port_uart.c
      1          /*
      2           * Copyright 2018 NXP
      3           * All rights reserved.
      4           *
      5           *
      6           * SPDX-License-Identifier: BSD-3-Clause
      7           */
      8          
      9          #include "fsl_common.h"
     10          #include "serial_manager.h"
     11          #include "serial_port_internal.h"
     12          
     13          #if (defined(SERIAL_PORT_TYPE_UART) && (SERIAL_PORT_TYPE_UART > 0U))
     14          #include "uart.h"
     15          
     16          #include "serial_port_uart.h"
     17          
     18          /*******************************************************************************
     19           * Definitions
     20           ******************************************************************************/
     21          #ifndef NDEBUG
     22          #if (defined(DEBUG_CONSOLE_ASSERT_DISABLE) && (DEBUG_CONSOLE_ASSERT_DISABLE > 0U))
     23          #undef assert
     24          #define assert(n)
     25          #endif
     26          #endif
     27          
     28          #if (defined(SERIAL_MANAGER_NON_BLOCKING_MODE) && (SERIAL_MANAGER_NON_BLOCKING_MODE > 0U))
     29          #define SERIAL_PORT_UART_RECEIVE_DATA_LENGTH 1U
     30          
     31          typedef struct _serial_uart_send_state
     32          {
     33              serial_manager_callback_t callback;
     34              void *callbackParam;
     35              uint8_t *buffer;
     36              uint32_t length;
     37              volatile uint8_t busy;
     38          } serial_uart_send_state_t;
     39          
     40          typedef struct _serial_uart_recv_state
     41          {
     42              serial_manager_callback_t callback;
     43              void *callbackParam;
     44              volatile uint8_t busy;
     45              uint8_t readBuffer[SERIAL_PORT_UART_RECEIVE_DATA_LENGTH];
     46          } serial_uart_recv_state_t;
     47          #endif
     48          
     49          typedef struct _serial_uart_state
     50          {
     51          #if (defined(SERIAL_MANAGER_NON_BLOCKING_MODE) && (SERIAL_MANAGER_NON_BLOCKING_MODE > 0U))
     52              serial_uart_send_state_t tx;
     53              serial_uart_recv_state_t rx;
     54          #endif
     55              uint8_t usartHandleBuffer[HAL_UART_HANDLE_SIZE];
     56          } serial_uart_state_t;
     57          
     58          /*******************************************************************************
     59           * Prototypes
     60           ******************************************************************************/
     61          
     62          /*******************************************************************************
     63           * Code
     64           ******************************************************************************/
     65          
     66          #if (defined(SERIAL_MANAGER_NON_BLOCKING_MODE) && (SERIAL_MANAGER_NON_BLOCKING_MODE > 0U))
     67          /* UART user callback */
     68          static void Serial_UartCallback(hal_uart_handle_t handle, hal_uart_status_t status, void *userData)
     69          {
     70              serial_uart_state_t *serialUartHandle;
     71              serial_manager_callback_message_t msg;
     72          #if (defined(HAL_UART_TRANSFER_MODE) && (HAL_UART_TRANSFER_MODE > 0U))
     73              hal_uart_transfer_t transfer;
     74          #endif
     75          
     76              if (NULL == userData)
     77              {
     78                  return;
     79              }
     80          
     81              serialUartHandle = (serial_uart_state_t *)userData;
     82          
     83              if ((hal_uart_status_t)kStatus_HAL_UartRxIdle == status)
     84              {
     85                  if ((NULL != serialUartHandle->rx.callback))
     86                  {
     87                      msg.buffer = &serialUartHandle->rx.readBuffer[0];
     88                      msg.length = sizeof(serialUartHandle->rx.readBuffer);
     89                      serialUartHandle->rx.callback(serialUartHandle->rx.callbackParam, &msg, kStatus_SerialManager_Success);
     90                  }
     91          #if (defined(HAL_UART_TRANSFER_MODE) && (HAL_UART_TRANSFER_MODE > 0U))
     92                  transfer.data     = &serialUartHandle->rx.readBuffer[0];
     93                  transfer.dataSize = sizeof(serialUartHandle->rx.readBuffer);
     94                  if (kStatus_HAL_UartSuccess ==
     95                      HAL_UartTransferReceiveNonBlocking(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]), &transfer))
     96          #else
     97                  if ((hal_uart_status_t)kStatus_HAL_UartSuccess ==
     98                      HAL_UartReceiveNonBlocking(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]),
     99                                                 &serialUartHandle->rx.readBuffer[0], sizeof(serialUartHandle->rx.readBuffer)))
    100          #endif
    101                  {
    102                      serialUartHandle->rx.busy = 1U;
    103                  }
    104                  else
    105                  {
    106                      serialUartHandle->rx.busy = 0U;
    107                  }
    108              }
    109              else if ((hal_uart_status_t)kStatus_HAL_UartTxIdle == status)
    110              {
    111                  if (serialUartHandle->tx.busy != 0U)
    112                  {
    113                      serialUartHandle->tx.busy = 0U;
    114                      if ((NULL != serialUartHandle->tx.callback))
    115                      {
    116                          msg.buffer = serialUartHandle->tx.buffer;
    117                          msg.length = serialUartHandle->tx.length;
    118                          serialUartHandle->tx.callback(serialUartHandle->tx.callbackParam, &msg, kStatus_SerialManager_Success);
    119                      }
    120                  }
    121              }
    122              else
    123              {
    124              }
    125          }
    126          #endif
    127          

   \                                 In section .text, align 2, keep-with-next
    128          serial_manager_status_t Serial_UartInit(serial_handle_t serialHandle, void *serialConfig)
    129          {
   \                     Serial_UartInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    130              serial_uart_state_t *serialUartHandle;
    131              serial_port_uart_config_t *uartConfig;
    132              hal_uart_config_t config;
    133          #if (defined(SERIAL_MANAGER_NON_BLOCKING_MODE) && (SERIAL_MANAGER_NON_BLOCKING_MODE > 0U))
    134          #if (defined(HAL_UART_TRANSFER_MODE) && (HAL_UART_TRANSFER_MODE > 0U))
    135              hal_uart_transfer_t transfer;
    136          #endif
    137          #endif
    138          
    139              assert(serialConfig);
   \        0x8   0xD106             BNE.N    ??Serial_UartInit_0
   \        0xA   0x228B             MOVS     R2,#+139
   \        0xC   0x....             LDR.N    R1,??DataTable3
   \        0xE   0x....             LDR.N    R0,??DataTable3_1
   \       0x10   0x....'....        BL       __aeabi_assert
   \       0x14   0x....'....        BL       __iar_EmptyStepPoint
    140              assert(serialHandle);
   \                     ??Serial_UartInit_0: (+1)
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD106             BNE.N    ??Serial_UartInit_1
   \       0x1C   0x228C             MOVS     R2,#+140
   \       0x1E   0x....             LDR.N    R1,??DataTable3
   \       0x20   0x....             LDR.N    R0,??DataTable3_2
   \       0x22   0x....'....        BL       __aeabi_assert
   \       0x26   0x....'....        BL       __iar_EmptyStepPoint
    141              assert(SERIAL_PORT_UART_HANDLE_SIZE >= sizeof(serial_uart_state_t));
    142          
    143              uartConfig       = (serial_port_uart_config_t *)serialConfig;
    144              serialUartHandle = (serial_uart_state_t *)serialHandle;
    145          
    146              config.baudRate_Bps = uartConfig->baudRate;
   \                     ??Serial_UartInit_1: (+1)
   \       0x2A   0x6868             LDR      R0,[R5, #+4]
   \       0x2C   0x9001             STR      R0,[SP, #+4]
    147              config.parityMode   = (hal_uart_parity_mode_t)uartConfig->parityMode;
   \       0x2E   0x7A28             LDRB     R0,[R5, #+8]
   \       0x30   0xF88D 0x0008      STRB     R0,[SP, #+8]
    148              config.stopBitCount = (hal_uart_stop_bit_count_t)uartConfig->stopBitCount;
   \       0x34   0x7A68             LDRB     R0,[R5, #+9]
   \       0x36   0xF88D 0x0009      STRB     R0,[SP, #+9]
    149              config.enableRx     = uartConfig->enableRx;
   \       0x3A   0x7AE8             LDRB     R0,[R5, #+11]
   \       0x3C   0xF88D 0x000A      STRB     R0,[SP, #+10]
    150              config.enableTx     = uartConfig->enableTx;
   \       0x40   0x7B28             LDRB     R0,[R5, #+12]
   \       0x42   0xF88D 0x000B      STRB     R0,[SP, #+11]
    151              config.srcClock_Hz  = uartConfig->clockRate;
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x9000             STR      R0,[SP, #+0]
    152              config.instance     = uartConfig->instance;
   \       0x4A   0x7AA8             LDRB     R0,[R5, #+10]
   \       0x4C   0xF88D 0x000C      STRB     R0,[SP, #+12]
    153          
    154              if (kStatus_HAL_UartSuccess != HAL_UartInit(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]), &config))
   \       0x50   0x4669             MOV      R1,SP
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x....'....        BL       HAL_UartInit
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD002             BEQ.N    ??Serial_UartInit_2
    155              {
    156                  return kStatus_SerialManager_Error;
   \       0x5C   0xF243 0x5021      MOVW     R0,#+13601
   \       0x60   0xE000             B.N      ??Serial_UartInit_3
    157              }
    158          
    159          #if (defined(SERIAL_MANAGER_NON_BLOCKING_MODE) && (SERIAL_MANAGER_NON_BLOCKING_MODE > 0U))
    160          
    161          #if (defined(HAL_UART_TRANSFER_MODE) && (HAL_UART_TRANSFER_MODE > 0U))
    162              if (kStatus_HAL_UartSuccess !=
    163                  HAL_UartTransferInstallCallback(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]),
    164                                                  Serial_UartCallback, serialUartHandle))
    165          #else
    166              if (kStatus_HAL_UartSuccess != HAL_UartInstallCallback(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]),
    167                                                                     Serial_UartCallback, serialUartHandle))
    168          #endif
    169              {
    170                  return kStatus_SerialManager_Error;
    171              }
    172          
    173              if (uartConfig->enableRx != 0U)
    174              {
    175                  serialUartHandle->rx.busy = 1U;
    176          #if (defined(HAL_UART_TRANSFER_MODE) && (HAL_UART_TRANSFER_MODE > 0U))
    177                  transfer.data     = &serialUartHandle->rx.readBuffer[0];
    178                  transfer.dataSize = sizeof(serialUartHandle->rx.readBuffer);
    179                  if (kStatus_HAL_UartSuccess !=
    180                      HAL_UartTransferReceiveNonBlocking(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]), &transfer))
    181          #else
    182                  if (kStatus_HAL_UartSuccess !=
    183                      HAL_UartReceiveNonBlocking(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]),
    184                                                 &serialUartHandle->rx.readBuffer[0], sizeof(serialUartHandle->rx.readBuffer)))
    185          #endif
    186                  {
    187                      serialUartHandle->rx.busy = 0U;
    188                      return kStatus_SerialManager_Error;
    189                  }
    190              }
    191          #endif
    192          
    193              return kStatus_SerialManager_Success;
   \                     ??Serial_UartInit_2: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \                     ??Serial_UartInit_3: (+1)
   \       0x64   0xB005             ADD      SP,SP,#+20
   \       0x66   0xBD30             POP      {R4,R5,PC}       ;; return
    194          }
    195          

   \                                 In section .text, align 2, keep-with-next
    196          serial_manager_status_t Serial_UartDeinit(serial_handle_t serialHandle)
    197          {
   \                     Serial_UartDeinit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    198              serial_uart_state_t *serialUartHandle;
    199          
    200              assert(serialHandle);
   \        0x4   0xD106             BNE.N    ??Serial_UartDeinit_0
   \        0x6   0x22C8             MOVS     R2,#+200
   \        0x8   0x....             LDR.N    R1,??DataTable3
   \        0xA   0x....             LDR.N    R0,??DataTable3_2
   \        0xC   0x....'....        BL       __aeabi_assert
   \       0x10   0x....'....        BL       __iar_EmptyStepPoint
    201          
    202              serialUartHandle = (serial_uart_state_t *)serialHandle;
    203          
    204          #if (defined(SERIAL_MANAGER_NON_BLOCKING_MODE) && (SERIAL_MANAGER_NON_BLOCKING_MODE > 0U))
    205          #if (defined(HAL_UART_TRANSFER_MODE) && (HAL_UART_TRANSFER_MODE > 0U))
    206              (void)HAL_UartTransferAbortReceive(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]));
    207          #else
    208              (void)HAL_UartAbortReceive(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]));
    209          #endif
    210          #endif
    211              (void)HAL_UartDeinit(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]));
   \                     ??Serial_UartDeinit_0: (+1)
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       HAL_UartDeinit
    212          
    213          #if (defined(SERIAL_MANAGER_NON_BLOCKING_MODE) && (SERIAL_MANAGER_NON_BLOCKING_MODE > 0U))
    214              serialUartHandle->tx.busy = 0U;
    215              serialUartHandle->rx.busy = 0U;
    216          #endif
    217          
    218              return kStatus_SerialManager_Success;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
    219          }
    220          
    221          #if (defined(SERIAL_MANAGER_NON_BLOCKING_MODE) && (SERIAL_MANAGER_NON_BLOCKING_MODE > 0U))
    222          
    223          serial_manager_status_t Serial_UartWrite(serial_handle_t serialHandle, uint8_t *buffer, uint32_t length)
    224          {
    225              serial_uart_state_t *serialUartHandle;
    226          #if (defined(HAL_UART_TRANSFER_MODE) && (HAL_UART_TRANSFER_MODE > 0U))
    227              hal_uart_transfer_t transfer;
    228          #endif
    229          
    230              assert(serialHandle);
    231              assert(buffer);
    232              assert(length);
    233          
    234              serialUartHandle = (serial_uart_state_t *)serialHandle;
    235          
    236              if (serialUartHandle->tx.busy != 0U)
    237              {
    238                  return kStatus_SerialManager_Busy;
    239              }
    240              serialUartHandle->tx.busy = 1U;
    241          
    242              serialUartHandle->tx.buffer = buffer;
    243              serialUartHandle->tx.length = length;
    244          
    245          #if (defined(HAL_UART_TRANSFER_MODE) && (HAL_UART_TRANSFER_MODE > 0U))
    246              transfer.data     = buffer;
    247              transfer.dataSize = length;
    248              if (kStatus_HAL_UartSuccess !=
    249                  HAL_UartTransferSendNonBlocking(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]), &transfer))
    250          #else
    251              if (kStatus_HAL_UartSuccess !=
    252                  HAL_UartSendNonBlocking(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]), buffer, length))
    253          #endif
    254              {
    255                  serialUartHandle->tx.busy = 0U;
    256                  return kStatus_SerialManager_Error;
    257              }
    258              return kStatus_SerialManager_Success;
    259          }
    260          
    261          #else
    262          

   \                                 In section .text, align 2, keep-with-next
    263          serial_manager_status_t Serial_UartWrite(serial_handle_t serialHandle, uint8_t *buffer, uint32_t length)
    264          {
   \                     Serial_UartWrite: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4614             MOV      R4,R2
    265              serial_uart_state_t *serialUartHandle;
    266          
    267              assert(serialHandle);
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD107             BNE.N    ??Serial_UartWrite_0
   \        0xC   0xF240 0x120B      MOVW     R2,#+267
   \       0x10   0x....             LDR.N    R1,??DataTable3
   \       0x12   0x....             LDR.N    R0,??DataTable3_2
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
    268              assert(buffer);
   \                     ??Serial_UartWrite_0: (+1)
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD107             BNE.N    ??Serial_UartWrite_1
   \       0x20   0xF44F 0x7286      MOV      R2,#+268
   \       0x24   0x....             LDR.N    R1,??DataTable3
   \       0x26   0x....             LDR.N    R0,??DataTable3_3
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
    269              assert(length);
   \                     ??Serial_UartWrite_1: (+1)
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD107             BNE.N    ??Serial_UartWrite_2
   \       0x34   0xF240 0x120D      MOVW     R2,#+269
   \       0x38   0x....             LDR.N    R1,??DataTable3
   \       0x3A   0x....             LDR.N    R0,??DataTable3_4
   \       0x3C   0x....'....        BL       __aeabi_assert
   \       0x40   0x....'....        BL       __iar_EmptyStepPoint
    270          
    271              serialUartHandle = (serial_uart_state_t *)serialHandle;
    272          
    273              return (serial_manager_status_t)HAL_UartSendBlocking(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]),
    274                                                                   buffer, length);
   \                     ??Serial_UartWrite_2: (+1)
   \       0x44   0x4622             MOV      R2,R4
   \       0x46   0x4629             MOV      R1,R5
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x4E   0x....'....        B.W      HAL_UartSendBlocking
    275          }
    276          

   \                                 In section .text, align 2, keep-with-next
    277          serial_manager_status_t Serial_UartRead(serial_handle_t serialHandle, uint8_t *buffer, uint32_t length)
    278          {
   \                     Serial_UartRead: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4614             MOV      R4,R2
    279              serial_uart_state_t *serialUartHandle;
    280          
    281              assert(serialHandle);
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD107             BNE.N    ??Serial_UartRead_0
   \        0xC   0xF240 0x1219      MOVW     R2,#+281
   \       0x10   0x....             LDR.N    R1,??DataTable3
   \       0x12   0x....             LDR.N    R0,??DataTable3_2
   \       0x14   0x....'....        BL       __aeabi_assert
   \       0x18   0x....'....        BL       __iar_EmptyStepPoint
    282              assert(buffer);
   \                     ??Serial_UartRead_0: (+1)
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD107             BNE.N    ??Serial_UartRead_1
   \       0x20   0xF44F 0x728D      MOV      R2,#+282
   \       0x24   0x....             LDR.N    R1,??DataTable3
   \       0x26   0x....             LDR.N    R0,??DataTable3_3
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
    283              assert(length);
   \                     ??Serial_UartRead_1: (+1)
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD107             BNE.N    ??Serial_UartRead_2
   \       0x34   0xF240 0x121B      MOVW     R2,#+283
   \       0x38   0x....             LDR.N    R1,??DataTable3
   \       0x3A   0x....             LDR.N    R0,??DataTable3_4
   \       0x3C   0x....'....        BL       __aeabi_assert
   \       0x40   0x....'....        BL       __iar_EmptyStepPoint
    284          
    285              serialUartHandle = (serial_uart_state_t *)serialHandle;
    286          
    287              return (serial_manager_status_t)HAL_UartReceiveBlocking(
    288                  ((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]), buffer, length);
   \                     ??Serial_UartRead_2: (+1)
   \       0x44   0x4622             MOV      R2,R4
   \       0x46   0x4629             MOV      R1,R5
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x4E   0x....'....        B.W      HAL_UartReceiveBlocking
    289          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x73 0x65          DC8 "serialConfig"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 43H, 3AH, 5CH, 44H, 65H, 76H, 65H, 6CH
   \              0x5C 0x44    
   \              0x65 0x76    
   \              0x65 0x6C    
   \        0x8   0x6F 0x70          DC8 6FH, 70H, 6DH, 65H, 6EH, 74H, 5CH, 73H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73    
   \       0x10   0x6D 0x61          DC8 6DH, 61H, 72H, 74H, 5FH, 77H, 61H, 73H
   \              0x72 0x74    
   \              0x5F 0x77    
   \              0x61 0x73    
   \       0x18   0x68 0x69          DC8 68H, 69H, 6EH, 67H, 5FH, 6DH, 61H, 63H
   \              0x6E 0x67    
   \              0x5F 0x6D    
   \              0x61 0x63    
   \       0x20   0x68 0x69          DC8 68H, 69H, 6EH, 65H, 5FH, 33H, 30H, 38H
   \              0x6E 0x65    
   \              0x5F 0x33    
   \              0x30 0x38    
   \       0x28   0x30 0x5C          DC8 30H, 5CH, 63H, 6FH, 6DH, 70H, 6FH, 6EH
   \              0x63 0x6F    
   \              0x6D 0x70    
   \              0x6F 0x6E    
   \       0x30   0x65 0x6E          DC8 65H, 6EH, 74H, 5CH, 73H, 65H, 72H, 69H
   \              0x74 0x5C    
   \              0x73 0x65    
   \              0x72 0x69    
   \       0x38   0x61 0x6C          DC8 61H, 6CH, 5FH, 6DH, 61H, 6EH, 61H, 67H
   \              0x5F 0x6D    
   \              0x61 0x6E    
   \              0x61 0x67    
   \       0x40   0x65 0x72          DC8 65H, 72H, 5CH, 73H, 65H, 72H, 69H, 61H
   \              0x5C 0x73    
   \              0x65 0x72    
   \              0x69 0x61    
   \       0x48   0x6C 0x5F          DC8 6CH, 5FH, 70H, 6FH, 72H, 74H, 5FH, 75H
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x5F 0x75    
   \       0x50   0x61 0x72          DC8 61H, 72H, 74H, 2EH, 63H, 0
   \              0x74 0x2E    
   \              0x63 0x00    
   \       0x56   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x73 0x65          DC8 "serialHandle"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x48 0x61    
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x62 0x75          DC8 "buffer"
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x6C 0x65          DC8 "length"
   \              0x6E 0x67    
   \              0x74 0x68    
   \              0x00         
   \        0x7   0x00               DC8 0
    290          
    291          #endif
    292          
    293          #if (defined(SERIAL_MANAGER_NON_BLOCKING_MODE) && (SERIAL_MANAGER_NON_BLOCKING_MODE > 0U))
    294          serial_manager_status_t Serial_UartCancelWrite(serial_handle_t serialHandle)
    295          {
    296              serial_uart_state_t *serialUartHandle;
    297              serial_manager_callback_message_t msg;
    298              uint32_t primask;
    299              uint8_t isBusy = 0U;
    300          
    301              assert(serialHandle);
    302          
    303              serialUartHandle = (serial_uart_state_t *)serialHandle;
    304          
    305              primask                   = DisableGlobalIRQ();
    306              isBusy                    = serialUartHandle->tx.busy;
    307              serialUartHandle->tx.busy = 0U;
    308              EnableGlobalIRQ(primask);
    309          
    310          #if (defined(HAL_UART_TRANSFER_MODE) && (HAL_UART_TRANSFER_MODE > 0U))
    311              (void)HAL_UartTransferAbortSend(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]));
    312          #else
    313              (void)HAL_UartAbortSend(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]));
    314          #endif
    315              if (isBusy != 0U)
    316              {
    317                  if ((NULL != serialUartHandle->tx.callback))
    318                  {
    319                      msg.buffer = serialUartHandle->tx.buffer;
    320                      msg.length = serialUartHandle->tx.length;
    321                      serialUartHandle->tx.callback(serialUartHandle->tx.callbackParam, &msg, kStatus_SerialManager_Canceled);
    322                  }
    323              }
    324              return kStatus_SerialManager_Success;
    325          }
    326          
    327          serial_manager_status_t Serial_UartInstallTxCallback(serial_handle_t serialHandle,
    328                                                               serial_manager_callback_t callback,
    329                                                               void *callbackParam)
    330          {
    331              serial_uart_state_t *serialUartHandle;
    332          
    333              assert(serialHandle);
    334          
    335              serialUartHandle = (serial_uart_state_t *)serialHandle;
    336          
    337              serialUartHandle->tx.callback      = callback;
    338              serialUartHandle->tx.callbackParam = callbackParam;
    339          
    340              return kStatus_SerialManager_Success;
    341          }
    342          
    343          serial_manager_status_t Serial_UartInstallRxCallback(serial_handle_t serialHandle,
    344                                                               serial_manager_callback_t callback,
    345                                                               void *callbackParam)
    346          {
    347              serial_uart_state_t *serialUartHandle;
    348          
    349              assert(serialHandle);
    350          
    351              serialUartHandle = (serial_uart_state_t *)serialHandle;
    352          
    353              serialUartHandle->rx.callback      = callback;
    354              serialUartHandle->rx.callbackParam = callbackParam;
    355          
    356              return kStatus_SerialManager_Success;
    357          }
    358          
    359          void Serial_UartIsrFunction(serial_handle_t serialHandle)
    360          {
    361              serial_uart_state_t *serialUartHandle;
    362          
    363              assert(serialHandle);
    364          
    365              serialUartHandle = (serial_uart_state_t *)serialHandle;
    366          
    367              HAL_UartIsrFunction(((hal_uart_handle_t)&serialUartHandle->usartHandleBuffer[0]));
    368          }
    369          #endif
    370          
    371          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Serial_UartDeinit
         8   -> HAL_UartDeinit
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      32   Serial_UartInit
        32   -> HAL_UartInit
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
      16   Serial_UartRead
         0   -> HAL_UartReceiveBlocking
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   Serial_UartWrite
         0   -> HAL_UartSendBlocking
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
      16  ?_0
      88  ?_1
      16  ?_2
       8  ?_3
       8  ?_4
      30  Serial_UartDeinit
     104  Serial_UartInit
      82  Serial_UartRead
      82  Serial_UartWrite

 
 136 bytes in section .rodata
 318 bytes in section .text
 
 318 bytes of CODE  memory
 136 bytes of CONST memory

Errors: none
Warnings: none
