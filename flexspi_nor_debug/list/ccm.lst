###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:03
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\mbedtls\library\ccm.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EW9C5F.tmp
#        (C:\Development\smart_washing_machine_3080\mbedtls\library\ccm.c -D
#        DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1
#        -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE
#        -D "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\ccm.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\ccm.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\mbedtls\library\ccm.c
      1          /*
      2           *  NIST SP800-38C compliant CCM implementation
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          /*
     23           * Definition of CCM:
     24           * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf
     25           * RFC 3610 "Counter with CBC-MAC (CCM)"
     26           *
     27           * Related:
     28           * RFC 5116 "An Interface and Algorithms for Authenticated Encryption"
     29           */
     30          
     31          #if !defined(MBEDTLS_CONFIG_FILE)
     32          #include "mbedtls/config.h"
     33          #else
     34          #include MBEDTLS_CONFIG_FILE
     35          #endif
     36          
     37          #if defined(MBEDTLS_CCM_C)
     38          
     39          #include "mbedtls/ccm.h"
     40          #include "mbedtls/platform_util.h"
     41          
     42          #include <string.h>
     43          
     44          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
     45          #if defined(MBEDTLS_PLATFORM_C)
     46          #include "mbedtls/platform.h"
     47          #else
     48          #include <stdio.h>
     49          #define mbedtls_printf printf
     50          #endif /* MBEDTLS_PLATFORM_C */
     51          #endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
     52          
     53          #if !defined(MBEDTLS_CCM_ALT)
     54          
     55          #define CCM_ENCRYPT 0
     56          #define CCM_DECRYPT 1
     57          
     58          /*
     59           * Initialize context
     60           */

   \                                 In section .text, align 2, keep-with-next
     61          void mbedtls_ccm_init( mbedtls_ccm_context *ctx )
     62          {
     63              memset( ctx, 0, sizeof( mbedtls_ccm_context ) );
   \                     mbedtls_ccm_init: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x2140             MOVS     R1,#+64
   \        0x4   0x....'....        B.W      __aeabi_memset4
     64          }
     65          

   \                                 In section .text, align 2, keep-with-next
     66          int mbedtls_ccm_setkey( mbedtls_ccm_context *ctx,
     67                                  mbedtls_cipher_id_t cipher,
     68                                  const unsigned char *key,
     69                                  unsigned int keybits )
     70          {
   \                     mbedtls_ccm_setkey: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
     71              int ret;
     72              const mbedtls_cipher_info_t *cipher_info;
     73          
     74              cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x4639             MOV      R1,R7
   \        0xE   0x....'....        BL       mbedtls_cipher_info_from_values
   \       0x12   0x0004             MOVS     R4,R0
     75              if( cipher_info == NULL )
   \       0x14   0xD002             BEQ.N    ??mbedtls_ccm_setkey_0
     76                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
     77          
     78              if( cipher_info->block_size != 16 )
   \       0x16   0x6960             LDR      R0,[R4, #+20]
   \       0x18   0x2810             CMP      R0,#+16
   \       0x1A   0xD002             BEQ.N    ??mbedtls_ccm_setkey_1
     79                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
   \                     ??mbedtls_ccm_setkey_0: (+1)
   \       0x1C   0xF06F 0x000C      MVN      R0,#+12
   \       0x20   0xBDF2             POP      {R1,R4-R7,PC}
     80          
     81              mbedtls_cipher_free( &ctx->cipher_ctx );
   \                     ??mbedtls_ccm_setkey_1: (+1)
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0x....'....        BL       mbedtls_cipher_free
     82          
     83              if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )
   \       0x28   0x4621             MOV      R1,R4
   \       0x2A   0x4628             MOV      R0,R5
   \       0x2C   0x....'....        BL       mbedtls_cipher_setup
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD108             BNE.N    ??mbedtls_ccm_setkey_2
     84                  return( ret );
     85          
     86              if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,
     87                                         MBEDTLS_ENCRYPT ) ) != 0 )
   \       0x34   0x2301             MOVS     R3,#+1
   \       0x36   0x463A             MOV      R2,R7
   \       0x38   0x4631             MOV      R1,R6
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0x....'....        BL       mbedtls_cipher_setkey
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD100             BNE.N    ??mbedtls_ccm_setkey_2
     88              {
     89                  return( ret );
     90              }
     91          
     92              return( 0 );
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_setkey_2: (+1)
   \       0x46   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     93          }
     94          
     95          /*
     96           * Free context
     97           */

   \                                 In section .text, align 2, keep-with-next
     98          void mbedtls_ccm_free( mbedtls_ccm_context *ctx )
     99          {
   \                     mbedtls_ccm_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    100              mbedtls_cipher_free( &ctx->cipher_ctx );
   \        0x4   0x....'....        BL       mbedtls_cipher_free
    101              mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ccm_context ) );
   \        0x8   0x2140             MOVS     R1,#+64
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0xE8BD 0x4010      POP      {R4,LR}
   \       0x10   0x....'....        B.W      mbedtls_platform_zeroize
    102          }
    103          
    104          /*
    105           * Macros for common operations.
    106           * Results in smaller compiled code than static inline functions.
    107           */
    108          
    109          /*
    110           * Update the CBC-MAC state in y using a block in b
    111           * (Always using b as the source helps the compiler optimise a bit better.)
    112           */
    113          #define UPDATE_CBC_MAC                                                      \
    114              for( i = 0; i < 16; i++ )                                               \
    115                  y[i] ^= b[i];                                                       \
    116                                                                                      \
    117              if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, y, 16, y, &olen ) ) != 0 ) \
    118                  return( ret );
    119          
    120          /*
    121           * Encrypt or decrypt a partial block with CTR
    122           * Warning: using b for temporary storage! src and dst must not be b!
    123           * This avoids allocating one more 16 bytes buffer while allowing src == dst.
    124           */
    125          #define CTR_CRYPT( dst, src, len  )                                            \
    126              if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctr, 16, b, &olen ) ) != 0 )  \
    127                  return( ret );                                                         \
    128                                                                                         \
    129              for( i = 0; i < len; i++ )                                                 \
    130                  dst[i] = src[i] ^ b[i];
    131          
    132          /*
    133           * Authenticated encryption or decryption
    134           */
    135          #if !defined(MBEDTLS_CCM_CRYPT_ALT)
    136          /* CCM selftest fails on ARM Cortex M with IAR 8.11 with common subexpression elimination optimalization enabled */
    137          #if defined(__ICCARM__)
    138          #pragma optimize=no_cse
    139          #endif

   \                                 In section .text, align 2, keep-with-next
    140          static int ccm_auth_crypt( mbedtls_ccm_context *ctx, int mode, size_t length,
    141                                     const unsigned char *iv, size_t iv_len,
    142                                     const unsigned char *add, size_t add_len,
    143                                     const unsigned char *input, unsigned char *output,
    144                                     unsigned char *tag, size_t tag_len )
    145          {
   \                     ccm_auth_crypt: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB090             SUB      SP,SP,#+64
   \        0x6   0x4607             MOV      R7,R0
   \        0x8   0x4688             MOV      R8,R1
    146              int ret;
    147              unsigned char i;
    148              unsigned char q;
    149              size_t len_left, olen;
    150              unsigned char b[16];
    151              unsigned char y[16];
    152              unsigned char ctr[16];
    153              const unsigned char *src;
    154              unsigned char *dst;
    155          
    156              /*
    157               * Check length requirements: SP800-38C A.1
    158               * Additional requirement: a < 2^16 - 2^8 to simplify the code.
    159               * 'length' checked later (when writing it to the first block)
    160               *
    161               * Also, loosen the requirements to enable support for CCM* (IEEE 802.15.4).
    162               */
    163              if( tag_len == 2 || tag_len > 16 || tag_len % 2 != 0 )
   \        0xA   0x9820             LDR      R0,[SP, #+128]
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD03B             BEQ.N    ??ccm_auth_crypt_0
   \       0x10   0x9820             LDR      R0,[SP, #+128]
   \       0x12   0x2811             CMP      R0,#+17
   \       0x14   0xD238             BCS.N    ??ccm_auth_crypt_0
   \       0x16   0x07C0             LSLS     R0,R0,#+31
   \       0x18   0xD436             BMI.N    ??ccm_auth_crypt_0
   \       0x1A   0x9D1A             LDR      R5,[SP, #+104]
    164                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
    165          
    166              /* Also implies q is within bounds */
    167              if( iv_len < 7 || iv_len > 13 )
   \       0x1C   0x1FE8             SUBS     R0,R5,#+7
   \       0x1E   0x2807             CMP      R0,#+7
   \       0x20   0xD232             BCS.N    ??ccm_auth_crypt_0
   \       0x22   0x9C1C             LDR      R4,[SP, #+112]
    168                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
    169          
    170              if( add_len > 0xFF00 )
   \       0x24   0xF64F 0x7001      MOVW     R0,#+65281
   \       0x28   0x4284             CMP      R4,R0
   \       0x2A   0xD22D             BCS.N    ??ccm_auth_crypt_0
   \       0x2C   0x930E             STR      R3,[SP, #+56]
   \       0x2E   0x920F             STR      R2,[SP, #+60]
    171                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
    172          
    173              q = 16 - 1 - (unsigned char) iv_len;
   \       0x30   0xF1C5 0x060F      RSB      R6,R5,#+15
   \       0x34   0xB2F6             UXTB     R6,R6
    174          
    175              /*
    176               * First block B_0:
    177               * 0        .. 0        flags
    178               * 1        .. iv_len   nonce (aka iv)
    179               * iv_len+1 .. 15       length
    180               *
    181               * With flags as (bits):
    182               * 7        0
    183               * 6        add present?
    184               * 5 .. 3   (t - 2) / 2
    185               * 2 .. 0   q - 1
    186               */
    187              b[0] = 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF88D 0x0004      STRB     R0,[SP, #+4]
    188              b[0] |= ( add_len > 0 ) << 6;
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \       0x40   0x4180             SBCS     R0,R0,R0
   \       0x42   0x43C0             MVNS     R0,R0
   \       0x44   0x0FC0             LSRS     R0,R0,#+31
   \       0x46   0x0180             LSLS     R0,R0,#+6
   \       0x48   0xF88D 0x0004      STRB     R0,[SP, #+4]
    189              b[0] |= ( ( tag_len - 2 ) / 2 ) << 3;
    190              b[0] |= q - 1;
   \       0x4C   0x9920             LDR      R1,[SP, #+128]
   \       0x4E   0x1E89             SUBS     R1,R1,#+2
   \       0x50   0x0849             LSRS     R1,R1,#+1
   \       0x52   0x4632             MOV      R2,R6
   \       0x54   0x1E52             SUBS     R2,R2,#+1
   \       0x56   0xEA42 0x02C1      ORR      R2,R2,R1, LSL #+3
   \       0x5A   0x4310             ORRS     R0,R2,R0
   \       0x5C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    191          
    192              memcpy( b + 1, iv, iv_len );
   \       0x60   0x462A             MOV      R2,R5
   \       0x62   0x990E             LDR      R1,[SP, #+56]
   \       0x64   0xF10D 0x0005      ADD      R0,SP,#+5
   \       0x68   0x....'....        BL       __aeabi_memcpy
    193          
    194              for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )
   \       0x6C   0x2100             MOVS     R1,#+0
   \       0x6E   0x980F             LDR      R0,[SP, #+60]
   \       0x70   0xE006             B.N      ??ccm_auth_crypt_1
    195                  b[15-i] = (unsigned char)( len_left & 0xFF );
   \                     ??ccm_auth_crypt_2: (+1)
   \       0x72   0xAA01             ADD      R2,SP,#+4
   \       0x74   0x424B             RSBS     R3,R1,#+0
   \       0x76   0x441A             ADD      R2,R2,R3
   \       0x78   0x73D0             STRB     R0,[R2, #+15]
   \       0x7A   0x1C49             ADDS     R1,R1,#+1
   \       0x7C   0xB2C9             UXTB     R1,R1
   \       0x7E   0x0A00             LSRS     R0,R0,#+8
   \                     ??ccm_auth_crypt_1: (+1)
   \       0x80   0x42B1             CMP      R1,R6
   \       0x82   0xDBF6             BLT.N    ??ccm_auth_crypt_2
    196          
    197              if( len_left > 0 )
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD002             BEQ.N    ??ccm_auth_crypt_3
    198                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
   \                     ??ccm_auth_crypt_0: (+1)
   \       0x88   0xF06F 0x000C      MVN      R0,#+12
   \       0x8C   0xE131             B.N      ??ccm_auth_crypt_4
    199          
    200          
    201              /* Start CBC-MAC with first block */
    202              memset( y, 0, 16 );
   \                     ??ccm_auth_crypt_3: (+1)
   \       0x8E   0x2200             MOVS     R2,#+0
   \       0x90   0x2110             MOVS     R1,#+16
   \       0x92   0xA806             ADD      R0,SP,#+24
   \       0x94   0x....'....        BL       __aeabi_memset4
    203              UPDATE_CBC_MAC;
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0xA906             ADD      R1,SP,#+24
   \       0x9C   0xE005             B.N      ??ccm_auth_crypt_5
   \                     ??ccm_auth_crypt_6: (+1)
   \       0x9E   0x5C0A             LDRB     R2,[R1, R0]
   \       0xA0   0xAB01             ADD      R3,SP,#+4
   \       0xA2   0x5C1B             LDRB     R3,[R3, R0]
   \       0xA4   0x405A             EORS     R2,R3,R2
   \       0xA6   0x540A             STRB     R2,[R1, R0]
   \       0xA8   0x1C40             ADDS     R0,R0,#+1
   \                     ??ccm_auth_crypt_5: (+1)
   \       0xAA   0x2810             CMP      R0,#+16
   \       0xAC   0xDBF7             BLT.N    ??ccm_auth_crypt_6
   \       0xAE   0xA805             ADD      R0,SP,#+20
   \       0xB0   0x9000             STR      R0,[SP, #+0]
   \       0xB2   0xAB06             ADD      R3,SP,#+24
   \       0xB4   0x2210             MOVS     R2,#+16
   \       0xB6   0x4638             MOV      R0,R7
   \       0xB8   0x....'....        BL       mbedtls_cipher_update
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xF040 0x8118      BNE.W    ??ccm_auth_crypt_4
    204          
    205              /*
    206               * If there is additional data, update CBC-MAC with
    207               * add_len, add, 0 (padding to a block boundary)
    208               */
    209              if( add_len > 0 )
   \       0xC2   0x2C00             CMP      R4,#+0
   \       0xC4   0xD05C             BEQ.N    ??ccm_auth_crypt_7
   \       0xC6   0xF8DD 0x906C      LDR      R9,[SP, #+108]
    210              {
    211                  size_t use_len;
    212                  len_left = add_len;
    213                  src = add;
    214          
    215                  memset( b, 0, 16 );
   \       0xCA   0x2200             MOVS     R2,#+0
   \       0xCC   0x2110             MOVS     R1,#+16
   \       0xCE   0xA801             ADD      R0,SP,#+4
   \       0xD0   0x....'....        BL       __aeabi_memset4
    216                  b[0] = (unsigned char)( ( add_len >> 8 ) & 0xFF );
   \       0xD4   0x4620             MOV      R0,R4
   \       0xD6   0x0A00             LSRS     R0,R0,#+8
   \       0xD8   0xF88D 0x0004      STRB     R0,[SP, #+4]
    217                  b[1] = (unsigned char)( ( add_len      ) & 0xFF );
   \       0xDC   0xF10D 0x0A04      ADD      R10,SP,#+4
   \       0xE0   0xF88A 0x4001      STRB     R4,[R10, #+1]
    218          
    219                  use_len = len_left < 16 - 2 ? len_left : 16 - 2;
   \       0xE4   0xF04F 0x0B0E      MOV      R11,#+14
   \       0xE8   0x2C0E             CMP      R4,#+14
   \       0xEA   0xD800             BHI.N    ??ccm_auth_crypt_8
   \       0xEC   0x46A3             MOV      R11,R4
    220                  memcpy( b + 2, src, use_len );
   \                     ??ccm_auth_crypt_8: (+1)
   \       0xEE   0x465A             MOV      R2,R11
   \       0xF0   0x4649             MOV      R1,R9
   \       0xF2   0xF10D 0x0006      ADD      R0,SP,#+6
   \       0xF6   0x....'....        BL       __aeabi_memcpy
    221                  len_left -= use_len;
   \       0xFA   0xEBA4 0x040B      SUB      R4,R4,R11
    222                  src += use_len;
   \       0xFE   0x44D9             ADD      R9,R9,R11
    223          
    224                  UPDATE_CBC_MAC;
   \      0x100   0x2000             MOVS     R0,#+0
   \      0x102   0xA906             ADD      R1,SP,#+24
   \      0x104   0xE005             B.N      ??ccm_auth_crypt_9
   \                     ??ccm_auth_crypt_10: (+1)
   \      0x106   0x5C0A             LDRB     R2,[R1, R0]
   \      0x108   0xF81A 0x3000      LDRB     R3,[R10, R0]
   \      0x10C   0x405A             EORS     R2,R3,R2
   \      0x10E   0x540A             STRB     R2,[R1, R0]
   \      0x110   0x1C40             ADDS     R0,R0,#+1
   \                     ??ccm_auth_crypt_9: (+1)
   \      0x112   0x2810             CMP      R0,#+16
   \      0x114   0xDBF7             BLT.N    ??ccm_auth_crypt_10
   \      0x116   0xA805             ADD      R0,SP,#+20
   \      0x118   0x9000             STR      R0,[SP, #+0]
   \      0x11A   0xAB06             ADD      R3,SP,#+24
   \      0x11C   0x2210             MOVS     R2,#+16
   \      0x11E   0x4638             MOV      R0,R7
   \      0x120   0x....'....        BL       mbedtls_cipher_update
   \      0x124   0x2800             CMP      R0,#+0
   \      0x126   0xF040 0x80E4      BNE.W    ??ccm_auth_crypt_4
   \      0x12A   0xE014             B.N      ??ccm_auth_crypt_11
    225          
    226                  while( len_left > 0 )
    227                  {
    228                      use_len = len_left > 16 ? 16 : len_left;
    229          
    230                      memset( b, 0, 16 );
    231                      memcpy( b, src, use_len );
    232                      UPDATE_CBC_MAC;
   \                     ??ccm_auth_crypt_12: (+1)
   \      0x12C   0x5C0A             LDRB     R2,[R1, R0]
   \      0x12E   0xF81A 0x3000      LDRB     R3,[R10, R0]
   \      0x132   0x405A             EORS     R2,R3,R2
   \      0x134   0x540A             STRB     R2,[R1, R0]
   \      0x136   0x1C40             ADDS     R0,R0,#+1
   \                     ??ccm_auth_crypt_13: (+1)
   \      0x138   0x2810             CMP      R0,#+16
   \      0x13A   0xDBF7             BLT.N    ??ccm_auth_crypt_12
   \      0x13C   0xA805             ADD      R0,SP,#+20
   \      0x13E   0x9000             STR      R0,[SP, #+0]
   \      0x140   0xAB06             ADD      R3,SP,#+24
   \      0x142   0x2210             MOVS     R2,#+16
   \      0x144   0x4638             MOV      R0,R7
   \      0x146   0x....'....        BL       mbedtls_cipher_update
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xF040 0x80D1      BNE.W    ??ccm_auth_crypt_4
    233          
    234                      len_left -= use_len;
   \      0x150   0xEBA4 0x040B      SUB      R4,R4,R11
    235                      src += use_len;
   \      0x154   0x44D9             ADD      R9,R9,R11
   \                     ??ccm_auth_crypt_11: (+1)
   \      0x156   0x2C00             CMP      R4,#+0
   \      0x158   0xD012             BEQ.N    ??ccm_auth_crypt_7
   \      0x15A   0x2C11             CMP      R4,#+17
   \      0x15C   0xD302             BCC.N    ??ccm_auth_crypt_14
   \      0x15E   0xF04F 0x0B10      MOV      R11,#+16
   \      0x162   0xE000             B.N      ??ccm_auth_crypt_15
   \                     ??ccm_auth_crypt_14: (+1)
   \      0x164   0x46A3             MOV      R11,R4
   \                     ??ccm_auth_crypt_15: (+1)
   \      0x166   0x2200             MOVS     R2,#+0
   \      0x168   0x2110             MOVS     R1,#+16
   \      0x16A   0xA801             ADD      R0,SP,#+4
   \      0x16C   0x....'....        BL       __aeabi_memset4
   \      0x170   0x465A             MOV      R2,R11
   \      0x172   0x4649             MOV      R1,R9
   \      0x174   0xA801             ADD      R0,SP,#+4
   \      0x176   0x....'....        BL       __aeabi_memcpy
   \      0x17A   0x2000             MOVS     R0,#+0
   \      0x17C   0xA906             ADD      R1,SP,#+24
   \      0x17E   0xE7DB             B.N      ??ccm_auth_crypt_13
    236                  }
    237              }
   \                     ??ccm_auth_crypt_7: (+1)
   \      0x180   0xF8DD 0x9078      LDR      R9,[SP, #+120]
   \      0x184   0xF8DD 0xA074      LDR      R10,[SP, #+116]
    238          
    239              /*
    240               * Prepare counter block for encryption:
    241               * 0        .. 0        flags
    242               * 1        .. iv_len   nonce (aka iv)
    243               * iv_len+1 .. 15       counter (initially 1)
    244               *
    245               * With flags as (bits):
    246               * 7 .. 3   0
    247               * 2 .. 0   q - 1
    248               */
    249              ctr[0] = q - 1;
   \      0x188   0x4630             MOV      R0,R6
   \      0x18A   0x1E40             SUBS     R0,R0,#+1
   \      0x18C   0xF88D 0x0028      STRB     R0,[SP, #+40]
    250              memcpy( ctr + 1, iv, iv_len );
   \      0x190   0x462A             MOV      R2,R5
   \      0x192   0x990E             LDR      R1,[SP, #+56]
   \      0x194   0xF10D 0x0029      ADD      R0,SP,#+41
   \      0x198   0x....'....        BL       __aeabi_memcpy
    251              memset( ctr + 1 + iv_len, 0, q );
   \      0x19C   0x2200             MOVS     R2,#+0
   \      0x19E   0x4631             MOV      R1,R6
   \      0x1A0   0xA80A             ADD      R0,SP,#+40
   \      0x1A2   0x4428             ADD      R0,R0,R5
   \      0x1A4   0x1C40             ADDS     R0,R0,#+1
   \      0x1A6   0x....'....        BL       __aeabi_memset
    252              ctr[15] = 1;
   \      0x1AA   0x2001             MOVS     R0,#+1
   \      0x1AC   0xF88D 0x0037      STRB     R0,[SP, #+55]
    253          
    254              /*
    255               * Authenticate and {en,de}crypt the message.
    256               *
    257               * The only difference between encryption and decryption is
    258               * the respective order of authentication and {en,de}cryption.
    259               */
    260              len_left = length;
   \      0x1B0   0x9C0F             LDR      R4,[SP, #+60]
    261              src = input;
   \      0x1B2   0x4655             MOV      R5,R10
    262              dst = output;
   \      0x1B4   0x46C2             MOV      R10,R8
    263          
    264              while( len_left > 0 )
   \                     ??ccm_auth_crypt_16: (+1)
   \      0x1B6   0x2C00             CMP      R4,#+0
   \      0x1B8   0xD076             BEQ.N    ??ccm_auth_crypt_17
    265              {
    266                  size_t use_len = len_left > 16 ? 16 : len_left;
   \      0x1BA   0x2C11             CMP      R4,#+17
   \      0x1BC   0xD302             BCC.N    ??ccm_auth_crypt_18
   \      0x1BE   0xF04F 0x0810      MOV      R8,#+16
   \      0x1C2   0xE000             B.N      ??ccm_auth_crypt_19
   \                     ??ccm_auth_crypt_18: (+1)
   \      0x1C4   0x46A0             MOV      R8,R4
    267          
    268                  if( mode == CCM_ENCRYPT )
   \                     ??ccm_auth_crypt_19: (+1)
   \      0x1C6   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x1CA   0xD11D             BNE.N    ??ccm_auth_crypt_20
    269                  {
    270                      memset( b, 0, 16 );
   \      0x1CC   0x2200             MOVS     R2,#+0
   \      0x1CE   0x2110             MOVS     R1,#+16
   \      0x1D0   0xA801             ADD      R0,SP,#+4
   \      0x1D2   0x....'....        BL       __aeabi_memset4
    271                      memcpy( b, src, use_len );
   \      0x1D6   0x4642             MOV      R2,R8
   \      0x1D8   0x4629             MOV      R1,R5
   \      0x1DA   0xA801             ADD      R0,SP,#+4
   \      0x1DC   0x....'....        BL       __aeabi_memcpy
    272                      UPDATE_CBC_MAC;
   \      0x1E0   0x2000             MOVS     R0,#+0
   \      0x1E2   0xA906             ADD      R1,SP,#+24
   \      0x1E4   0xE005             B.N      ??ccm_auth_crypt_21
   \                     ??ccm_auth_crypt_22: (+1)
   \      0x1E6   0x5C0A             LDRB     R2,[R1, R0]
   \      0x1E8   0xAB01             ADD      R3,SP,#+4
   \      0x1EA   0x5C1B             LDRB     R3,[R3, R0]
   \      0x1EC   0x405A             EORS     R2,R3,R2
   \      0x1EE   0x540A             STRB     R2,[R1, R0]
   \      0x1F0   0x1C40             ADDS     R0,R0,#+1
   \                     ??ccm_auth_crypt_21: (+1)
   \      0x1F2   0x2810             CMP      R0,#+16
   \      0x1F4   0xDBF7             BLT.N    ??ccm_auth_crypt_22
   \      0x1F6   0xA805             ADD      R0,SP,#+20
   \      0x1F8   0x9000             STR      R0,[SP, #+0]
   \      0x1FA   0xAB06             ADD      R3,SP,#+24
   \      0x1FC   0x2210             MOVS     R2,#+16
   \      0x1FE   0x4638             MOV      R0,R7
   \      0x200   0x....'....        BL       mbedtls_cipher_update
   \      0x204   0x2800             CMP      R0,#+0
   \      0x206   0xD174             BNE.N    ??ccm_auth_crypt_4
    273                  }
    274          
    275                  CTR_CRYPT( dst, src, use_len );
   \                     ??ccm_auth_crypt_20: (+1)
   \      0x208   0xA805             ADD      R0,SP,#+20
   \      0x20A   0x9000             STR      R0,[SP, #+0]
   \      0x20C   0xAB01             ADD      R3,SP,#+4
   \      0x20E   0x2210             MOVS     R2,#+16
   \      0x210   0xA90A             ADD      R1,SP,#+40
   \      0x212   0x4638             MOV      R0,R7
   \      0x214   0x....'....        BL       mbedtls_cipher_update
   \      0x218   0x2800             CMP      R0,#+0
   \      0x21A   0xD16A             BNE.N    ??ccm_auth_crypt_4
   \      0x21C   0x2000             MOVS     R0,#+0
   \      0x21E   0xE007             B.N      ??ccm_auth_crypt_23
   \                     ??ccm_auth_crypt_24: (+1)
   \      0x220   0x5C29             LDRB     R1,[R5, R0]
   \      0x222   0xAA01             ADD      R2,SP,#+4
   \      0x224   0x5C12             LDRB     R2,[R2, R0]
   \      0x226   0x4051             EORS     R1,R2,R1
   \      0x228   0xF809 0x1000      STRB     R1,[R9, R0]
   \      0x22C   0x1C40             ADDS     R0,R0,#+1
   \      0x22E   0xB2C0             UXTB     R0,R0
   \                     ??ccm_auth_crypt_23: (+1)
   \      0x230   0x4540             CMP      R0,R8
   \      0x232   0xD3F5             BCC.N    ??ccm_auth_crypt_24
    276          
    277                  if( mode == CCM_DECRYPT )
   \      0x234   0xF1BA 0x0F01      CMP      R10,#+1
   \      0x238   0xD11D             BNE.N    ??ccm_auth_crypt_25
    278                  {
    279                      memset( b, 0, 16 );
   \      0x23A   0x2200             MOVS     R2,#+0
   \      0x23C   0x2110             MOVS     R1,#+16
   \      0x23E   0xA801             ADD      R0,SP,#+4
   \      0x240   0x....'....        BL       __aeabi_memset4
    280                      memcpy( b, dst, use_len );
   \      0x244   0x4642             MOV      R2,R8
   \      0x246   0x4649             MOV      R1,R9
   \      0x248   0xA801             ADD      R0,SP,#+4
   \      0x24A   0x....'....        BL       __aeabi_memcpy
    281                      UPDATE_CBC_MAC;
   \      0x24E   0x2000             MOVS     R0,#+0
   \      0x250   0xA906             ADD      R1,SP,#+24
   \      0x252   0xE005             B.N      ??ccm_auth_crypt_26
   \                     ??ccm_auth_crypt_27: (+1)
   \      0x254   0x5C0A             LDRB     R2,[R1, R0]
   \      0x256   0xAB01             ADD      R3,SP,#+4
   \      0x258   0x5C1B             LDRB     R3,[R3, R0]
   \      0x25A   0x405A             EORS     R2,R3,R2
   \      0x25C   0x540A             STRB     R2,[R1, R0]
   \      0x25E   0x1C40             ADDS     R0,R0,#+1
   \                     ??ccm_auth_crypt_26: (+1)
   \      0x260   0x2810             CMP      R0,#+16
   \      0x262   0xDBF7             BLT.N    ??ccm_auth_crypt_27
   \      0x264   0xA805             ADD      R0,SP,#+20
   \      0x266   0x9000             STR      R0,[SP, #+0]
   \      0x268   0xAB06             ADD      R3,SP,#+24
   \      0x26A   0x2210             MOVS     R2,#+16
   \      0x26C   0x4638             MOV      R0,R7
   \      0x26E   0x....'....        BL       mbedtls_cipher_update
   \      0x272   0x2800             CMP      R0,#+0
   \      0x274   0xD13D             BNE.N    ??ccm_auth_crypt_4
    282                  }
    283          
    284                  dst += use_len;
   \                     ??ccm_auth_crypt_25: (+1)
   \      0x276   0x44C1             ADD      R9,R9,R8
    285                  src += use_len;
   \      0x278   0x4445             ADD      R5,R5,R8
    286                  len_left -= use_len;
   \      0x27A   0xEBA4 0x0408      SUB      R4,R4,R8
    287          
    288                  /*
    289                   * Increment counter.
    290                   * No need to check for overflow thanks to the length check above.
    291                   */
    292                  for( i = 0; i < q; i++ )
   \      0x27E   0x2100             MOVS     R1,#+0
   \                     ??ccm_auth_crypt_28: (+1)
   \      0x280   0x42B1             CMP      R1,R6
   \      0x282   0xDA98             BGE.N    ??ccm_auth_crypt_16
    293                      if( ++ctr[15-i] != 0 )
   \      0x284   0xA80A             ADD      R0,SP,#+40
   \      0x286   0x424A             RSBS     R2,R1,#+0
   \      0x288   0x4410             ADD      R0,R0,R2
   \      0x28A   0x7BC0             LDRB     R0,[R0, #+15]
   \      0x28C   0x1C40             ADDS     R0,R0,#+1
   \      0x28E   0xAA0A             ADD      R2,SP,#+40
   \      0x290   0x424B             RSBS     R3,R1,#+0
   \      0x292   0x441A             ADD      R2,R2,R3
   \      0x294   0x73D0             STRB     R0,[R2, #+15]
   \      0x296   0xA80A             ADD      R0,SP,#+40
   \      0x298   0x424A             RSBS     R2,R1,#+0
   \      0x29A   0x4410             ADD      R0,R0,R2
   \      0x29C   0x7BC0             LDRB     R0,[R0, #+15]
   \      0x29E   0x2800             CMP      R0,#+0
   \      0x2A0   0xD189             BNE.N    ??ccm_auth_crypt_16
   \      0x2A2   0x1C49             ADDS     R1,R1,#+1
   \      0x2A4   0xB2C9             UXTB     R1,R1
   \      0x2A6   0xE7EB             B.N      ??ccm_auth_crypt_28
    294                          break;
    295              }
    296          
    297              /*
    298               * Authentication: reset counter and crypt/mask internal tag
    299               */
    300              for( i = 0; i < q; i++ )
   \                     ??ccm_auth_crypt_17: (+1)
   \      0x2A8   0x2000             MOVS     R0,#+0
   \      0x2AA   0x4601             MOV      R1,R0
   \      0x2AC   0xE005             B.N      ??ccm_auth_crypt_29
    301                  ctr[15-i] = 0;
   \                     ??ccm_auth_crypt_30: (+1)
   \      0x2AE   0xAA0A             ADD      R2,SP,#+40
   \      0x2B0   0x4243             RSBS     R3,R0,#+0
   \      0x2B2   0x441A             ADD      R2,R2,R3
   \      0x2B4   0x73D1             STRB     R1,[R2, #+15]
   \      0x2B6   0x1C40             ADDS     R0,R0,#+1
   \      0x2B8   0xB2C0             UXTB     R0,R0
   \                     ??ccm_auth_crypt_29: (+1)
   \      0x2BA   0x42B0             CMP      R0,R6
   \      0x2BC   0xDBF7             BLT.N    ??ccm_auth_crypt_30
    302          
    303              CTR_CRYPT( y, y, 16 );
   \      0x2BE   0xA805             ADD      R0,SP,#+20
   \      0x2C0   0x9000             STR      R0,[SP, #+0]
   \      0x2C2   0xAB01             ADD      R3,SP,#+4
   \      0x2C4   0x2210             MOVS     R2,#+16
   \      0x2C6   0xA90A             ADD      R1,SP,#+40
   \      0x2C8   0x4638             MOV      R0,R7
   \      0x2CA   0x....'....        BL       mbedtls_cipher_update
   \      0x2CE   0x2800             CMP      R0,#+0
   \      0x2D0   0xD10F             BNE.N    ??ccm_auth_crypt_4
   \      0x2D2   0x2000             MOVS     R0,#+0
   \      0x2D4   0xA906             ADD      R1,SP,#+24
   \      0x2D6   0xE005             B.N      ??ccm_auth_crypt_31
   \                     ??ccm_auth_crypt_32: (+1)
   \      0x2D8   0x5C0A             LDRB     R2,[R1, R0]
   \      0x2DA   0xAB01             ADD      R3,SP,#+4
   \      0x2DC   0x5C1B             LDRB     R3,[R3, R0]
   \      0x2DE   0x405A             EORS     R2,R3,R2
   \      0x2E0   0x540A             STRB     R2,[R1, R0]
   \      0x2E2   0x1C40             ADDS     R0,R0,#+1
   \                     ??ccm_auth_crypt_31: (+1)
   \      0x2E4   0x2810             CMP      R0,#+16
   \      0x2E6   0xDBF7             BLT.N    ??ccm_auth_crypt_32
   \      0x2E8   0x981F             LDR      R0,[SP, #+124]
    304              memcpy( tag, y, tag_len );
   \      0x2EA   0x9A20             LDR      R2,[SP, #+128]
   \      0x2EC   0x....'....        BL       __aeabi_memcpy
    305          
    306              return( 0 );
   \      0x2F0   0x2000             MOVS     R0,#+0
   \                     ??ccm_auth_crypt_4: (+1)
   \      0x2F2   0xB011             ADD      SP,SP,#+68
   \      0x2F4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    307          }
    308          
    309          /*
    310           * Authenticated encryption
    311           */

   \                                 In section .text, align 2, keep-with-next
    312          int mbedtls_ccm_star_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,
    313                                   const unsigned char *iv, size_t iv_len,
    314                                   const unsigned char *add, size_t add_len,
    315                                   const unsigned char *input, unsigned char *output,
    316                                   unsigned char *tag, size_t tag_len )
    317          {
   \                     mbedtls_ccm_star_encrypt_and_tag: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x9C0C             LDR      R4,[SP, #+48]
   \        0x6   0x9D0D             LDR      R5,[SP, #+52]
   \        0x8   0x9E0E             LDR      R6,[SP, #+56]
   \        0xA   0x9F0F             LDR      R7,[SP, #+60]
   \        0xC   0xF8DD 0xC040      LDR      R12,[SP, #+64]
   \       0x10   0xF8DD 0xE044      LDR      LR,[SP, #+68]
    318              return( ccm_auth_crypt( ctx, CCM_ENCRYPT, length, iv, iv_len,
    319                                      add, add_len, input, output, tag, tag_len ) );
   \       0x14   0xF8CD 0xE018      STR      LR,[SP, #+24]
   \       0x18   0xF8CD 0xC014      STR      R12,[SP, #+20]
   \       0x1C   0x9704             STR      R7,[SP, #+16]
   \       0x1E   0x9603             STR      R6,[SP, #+12]
   \       0x20   0x9502             STR      R5,[SP, #+8]
   \       0x22   0x9401             STR      R4,[SP, #+4]
   \       0x24   0x9300             STR      R3,[SP, #+0]
   \       0x26   0x4613             MOV      R3,R2
   \       0x28   0x460A             MOV      R2,R1
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x....'....        BL       ccm_auth_crypt
   \       0x30   0xB007             ADD      SP,SP,#+28
   \       0x32   0xBDF0             POP      {R4-R7,PC}       ;; return
    320          }
    321          

   \                                 In section .text, align 2, keep-with-next
    322          int mbedtls_ccm_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,
    323                                   const unsigned char *iv, size_t iv_len,
    324                                   const unsigned char *add, size_t add_len,
    325                                   const unsigned char *input, unsigned char *output,
    326                                   unsigned char *tag, size_t tag_len )
    327          {
   \                     mbedtls_ccm_encrypt_and_tag: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x9C11             LDR      R4,[SP, #+68]
    328              if( tag_len == 0 )
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??mbedtls_ccm_encrypt_and_tag_0
    329                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
   \        0xA   0xF06F 0x000C      MVN      R0,#+12
   \        0xE   0xE010             B.N      ??mbedtls_ccm_encrypt_and_tag_1
   \                     ??mbedtls_ccm_encrypt_and_tag_0: (+1)
   \       0x10   0xF8DD 0xE040      LDR      LR,[SP, #+64]
   \       0x14   0xF8DD 0xC03C      LDR      R12,[SP, #+60]
   \       0x18   0x9F0E             LDR      R7,[SP, #+56]
   \       0x1A   0x9E0D             LDR      R6,[SP, #+52]
   \       0x1C   0x9D0C             LDR      R5,[SP, #+48]
    330          
    331              return( mbedtls_ccm_star_encrypt_and_tag( ctx, length, iv, iv_len, add,
    332                          add_len, input, output, tag, tag_len ) );
   \       0x1E   0x9405             STR      R4,[SP, #+20]
   \       0x20   0xF8CD 0xE010      STR      LR,[SP, #+16]
   \       0x24   0xF8CD 0xC00C      STR      R12,[SP, #+12]
   \       0x28   0x9702             STR      R7,[SP, #+8]
   \       0x2A   0x9601             STR      R6,[SP, #+4]
   \       0x2C   0x9500             STR      R5,[SP, #+0]
   \       0x2E   0x....'....        BL       mbedtls_ccm_star_encrypt_and_tag
   \                     ??mbedtls_ccm_encrypt_and_tag_1: (+1)
   \       0x32   0xB007             ADD      SP,SP,#+28
   \       0x34   0xBDF0             POP      {R4-R7,PC}       ;; return
    333          }
    334          
    335          /*
    336           * Authenticated decryption
    337           */

   \                                 In section .text, align 2, keep-with-next
    338          int mbedtls_ccm_star_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,
    339                                const unsigned char *iv, size_t iv_len,
    340                                const unsigned char *add, size_t add_len,
    341                                const unsigned char *input, unsigned char *output,
    342                                const unsigned char *tag, size_t tag_len )
    343          {
   \                     mbedtls_ccm_star_auth_decrypt: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x9910             LDR      R1,[SP, #+64]
   \        0x8   0x9F11             LDR      R7,[SP, #+68]
   \        0xA   0xF8DD 0xC048      LDR      R12,[SP, #+72]
   \        0xE   0x9D13             LDR      R5,[SP, #+76]
   \       0x10   0x9E15             LDR      R6,[SP, #+84]
    344              int ret;
    345              unsigned char check_tag[16];
    346              unsigned char i;
    347              int diff;
    348          
    349              if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,
    350                                          iv, iv_len, add, add_len,
    351                                          input, output, check_tag, tag_len ) ) != 0 )
   \       0x12   0x9606             STR      R6,[SP, #+24]
   \       0x14   0xF10D 0x0E1C      ADD      LR,SP,#+28
   \       0x18   0xF8CD 0xE014      STR      LR,[SP, #+20]
   \       0x1C   0x9504             STR      R5,[SP, #+16]
   \       0x1E   0xF8CD 0xC00C      STR      R12,[SP, #+12]
   \       0x22   0x9702             STR      R7,[SP, #+8]
   \       0x24   0x9101             STR      R1,[SP, #+4]
   \       0x26   0x9300             STR      R3,[SP, #+0]
   \       0x28   0x4613             MOV      R3,R2
   \       0x2A   0x4622             MOV      R2,R4
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x....'....        BL       ccm_auth_crypt
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD116             BNE.N    ??mbedtls_ccm_star_auth_decrypt_0
    352              {
    353                  return( ret );
    354              }
    355          
    356              /* Check tag in "constant-time" */
    357              for( diff = 0, i = 0; i < tag_len; i++ )
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x4602             MOV      R2,R0
   \       0x3A   0x9914             LDR      R1,[SP, #+80]
   \       0x3C   0xE006             B.N      ??mbedtls_ccm_star_auth_decrypt_1
    358                  diff |= tag[i] ^ check_tag[i];
   \                     ??mbedtls_ccm_star_auth_decrypt_2: (+1)
   \       0x3E   0x5C8B             LDRB     R3,[R1, R2]
   \       0x40   0xAF07             ADD      R7,SP,#+28
   \       0x42   0x5CBF             LDRB     R7,[R7, R2]
   \       0x44   0x407B             EORS     R3,R7,R3
   \       0x46   0x4318             ORRS     R0,R3,R0
   \       0x48   0x1C52             ADDS     R2,R2,#+1
   \       0x4A   0xB2D2             UXTB     R2,R2
   \                     ??mbedtls_ccm_star_auth_decrypt_1: (+1)
   \       0x4C   0x42B2             CMP      R2,R6
   \       0x4E   0xD3F6             BCC.N    ??mbedtls_ccm_star_auth_decrypt_2
    359          
    360              if( diff != 0 )
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD006             BEQ.N    ??mbedtls_ccm_star_auth_decrypt_3
    361              {
    362                  mbedtls_platform_zeroize( output, length );
   \       0x54   0x4621             MOV      R1,R4
   \       0x56   0x4628             MOV      R0,R5
   \       0x58   0x....'....        BL       mbedtls_platform_zeroize
    363                  return( MBEDTLS_ERR_CCM_AUTH_FAILED );
   \       0x5C   0xF06F 0x000E      MVN      R0,#+14
   \       0x60   0xE000             B.N      ??mbedtls_ccm_star_auth_decrypt_0
    364              }
    365          
    366              return( 0 );
   \                     ??mbedtls_ccm_star_auth_decrypt_3: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_star_auth_decrypt_0: (+1)
   \       0x64   0xB00B             ADD      SP,SP,#+44
   \       0x66   0xBDF0             POP      {R4-R7,PC}       ;; return
    367          }
    368          

   \                                 In section .text, align 2, keep-with-next
    369          int mbedtls_ccm_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,
    370                                const unsigned char *iv, size_t iv_len,
    371                                const unsigned char *add, size_t add_len,
    372                                const unsigned char *input, unsigned char *output,
    373                                const unsigned char *tag, size_t tag_len )
    374          {
   \                     mbedtls_ccm_auth_decrypt: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x9C11             LDR      R4,[SP, #+68]
    375              if( tag_len == 0 )
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??mbedtls_ccm_auth_decrypt_0
    376                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
   \        0xA   0xF06F 0x000C      MVN      R0,#+12
   \        0xE   0xE010             B.N      ??mbedtls_ccm_auth_decrypt_1
   \                     ??mbedtls_ccm_auth_decrypt_0: (+1)
   \       0x10   0xF8DD 0xE040      LDR      LR,[SP, #+64]
   \       0x14   0xF8DD 0xC03C      LDR      R12,[SP, #+60]
   \       0x18   0x9F0E             LDR      R7,[SP, #+56]
   \       0x1A   0x9E0D             LDR      R6,[SP, #+52]
   \       0x1C   0x9D0C             LDR      R5,[SP, #+48]
    377          
    378              return( mbedtls_ccm_star_auth_decrypt( ctx, length, iv, iv_len, add,
    379                          add_len, input, output, tag, tag_len ) );
   \       0x1E   0x9405             STR      R4,[SP, #+20]
   \       0x20   0xF8CD 0xE010      STR      LR,[SP, #+16]
   \       0x24   0xF8CD 0xC00C      STR      R12,[SP, #+12]
   \       0x28   0x9702             STR      R7,[SP, #+8]
   \       0x2A   0x9601             STR      R6,[SP, #+4]
   \       0x2C   0x9500             STR      R5,[SP, #+0]
   \       0x2E   0x....'....        BL       mbedtls_ccm_star_auth_decrypt
   \                     ??mbedtls_ccm_auth_decrypt_1: (+1)
   \       0x32   0xB007             ADD      SP,SP,#+28
   \       0x34   0xBDF0             POP      {R4-R7,PC}       ;; return
    380          }
    381          #endif /* !MBEDTLS_CCM_CRYPT_ALT */
    382          #endif /* !MBEDTLS_CCM_ALT */
    383          
    384          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
    385          /*
    386           * Examples 1 to 3 from SP800-38C Appendix C
    387           */
    388          
    389          #define NB_TESTS 3
    390          #define CCM_SELFTEST_PT_MAX_LEN 24
    391          #define CCM_SELFTEST_CT_MAX_LEN 32
    392          /*
    393           * The data is the same for all tests, only the used length changes
    394           */

   \                                 In section .rodata, align 8
    395          static const unsigned char key[] __attribute__((aligned)) = {
   \                     key:
   \        0x0   0x40 0x41          DC8 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79
   \              0x42 0x43    
   \              0x44 0x45    
   \              0x46 0x47    
   \              0x48 0x49    
   \              0x4A 0x4B    
   \              0x4C 0x4D    
   \              0x4E 0x4F    
    396              0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    397              0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
    398          };
    399          

   \                                 In section .rodata, align 4
    400          static const unsigned char iv[] = {
   \                     iv:
   \        0x0   0x10 0x11          DC8 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27
   \              0x12 0x13    
   \              0x14 0x15    
   \              0x16 0x17    
   \              0x18 0x19    
   \              0x1A 0x1B    
    401              0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    402              0x18, 0x19, 0x1a, 0x1b
    403          };
    404          

   \                                 In section .rodata, align 4
    405          static const unsigned char ad[] = {
   \                     ad:
   \        0x0   0x00 0x01          DC8 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18
   \              0x02 0x03    
   \              0x04 0x05    
   \              0x06 0x07    
   \              0x08 0x09    
   \              0x0A 0x0B    
   \              0x0C 0x0D    
   \              0x0E 0x0F    
   \              0x10 0x11    
   \              0x12         
   \       0x13   0x13               DC8 19
    406              0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    407              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    408              0x10, 0x11, 0x12, 0x13
    409          };
    410          

   \                                 In section .rodata, align 4
    411          static const unsigned char msg[CCM_SELFTEST_PT_MAX_LEN] = {
   \                     msg:
   \        0x0   0x20 0x21          DC8 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48
   \              0x22 0x23    
   \              0x24 0x25    
   \              0x26 0x27    
   \              0x28 0x29    
   \              0x2A 0x2B    
   \              0x2C 0x2D    
   \              0x2E 0x2F    
   \              0x30         
   \       0x11   0x31 0x32          DC8 49, 50, 51, 52, 53, 54, 55
   \              0x33 0x34    
   \              0x35 0x36    
   \              0x37         
    412              0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    413              0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    414              0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    415          };
    416          

   \                                 In section .rodata, align 4
    417          static const size_t iv_len [NB_TESTS] = { 7, 8,  12 };
   \                     iv_len:
   \        0x0   0x0000'0007        DC32 7, 8, 12
   \              0x0000'0008  
   \              0x0000'000C  

   \                                 In section .rodata, align 4
    418          static const size_t add_len[NB_TESTS] = { 8, 16, 20 };
   \                     add_len:
   \        0x0   0x0000'0008        DC32 8, 16, 20
   \              0x0000'0010  
   \              0x0000'0014  

   \                                 In section .rodata, align 4
    419          static const size_t msg_len[NB_TESTS] = { 4, 16, 24 };
   \                     msg_len:
   \        0x0   0x0000'0004        DC32 4, 16, 24
   \              0x0000'0010  
   \              0x0000'0018  

   \                                 In section .rodata, align 4
    420          static const size_t tag_len[NB_TESTS] = { 4, 6,  8  };
   \                     tag_len:
   \        0x0   0x0000'0004        DC32 4, 6, 8
   \              0x0000'0006  
   \              0x0000'0008  
    421          

   \                                 In section .rodata, align 4
    422          static const unsigned char res[NB_TESTS][CCM_SELFTEST_CT_MAX_LEN] = {
   \                     res:
   \        0x0   0x71 0x62          DC8 113, 98, 1, 91, 77, 172, 37, 93, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x01 0x5B    
   \              0x4D 0xAC    
   \              0x25 0x5D    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x14   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 161, 240, 224, 81, 234, 95
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0xD2 0xA1    
   \              0xF0 0xE0    
   \              0x51 0xEA    
   \              0x5F         
   \       0x27   0x62 0x08          DC8 98, 8, 26, 119, 146, 7, 61, 89, 61, 31, 198, 79, 191, 172, 205, 0
   \              0x1A 0x77    
   \              0x92 0x07    
   \              0x3D 0x59    
   \              0x3D 0x1F    
   \              0xC6 0x4F    
   \              0xBF 0xAC    
   \              0xCD 0x00    
   \       0x37   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 178, 1, 169, 245, 183, 26, 122, 155
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0xE3    
   \              0xB2 0x01    
   \              0xA9 0xF5    
   \              0xB7 0x1A    
   \              0x7A 0x9B    
   \       0x49   0x1C 0xEA          DC8 28, 234, 236, 205, 151, 231, 11, 97, 118, 170, 217, 164, 66, 138
   \              0xEC 0xCD    
   \              0x97 0xE7    
   \              0x0B 0x61    
   \              0x76 0xAA    
   \              0xD9 0xA4    
   \              0x42 0x8A    
   \       0x57   0xA5 0x48          DC8 165, 72, 67, 146, 251, 193, 176, 153, 81
   \              0x43 0x92    
   \              0xFB 0xC1    
   \              0xB0 0x99    
   \              0x51         
    423              {   0x71, 0x62, 0x01, 0x5b, 0x4d, 0xac, 0x25, 0x5d },
    424              {   0xd2, 0xa1, 0xf0, 0xe0, 0x51, 0xea, 0x5f, 0x62,
    425                  0x08, 0x1a, 0x77, 0x92, 0x07, 0x3d, 0x59, 0x3d,
    426                  0x1f, 0xc6, 0x4f, 0xbf, 0xac, 0xcd },
    427              {   0xe3, 0xb2, 0x01, 0xa9, 0xf5, 0xb7, 0x1a, 0x7a,
    428                  0x9b, 0x1c, 0xea, 0xec, 0xcd, 0x97, 0xe7, 0x0b,
    429                  0x61, 0x76, 0xaa, 0xd9, 0xa4, 0x42, 0x8a, 0xa5,
    430                  0x48, 0x43, 0x92, 0xfb, 0xc1, 0xb0, 0x99, 0x51 }
    431          };
    432          

   \                                 In section .text, align 2, keep-with-next
    433          int mbedtls_ccm_self_test( int verbose )
    434          {
   \                     mbedtls_ccm_self_test: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB0A4             SUB      SP,SP,#+144
   \        0x6   0x4682             MOV      R10,R0
    435              mbedtls_ccm_context ctx;
    436              /*
    437               * Some hardware accelerators require the input and output buffers
    438               * would be in RAM, because the flash is not accessible.
    439               * Use buffers on the stack to hold the test vectors data.
    440               */
    441              unsigned char plaintext[CCM_SELFTEST_PT_MAX_LEN];
    442              unsigned char ciphertext[CCM_SELFTEST_CT_MAX_LEN];
    443              size_t i;
    444              int ret;
    445          
    446              mbedtls_ccm_init( &ctx );
   \        0x8   0xA814             ADD      R0,SP,#+80
   \        0xA   0x....'....        BL       mbedtls_ccm_init
    447          
    448              if( mbedtls_ccm_setkey( &ctx, MBEDTLS_CIPHER_ID_AES, key, 8 * sizeof key ) != 0 )
   \        0xE   0x2380             MOVS     R3,#+128
   \       0x10   0x....             LDR.N    R2,??DataTable1_1
   \       0x12   0x2102             MOVS     R1,#+2
   \       0x14   0xA814             ADD      R0,SP,#+80
   \       0x16   0x....'....        BL       mbedtls_ccm_setkey
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD007             BEQ.N    ??mbedtls_ccm_self_test_0
    449              {
    450                  if( verbose != 0 )
   \       0x1E   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x22   0xF000 0x809A      BEQ.W    ??mbedtls_ccm_self_test_1
    451                      mbedtls_printf( "  CCM: setup failed" );
   \       0x26   0x....             LDR.N    R0,??DataTable1_2
   \       0x28   0x....'....        BL       DbgConsole_Printf
   \       0x2C   0xE095             B.N      ??mbedtls_ccm_self_test_1
    452          
    453                  return( 1 );
    454              }
    455          
    456              for( i = 0; i < NB_TESTS; i++ )
   \                     ??mbedtls_ccm_self_test_0: (+1)
   \       0x2E   0xF04F 0x0B00      MOV      R11,#+0
   \       0x32   0x....             LDR.N    R4,??DataTable1_3
   \       0x34   0x....             LDR.N    R5,??DataTable1_4
   \       0x36   0x....             LDR.N    R6,??DataTable1_5
   \       0x38   0x....             LDR.N    R7,??DataTable1_6
   \       0x3A   0x....'....        LDR.W    R8,??DataTable1_7
   \       0x3E   0x....'....        LDR.W    R9,??DataTable1_8
   \                     ??mbedtls_ccm_self_test_2: (+1)
   \       0x42   0xF1BB 0x0F03      CMP      R11,#+3
   \       0x46   0xD26E             BCS.N    ??mbedtls_ccm_self_test_3
    457              {
    458                  if( verbose != 0 )
   \       0x48   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x4C   0xD004             BEQ.N    ??mbedtls_ccm_self_test_4
    459                      mbedtls_printf( "  CCM-AES #%u: ", (unsigned int) i + 1 );
   \       0x4E   0xF10B 0x0101      ADD      R1,R11,#+1
   \       0x52   0x....             LDR.N    R0,??DataTable1_9
   \       0x54   0x....'....        BL       DbgConsole_Printf
    460          
    461                  memset( plaintext, 0, CCM_SELFTEST_PT_MAX_LEN );
   \                     ??mbedtls_ccm_self_test_4: (+1)
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x2118             MOVS     R1,#+24
   \       0x5C   0xA806             ADD      R0,SP,#+24
   \       0x5E   0x....'....        BL       __aeabi_memset4
    462                  memset( ciphertext, 0, CCM_SELFTEST_CT_MAX_LEN );
   \       0x62   0x2200             MOVS     R2,#+0
   \       0x64   0x2120             MOVS     R1,#+32
   \       0x66   0xA80C             ADD      R0,SP,#+48
   \       0x68   0x....'....        BL       __aeabi_memset4
    463                  memcpy( plaintext, msg, msg_len[i] );
   \       0x6C   0xF854 0x202B      LDR      R2,[R4, R11, LSL #+2]
   \       0x70   0x....             LDR.N    R1,??DataTable1_10
   \       0x72   0xA806             ADD      R0,SP,#+24
   \       0x74   0x....'....        BL       __aeabi_memcpy4
    464          
    465                  ret = mbedtls_ccm_encrypt_and_tag( &ctx, msg_len[i],
    466                                                     iv, iv_len[i], ad, add_len[i],
    467                                                     plaintext, ciphertext,
    468                                                     ciphertext + msg_len[i], tag_len[i] );
    469          
    470                  if( ret != 0 ||
    471                      memcmp( ciphertext, res[i], msg_len[i] + tag_len[i] ) != 0 )
   \       0x78   0xF859 0x002B      LDR      R0,[R9, R11, LSL #+2]
   \       0x7C   0x9005             STR      R0,[SP, #+20]
   \       0x7E   0xA80C             ADD      R0,SP,#+48
   \       0x80   0xF854 0x102B      LDR      R1,[R4, R11, LSL #+2]
   \       0x84   0x4408             ADD      R0,R0,R1
   \       0x86   0x9004             STR      R0,[SP, #+16]
   \       0x88   0xA80C             ADD      R0,SP,#+48
   \       0x8A   0x9003             STR      R0,[SP, #+12]
   \       0x8C   0xA806             ADD      R0,SP,#+24
   \       0x8E   0x9002             STR      R0,[SP, #+8]
   \       0x90   0xF858 0x002B      LDR      R0,[R8, R11, LSL #+2]
   \       0x94   0x9001             STR      R0,[SP, #+4]
   \       0x96   0x9700             STR      R7,[SP, #+0]
   \       0x98   0xF856 0x302B      LDR      R3,[R6, R11, LSL #+2]
   \       0x9C   0x462A             MOV      R2,R5
   \       0x9E   0xF854 0x102B      LDR      R1,[R4, R11, LSL #+2]
   \       0xA2   0xA814             ADD      R0,SP,#+80
   \       0xA4   0x....'....        BL       mbedtls_ccm_encrypt_and_tag
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD149             BNE.N    ??mbedtls_ccm_self_test_5
   \       0xAC   0xF854 0x202B      LDR      R2,[R4, R11, LSL #+2]
   \       0xB0   0xF859 0x002B      LDR      R0,[R9, R11, LSL #+2]
   \       0xB4   0x1882             ADDS     R2,R0,R2
   \       0xB6   0x....             LDR.N    R0,??DataTable1_11
   \       0xB8   0xEB00 0x114B      ADD      R1,R0,R11, LSL #+5
   \       0xBC   0xA80C             ADD      R0,SP,#+48
   \       0xBE   0x....'....        BL       memcmp
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD13C             BNE.N    ??mbedtls_ccm_self_test_5
    472                  {
    473                      if( verbose != 0 )
    474                          mbedtls_printf( "failed\n\r" );
    475          
    476                      return( 1 );
    477                  }
    478                  memset( plaintext, 0, CCM_SELFTEST_PT_MAX_LEN );
   \       0xC6   0x2200             MOVS     R2,#+0
   \       0xC8   0x2118             MOVS     R1,#+24
   \       0xCA   0xA806             ADD      R0,SP,#+24
   \       0xCC   0x....'....        BL       __aeabi_memset4
    479          
    480                  ret = mbedtls_ccm_auth_decrypt( &ctx, msg_len[i],
    481                                                  iv, iv_len[i], ad, add_len[i],
    482                                                  ciphertext, plaintext,
    483                                                  ciphertext + msg_len[i], tag_len[i] );
    484          
    485                  if( ret != 0 ||
    486                      memcmp( plaintext, msg, msg_len[i] ) != 0 )
   \       0xD0   0xF859 0x002B      LDR      R0,[R9, R11, LSL #+2]
   \       0xD4   0x9005             STR      R0,[SP, #+20]
   \       0xD6   0xA80C             ADD      R0,SP,#+48
   \       0xD8   0xF854 0x102B      LDR      R1,[R4, R11, LSL #+2]
   \       0xDC   0x4408             ADD      R0,R0,R1
   \       0xDE   0x9004             STR      R0,[SP, #+16]
   \       0xE0   0xA806             ADD      R0,SP,#+24
   \       0xE2   0x9003             STR      R0,[SP, #+12]
   \       0xE4   0xA80C             ADD      R0,SP,#+48
   \       0xE6   0x9002             STR      R0,[SP, #+8]
   \       0xE8   0xF858 0x002B      LDR      R0,[R8, R11, LSL #+2]
   \       0xEC   0x9001             STR      R0,[SP, #+4]
   \       0xEE   0x9700             STR      R7,[SP, #+0]
   \       0xF0   0xF856 0x302B      LDR      R3,[R6, R11, LSL #+2]
   \       0xF4   0x462A             MOV      R2,R5
   \       0xF6   0xF854 0x102B      LDR      R1,[R4, R11, LSL #+2]
   \       0xFA   0xA814             ADD      R0,SP,#+80
   \       0xFC   0x....'....        BL       mbedtls_ccm_auth_decrypt
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD124             BNE.N    ??mbedtls_ccm_self_test_6
   \      0x104   0xF854 0x202B      LDR      R2,[R4, R11, LSL #+2]
   \      0x108   0x....             LDR.N    R1,??DataTable1_10
   \      0x10A   0xA806             ADD      R0,SP,#+24
   \      0x10C   0x....'....        BL       memcmp
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD11C             BNE.N    ??mbedtls_ccm_self_test_6
    487                  {
    488                      if( verbose != 0 )
    489                          mbedtls_printf( "failed\n\r" );
    490          
    491                      return( 1 );
    492                  }
    493          
    494                  if( verbose != 0 )
   \      0x114   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x118   0xD002             BEQ.N    ??mbedtls_ccm_self_test_7
    495                      mbedtls_printf( "passed\n\r" );
   \      0x11A   0x....             LDR.N    R0,??DataTable1_12
   \      0x11C   0x....'....        BL       DbgConsole_Printf
   \                     ??mbedtls_ccm_self_test_7: (+1)
   \      0x120   0xF10B 0x0B01      ADD      R11,R11,#+1
   \      0x124   0xE78D             B.N      ??mbedtls_ccm_self_test_2
    496              }
    497          
    498              mbedtls_ccm_free( &ctx );
   \                     ??mbedtls_ccm_self_test_3: (+1)
   \      0x126   0xA814             ADD      R0,SP,#+80
   \      0x128   0x....'....        BL       mbedtls_ccm_free
    499          
    500              if( verbose != 0 )
   \      0x12C   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x130   0xD002             BEQ.N    ??mbedtls_ccm_self_test_8
    501                  mbedtls_printf( "\n\r" );
   \      0x132   0x....             ADR.N    R0,??DataTable1  ;; 0x0A, 0x0D, 0x00, 0x00
   \      0x134   0x....'....        BL       DbgConsole_Printf
    502          
    503              return( 0 );
   \                     ??mbedtls_ccm_self_test_8: (+1)
   \      0x138   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_self_test_9: (+1)
   \      0x13A   0xB025             ADD      SP,SP,#+148
   \      0x13C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??mbedtls_ccm_self_test_5: (+1)
   \      0x140   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x144   0xD009             BEQ.N    ??mbedtls_ccm_self_test_1
   \      0x146   0x....             LDR.N    R0,??DataTable1_13
   \      0x148   0x....'....        BL       DbgConsole_Printf
   \      0x14C   0xE005             B.N      ??mbedtls_ccm_self_test_1
   \                     ??mbedtls_ccm_self_test_6: (+1)
   \      0x14E   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x152   0xD002             BEQ.N    ??mbedtls_ccm_self_test_1
   \      0x154   0x....             LDR.N    R0,??DataTable1_13
   \      0x156   0x....'....        BL       DbgConsole_Printf
   \                     ??mbedtls_ccm_self_test_1: (+1)
   \      0x15A   0x2001             MOVS     R0,#+1
   \      0x15C   0xE7ED             B.N      ??mbedtls_ccm_self_test_9
    504          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x0A 0x0D          DC8      0x0A, 0x0D, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     key

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x....'....        DC32     msg_len

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x....'....        DC32     iv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x....'....        DC32     iv_len

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x....'....        DC32     ad

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \        0x0   0x....'....        DC32     add_len

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \        0x0   0x....'....        DC32     tag_len

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_9:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_10:
   \        0x0   0x....'....        DC32     msg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_11:
   \        0x0   0x....'....        DC32     res

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_12:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_13:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x20 0x20          DC8 "  CCM: setup failed"
   \              0x43 0x43    
   \              0x4D 0x3A    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x75 0x70    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x20 0x20          DC8 "  CCM-AES #%u: "
   \              0x43 0x43    
   \              0x4D 0x2D    
   \              0x41 0x45    
   \              0x53 0x20    
   \              0x23 0x25    
   \              0x75 0x3A    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x66 0x61          DC8 "failed\012\015"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x70 0x61          DC8 "passed\012\015"
   \              0x73 0x73    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \        0x0   0x0A 0x0D          DC8 "\012\015"
   \              0x00         
   \        0x3   0x00               DC8 0
    505          
    506          #endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
    507          
    508          #endif /* MBEDTLS_CCM_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     104   ccm_auth_crypt
       104   -> __aeabi_memcpy
       104   -> __aeabi_memset
       104   -> __aeabi_memset4
       104   -> mbedtls_cipher_update
      48   mbedtls_ccm_auth_decrypt
        48   -> mbedtls_ccm_star_auth_decrypt
      48   mbedtls_ccm_encrypt_and_tag
        48   -> mbedtls_ccm_star_encrypt_and_tag
       8   mbedtls_ccm_free
         8   -> mbedtls_cipher_free
         0   -> mbedtls_platform_zeroize
       0   mbedtls_ccm_init
         0   -> __aeabi_memset4
     184   mbedtls_ccm_self_test
       184   -> DbgConsole_Printf
       184   -> __aeabi_memcpy4
       184   -> __aeabi_memset4
       184   -> mbedtls_ccm_auth_decrypt
       184   -> mbedtls_ccm_encrypt_and_tag
       184   -> mbedtls_ccm_free
       184   -> mbedtls_ccm_init
       184   -> mbedtls_ccm_setkey
       184   -> memcmp
      24   mbedtls_ccm_setkey
        24   -> mbedtls_cipher_free
        24   -> mbedtls_cipher_info_from_values
        24   -> mbedtls_cipher_setkey
        24   -> mbedtls_cipher_setup
      64   mbedtls_ccm_star_auth_decrypt
        64   -> ccm_auth_crypt
        64   -> mbedtls_platform_zeroize
      48   mbedtls_ccm_star_encrypt_and_tag
        48   -> ccm_auth_crypt


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_13
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
      20  ?_0
      16  ?_1
      12  ?_2
      12  ?_3
       4  ?_4
      20  ad
      12  add_len
     760  ccm_auth_crypt
      12  iv
      12  iv_len
      16  key
      54  mbedtls_ccm_auth_decrypt
      54  mbedtls_ccm_encrypt_and_tag
      20  mbedtls_ccm_free
       8  mbedtls_ccm_init
     350  mbedtls_ccm_self_test
      72  mbedtls_ccm_setkey
     104  mbedtls_ccm_star_auth_decrypt
      52  mbedtls_ccm_star_encrypt_and_tag
      24  msg
      12  msg_len
      96  res
      12  tag_len

 
   280 bytes in section .rodata
 1 530 bytes in section .text
 
 1 530 bytes of CODE  memory
   280 bytes of CONST memory

Errors: none
Warnings: none
