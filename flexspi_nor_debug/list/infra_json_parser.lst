###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         10/Jun/2019  13:48:28
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\infra_json_parser.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\1\EWFD75.tmp
#        (C:\Development\smart_washing_machine_3080\csdk\eng\infra\infra_json_parser.c
#        -D DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D
#        XIP_BOOT_HEADER_ENABLE=1 -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS
#        -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list -lA
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list
#        --diag_suppress Pa082,Pa050 -o
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\smart_washing_machine_3080/source\app_preinclude.h -I
#        C:\Development\smart_washing_machine_3080/board\ -I
#        C:\Development\smart_washing_machine_3080/source\ -I
#        C:\Development\smart_washing_machine_3080/CMSIS\ -I
#        C:\Development\smart_washing_machine_3080/amazon-freertos/freertos/portable\
#        -I C:\Development\smart_washing_machine_3080/amazon-freertos/include\
#        -I C:\Development\smart_washing_machine_3080/component/lists\ -I
#        C:\Development\smart_washing_machine_3080/component/serial_manager\ -I
#        C:\Development\smart_washing_machine_3080/component/uart\ -I
#        C:\Development\smart_washing_machine_3080/component/kv\ -I
#        C:\Development\smart_washing_machine_3080/component/kv/include\ -I
#        C:\Development\smart_washing_machine_3080/device\ -I
#        C:\Development\smart_washing_machine_3080/doc\ -I
#        C:\Development\smart_washing_machine_3080/drivers\ -I
#        C:\Development\smart_washing_machine_3080/src\ -I
#        C:\Development\smart_washing_machine_3080/startup\ -I
#        C:\Development\smart_washing_machine_3080/utilities\ -I
#        C:\Development\smart_washing_machine_3080/xip\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\atm\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_model\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_sign\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\infra\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\mqtt\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\wrappers\external_libs\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\coap_cloud\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\CoAPPacket\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\coap_server\server\
#        -I C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\ -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\os\
#        -I
#        C:\Development\smart_washing_machine_3080\csdk\eng\dev_bind\impl\awss_reset\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\mbedtls\
#        -I C:\Development\smart_washing_machine_3080\mbedtls\include\ -I
#        C:\Development\smart_washing_machine_3080\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\list\infra_json_parser.lst
#    Object file  =  
#        C:\Development\smart_washing_machine_3080\flexspi_nor_debug\obj\infra_json_parser.o
#
###############################################################################

C:\Development\smart_washing_machine_3080\csdk\eng\infra\infra_json_parser.c
      1          /*
      2           * Copyright (C) 2015-2018 Alibaba Group Holding Limited
      3           */
      4          #include "infra_config.h"
      5          
      6          #ifdef INFRA_JSON_PARSER
      7          
      8          #include <stdio.h>
      9          #include <stdlib.h>
     10          #include <string.h>
     11          #include <stdarg.h>
     12          
     13          #include "infra_types.h"
     14          #include "infra_json_parser.h"
     15          
     16          void *HAL_Malloc(uint32_t size);
     17          void HAL_Free(void *ptr);
     18          int HAL_Snprintf(char *str, const int len, const char *fmt, ...);
     19          
     20          #ifdef INFRA_LOG
     21          #include "infra_log.h"
     22          #define jparser_debug(...)              log_debug("jparser", __VA_ARGS__)
     23          #else
     24          #define jparser_debug(...)              do{HAL_Printf(__VA_ARGS__);HAL_Printf("\r\n");}while(0)
     25          #endif
     26          
     27          #ifdef INFRA_MEM_STATS
     28          #include "infra_mem_stats.h"
     29          #define jparser_malloc(size)            LITE_malloc(size, MEM_MAGIC, "jparser")
     30          #define jparser_free(ptr)               LITE_free(ptr)
     31          #else
     32          #define jparser_malloc(size)            HAL_Malloc(size)
     33          #define jparser_free(ptr)               {HAL_Free((void *)ptr);ptr = NULL;}
     34          #endif
     35          

   \                                 In section .text, align 2, keep-with-next
     36          char *json_get_object(int type, char *str, char *str_end)
     37          {
   \                     json_get_object: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x4603             MOV      R3,R0
     38              char *pos = NULL;
   \        0x4   0x2000             MOVS     R0,#+0
     39              char ch = (type == JOBJECT) ? '{' : '[';
   \        0x6   0x2B01             CMP      R3,#+1
   \        0x8   0xD101             BNE.N    ??json_get_object_0
   \        0xA   0x247B             MOVS     R4,#+123
   \        0xC   0xE000             B.N      ??json_get_object_1
   \                     ??json_get_object_0: (+1)
   \        0xE   0x245B             MOVS     R4,#+91
     40          
     41              if (!str || !str_end) {
   \                     ??json_get_object_1: (+1)
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD010             BEQ.N    ??json_get_object_2
   \       0x14   0x2A00             CMP      R2,#+0
   \       0x16   0xD101             BNE.N    ??json_get_object_3
     42                  return NULL;
   \       0x18   0xE00D             B.N      ??json_get_object_2
     43              }
     44          
     45              while (str != NULL && *str != 0 && str < str_end) {
     46                  if (*str == ' ') {
     47                      str++;
   \                     ??json_get_object_4: (+1)
   \       0x1A   0x1C49             ADDS     R1,R1,#+1
     48                      continue;
     49                  }
   \                     ??json_get_object_3: (+1)
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD00A             BEQ.N    ??json_get_object_2
   \       0x20   0x780B             LDRB     R3,[R1, #+0]
   \       0x22   0x2B00             CMP      R3,#+0
   \       0x24   0xD007             BEQ.N    ??json_get_object_2
   \       0x26   0x4291             CMP      R1,R2
   \       0x28   0xD205             BCS.N    ??json_get_object_2
   \       0x2A   0x2B20             CMP      R3,#+32
   \       0x2C   0xD0F5             BEQ.N    ??json_get_object_4
     50                  pos = (*str == ch) ? str : NULL;
   \       0x2E   0x461A             MOV      R2,R3
   \       0x30   0x42A2             CMP      R2,R4
   \       0x32   0xD100             BNE.N    ??json_get_object_2
   \       0x34   0x4608             MOV      R0,R1
     51                  break;
     52              }
     53              return pos;
   \                     ??json_get_object_2: (+1)
   \       0x36   0xBC10             POP      {R4}
   \       0x38   0x4770             BX       LR               ;; return
     54          }
     55          

   \                                 In section .text, align 2, keep-with-next
     56          char *json_get_next_object(int type, char *str, char *str_end, char **key, int *key_len,
     57                                     char **val, int *val_len, int *val_type)
     58          {
   \                     json_get_next_object: (+1)
   \        0x0   0xE92D 0x4FF9      PUSH     {R0,R3-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4608             MOV      R0,R1
   \        0x8   0x4692             MOV      R10,R2
     59              char    JsonMark[JTYPEMAX][2] = { { '\"', '\"' }, { '{', '}' }, { '[', ']' }, { '0', ' ' } };
   \        0xA   0xA902             ADD      R1,SP,#+8
   \        0xC   0x....'....        LDR.W    R2,??DataTable4_1
   \       0x10   0xE892 0x0038      LDM      R2,{R3-R5}
   \       0x14   0xE881 0x0038      STM      R1,{R3-R5}
     60              int     iMarkDepth = 0, iValueType = JNONE, iNameLen = 0, iValueLen = 0, iStringDepth = 0;
   \       0x18   0x2700             MOVS     R7,#+0
   \       0x1A   0xF04F 0x34FF      MOV      R4,#-1
   \       0x1E   0x4639             MOV      R1,R7
   \       0x20   0x9101             STR      R1,[SP, #+4]
   \       0x22   0x4689             MOV      R9,R1
   \       0x24   0x460E             MOV      R6,R1
     61              char   *p_cName = 0, *p_cValue = 0, *p_cPos = str;
   \       0x26   0x9100             STR      R1,[SP, #+0]
   \       0x28   0x4688             MOV      R8,R1
     62          
     63              if (type == JOBJECT) {
   \       0x2A   0x9905             LDR      R1,[SP, #+20]
   \       0x2C   0x2901             CMP      R1,#+1
   \       0x2E   0xD113             BNE.N    ??json_get_next_object_0
     64                  /* Get Key */
     65                  p_cPos = strchr(p_cPos, '\"');
   \       0x30   0x2122             MOVS     R1,#+34
   \       0x32   0x....'....        BL       strchr
     66                  if (!p_cPos) {
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xF000 0x80B8      BEQ.W    ??json_get_next_object_1
     67                      goto do_exit;
     68                  }
     69                  p_cName = ++p_cPos;
   \       0x3C   0x1C40             ADDS     R0,R0,#+1
   \       0x3E   0x9000             STR      R0,[SP, #+0]
     70                  p_cPos = strchr(p_cPos, '\"');
   \       0x40   0x2122             MOVS     R1,#+34
   \       0x42   0x....'....        BL       strchr
     71                  if (!p_cPos) {
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xF000 0x80B0      BEQ.W    ??json_get_next_object_1
     72                      goto do_exit;
     73                  }
     74                  iNameLen = p_cPos - p_cName;
   \       0x4C   0x9900             LDR      R1,[SP, #+0]
   \       0x4E   0x1A41             SUBS     R1,R0,R1
   \       0x50   0x9101             STR      R1,[SP, #+4]
     75          
     76                  /* Get Value */
     77                  p_cPos = strchr(p_cPos, ':');
   \       0x52   0x213A             MOVS     R1,#+58
   \       0x54   0x....'....        BL       strchr
   \                     ??json_get_next_object_0: (+1)
   \       0x58   0x4605             MOV      R5,R0
   \       0x5A   0xE018             B.N      ??json_get_next_object_2
     78              }
     79              while (p_cPos && *p_cPos && p_cPos < str_end) {
     80                  if (*p_cPos == '\"') {
     81                      iValueType = JSTRING;
     82                      p_cValue = ++p_cPos;
     83                      break;
     84                  } else if (*p_cPos == '{') {
   \                     ??json_get_next_object_3: (+1)
   \       0x5C   0x287B             CMP      R0,#+123
   \       0x5E   0xD025             BEQ.N    ??json_get_next_object_4
     85                      iValueType = JOBJECT;
     86                      p_cValue = p_cPos++;
     87                      break;
     88                  } else if (*p_cPos == '[') {
   \       0x60   0x285B             CMP      R0,#+91
   \       0x62   0xD026             BEQ.N    ??json_get_next_object_5
     89                      iValueType = JARRAY;
     90                      p_cValue = p_cPos++;
     91                      break;
     92                  } else if ((*p_cPos == '-') || (*p_cPos >= '0' && *p_cPos <= '9')) {
   \       0x64   0x282D             CMP      R0,#+45
   \       0x66   0xF000 0x80AD      BEQ.W    ??json_get_next_object_6
   \       0x6A   0x3830             SUBS     R0,R0,#+48
   \       0x6C   0x280A             CMP      R0,#+10
   \       0x6E   0xF0C0 0x80A9      BCC.W    ??json_get_next_object_6
     93                      iValueType = JNUMBER;
     94                      p_cValue = p_cPos++;
     95                      break;
     96                  } else if (*p_cPos == 't' || *p_cPos == 'T' || *p_cPos == 'f' || *p_cPos == 'F') {
   \       0x72   0x7828             LDRB     R0,[R5, #+0]
   \       0x74   0x2874             CMP      R0,#+116
   \       0x76   0xF000 0x80A8      BEQ.W    ??json_get_next_object_7
   \       0x7A   0x2854             CMP      R0,#+84
   \       0x7C   0xF000 0x80A5      BEQ.W    ??json_get_next_object_7
   \       0x80   0x2866             CMP      R0,#+102
   \       0x82   0xF000 0x80A2      BEQ.W    ??json_get_next_object_7
   \       0x86   0x2846             CMP      R0,#+70
   \       0x88   0xF000 0x809F      BEQ.W    ??json_get_next_object_7
     97                      iValueType = JBOOLEAN;
     98                      p_cValue = p_cPos;
     99                      break;
    100                  }
    101                  p_cPos++;
   \       0x8C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??json_get_next_object_2: (+1)
   \       0x8E   0x2D00             CMP      R5,#+0
   \       0x90   0xD021             BEQ.N    ??json_get_next_object_8
   \       0x92   0x7828             LDRB     R0,[R5, #+0]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD01E             BEQ.N    ??json_get_next_object_8
   \       0x98   0x4555             CMP      R5,R10
   \       0x9A   0xD21C             BCS.N    ??json_get_next_object_8
   \       0x9C   0x2822             CMP      R0,#+34
   \       0x9E   0xD1DD             BNE.N    ??json_get_next_object_3
   \       0xA0   0x4634             MOV      R4,R6
   \       0xA2   0x1C68             ADDS     R0,R5,#+1
   \       0xA4   0x4605             MOV      R5,R0
   \                     ??json_get_next_object_9: (+1)
   \       0xA6   0x46A8             MOV      R8,R5
   \       0xA8   0x4605             MOV      R5,R0
   \       0xAA   0xE014             B.N      ??json_get_next_object_8
   \                     ??json_get_next_object_4: (+1)
   \       0xAC   0x2401             MOVS     R4,#+1
   \       0xAE   0x1C68             ADDS     R0,R5,#+1
   \       0xB0   0xE7F9             B.N      ??json_get_next_object_9
   \                     ??json_get_next_object_5: (+1)
   \       0xB2   0x2402             MOVS     R4,#+2
   \       0xB4   0x1C68             ADDS     R0,R5,#+1
   \       0xB6   0xE7F6             B.N      ??json_get_next_object_9
    102              }
    103          
    104              while (p_cPos && *p_cPos && p_cPos < str_end && iValueType > JNONE) {
    105                  if (iValueType == JBOOLEAN) {
    106                      int     len = strlen(p_cValue);
    107          
    108                      if ((*p_cValue == 't' || *p_cValue == 'T') && len >= 4
    109                          && (!strncmp(p_cValue, "true", 4)
    110                              || !strncmp(p_cValue, "TRUE", 4))) {
    111                          iValueLen = 4;
    112                          p_cPos = p_cValue + iValueLen;
    113                          break;
    114                      } else if ((*p_cValue == 'f' || *p_cValue == 'F') && len >= 5
    115                                 && (!strncmp(p_cValue, "false", 5)
    116                                     || !strncmp(p_cValue, "FALSE", 5))) {
    117                          iValueLen = 5;
    118                          p_cPos = p_cValue + iValueLen;
    119                          break;
    120                      }
    121                  } else if (iValueType == JNUMBER) {
    122                      if ((*p_cPos < '0' || *p_cPos > '9') && (*p_cPos != '.') && (*p_cPos != '+') \
    123                          && (*p_cPos != '-') && ((*p_cPos != 'e')) && (*p_cPos != 'E')) {
    124                          iValueLen = p_cPos - p_cValue;
    125                          break;
    126                      }
    127                  } else if (iValueType == JSTRING) {
    128                      if (*p_cPos == '\"') {
    129                          iValueLen = p_cPos - p_cValue;
    130                          break;
    131                      }
    132                  } else if (*p_cPos == JsonMark[iValueType][1]) {
    133                      if (iStringDepth  == 0) {
    134                          if (iMarkDepth == 0) {
    135                              iValueLen = p_cPos - p_cValue + 1;
    136                              p_cPos++;
    137                              break;
    138                          } else {
    139                              iMarkDepth--;
    140                          }
    141                      }
    142                  } else if (*p_cPos == JsonMark[iValueType][0]) {
    143                      if (iStringDepth == 0) {
    144                          iMarkDepth++;
    145                      }
    146                  } else if (*p_cPos == '\"') {
   \                     ??json_get_next_object_10: (+1)
   \       0xB8   0x2822             CMP      R0,#+34
   \       0xBA   0xD10B             BNE.N    ??json_get_next_object_11
    147                      if (iStringDepth) {
   \       0xBC   0x1E76             SUBS     R6,R6,#+1
   \       0xBE   0x41B6             SBCS     R6,R6,R6
   \       0xC0   0x0FF6             LSRS     R6,R6,#+31
   \       0xC2   0xE007             B.N      ??json_get_next_object_11
    148                          iStringDepth = 0;
    149                      } else {
    150                          iStringDepth = 1;
    151                      }
    152                  }
   \                     ??json_get_next_object_12: (+1)
   \       0xC4   0xA902             ADD      R1,SP,#+8
   \       0xC6   0xF811 0x1014      LDRB     R1,[R1, R4, LSL #+1]
   \       0xCA   0x4288             CMP      R0,R1
   \       0xCC   0xD1F4             BNE.N    ??json_get_next_object_10
   \       0xCE   0x2E00             CMP      R6,#+0
   \       0xD0   0xD100             BNE.N    ??json_get_next_object_11
   \       0xD2   0x1C7F             ADDS     R7,R7,#+1
    153                  p_cPos++;
   \                     ??json_get_next_object_11: (+1)
   \       0xD4   0x1C6D             ADDS     R5,R5,#+1
   \                     ??json_get_next_object_8: (+1)
   \       0xD6   0x2D00             CMP      R5,#+0
   \       0xD8   0xD07C             BEQ.N    ??json_get_next_object_13
   \       0xDA   0x7828             LDRB     R0,[R5, #+0]
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD079             BEQ.N    ??json_get_next_object_13
   \       0xE0   0x4555             CMP      R5,R10
   \       0xE2   0xD277             BCS.N    ??json_get_next_object_13
   \       0xE4   0x2C00             CMP      R4,#+0
   \       0xE6   0xD475             BMI.N    ??json_get_next_object_13
   \       0xE8   0x2C04             CMP      R4,#+4
   \       0xEA   0xD134             BNE.N    ??json_get_next_object_14
   \       0xEC   0x4640             MOV      R0,R8
   \       0xEE   0x....'....        BL       strlen
   \       0xF2   0x4683             MOV      R11,R0
   \       0xF4   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0xF8   0x2874             CMP      R0,#+116
   \       0xFA   0xD001             BEQ.N    ??json_get_next_object_15
   \       0xFC   0x2854             CMP      R0,#+84
   \       0xFE   0xD110             BNE.N    ??json_get_next_object_16
   \                     ??json_get_next_object_15: (+1)
   \      0x100   0xF1BB 0x0F04      CMP      R11,#+4
   \      0x104   0xDB0D             BLT.N    ??json_get_next_object_16
   \      0x106   0x2204             MOVS     R2,#+4
   \      0x108   0x....             LDR.N    R1,??DataTable4_2
   \      0x10A   0x4640             MOV      R0,R8
   \      0x10C   0x....'....        BL       strncmp
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD05D             BEQ.N    ??json_get_next_object_17
   \      0x114   0x2204             MOVS     R2,#+4
   \      0x116   0x....             LDR.N    R1,??DataTable4_3
   \      0x118   0x4640             MOV      R0,R8
   \      0x11A   0x....'....        BL       strncmp
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD056             BEQ.N    ??json_get_next_object_17
   \                     ??json_get_next_object_16: (+1)
   \      0x122   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x126   0x2866             CMP      R0,#+102
   \      0x128   0xD001             BEQ.N    ??json_get_next_object_18
   \      0x12A   0x2846             CMP      R0,#+70
   \      0x12C   0xD1D2             BNE.N    ??json_get_next_object_11
   \                     ??json_get_next_object_18: (+1)
   \      0x12E   0xF1BB 0x0F05      CMP      R11,#+5
   \      0x132   0xDBCF             BLT.N    ??json_get_next_object_11
   \      0x134   0x2205             MOVS     R2,#+5
   \      0x136   0x....             LDR.N    R1,??DataTable4_4
   \      0x138   0x4640             MOV      R0,R8
   \      0x13A   0x....'....        BL       strncmp
   \      0x13E   0x2800             CMP      R0,#+0
   \      0x140   0xD006             BEQ.N    ??json_get_next_object_19
   \      0x142   0x2205             MOVS     R2,#+5
   \      0x144   0x....             LDR.N    R1,??DataTable4_5
   \      0x146   0x4640             MOV      R0,R8
   \      0x148   0x....'....        BL       strncmp
   \      0x14C   0x2800             CMP      R0,#+0
   \      0x14E   0xD1C1             BNE.N    ??json_get_next_object_11
   \                     ??json_get_next_object_19: (+1)
   \      0x150   0xF04F 0x0905      MOV      R9,#+5
   \      0x154   0xE03E             B.N      ??json_get_next_object_13
   \                     ??json_get_next_object_14: (+1)
   \      0x156   0x2C03             CMP      R4,#+3
   \      0x158   0xD111             BNE.N    ??json_get_next_object_20
   \      0x15A   0x3830             SUBS     R0,R0,#+48
   \      0x15C   0x280A             CMP      R0,#+10
   \      0x15E   0xD3B9             BCC.N    ??json_get_next_object_11
   \      0x160   0x7828             LDRB     R0,[R5, #+0]
   \      0x162   0x282E             CMP      R0,#+46
   \      0x164   0xD0B6             BEQ.N    ??json_get_next_object_11
   \      0x166   0x282B             CMP      R0,#+43
   \      0x168   0xD0B4             BEQ.N    ??json_get_next_object_11
   \      0x16A   0x282D             CMP      R0,#+45
   \      0x16C   0xD0B2             BEQ.N    ??json_get_next_object_11
   \      0x16E   0x2865             CMP      R0,#+101
   \      0x170   0xD0B0             BEQ.N    ??json_get_next_object_11
   \      0x172   0x2845             CMP      R0,#+69
   \      0x174   0xD0AE             BEQ.N    ??json_get_next_object_11
   \                     ??json_get_next_object_21: (+1)
   \      0x176   0x46A9             MOV      R9,R5
   \      0x178   0xEBA9 0x0908      SUB      R9,R9,R8
   \      0x17C   0xE02A             B.N      ??json_get_next_object_13
   \                     ??json_get_next_object_20: (+1)
   \      0x17E   0x2C00             CMP      R4,#+0
   \      0x180   0xD102             BNE.N    ??json_get_next_object_22
   \      0x182   0x2822             CMP      R0,#+34
   \      0x184   0xD1A6             BNE.N    ??json_get_next_object_11
   \      0x186   0xE7F6             B.N      ??json_get_next_object_21
   \                     ??json_get_next_object_22: (+1)
   \      0x188   0xA902             ADD      R1,SP,#+8
   \      0x18A   0xEB01 0x0144      ADD      R1,R1,R4, LSL #+1
   \      0x18E   0x7849             LDRB     R1,[R1, #+1]
   \      0x190   0x4288             CMP      R0,R1
   \      0x192   0xD197             BNE.N    ??json_get_next_object_12
   \      0x194   0x2E00             CMP      R6,#+0
   \      0x196   0xD19D             BNE.N    ??json_get_next_object_11
   \      0x198   0x2F00             CMP      R7,#+0
   \      0x19A   0xD001             BEQ.N    ??json_get_next_object_23
   \      0x19C   0x1E7F             SUBS     R7,R7,#+1
   \      0x19E   0xE799             B.N      ??json_get_next_object_11
   \                     ??json_get_next_object_23: (+1)
   \      0x1A0   0x46A9             MOV      R9,R5
   \      0x1A2   0xEBA9 0x0908      SUB      R9,R9,R8
   \      0x1A6   0xF109 0x0901      ADD      R9,R9,#+1
   \      0x1AA   0xE013             B.N      ??json_get_next_object_13
    154              }
    155          
    156              if (type == JOBJECT) {
    157                  if ((p_cName + iNameLen) > str_end) {
    158                      goto do_exit;
    159                  }
    160                  *key = p_cName;
    161                  *key_len = iNameLen;
    162              }
    163              if ((p_cValue + iValueLen) > str_end) {
    164                  goto do_exit;
    165              }
    166          
    167              *val = p_cValue;
    168              *val_len = iValueLen;
    169              *val_type = iValueType;
    170              if (iValueType == JSTRING) {
    171                  return p_cValue + iValueLen + 1;
    172              } else {
    173                  return p_cValue + iValueLen;
    174              }
    175          
    176          do_exit:
    177              *val = NULL;
   \                     ??json_get_next_object_1: (+1)
   \      0x1AC   0x2000             MOVS     R0,#+0
   \      0x1AE   0x9911             LDR      R1,[SP, #+68]
   \      0x1B0   0x6008             STR      R0,[R1, #+0]
    178              *val_len = 0;
   \      0x1B2   0x9912             LDR      R1,[SP, #+72]
   \      0x1B4   0x6008             STR      R0,[R1, #+0]
    179              *key = NULL;
   \      0x1B6   0x9906             LDR      R1,[SP, #+24]
   \      0x1B8   0x6008             STR      R0,[R1, #+0]
    180              *key_len = 0;
   \      0x1BA   0x9910             LDR      R1,[SP, #+64]
   \      0x1BC   0x6008             STR      R0,[R1, #+0]
    181              return NULL;
   \                     ??json_get_next_object_24: (+1)
   \      0x1BE   0xB007             ADD      SP,SP,#+28
   \      0x1C0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??json_get_next_object_6: (+1)
   \      0x1C4   0x2403             MOVS     R4,#+3
   \      0x1C6   0x1C68             ADDS     R0,R5,#+1
   \      0x1C8   0xE76D             B.N      ??json_get_next_object_9
   \                     ??json_get_next_object_7: (+1)
   \      0x1CA   0x4628             MOV      R0,R5
   \      0x1CC   0x2404             MOVS     R4,#+4
   \      0x1CE   0xE76A             B.N      ??json_get_next_object_9
   \                     ??json_get_next_object_17: (+1)
   \      0x1D0   0x2004             MOVS     R0,#+4
   \      0x1D2   0x4681             MOV      R9,R0
   \                     ??json_get_next_object_13: (+1)
   \      0x1D4   0x9805             LDR      R0,[SP, #+20]
   \      0x1D6   0x2801             CMP      R0,#+1
   \      0x1D8   0xD10A             BNE.N    ??json_get_next_object_25
   \      0x1DA   0x9800             LDR      R0,[SP, #+0]
   \      0x1DC   0x9901             LDR      R1,[SP, #+4]
   \      0x1DE   0x4408             ADD      R0,R0,R1
   \      0x1E0   0x4582             CMP      R10,R0
   \      0x1E2   0xD3E3             BCC.N    ??json_get_next_object_1
   \      0x1E4   0x9800             LDR      R0,[SP, #+0]
   \      0x1E6   0x9906             LDR      R1,[SP, #+24]
   \      0x1E8   0x6008             STR      R0,[R1, #+0]
   \      0x1EA   0x9801             LDR      R0,[SP, #+4]
   \      0x1EC   0x9910             LDR      R1,[SP, #+64]
   \      0x1EE   0x6008             STR      R0,[R1, #+0]
   \                     ??json_get_next_object_25: (+1)
   \      0x1F0   0xEB08 0x0009      ADD      R0,R8,R9
   \      0x1F4   0x4582             CMP      R10,R0
   \      0x1F6   0xD3D9             BCC.N    ??json_get_next_object_1
   \      0x1F8   0x9813             LDR      R0,[SP, #+76]
   \      0x1FA   0x9911             LDR      R1,[SP, #+68]
   \      0x1FC   0xF8C1 0x8000      STR      R8,[R1, #+0]
   \      0x200   0x9912             LDR      R1,[SP, #+72]
   \      0x202   0xF8C1 0x9000      STR      R9,[R1, #+0]
   \      0x206   0x6004             STR      R4,[R0, #+0]
   \      0x208   0x2C00             CMP      R4,#+0
   \      0x20A   0xEB08 0x0009      ADD      R0,R8,R9
   \      0x20E   0xD1D6             BNE.N    ??json_get_next_object_24
   \      0x210   0x1C40             ADDS     R0,R0,#+1
   \      0x212   0xE7D4             B.N      ??json_get_next_object_24
    182          }
    183          

   \                                 In section .text, align 2, keep-with-next
    184          int json_parse_name_value(char *p_cJsonStr, int iStrLen, json_parse_cb pfnCB, void *p_CBData)
    185          {
   \                     json_parse_name_value: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4617             MOV      R7,R2
   \        0xC   0x4698             MOV      R8,R3
    186              char    *pos = 0, *key = 0, *val = 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9007             STR      R0,[SP, #+28]
   \       0x12   0x9006             STR      R0,[SP, #+24]
    187              int     klen = 0, vlen = 0, vtype = 0;
   \       0x14   0x9005             STR      R0,[SP, #+20]
   \       0x16   0x9004             STR      R0,[SP, #+16]
   \       0x18   0x9008             STR      R0,[SP, #+32]
    188              int     ret = JSON_RESULT_ERR;
   \       0x1A   0xF04F 0x39FF      MOV      R9,#-1
    189          
    190              if (p_cJsonStr == NULL || iStrLen == 0 || pfnCB == NULL) {
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD038             BEQ.N    ??json_parse_name_value_0
   \       0x22   0x2E00             CMP      R6,#+0
   \       0x24   0xD036             BEQ.N    ??json_parse_name_value_0
   \       0x26   0x0038             MOVS     R0,R7
   \       0x28   0xD034             BEQ.N    ??json_parse_name_value_0
    191                  return ret;
    192              }
    193          
    194              json_object_for_each_kv(p_cJsonStr, iStrLen, pos, key, klen, val, vlen, vtype) {
   \       0x2A   0x19A2             ADDS     R2,R4,R6
   \       0x2C   0x4621             MOV      R1,R4
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x....'....        BL       json_get_object
   \       0x34   0x4625             MOV      R5,R4
   \       0x36   0x4604             MOV      R4,R0
   \                     ??json_parse_name_value_1: (+1)
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD02B             BEQ.N    ??json_parse_name_value_0
   \       0x3C   0x7820             LDRB     R0,[R4, #+0]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD028             BEQ.N    ??json_parse_name_value_0
   \       0x42   0xA808             ADD      R0,SP,#+32
   \       0x44   0x9003             STR      R0,[SP, #+12]
   \       0x46   0xA804             ADD      R0,SP,#+16
   \       0x48   0x9002             STR      R0,[SP, #+8]
   \       0x4A   0xA806             ADD      R0,SP,#+24
   \       0x4C   0x9001             STR      R0,[SP, #+4]
   \       0x4E   0xA805             ADD      R0,SP,#+20
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0xAB07             ADD      R3,SP,#+28
   \       0x54   0x19AA             ADDS     R2,R5,R6
   \       0x56   0x4621             MOV      R1,R4
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0x....'....        BL       json_get_next_object
   \       0x5E   0x0004             MOVS     R4,R0
   \       0x60   0xD018             BEQ.N    ??json_parse_name_value_0
    195                  if (key && klen && val && vlen) {
   \       0x62   0x9807             LDR      R0,[SP, #+28]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD0E7             BEQ.N    ??json_parse_name_value_1
   \       0x68   0x9805             LDR      R0,[SP, #+20]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD0E4             BEQ.N    ??json_parse_name_value_1
   \       0x6E   0x9806             LDR      R0,[SP, #+24]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD0E1             BEQ.N    ??json_parse_name_value_1
   \       0x74   0x9804             LDR      R0,[SP, #+16]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD0DE             BEQ.N    ??json_parse_name_value_1
    196                      ret = JSON_RESULT_OK;
   \       0x7A   0xF04F 0x0900      MOV      R9,#+0
    197                      if (JSON_PARSE_FINISH == pfnCB(key, klen, val, vlen, vtype, p_CBData)) {
   \       0x7E   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x82   0x9808             LDR      R0,[SP, #+32]
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x9B04             LDR      R3,[SP, #+16]
   \       0x88   0x9A06             LDR      R2,[SP, #+24]
   \       0x8A   0x9905             LDR      R1,[SP, #+20]
   \       0x8C   0x9807             LDR      R0,[SP, #+28]
   \       0x8E   0x47B8             BLX      R7
   \       0x90   0x2802             CMP      R0,#+2
   \       0x92   0xD1D1             BNE.N    ??json_parse_name_value_1
    198                          break;
    199                      }
    200                  }
    201              }
    202          
    203              return ret;
   \                     ??json_parse_name_value_0: (+1)
   \       0x94   0x4648             MOV      R0,R9
   \       0x96   0xB009             ADD      SP,SP,#+36
   \       0x98   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    204          }
    205          

   \                                 In section .text, align 2, keep-with-next
    206          int json_get_value_by_name_cb(char *p_cName, int iNameLen, char *p_cValue, int iValueLen, int iValueType,
    207                                        void *p_CBData)
    208          {
   \                     json_get_value_by_name_cb: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4614             MOV      R4,R2
   \        0x4   0x461D             MOV      R5,R3
   \        0x6   0x9E05             LDR      R6,[SP, #+20]
    209              JSON_NV     *p_stNameValue = (JSON_NV *)p_CBData;
    210          
    211          #ifdef JSON_DEBUG
    212              int         i;
    213          
    214              if (p_cName) {
    215                  jparser_debug("Name:");
    216                  for (i = 0; i < iNameLen; i++) {
    217                      jparser_debug("%c", *(p_cName + i));
    218                  }
    219              }
    220          
    221              if (p_cValue) {
    222                  jparser_debug("Value:");
    223                  for (i = 0; i < iValueLen; i++) {
    224                      jparser_debug("%c", *(p_cValue + i));
    225                  }
    226              }
    227          #endif
    228          
    229              if ((iNameLen == p_stNameValue->nLen) && !strncmp(p_cName, p_stNameValue->pN, p_stNameValue->nLen)) {
   \        0x8   0x6832             LDR      R2,[R6, #+0]
   \        0xA   0x4291             CMP      R1,R2
   \        0xC   0xD10A             BNE.N    ??json_get_value_by_name_cb_0
   \        0xE   0x68F1             LDR      R1,[R6, #+12]
   \       0x10   0x....'....        BL       strncmp
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??json_get_value_by_name_cb_0
   \       0x18   0x9804             LDR      R0,[SP, #+16]
    230                  p_stNameValue->pV = p_cValue;
   \       0x1A   0x6134             STR      R4,[R6, #+16]
    231                  p_stNameValue->vLen = iValueLen;
   \       0x1C   0x6075             STR      R5,[R6, #+4]
    232                  p_stNameValue->vType = iValueType;
   \       0x1E   0x60B0             STR      R0,[R6, #+8]
    233                  return JSON_PARSE_FINISH;
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xBD70             POP      {R4-R6,PC}
    234              } else {
    235                  return JSON_PARSE_OK;
   \                     ??json_get_value_by_name_cb_0: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
    236              }
    237          }
    238          

   \                                 In section .text, align 2, keep-with-next
    239          char *json_get_value_by_name(char *p_cJsonStr, int iStrLen, char *p_cName, int *p_iValueLen, int *p_iValueType)
    240          {
   \                     json_get_value_by_name: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x461C             MOV      R4,R3
    241              JSON_NV     stNV;
    242          
    243              memset(&stNV, 0, sizeof(stNV));
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2114             MOVS     R1,#+20
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x....'....        BL       __aeabi_memset4
    244              stNV.pN = p_cName;
   \       0x16   0x9703             STR      R7,[SP, #+12]
    245              stNV.nLen = strlen(p_cName);
   \       0x18   0x4638             MOV      R0,R7
   \       0x1A   0x....'....        BL       strlen
   \       0x1E   0x9000             STR      R0,[SP, #+0]
    246              if (JSON_RESULT_OK == json_parse_name_value(p_cJsonStr, iStrLen, json_get_value_by_name_cb, (void *)&stNV)) {
   \       0x20   0x466B             MOV      R3,SP
   \       0x22   0x....             LDR.N    R2,??DataTable4_6
   \       0x24   0x4631             MOV      R1,R6
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x....'....        BL       json_parse_name_value
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD108             BNE.N    ??json_get_value_by_name_0
    247                  if (p_iValueLen) {
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD001             BEQ.N    ??json_get_value_by_name_1
    248                      *p_iValueLen = stNV.vLen;
   \       0x34   0x9801             LDR      R0,[SP, #+4]
   \       0x36   0x6020             STR      R0,[R4, #+0]
   \                     ??json_get_value_by_name_1: (+1)
   \       0x38   0x980A             LDR      R0,[SP, #+40]
    249                  }
    250                  if (p_iValueType) {
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD001             BEQ.N    ??json_get_value_by_name_0
    251                      *p_iValueType = stNV.vType;
   \       0x3E   0x9902             LDR      R1,[SP, #+8]
   \       0x40   0x6001             STR      R1,[R0, #+0]
    252                  }
    253              }
    254              return stNV.pV;
   \                     ??json_get_value_by_name_0: (+1)
   \       0x42   0x9804             LDR      R0,[SP, #+16]
   \       0x44   0xB005             ADD      SP,SP,#+20
   \       0x46   0xBDF0             POP      {R4-R7,PC}       ;; return
    255          }
    256          

   \                                 In section .text, align 2, keep-with-next
    257          char *json_get_value_by_name_len(char *p_cJsonStr, int iStrLen, char *p_cName, int p_cNameLen, int *p_iValueLen,
    258                                           int *p_iValueType)
    259          {
   \                     json_get_value_by_name_len: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    260              JSON_NV     stNV;
    261          
    262              memset(&stNV, 0, sizeof(stNV));
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2114             MOVS     R1,#+20
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x....'....        BL       __aeabi_memset4
    263              stNV.pN = p_cName;
   \       0x16   0x9603             STR      R6,[SP, #+12]
    264              stNV.nLen = p_cNameLen;
   \       0x18   0x9700             STR      R7,[SP, #+0]
    265              if (JSON_RESULT_OK == json_parse_name_value(p_cJsonStr, iStrLen, json_get_value_by_name_cb, (void *)&stNV)) {
   \       0x1A   0x466B             MOV      R3,SP
   \       0x1C   0x....             LDR.N    R2,??DataTable4_6
   \       0x1E   0x4629             MOV      R1,R5
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x....'....        BL       json_parse_name_value
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD109             BNE.N    ??json_get_value_by_name_len_0
   \       0x2A   0x980A             LDR      R0,[SP, #+40]
    266                  if (p_iValueLen) {
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD001             BEQ.N    ??json_get_value_by_name_len_1
    267                      *p_iValueLen = stNV.vLen;
   \       0x30   0x9901             LDR      R1,[SP, #+4]
   \       0x32   0x6001             STR      R1,[R0, #+0]
   \                     ??json_get_value_by_name_len_1: (+1)
   \       0x34   0x980B             LDR      R0,[SP, #+44]
    268                  }
    269                  if (p_iValueType) {
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD001             BEQ.N    ??json_get_value_by_name_len_0
    270                      *p_iValueType = stNV.vType;
   \       0x3A   0x9902             LDR      R1,[SP, #+8]
   \       0x3C   0x6001             STR      R1,[R0, #+0]
    271                  }
    272              }
    273              return stNV.pV;
   \                     ??json_get_value_by_name_len_0: (+1)
   \       0x3E   0x9804             LDR      R0,[SP, #+16]
   \       0x40   0xB005             ADD      SP,SP,#+20
   \       0x42   0xBDF0             POP      {R4-R7,PC}       ;; return
    274          }
    275          

   \                                 In section .text, align 2, keep-with-next
    276          char *LITE_json_value_of(char *key, char *src, ...)
    277          {
   \                     LITE_json_value_of: (+1)
   \        0x0   0xB40C             PUSH     {R2,R3}
   \        0x2   0xB5FE             PUSH     {R1-R7,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
    278              char       *value = NULL;
    279              char       *ret = NULL;
    280              char       *delim = NULL;
    281              char       *key_iter;
    282              char       *key_next;
    283              char       *src_iter;
    284          
    285              int         key_len;
    286              int         value_len = -1;
   \        0x8   0xF04F 0x30FF      MOV      R0,#-1
   \        0xC   0x9002             STR      R0,[SP, #+8]
    287              int         src_iter_len;
    288          
    289              if (NULL == key || NULL == src) {
   \        0xE   0x2E00             CMP      R6,#+0
   \       0x10   0xD001             BEQ.N    ??LITE_json_value_of_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??LITE_json_value_of_1
    290                  return NULL;
   \                     ??LITE_json_value_of_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE03B             B.N      ??LITE_json_value_of_2
    291              }
    292          
    293          #if WITH_MEM_STATS_PER_MODULE
    294          {
    295              char       *module_name = NULL;
    296              int         magic = 0;
    297              va_list     ap;
    298              va_start(ap, src);
    299              magic = va_arg(ap, int);
    300              if (MEM_MAGIC == magic) {
    301                  module_name = va_arg(ap, char *);
    302              }
    303              va_end(ap);
    304          }
    305          #endif
    306          
    307              src_iter = src;
    308              src_iter_len = strlen(src_iter);
   \                     ??LITE_json_value_of_1: (+1)
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x....'....        BL       strlen
   \       0x20   0x4607             MOV      R7,R0
    309              key_iter = key;
    310          
    311              do {
    312                  if ((delim = strchr(key_iter, '.')) != NULL) {
   \                     ??LITE_json_value_of_3: (+1)
   \       0x22   0x212E             MOVS     R1,#+46
   \       0x24   0x4630             MOV      R0,R6
   \       0x26   0x....'....        BL       strchr
   \       0x2A   0x0004             MOVS     R4,R0
   \       0x2C   0xD00D             BEQ.N    ??LITE_json_value_of_4
    313                      key_len = delim - key_iter;
    314                      key_next = key_iter;
    315          
    316                      value = json_get_value_by_name_len(src_iter, src_iter_len, key_next, key_len, &value_len, 0);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x9001             STR      R0,[SP, #+4]
   \       0x32   0xA802             ADD      R0,SP,#+8
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x1BA3             SUBS     R3,R4,R6
   \       0x38   0x4632             MOV      R2,R6
   \       0x3A   0x4639             MOV      R1,R7
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x....'....        BL       json_get_value_by_name_len
   \       0x42   0x0005             MOVS     R5,R0
    317                      if (value == NULL) {
   \       0x44   0xD014             BEQ.N    ??LITE_json_value_of_5
    318                          return NULL;
    319                      }
    320          
    321                      src_iter = value;
    322                      src_iter_len = value_len;
   \       0x46   0x9F02             LDR      R7,[SP, #+8]
    323                      key_iter = delim + 1;
   \       0x48   0x1C66             ADDS     R6,R4,#+1
    324                  }
    325              } while (delim);
   \                     ??LITE_json_value_of_4: (+1)
   \       0x4A   0x2C00             CMP      R4,#+0
   \       0x4C   0xD1E9             BNE.N    ??LITE_json_value_of_3
    326          
    327              key_len = strlen(key_iter);
   \       0x4E   0x4630             MOV      R0,R6
   \       0x50   0x....'....        BL       strlen
   \       0x54   0x4603             MOV      R3,R0
    328              key_next = key_iter;
    329              value = json_get_value_by_name_len(src_iter, src_iter_len, key_next, key_len, &value_len, 0);
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x9001             STR      R0,[SP, #+4]
   \       0x5A   0xA802             ADD      R0,SP,#+8
   \       0x5C   0x9000             STR      R0,[SP, #+0]
   \       0x5E   0x4632             MOV      R2,R6
   \       0x60   0x4639             MOV      R1,R7
   \       0x62   0x4628             MOV      R0,R5
   \       0x64   0x....'....        BL       json_get_value_by_name_len
   \       0x68   0x0005             MOVS     R5,R0
    330              if (NULL == value) {
   \       0x6A   0xD103             BNE.N    ??LITE_json_value_of_6
    331                  return NULL;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xE010             B.N      ??LITE_json_value_of_2
    332              }
   \                     ??LITE_json_value_of_5: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xE00E             B.N      ??LITE_json_value_of_2
    333          
    334              ret = jparser_malloc((value_len + 1) * sizeof(char));
   \                     ??LITE_json_value_of_6: (+1)
   \       0x74   0x9802             LDR      R0,[SP, #+8]
   \       0x76   0x1C40             ADDS     R0,R0,#+1
   \       0x78   0x....'....        BL       HAL_Malloc
   \       0x7C   0x0004             MOVS     R4,R0
    335          
    336              if (NULL == ret) {
   \       0x7E   0xD101             BNE.N    ??LITE_json_value_of_7
    337                  return NULL;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xE006             B.N      ??LITE_json_value_of_2
    338              }
    339          
    340              HAL_Snprintf(ret, value_len + 1, "%s", value);
   \                     ??LITE_json_value_of_7: (+1)
   \       0x84   0x462B             MOV      R3,R5
   \       0x86   0x....             ADR.N    R2,??DataTable4  ;; 0x25, 0x73, 0x00, 0x00
   \       0x88   0x9902             LDR      R1,[SP, #+8]
   \       0x8A   0x1C49             ADDS     R1,R1,#+1
   \       0x8C   0x....'....        BL       HAL_Snprintf
    341              return ret;
   \       0x90   0x4620             MOV      R0,R4
   \                     ??LITE_json_value_of_2: (+1)
   \       0x92   0xBCFE             POP      {R1-R7}
   \       0x94   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    342          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x25 0x73          DC8      0x25, 0x73, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x....'....        DC32     json_get_value_by_name_cb

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x22 0x22          DC8 34, 34, 123, 125, 91, 93, 48, 32, 0, 0, 0, 0
   \              0x7B 0x7D    
   \              0x5B 0x5D    
   \              0x30 0x20    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x74 0x72          DC8 "true"
   \              0x75 0x65    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x54 0x52          DC8 "TRUE"
   \              0x55 0x45    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x66 0x61          DC8 "false"
   \              0x6C 0x73    
   \              0x65 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x46 0x41          DC8 "FALSE"
   \              0x4C 0x53    
   \              0x45 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x25 0x73          DC8 "%s"
   \              0x00         
   \        0x3   0x00               DC8 0
    343          
    344          #if WITH_JSON_KEYS_OF
    345          static list_head_t *_LITE_json_keys_of(char *src, int src_len, char *prefix, ...)
    346          {
    347              static          LIST_HEAD(keylist);
    348              char           *module_name = NULL;
    349              char           *iter_pre = NULL;
    350              char           *pos = 0, *key = 0, *val = 0;
    351              int             klen = 0, vlen = 0, vtype = 0;
    352              int             magic = 0;
    353              unsigned int    mlen = 0;
    354          
    355          #if WITH_MEM_STATS_PER_MODULE
    356              va_list         ap;
    357              va_start(ap, prefix);
    358              magic = va_arg(ap, int);
    359              if (MEM_MAGIC == magic) {
    360                  module_name = va_arg(ap, char *);
    361              }
    362              va_end(ap);
    363          #endif
    364          
    365              if (!strcmp("", prefix)) {
    366                  INIT_LIST_HEAD(&keylist);
    367              }
    368          
    369              json_object_for_each_kv(src, src_len, pos, key, klen, val, vlen, vtype) {
    370                  if (key && klen && val && vlen) {
    371          
    372                      json_key_t     *entry = NULL;
    373          
    374                      entry = jparser_malloc(sizeof(json_key_t), magic, module_name);
    375                      if (NULL == entry) {
    376                          utils_err("jparser_malloc failed!");
    377                          return NULL;
    378                      }
    379                      memset(entry, 0, sizeof(json_key_t));
    380          
    381                      mlen = strlen(prefix) + klen + 1;
    382                      if (module_name) {
    383                          entry->key = LITE_format_nstring(mlen, "%s%.*s", magic, module_name, prefix, klen, key);
    384                      } else {
    385                          entry->key = LITE_format_nstring(mlen, "%s%.*s", prefix, klen, key);
    386                      }
    387                      if (NULL == entry->key) {
    388                          jparser_free(entry);
    389                          return NULL;
    390                      }
    391          
    392                      list_add_tail(&entry->list, &keylist);
    393          
    394                      if (JOBJECT == vtype) {
    395                          mlen = strlen(prefix) + klen + 2;
    396                          if (module_name) {
    397                              iter_pre = LITE_format_nstring(mlen, "%s%.*s.", magic, module_name, prefix, klen, key);
    398                          } else {
    399                              iter_pre = LITE_format_nstring(mlen, "%s%.*s.", prefix, klen, key);
    400                          }
    401                          if (NULL == iter_pre) {
    402                              return NULL;
    403                          }
    404          
    405                          _LITE_json_keys_of(val, vlen, iter_pre, magic, module_name);
    406                          jparser_free(iter_pre);
    407                      }
    408                  }
    409              }
    410          
    411              if (!strcmp("", prefix)) {
    412                  json_key_t     *entry = NULL;
    413          
    414                  entry = jparser_malloc(sizeof(json_key_t), magic, module_name);
    415                  if (NULL == entry) {
    416                      utils_err("jparser_malloc failed!");
    417                      return NULL;
    418                  }
    419                  memset(entry, 0, sizeof(json_key_t));
    420                  list_add_tail(&entry->list, &keylist);
    421          
    422                  return &keylist;
    423              }
    424          
    425              return NULL;
    426          }
    427          
    428          list_head_t *LITE_json_keys_of(char *src, char *prefix, ...)
    429          {
    430              char *module_name = NULL;
    431              int magic = 0;
    432          
    433              if (!src || !prefix) {
    434                  return NULL;
    435              }
    436          
    437          #if WITH_MEM_STATS_PER_MODULE
    438          
    439              va_list ap;
    440              va_start(ap, prefix);
    441              magic = va_arg(ap, int);
    442              if (MEM_MAGIC == magic) {
    443                  module_name = va_arg(ap, char *);
    444              }
    445              va_end(ap);
    446          #endif
    447          
    448              return _LITE_json_keys_of(src, strlen(src), prefix, magic, module_name);
    449          
    450          }
    451          
    452          #if WITH_JSON_TOKEN_EXT
    453          static list_head_t *_LITE_json_keys_of_ext(int type, char *src, int src_len, char *prefix, ...)
    454          {
    455              static          LIST_HEAD(keylist);
    456              char           *module_name = NULL;
    457              char           *iter_pre = NULL;
    458              char           *pos = 0, *key = 0, *val = 0;
    459              int             klen = 0, vlen = 0, vtype = 0;
    460              int             magic = 0;
    461              unsigned int    count = 1;
    462              unsigned int    mlen = 0;
    463          
    464              if (src == NULL || prefix == NULL) {
    465                  return NULL;
    466              }
    467          
    468          #if WITH_MEM_STATS_PER_MODULE
    469              va_list         ap;
    470              va_start(ap, prefix);
    471              magic = va_arg(ap, int);
    472              if (MEM_MAGIC == magic) {
    473                  module_name = va_arg(ap, char *);
    474              }
    475              va_end(ap);
    476          #endif
    477          
    478              if (!strcmp("", prefix)) {
    479                  INIT_LIST_HEAD(&keylist);
    480              }
    481          
    482              if (JOBJECT == type) {
    483                  json_object_for_each_kv(src, src_len, pos, key, klen, val, vlen, vtype) {
    484                      if (key && klen && val && vlen) {
    485          
    486                          json_key_t     *entry = NULL;
    487          
    488                          entry =  jparser_malloc(sizeof(json_key_t), magic, module_name);
    489          
    490                          if (NULL == entry) {
    491                              utils_err("jparser_malloc failed!");
    492                              return NULL;
    493                          }
    494                          memset(entry, 0, sizeof(json_key_t));
    495          
    496                          mlen = strlen(prefix) + klen + 1;
    497                          if (module_name) {
    498                              entry->key = LITE_format_nstring(mlen, "%s%.*s", magic, module_name, prefix, klen, key);
    499                          } else {
    500                              entry->key = LITE_format_nstring(mlen, "%s%.*s", prefix, klen, key);
    501                          }
    502          
    503                          if (NULL == entry->key) {
    504                              jparser_free(entry);
    505                              return NULL;
    506                          }
    507          
    508                          list_add_tail(&entry->list, &keylist);
    509          
    510                          if (JOBJECT == vtype) {
    511                              mlen = strlen(prefix) + klen + 2;
    512                              if (module_name) {
    513                                  iter_pre = LITE_format_nstring(mlen, "%s%.*s.", magic, module_name, prefix, klen, key);
    514                              } else {
    515                                  iter_pre = LITE_format_nstring(mlen, "%s%.*s.", prefix, klen, key);
    516                              }
    517                              if (NULL == iter_pre) {
    518                                  return NULL;
    519                              }
    520          
    521                              _LITE_json_keys_of_ext(vtype, val, vlen, iter_pre, magic, module_name);
    522                              jparser_free(iter_pre);
    523                          } else if (JARRAY == vtype) {
    524                              mlen = strlen(prefix) + klen + 1;
    525                              if (module_name) {
    526                                  iter_pre = LITE_format_nstring(mlen, "%s%.*s", magic, module_name, prefix, klen, key);
    527                              } else {
    528                                  iter_pre = LITE_format_nstring(mlen, "%s%.*s", prefix, klen, key);
    529                              }
    530                              if (NULL == iter_pre) {
    531                                  return NULL;
    532                              }
    533          
    534                              _LITE_json_keys_of_ext(vtype, val, vlen, iter_pre, magic, module_name);
    535                              jparser_free(iter_pre);
    536                          }
    537                      }
    538                  }
    539              } else if (JARRAY == type) {
    540                  json_array_for_each_entry(src, src_len, pos, val, vlen, vtype) {
    541                      if (val && vlen) {
    542          
    543                          json_key_t     *entry = NULL;
    544                          unsigned int    tmp = 0;
    545                          unsigned int    arridxlen = 0;
    546                          entry = jparser_malloc(sizeof(json_key_t), magic, module_name);
    547                          if (NULL == entry) {
    548                              utils_err("jparser_malloc failed!");
    549                              return NULL;
    550                          }
    551                          memset(entry, 0, sizeof(json_key_t));
    552          
    553                          tmp = count;
    554                          do {
    555                              tmp /= 10;
    556                              ++arridxlen;
    557                          } while (tmp);
    558                          mlen = strlen("%s[%d]") + strlen(prefix) + arridxlen;
    559                          if (module_name) {
    560                              entry->key = LITE_format_nstring(mlen, "%s[%d]", magic, module_name, prefix, count);
    561                          } else {
    562                              entry->key = LITE_format_nstring(mlen, "%s[%d]", prefix, count);
    563                          }
    564                          if (NULL == entry->key) {
    565                              jparser_free(entry);
    566                              return NULL;
    567                          }
    568          
    569                          list_add_tail(&entry->list, &keylist);
    570          
    571                          if (JOBJECT == vtype) {
    572                              mlen = strlen("%s[%d].") + strlen(prefix) + arridxlen;
    573                              if (module_name) {
    574                                  iter_pre = LITE_format_nstring(mlen, "%s[%d].", magic, module_name, prefix, count);
    575                              } else {
    576                                  iter_pre = LITE_format_nstring(mlen, "%s[%d].", prefix, count);
    577                              }
    578                              if (NULL == iter_pre) {
    579                                  return NULL;
    580                              }
    581          
    582                              _LITE_json_keys_of_ext(vtype, val, vlen, iter_pre, magic, module_name);
    583                              jparser_free(iter_pre);
    584                          } else if (JARRAY == vtype) {
    585                              mlen = strlen("%s[%d]") + strlen(prefix) + arridxlen;
    586                              if (module_name) {
    587                                  iter_pre = LITE_format_nstring(mlen, "%s[%d]", magic, module_name, prefix, count);
    588                              } else {
    589                                  iter_pre = LITE_format_nstring(mlen, "%s[%d]", prefix, count);
    590                              }
    591                              if (NULL == iter_pre) {
    592                                  return NULL;
    593                              }
    594          
    595                              _LITE_json_keys_of_ext(vtype, val, vlen, iter_pre, magic, module_name);
    596                              jparser_free(iter_pre);
    597                          }
    598                          ++count;
    599                      }
    600                  }
    601              }
    602          
    603              if (!strcmp("", prefix)) {
    604                  json_key_t     *entry = NULL;
    605          
    606                  entry = jparser_malloc(sizeof(json_key_t), magic, module_name);
    607                  if (NULL == entry) {
    608                      utils_err("jparser_malloc failed!");
    609                      return NULL;
    610                  }
    611                  memset(entry, 0, sizeof(json_key_t));
    612                  list_add_tail(&entry->list, &keylist);
    613          
    614                  return &keylist;
    615              }
    616          
    617              return NULL;
    618          
    619          }
    620          
    621          int contain_arr(const char *src, int src_len, const char **arr_pre)
    622          {
    623              int         i = 0;
    624              int         ret = -1;
    625              int         deep = 0;
    626              const char *pre = NULL;
    627          
    628              if (NULL == src || NULL == arr_pre || src_len <= 0) {
    629                  return -1;
    630              }
    631          
    632              *arr_pre = NULL;
    633              for (i = 0; i < src_len; ++i) {
    634                  switch (src[i]) {
    635                      case '[': {
    636                          if (deep != 0) {
    637                              return ret;
    638                          }
    639                          ++deep;
    640                          if (!pre) {
    641                              pre = &src[i];
    642                          }
    643                      }
    644                      break;
    645                      case ']': {
    646                          if (deep != 1) {
    647                              return ret;
    648                          }
    649                          --deep;
    650                          if ('[' == src[i - 1]) {
    651                              return ret;
    652                          }
    653                      }
    654                      break;
    655                      default: {
    656                          if ((pre != NULL) && (0 == deep)) {
    657                              return ret;
    658                          }
    659                      }
    660                      break;
    661                  }
    662              }
    663              if ((NULL != pre) && (pre < src + src_len) && (pre >= src)) {
    664                  *arr_pre = pre;
    665                  ret = 0;
    666              }
    667              return ret;
    668          }
    669          
    670          static char *_json_value_by_arrname(char *src, int src_len, const char *key, int key_len, int *val_len)
    671          {
    672              char       *pos = src;
    673              char       *entry = NULL;
    674              const char *p = NULL;
    675              const char *arr_pre = key;
    676              const char *arr_suf = NULL;
    677              int         vtype;
    678              int         loop;
    679              int         loop_tmp = 0;
    680              do {
    681                  loop = 0;
    682          
    683                  arr_pre = strchr(arr_pre, '[');
    684                  if (arr_pre && (arr_pre <  key + key_len)) {
    685                      arr_suf = strchr(arr_pre, ']');
    686                  }
    687                  if (arr_pre && arr_suf && (arr_suf < key + key_len)) {
    688                      loop_tmp = 0;
    689                      for (p = arr_pre + 1; p < arr_suf; ++p) {
    690                          if (*p > '9' || *p < '0') {
    691                              return NULL;
    692                          }
    693                          loop_tmp *= 10;
    694                          loop_tmp += *p - '0';
    695          
    696                      }
    697          
    698                      pos = json_get_object(JARRAY, pos, src + src_len);
    699                      if (pos != 0 && *pos != 0) {
    700                          if (*pos == '[' && *(pos + 1) == ']') {
    701                              return NULL;
    702                          }
    703                      }
    704          
    705                      json_array_for_each_entry(src, src_len, pos, entry, *val_len, vtype) {
    706                          if (entry && *val_len) {
    707                              if (++loop >= loop_tmp) {
    708                                  break;
    709                              }
    710                          }
    711                      }
    712          
    713                      if (loop != loop_tmp) {
    714                          return NULL;
    715                      }
    716                      src = entry;
    717                      arr_pre = arr_suf + 1;
    718                  }
    719              } while (arr_pre && arr_suf && (arr_pre < key + key_len));
    720              return entry;
    721          }
    722          
    723          void LITE_json_keys_release(list_head_t *keylist)
    724          {
    725              json_key_t         *pos, *tmp;
    726          
    727              if (NULL == keylist) {
    728                  return;
    729              }
    730          
    731              list_for_each_entry_safe(pos, tmp, keylist, list, json_key_t) {
    732                  if (pos->key) {
    733                      jparser_free(pos->key);
    734                  }
    735                  list_del(&pos->list);
    736                  jparser_free(pos);
    737              }
    738          }
    739          
    740          list_head_t *LITE_json_keys_of_ext(char *src, char *prefix, ...)
    741          {
    742              char *module_name = NULL;
    743              int magic = 0;
    744          
    745          #if WITH_MEM_STATS_PER_MODULE
    746          
    747              va_list ap;
    748              va_start(ap, prefix);
    749              magic = va_arg(ap, int);
    750              if (MEM_MAGIC == magic) {
    751                  module_name = va_arg(ap, char *);
    752              }
    753              va_end(ap);
    754          #endif
    755          
    756              if (!src || !prefix) {
    757                  return NULL;
    758              }
    759          
    760              return _LITE_json_keys_of_ext(JOBJECT, src, strlen(src), prefix, magic, module_name);
    761          }
    762          
    763          static char *_LITE_json_value_of_ext(char *key, char *src, int src_len, int *val_len)
    764          {
    765              char       *value = NULL;
    766              char       *delim = NULL;
    767              char       *key_iter;
    768              char       *key_next;
    769              char       *src_iter;
    770              const char *arr_pre = NULL;
    771          
    772              int         value_len;
    773              int         key_len;
    774              int         obj_key_len = 0;
    775              int         key_type;
    776              int         src_iter_len;
    777          
    778              src_iter = src;
    779              src_iter_len = src_len;
    780              key_iter = key;
    781              value_len = src_iter_len;
    782              do {
    783                  if ((delim = strchr(key_iter, '.')) != NULL) {
    784                      key_len = delim - key_iter;
    785                      key_type = JOBJECT;
    786                      key_next = key_iter;
    787                      if (0 == contain_arr(key_next, key_len, &arr_pre)) {
    788                          key_type = JARRAY;
    789                          obj_key_len = arr_pre - key_iter;
    790                          if (obj_key_len) {
    791                              value = json_get_value_by_name_len(src_iter, src_iter_len, key_next, obj_key_len, &value_len, 0);
    792                          } else {
    793                              value = src_iter;
    794                          }
    795                      } else {
    796                          value = json_get_value_by_name_len(src_iter, src_iter_len, key_next, key_len, &value_len, 0);
    797                      }
    798          
    799                      if (NULL == value) {
    800                          return NULL;
    801                      }
    802          
    803                      if (key_type == JARRAY) {
    804                          if (NULL == (value = _json_value_by_arrname(value, value_len, arr_pre, key_len - obj_key_len, &value_len))) {
    805                              return NULL;
    806                          }
    807                      }
    808                      src_iter = value;
    809                      src_iter_len = value_len;
    810                      key_iter = delim + 1;
    811          
    812                  }
    813              } while (delim);
    814          
    815              key_len = strlen(key_iter);
    816              key_next = key_iter;
    817              key_type = JOBJECT;
    818              if (0 == contain_arr(key_next, key_len, &arr_pre)) {
    819                  key_type = JARRAY;
    820                  obj_key_len = arr_pre - key_iter;
    821                  if (obj_key_len) {
    822                      value = json_get_value_by_name_len(src_iter, src_iter_len, key_next, obj_key_len, &value_len, 0);
    823                  } else {
    824                      value = src_iter;
    825                  }
    826              } else {
    827                  value = json_get_value_by_name_len(src_iter, src_iter_len, key_next, key_len, &value_len, 0);
    828              }
    829          
    830              if (NULL == value) {
    831                  return NULL;
    832              }
    833              if (key_type == JARRAY) {
    834                  if (NULL == (value = _json_value_by_arrname(value, value_len, arr_pre, key_len - obj_key_len, &value_len))) {
    835                      return NULL;
    836                  }
    837              }
    838              *val_len = value_len;
    839              return value;
    840          }
    841          
    842          #endif  /* #if WITH_JSON_TOKEN_EXT */
    843          #endif  /* #if WITH_JSON_KEYS_OF */
    844          #endif
    845          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   LITE_json_value_of
        40   -> HAL_Malloc
        40   -> HAL_Snprintf
        40   -> json_get_value_by_name_len
        40   -> strchr
        40   -> strlen
      64   json_get_next_object
        64   -> strchr
        64   -> strlen
        64   -> strncmp
       4   json_get_object
      40   json_get_value_by_name
        40   -> __aeabi_memset4
        40   -> json_parse_name_value
        40   -> strlen
      16   json_get_value_by_name_cb
        16   -> strncmp
      40   json_get_value_by_name_len
        40   -> __aeabi_memset4
        40   -> json_parse_name_value
      64   json_parse_name_value
        64   -- Indirect call
        64   -> json_get_next_object
        64   -> json_get_object


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
      12  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
       8  ?_4
       4  ?_5
     152  LITE_json_value_of
     532  json_get_next_object
      58  json_get_object
      72  json_get_value_by_name
      40  json_get_value_by_name_cb
      68  json_get_value_by_name_len
     156  json_parse_name_value

 
    48 bytes in section .rodata
 1 106 bytes in section .text
 
 1 106 bytes of CODE  memory
    48 bytes of CONST memory

Errors: none
Warnings: none
